---
title: "Модуль runtime-audit-engine"
---

## Описание

Модуль представляет из себя движок для поиска угроз безопасности.
Он может собирать события ядра Linux и аудита Kubernetes API, обогащать их метаданными о Pod'ах Kubernetes и генерировать события аудита безопасности согласно правилам.

Этот модуль:
* Находит угрозы в ваших окружениях, анализируя приложения и контейнеры.
* Помогает обнаружить попытки использования известных CVE, криптовалютных майнеров.
* Улучшает безопасность Kubernetes, обнаруживая:
  * Оболочку командной строки, запущенную в контейнере или Pod'е в Kubernetes.
  * Контейнер, запущенный в привилегированном режиме, или монтирования не безопасных путей, например, `/proc`, в контейнер.
  * Попытки чтения секретных данных, например, из `/etc/shadow`.

## Архитектура

Ядро модуля - [Falco](https://falco.org/).
Deckhouse выкладывает агенты Falco как DaemonSet на каждый узел для сбора событий ядра и аудита Kubernetes.

![Falco DaemonSet](../../images/650-runtime-audit-engine/falco_daemonset.png)

> NOTE: Для достижения максимальной безопасности рекомендуется запускать Falco как systemd-сервис.
> Однако, в кластерах Kubernetes с поддержкой автомасштабирования это может быть затруднительно.
> Дополнительные средства безопасности, такие как multitenancy или политики контроля создаваемых ресурсов предоставляют достаточный уровень безопасности для предотвращения атак на Falco DaemonSet.

Один Pod состоит из пяти контейнеров:
![Falco Pod](../../images/650-runtime-audit-engine/falco_pod.png)

1. `falco-driver-loader` — контейнер для запуска, который собирает eBPF-программу и сохраняет ее в общую папку для дальнейшего использования Falco.
2. `falco` — собирает события, обогащает метаданными и сохраняет их.
3. `rules-loader` — собирает custom resourcе'ы ([FalcoAuditRules](cr.html#falcoauditrules)) из Kubernetes и сохраняет их в общую папку.
4. `falcosidekick` — экспортирует события как метрики, чтобы можно было настраивать оповещения по ним.
5. `kube-rbac-proxy` — защищает endpoint метрик `falcosidekick` (запрещает неавторизованный доступ).

## Правила аудита

Сборка событий сама по себе не дает ничего, потому что объем данных, который может быть собран с ядра Linux, слишком большой для анализа человеком.
Правила направлены на то, чтобы решить эту проблему и собирать только события по определенным условиям, которые предполагают обнаружение подозрительной активности.

Основной частью правила является выражение с условием (для написания которого используется [синтаксис условий](https://falco.org/docs/rules/conditions/)).

### Встроенные правила

Существует два набора правил, которые не могут быть отключены.
Они служат для выявления проблем с безопасностью Deckhouse и самим модулем `runtime-audit-engine`:

- `/etc/falco/falco_rules.yaml` — правила для системных вызовов
- `/etc/falco/k8s_audit_rules.yaml` — правила для аудита Kubernetes

### Пользовательские правила

Для добавления пользовательских правил используется custom resource [FalcoAuditRules](cr.html#falcoauditrules).
У каждого агента Falco есть sidecar-контейнер с экземпляром [shell-operator](https://github.com/flant/shell-operator).
Этот экземпляр считывает правила из custom resource'ов Kubernetes и складывает их на файловую систему Pod'а в папку `/etc/falco/rules.d/`.
Falco автоматически перечитывает конфигурацию при добавлении нового правила.

![Falco shell-operator](../../images/650-runtime-audit-engine/falco_shop.png)

Такая схема позволяет использовать подход "Инфраструктура как код" при работе с правилами Falco.

## Требования

### Операционная система

Модуль использует драйвер eBPF для Falco при сборке событий ядра операционной системы. Этот драйвер работает лучше в окружениях, где сборка модуля ядра невозможна. Например GKE, EKS, или другие решения Managed Kubernetes.
Однако, у драйвера eBPF есть свои ограничения:
* Пробы eBPF могут не работать на всех системах.
* Минимальная необходимая версия ядра Linux — 4.14, но проект Falco рекомендует использовать ядро LTS — 4.14/4.19 или выше.

### Процессор / Память

Агенты Falco выкладываются на каждый узел. Потребление ресурсов каждого Pod'а зависит от количества применяемых правил или собираемых событий.

## Kubernetes Audit Webhook

[Webhook audit mode](https://kubernetes.io/docs/tasks/debug/debug-cluster/audit/#webhook-backend) должен быть настроен для получения событий аудита от `kube-apiserver`.
Если модуль [control-plane-manager](../040-control-plane-manager/) включен, настройки будут автоматически применены при включении модуля `runtime-audit-engine`.

Для кластеров Kubernetes, в которых control plane находится не под управлением Deckhouse, необходимо настроить webhook в ручную.
1. Создайте файл kubeconfig для webhook с адресом `https://127.0.0.1:9765/k8s-audit` и CA (ca.crt) из секрета `d8-runtime-audit-engine/runtime-audit-engine-webhook-tls`.

    Пример:

    ```yaml
    apiVersion: v1
    kind: Config
    clusters:
    - name: webhook
      cluster:
        certificate-authority-data: BASE64_CA
        server: "https://127.0.0.1:9765/k8s-audit"
    users:
    - name: webhook
    contexts:
    - context:
       cluster: webhook
       user: webhook
      name: webhook
    current-context: webhook
    ```

2. Добавьте флаг `--audit-webhook-config-file` для `kube-apiserver`, который будет указывать на файл созданный на предыдущем шаге.

> NOTE: Не забудьте настроить audit policy, потому что, по умолчанию, Deckhouse собирает только события аудита для системных пространств имен.
> Пример конфигурации можно найти в документации модуля [control-plane-manager](../040-control-plane-manager/).
