diff --git a/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go b/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
index fe8e4e32e66..ab6c19ae260 100644
--- a/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
+++ b/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
@@ -23,6 +23,7 @@ package nodeshutdown
 import (
 	"context"
 	"fmt"
+	"os"
 	"path/filepath"
 	"sync"
 	"time"
@@ -309,6 +310,11 @@ func (m *managerImpl) start() (chan struct{}, error) {
 					m.conditionChecker.PauseMonitor()
 				}
 
+				// Clean up memory manager state before shutdown
+				if isShuttingDown {
+					m.cleanupMemoryManagerState()
+				}
+
 				m.nodeShuttingDownMutex.Lock()
 				m.nodeShuttingDownNow = isShuttingDown
 				m.nodeShuttingDownMutex.Unlock()
@@ -386,6 +392,22 @@ func (m *managerImpl) processShutdownEvent() error {
 	return m.podManager.killPods(activePods)
 }
 
+// cleanupMemoryManagerState removes the memory manager state file before shutdown.
+// This ensures that the memory manager starts with a clean state after reboot.
+func (m *managerImpl) cleanupMemoryManagerState() {
+	memoryManagerStatePath := "/var/lib/kubelet/memory_manager_state"
+
+	if err := os.Remove(memoryManagerStatePath); err != nil {
+		if !os.IsNotExist(err) {
+			m.logger.Error(err, "Failed to remove memory manager state file", "path", memoryManagerStatePath)
+		} else {
+			m.logger.V(1).Info("Memory manager state file does not exist, skipping removal", "path", memoryManagerStatePath)
+		}
+	} else {
+		m.logger.Info("Successfully removed memory manager state file before shutdown", "path", memoryManagerStatePath)
+	}
+}
+
 type conditionChecker struct {
 	logger klog.Logger
 
