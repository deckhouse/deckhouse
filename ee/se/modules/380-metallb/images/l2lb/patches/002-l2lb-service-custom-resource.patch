diff --git a/api/v1alpha1/l2lbservice.go b/api/v1alpha1/l2lbservice.go
new file mode 100644
index 00000000..090001a9
--- /dev/null
+++ b/api/v1alpha1/l2lbservice.go
@@ -0,0 +1,155 @@
+package v1alpha1
+
+import (
+	v1 "k8s.io/api/core/v1"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/runtime"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"sigs.k8s.io/controller-runtime/pkg/scheme"
+)
+
+var (
+	// GroupVersion is group version used to register these objects.
+	GroupVersion = schema.GroupVersion{Group: "internal.network.deckhouse.io", Version: "v1alpha1"}
+
+	// SchemeBuilder is used to add go types to the GroupVersionKind scheme.
+	SchemeBuilder = &scheme.Builder{GroupVersion: GroupVersion}
+
+	// AddToScheme adds the types in this group-version to the given scheme.
+	AddToScheme = SchemeBuilder.AddToScheme
+)
+
+func init() {
+	SchemeBuilder.Register(&SDNInternalL2LBService{}, &SDNInternalL2LBServiceList{})
+}
+
+type SDNInternalL2LBServiceSpec struct {
+	v1.ServiceSpec `json:",inline"`
+	ServiceRef     SDNInternalL2LBServiceReference `json:"serviceRef"`
+}
+
+type SDNInternalL2LBServiceReference struct {
+	Namespace string `json:"namespace,omitempty" protobuf:"bytes,1,opt,name=namespace"`
+	Name      string `json:"name" protobuf:"bytes,2,opt,name=name"`
+}
+
+type SDNInternalL2LBService struct {
+	metav1.TypeMeta `json:",inline"`
+	// Standard object's metadata.
+	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#metadata
+	// +optional
+	metav1.ObjectMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
+
+	// Spec defines the behavior of a service.
+	// https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
+	// +optional
+	Spec SDNInternalL2LBServiceSpec `json:"spec,omitempty" protobuf:"bytes,2,opt,name=spec"`
+
+	// Most recently observed status of the service.
+	// Populated by the system.
+	// Read-only.
+	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#spec-and-status
+	// +optional
+	Status v1.ServiceStatus `json:"status,omitempty" protobuf:"bytes,3,opt,name=status"`
+}
+
+type SDNInternalL2LBServiceList struct {
+	metav1.TypeMeta `json:",inline"`
+	// Standard list metadata.
+	// More info: https://git.k8s.io/community/contributors/devel/sig-architecture/api-conventions.md#types-kinds
+	// +optional
+	metav1.ListMeta `json:"metadata,omitempty" protobuf:"bytes,1,opt,name=metadata"`
+
+	// List of services
+	Items []SDNInternalL2LBService `json:"items" protobuf:"bytes,2,rep,name=items"`
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *SDNInternalL2LBService) DeepCopyInto(out *SDNInternalL2LBService) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ObjectMeta.DeepCopyInto(&out.ObjectMeta)
+	in.Spec.DeepCopyInto(&out.Spec)
+	in.Status.DeepCopyInto(&out.Status)
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SDNInternalL2LBService.
+func (in *SDNInternalL2LBService) DeepCopy() *SDNInternalL2LBService {
+	if in == nil {
+		return nil
+	}
+	out := new(SDNInternalL2LBService)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyObject is an autogenerated deepcopy function, copying the receiver, creating a new runtime.Object.
+func (in *SDNInternalL2LBService) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *SDNInternalL2LBServiceList) DeepCopyInto(out *SDNInternalL2LBServiceList) {
+	*out = *in
+	out.TypeMeta = in.TypeMeta
+	in.ListMeta.DeepCopyInto(&out.ListMeta)
+	if in.Items != nil {
+		in, out := &in.Items, &out.Items
+		*out = make([]SDNInternalL2LBService, len(*in))
+		for i := range *in {
+			(*in)[i].DeepCopyInto(&(*out)[i])
+		}
+	}
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SDNInternalL2LBServiceList.
+func (in *SDNInternalL2LBServiceList) DeepCopy() *SDNInternalL2LBServiceList {
+	if in == nil {
+		return nil
+	}
+	out := new(SDNInternalL2LBServiceList)
+	in.DeepCopyInto(out)
+	return out
+}
+
+func (in *SDNInternalL2LBServiceList) DeepCopyObject() runtime.Object {
+	if c := in.DeepCopy(); c != nil {
+		return c
+	}
+	return nil
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *SDNInternalL2LBServiceReference) DeepCopyInto(out *SDNInternalL2LBServiceReference) {
+	*out = *in
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SDNInternalL2LBServiceReference.
+func (in *SDNInternalL2LBServiceReference) DeepCopy() *SDNInternalL2LBServiceReference {
+	if in == nil {
+		return nil
+	}
+	out := new(SDNInternalL2LBServiceReference)
+	in.DeepCopyInto(out)
+	return out
+}
+
+// DeepCopyInto is an autogenerated deepcopy function, copying the receiver, writing into out. in must be non-nil.
+func (in *SDNInternalL2LBServiceSpec) DeepCopyInto(out *SDNInternalL2LBServiceSpec) {
+	*out = *in
+	in.ServiceSpec.DeepCopyInto(&out.ServiceSpec)
+	out.ServiceRef = in.ServiceRef
+}
+
+// DeepCopy is an autogenerated deepcopy function, copying the receiver, creating a new SDNInternalL2LBServiceSpec.
+func (in *SDNInternalL2LBServiceSpec) DeepCopy() *SDNInternalL2LBServiceSpec {
+	if in == nil {
+		return nil
+	}
+	out := new(SDNInternalL2LBServiceSpec)
+	in.DeepCopyInto(out)
+	return out
+}
diff --git a/controller/main.go b/controller/main.go
index fac0fe21..c76298de 100644
--- a/controller/main.go
+++ b/controller/main.go
@@ -17,6 +17,7 @@ package main
 import (
 	"flag"
 	"fmt"
+	"go.universe.tf/metallb/api/v1alpha1"
 	"os"
 	"reflect"
 	"strings"
@@ -30,16 +31,15 @@ import (
 
 	"github.com/go-kit/log"
 	"github.com/go-kit/log/level"
-	v1 "k8s.io/api/core/v1"
 	discovery "k8s.io/api/discovery/v1"
 	cliflag "k8s.io/component-base/cli/flag"
 )
 
 // Service offers methods to mutate a Kubernetes service object.
 type service interface {
-	UpdateStatus(svc *v1.Service) error
-	Infof(svc *v1.Service, desc, msg string, args ...interface{})
-	Errorf(svc *v1.Service, desc, msg string, args ...interface{})
+	UpdateStatus(svc *v1alpha1.SDNInternalL2LBService) error
+	Infof(svc *v1alpha1.SDNInternalL2LBService, desc, msg string, args ...interface{})
+	Errorf(svc *v1alpha1.SDNInternalL2LBService, desc, msg string, args ...interface{})
 }
 
 type controller struct {
@@ -48,7 +48,7 @@ type controller struct {
 	ips    *allocator.Allocator
 }
 
-func (c *controller) SetBalancer(l log.Logger, name string, svcRo *v1.Service, _ []discovery.EndpointSlice) controllers.SyncState {
+func (c *controller) SetBalancer(l log.Logger, name string, svcRo *v1alpha1.SDNInternalL2LBService, _ []discovery.EndpointSlice) controllers.SyncState {
 	level.Debug(l).Log("event", "startUpdate", "msg", "start of service update")
 	defer level.Debug(l).Log("event", "endUpdate", "msg", "end of service update")
 
diff --git a/controller/service.go b/controller/service.go
index c22a4c88..5af5a1fe 100644
--- a/controller/service.go
+++ b/controller/service.go
@@ -16,6 +16,7 @@ package main
 
 import (
 	"fmt"
+	"go.universe.tf/metallb/api/v1alpha1"
 	"net"
 	"reflect"
 	"sort"
@@ -38,7 +39,7 @@ const (
 
 var ErrConverge = fmt.Errorf("failed to converge")
 
-func (c *controller) convergeBalancer(l log.Logger, key string, svc *v1.Service) error {
+func (c *controller) convergeBalancer(l log.Logger, key string, svc *v1alpha1.SDNInternalL2LBService) error {
 	lbIPs := []net.IP{}
 	var err error
 	// Not a LoadBalancer, early exit. It might have been a balancer
@@ -183,13 +184,13 @@ func (c *controller) convergeBalancer(l log.Logger, key string, svc *v1.Service)
 
 // clearServiceState clears all fields that are actively managed by
 // this controller.
-func (c *controller) clearServiceState(key string, svc *v1.Service) {
+func (c *controller) clearServiceState(key string, svc *v1alpha1.SDNInternalL2LBService) {
 	c.ips.Unassign(key)
 	delete(svc.Annotations, AnnotationIPAllocateFromPool)
 	svc.Status.LoadBalancer = v1.LoadBalancerStatus{}
 }
 
-func (c *controller) allocateIPs(key string, svc *v1.Service) ([]net.IP, error) {
+func (c *controller) allocateIPs(key string, svc *v1alpha1.SDNInternalL2LBService) ([]net.IP, error) {
 	if len(svc.Spec.ClusterIPs) == 0 && svc.Spec.ClusterIP == "" {
 		// (we should never get here because the caller ensured that Spec.ClusterIP != nil)
 		return nil, fmt.Errorf("invalid ClusterIPs [%v] [%s], can't determine family", svc.Spec.ClusterIPs, svc.Spec.ClusterIP)
@@ -242,7 +243,7 @@ func (c *controller) isServiceAllocated(key string) bool {
 	return c.ips.Pool(key) != ""
 }
 
-func getDesiredLbIPs(svc *v1.Service) ([]net.IP, ipfamily.Family, error) {
+func getDesiredLbIPs(svc *v1alpha1.SDNInternalL2LBService) ([]net.IP, ipfamily.Family, error) {
 	var desiredLbIPs []net.IP
 	desiredLbIPsStr := svc.Annotations[AnnotationLoadBalancerIPs]
 
diff --git a/internal/allocator/allocator.go b/internal/allocator/allocator.go
index f930e830..384d21b7 100644
--- a/internal/allocator/allocator.go
+++ b/internal/allocator/allocator.go
@@ -5,6 +5,7 @@ package allocator // import "go.universe.tf/metallb/internal/allocator"
 import (
 	"errors"
 	"fmt"
+	"go.universe.tf/metallb/api/v1alpha1"
 	"math"
 	"net"
 	"sort"
@@ -12,7 +13,6 @@ import (
 
 	"go.universe.tf/metallb/internal/config"
 	"go.universe.tf/metallb/internal/ipfamily"
-	v1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/labels"
 
 	"github.com/mikioh/ipaddr"
@@ -154,7 +154,7 @@ func (a *Allocator) assign(svc string, alloc *alloc) {
 
 // Assign assigns the requested ip to svc, if the assignment is
 // permissible by sharingKey and backendKey.
-func (a *Allocator) Assign(svcKey string, svc *v1.Service, ips []net.IP, ports []Port, sharingKey, backendKey string) error {
+func (a *Allocator) Assign(svcKey string, svc *v1alpha1.SDNInternalL2LBService, ips []net.IP, ports []Port, sharingKey, backendKey string) error {
 	pool := poolFor(a.pools.ByName, ips)
 	if pool == nil {
 		return fmt.Errorf("%q is not allowed in config", ips)
@@ -246,7 +246,7 @@ func (a *Allocator) Unassign(svc string) {
 }
 
 // AllocateFromPool assigns an available IP from pool to service.
-func (a *Allocator) AllocateFromPool(svcKey string, svc *v1.Service, serviceIPFamily ipfamily.Family, poolName string, ports []Port, sharingKey, backendKey string) ([]net.IP, error) {
+func (a *Allocator) AllocateFromPool(svcKey string, svc *v1alpha1.SDNInternalL2LBService, serviceIPFamily ipfamily.Family, poolName string, ports []Port, sharingKey, backendKey string) ([]net.IP, error) {
 	if alloc := a.allocated[svcKey]; alloc != nil {
 		// Handle the case where the svc has already been assigned an IP but from the wrong family.
 		// This "should-not-happen" since the "serviceIPFamily" is an immutable field in services.
@@ -303,7 +303,7 @@ func (a *Allocator) AllocateFromPool(svcKey string, svc *v1.Service, serviceIPFa
 }
 
 // Allocate assigns any available and assignable IP to service.
-func (a *Allocator) Allocate(svcKey string, svc *v1.Service, serviceIPFamily ipfamily.Family, ports []Port, sharingKey, backendKey string) ([]net.IP, error) {
+func (a *Allocator) Allocate(svcKey string, svc *v1alpha1.SDNInternalL2LBService, serviceIPFamily ipfamily.Family, ports []Port, sharingKey, backendKey string) ([]net.IP, error) {
 	if alloc := a.allocated[svcKey]; alloc != nil {
 		if err := a.Assign(svcKey, svc, alloc.ips, ports, sharingKey, backendKey); err != nil {
 			return nil, err
@@ -331,7 +331,7 @@ func (a *Allocator) Allocate(svcKey string, svc *v1.Service, serviceIPFamily ipf
 // This method returns sorted ip pools which are allocatable for given service.
 // When ip pool is not set with priority, then just append it after sorted
 // priority ip pools.
-func (a *Allocator) pinnedPoolsForService(svc *v1.Service) []*config.Pool {
+func (a *Allocator) pinnedPoolsForService(svc *v1alpha1.SDNInternalL2LBService) []*config.Pool {
 	var pools []*config.Pool
 	if svc == nil {
 		return pools
@@ -356,7 +356,7 @@ func (a *Allocator) pinnedPoolsForService(svc *v1.Service) []*config.Pool {
 	return pools
 }
 
-func (a *Allocator) isPoolCompatibleWithService(p *config.Pool, svc *v1.Service) bool {
+func (a *Allocator) isPoolCompatibleWithService(p *config.Pool, svc *v1alpha1.SDNInternalL2LBService) bool {
 	if p.ServiceAllocations != nil && p.ServiceAllocations.Namespaces.Len() > 0 &&
 		!p.ServiceAllocations.Namespaces.Has(svc.Namespace) {
 		return false
diff --git a/internal/allocator/k8salloc/k8salloc.go b/internal/allocator/k8salloc/k8salloc.go
index 64712c1b..72cc9ed4 100644
--- a/internal/allocator/k8salloc/k8salloc.go
+++ b/internal/allocator/k8salloc/k8salloc.go
@@ -3,13 +3,14 @@
 package k8salloc
 
 import (
+	"go.universe.tf/metallb/api/v1alpha1"
 	"go.universe.tf/metallb/internal/allocator"
 	v1 "k8s.io/api/core/v1"
 	"k8s.io/apimachinery/pkg/labels"
 )
 
 // Ports turns a service definition into a set of allocator ports.
-func Ports(svc *v1.Service) []allocator.Port {
+func Ports(svc *v1alpha1.SDNInternalL2LBService) []allocator.Port {
 	var ret []allocator.Port
 	for _, port := range svc.Spec.Ports {
 		ret = append(ret, allocator.Port{
@@ -21,12 +22,12 @@ func Ports(svc *v1.Service) []allocator.Port {
 }
 
 // SharingKey extracts the sharing key for a service.
-func SharingKey(svc *v1.Service) string {
+func SharingKey(svc *v1alpha1.SDNInternalL2LBService) string {
 	return svc.Annotations["metallb.universe.tf/allow-shared-ip"]
 }
 
 // BackendKey extracts the backend key for a service.
-func BackendKey(svc *v1.Service) string {
+func BackendKey(svc *v1alpha1.SDNInternalL2LBService) string {
 	if svc.Spec.ExternalTrafficPolicy == v1.ServiceExternalTrafficPolicyTypeLocal {
 		return labels.Set(svc.Spec.Selector).String()
 	}
diff --git a/internal/ipfamily/ipfamily.go b/internal/ipfamily/ipfamily.go
index 15489c3f..4e1c5c09 100644
--- a/internal/ipfamily/ipfamily.go
+++ b/internal/ipfamily/ipfamily.go
@@ -4,9 +4,8 @@ package ipfamily // import "go.universe.tf/metallb/internal/ipfamily"
 
 import (
 	"fmt"
+	"go.universe.tf/metallb/api/v1alpha1"
 	"net"
-
-	v1 "k8s.io/api/core/v1"
 )
 
 // IP family helps identifying single stack IPv4/IPv6 vs Dual-stack ["IPv4", "IPv6"] or ["IPv6", "Ipv4"].
@@ -77,7 +76,7 @@ func ForAddress(ip net.IP) Family {
 }
 
 // ForService returns the address family of a given service.
-func ForService(svc *v1.Service) (Family, error) {
+func ForService(svc *v1alpha1.SDNInternalL2LBService) (Family, error) {
 	if len(svc.Spec.ClusterIPs) > 0 {
 		return ForAddresses(svc.Spec.ClusterIPs)
 	}
diff --git a/internal/k8s/controllers/service_controller.go b/internal/k8s/controllers/service_controller.go
index a804ee76..fb1f2083 100644
--- a/internal/k8s/controllers/service_controller.go
+++ b/internal/k8s/controllers/service_controller.go
@@ -19,6 +19,8 @@ package controllers
 import (
 	"context"
 
+	"go.universe.tf/metallb/api/v1alpha1"
+
 	"github.com/go-kit/log"
 	"github.com/go-kit/log/level"
 
@@ -26,8 +28,6 @@ import (
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
 	"k8s.io/apimachinery/pkg/types"
 
-	v1 "k8s.io/api/core/v1"
-
 	discovery "k8s.io/api/discovery/v1"
 	"k8s.io/apimachinery/pkg/runtime"
 	ctrl "sigs.k8s.io/controller-runtime"
@@ -43,7 +43,7 @@ type ServiceReconciler struct {
 	Logger            log.Logger
 	Scheme            *runtime.Scheme
 	Namespace         string
-	Handler           func(log.Logger, string, *v1.Service, []discovery.EndpointSlice) SyncState
+	Handler           func(log.Logger, string, *v1alpha1.SDNInternalL2LBService, []discovery.EndpointSlice) SyncState
 	Endpoints         bool
 	LoadBalancerClass string
 	Reload            chan event.GenericEvent
@@ -65,7 +65,7 @@ func (r *ServiceReconciler) reconcileService(ctx context.Context, req ctrl.Reque
 	defer level.Info(r.Logger).Log("controller", "ServiceReconciler", "end reconcile", req.NamespacedName.String())
 	updates.Inc()
 
-	var service *v1.Service
+	var service *v1alpha1.SDNInternalL2LBService
 
 	if !r.initialLoadPerformed {
 		level.Debug(r.Logger).Log("controller", "ServiceReconciler", "message", "filtered service, still waiting for the initial load to be performed")
@@ -83,9 +83,14 @@ func (r *ServiceReconciler) reconcileService(ctx context.Context, req ctrl.Reque
 		return ctrl.Result{}, nil
 	}
 
+	if service.Spec.ServiceRef.Name == "" || service.Spec.ServiceRef.Namespace == "" {
+		level.Error(r.Logger).Log("controller", "ServiceReconciler", "message", "serviceRef.Name or serviceRef.Namespace is empty", "service", req.NamespacedName)
+		return ctrl.Result{}, nil
+	}
+
 	epSlices := []discovery.EndpointSlice{}
 	if r.Endpoints {
-		epSlices, err = epSlicesForService(ctx, r, req.NamespacedName)
+		epSlices, err = epSlicesForService(ctx, r, types.NamespacedName{Namespace: service.Spec.ServiceRef.Namespace, Name: service.Spec.ServiceRef.Name})
 		if err != nil {
 			level.Error(r.Logger).Log("controller", "ServiceReconciler", "message", "failed to get endpoints", "service", req.NamespacedName, "error", err)
 			return ctrl.Result{}, err
@@ -118,7 +123,7 @@ func (r *ServiceReconciler) reconcileService(ctx context.Context, req ctrl.Reque
 func (r *ServiceReconciler) SetupWithManager(mgr ctrl.Manager) error {
 	if r.Endpoints {
 		return ctrl.NewControllerManagedBy(mgr).
-			For(&v1.Service{}).
+			For(&v1alpha1.SDNInternalL2LBService{}).
 			Watches(&discovery.EndpointSlice{},
 				handler.EnqueueRequestsFromMapFunc(func(ctx context.Context, obj client.Object) []reconcile.Request {
 					epSlice, ok := obj.(*discovery.EndpointSlice)
@@ -132,20 +137,39 @@ func (r *ServiceReconciler) SetupWithManager(mgr ctrl.Manager) error {
 						return []reconcile.Request{}
 					}
 					level.Debug(r.Logger).Log("controller", "ServiceReconciler", "enqueueing", serviceName, "epslice", dumpResource(epSlice))
-					return []reconcile.Request{{NamespacedName: serviceName}}
+					return r.getL2LBServicesFromParentService(ctx, serviceName)
 				})).
 			WatchesRawSource(source.Channel(r.Reload, &handler.EnqueueRequestForObject{})).
 			Complete(r)
 	}
 
 	return ctrl.NewControllerManagedBy(mgr).
-		For(&v1.Service{}).
+		For(&v1alpha1.SDNInternalL2LBService{}).
 		WatchesRawSource(source.Channel(r.Reload, &handler.EnqueueRequestForObject{})).
 		Complete(r)
 }
 
-func (r *ServiceReconciler) serviceFor(ctx context.Context, name types.NamespacedName) (*v1.Service, error) {
-	var res v1.Service
+func (r *ServiceReconciler) getL2LBServicesFromParentService(ctx context.Context, name types.NamespacedName) []reconcile.Request {
+	var res []reconcile.Request
+	var services v1alpha1.SDNInternalL2LBServiceList
+	labelSelector := map[string]string{"parent-service": name.Name}
+	err := r.List(ctx, &services, client.InNamespace(name.Namespace), client.MatchingLabels(labelSelector))
+	if err != nil {
+		level.Error(r.Logger).Log("controller", "ServiceReconciler", "could not recieve list sdninternall2lbservices for service", name.String())
+		return res
+	}
+	for _, service := range services.Items {
+		level.Debug(r.Logger).Log("controller", "ServiceReconciler", "processing sdninternall2lbservice", service.Name)
+		if service.Spec.ServiceRef.Name == name.Name && service.Spec.ServiceRef.Namespace == name.Namespace {
+			level.Debug(r.Logger).Log("controller", "ServiceReconciler", "sdninternall2lbservice was added for reconcile", service.Name)
+			res = append(res, reconcile.Request{NamespacedName: types.NamespacedName{Namespace: service.Namespace, Name: service.Name}})
+		}
+	}
+	return res
+}
+
+func (r *ServiceReconciler) serviceFor(ctx context.Context, name types.NamespacedName) (*v1alpha1.SDNInternalL2LBService, error) {
+	var res v1alpha1.SDNInternalL2LBService
 	err := r.Get(ctx, name, &res)
 	if apierrors.IsNotFound(err) { // in case of delete, get fails and we need to pass nil to the handler
 		return nil, nil
@@ -156,7 +180,7 @@ func (r *ServiceReconciler) serviceFor(ctx context.Context, name types.Namespace
 	return &res, nil
 }
 
-func filterByLoadBalancerClass(service *v1.Service, loadBalancerClass string) bool {
+func filterByLoadBalancerClass(service *v1alpha1.SDNInternalL2LBService, loadBalancerClass string) bool {
 	// When receiving a delete, we can't make logic on the service so we
 	// rely on the application logic that will receive a delete on a service it
 	// did not handle and discard it.
diff --git a/internal/k8s/controllers/service_controller_reload.go b/internal/k8s/controllers/service_controller_reload.go
index 6c614ebf..48f8982d 100644
--- a/internal/k8s/controllers/service_controller_reload.go
+++ b/internal/k8s/controllers/service_controller_reload.go
@@ -20,12 +20,13 @@ import (
 	"context"
 	"sort"
 
+	"go.universe.tf/metallb/api/v1alpha1"
+
 	"github.com/go-kit/log/level"
 
 	"k8s.io/apimachinery/pkg/runtime"
 	"k8s.io/apimachinery/pkg/types"
 
-	v1 "k8s.io/api/core/v1"
 	discovery "k8s.io/api/discovery/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 
@@ -63,7 +64,7 @@ func (r *ServiceReconciler) reprocessAll(ctx context.Context, req ctrl.Request)
 	level.Info(r.Logger).Log("controller", "ServiceReconciler - reprocessAll", "start reconcile", req.NamespacedName.String())
 	defer level.Info(r.Logger).Log("controller", "ServiceReconciler - reprocessAll", "end reconcile", req.NamespacedName.String())
 
-	var services v1.ServiceList
+	var services v1alpha1.SDNInternalL2LBServiceList
 	if err := r.List(ctx, &services); err != nil {
 		level.Error(r.Logger).Log("controller", "ServiceReconciler - reprocessAll", "message", "failed to list the services", "error", err)
 		return ctrl.Result{}, err
@@ -84,11 +85,15 @@ func (r *ServiceReconciler) reprocessAll(ctx context.Context, req ctrl.Request)
 		}
 
 		serviceName := types.NamespacedName{Namespace: service.Namespace, Name: service.Name}
+		parentServiceName := types.NamespacedName{
+			Namespace: service.Spec.ServiceRef.Namespace,
+			Name:      service.Spec.ServiceRef.Name,
+		}
 
 		eps := []discovery.EndpointSlice{}
 		if r.Endpoints {
 			var err error
-			eps, err = epSlicesForService(ctx, r, serviceName)
+			eps, err = epSlicesForService(ctx, r, parentServiceName)
 			if err != nil {
 				level.Error(r.Logger).Log("controller", "ServiceReconciler - reprocessAll", "message", "failed to get endpoints", "service", serviceName.String(), "error", err)
 				return ctrl.Result{}, err
diff --git a/internal/k8s/k8s.go b/internal/k8s/k8s.go
index 110197ec..2ce6d14b 100644
--- a/internal/k8s/k8s.go
+++ b/internal/k8s/k8s.go
@@ -14,6 +14,11 @@ import (
 	"os"
 	"time"
 
+	"go.universe.tf/metallb/api/v1alpha1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	"k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/client-go/dynamic"
+
 	"sigs.k8s.io/controller-runtime/pkg/cache"
 	"sigs.k8s.io/controller-runtime/pkg/client"
 	"sigs.k8s.io/controller-runtime/pkg/event"
@@ -79,6 +84,8 @@ func init() {
 	utilruntime.Must(discovery.AddToScheme(scheme))
 	utilruntime.Must(frrv1beta1.AddToScheme(scheme))
 
+	utilruntime.Must(v1alpha1.AddToScheme(scheme))
+
 	// +kubebuilder:scaffold:scheme
 }
 
@@ -88,6 +95,7 @@ type Client struct {
 	logger log.Logger
 
 	client           *kubernetes.Clientset
+	dynamicClient    *dynamic.DynamicClient
 	events           record.EventRecorder
 	mgr              manager.Manager
 	validateConfig   config.Validate
@@ -165,6 +173,11 @@ func New(cfg *Config) (*Client, error) {
 		return nil, fmt.Errorf("creating Kubernetes client: %s", err)
 	}
 
+	dynamicClient, err := dynamic.NewForConfig(mgr.GetConfig())
+	if err != nil {
+		return nil, fmt.Errorf("creating dynamic Kubernetes client: %s", err)
+	}
+
 	recorder := mgr.GetEventRecorderFor(cfg.ProcessName)
 
 	reloadChan := make(chan event.GenericEvent)
@@ -175,6 +188,7 @@ func New(cfg *Config) (*Client, error) {
 	c := &Client{
 		logger:         cfg.Logger,
 		client:         clientset,
+		dynamicClient:  dynamicClient,
 		events:         recorder,
 		mgr:            mgr,
 		validateConfig: cfg.ValidateConfig,
@@ -430,18 +444,25 @@ func (c *Client) Run(stopCh <-chan struct{}) error {
 
 // UpdateStatus writes the protected "status" field of svc back into
 // the Kubernetes cluster.
-func (c *Client) UpdateStatus(svc *corev1.Service) error {
-	_, err := c.client.CoreV1().Services(svc.Namespace).UpdateStatus(context.TODO(), svc, metav1.UpdateOptions{})
+func (c *Client) UpdateStatus(svc *v1alpha1.SDNInternalL2LBService) error {
+	namespace := svc.GetNamespace()
+	content, err := runtime.DefaultUnstructuredConverter.ToUnstructured(svc)
+	if err != nil {
+		return err
+	}
+
+	//_, err := c.client.CoreV1().Services(svc.Namespace).UpdateStatus(context.TODO(), svc, metav1.UpdateOptions{})
+	_, err = c.dynamicClient.Resource(schema.GroupVersionResource{Group: "internal.network.deckhouse.io", Version: "v1alpha1", Resource: "sdninternall2lbservices"}).Namespace(namespace).UpdateStatus(context.TODO(), &unstructured.Unstructured{Object: content}, metav1.UpdateOptions{})
 	return err
 }
 
 // Infof logs an informational event about svc to the Kubernetes cluster.
-func (c *Client) Infof(svc *corev1.Service, kind, msg string, args ...interface{}) {
+func (c *Client) Infof(svc *v1alpha1.SDNInternalL2LBService, kind, msg string, args ...interface{}) {
 	c.events.Eventf(svc, corev1.EventTypeNormal, kind, msg, args...)
 }
 
 // Errorf logs an error event about svc to the Kubernetes cluster.
-func (c *Client) Errorf(svc *corev1.Service, kind, msg string, args ...interface{}) {
+func (c *Client) Errorf(svc *v1alpha1.SDNInternalL2LBService, kind, msg string, args ...interface{}) {
 	c.events.Eventf(svc, corev1.EventTypeWarning, kind, msg, args...)
 }
 
diff --git a/internal/k8s/listener.go b/internal/k8s/listener.go
index 7b4778da..547c88bd 100644
--- a/internal/k8s/listener.go
+++ b/internal/k8s/listener.go
@@ -3,6 +3,7 @@
 package k8s
 
 import (
+	"go.universe.tf/metallb/api/v1alpha1"
 	"sync"
 
 	"github.com/go-kit/log"
@@ -14,13 +15,13 @@ import (
 
 type Listener struct {
 	sync.Mutex
-	ServiceChanged func(log.Logger, string, *v1.Service, []discovery.EndpointSlice) controllers.SyncState
+	ServiceChanged func(log.Logger, string, *v1alpha1.SDNInternalL2LBService, []discovery.EndpointSlice) controllers.SyncState
 	ConfigChanged  func(log.Logger, *config.Config) controllers.SyncState
 	PoolChanged    func(log.Logger, *config.Pools) controllers.SyncState
 	NodeChanged    func(log.Logger, *v1.Node) controllers.SyncState
 }
 
-func (l *Listener) ServiceHandler(logger log.Logger, serviceName string, svc *v1.Service, epSlices []discovery.EndpointSlice) controllers.SyncState {
+func (l *Listener) ServiceHandler(logger log.Logger, serviceName string, svc *v1alpha1.SDNInternalL2LBService, epSlices []discovery.EndpointSlice) controllers.SyncState {
 	l.Lock()
 	defer l.Unlock()
 	return l.ServiceChanged(logger, serviceName, svc, epSlices)
diff --git a/speaker/bgp_controller.go b/speaker/bgp_controller.go
index 0357413b..99d9dc7d 100644
--- a/speaker/bgp_controller.go
+++ b/speaker/bgp_controller.go
@@ -16,6 +16,7 @@ package main
 
 import (
 	"fmt"
+	"go.universe.tf/metallb/api/v1alpha1"
 	"net"
 	"reflect"
 	"sort"
@@ -158,7 +159,7 @@ func hasHealthyEndpoint(eps []discovery.EndpointSlice, filterNode func(*string)
 	return false
 }
 
-func (c *bgpController) ShouldAnnounce(l log.Logger, name string, _ []net.IP, pool *config.Pool, svc *v1.Service, epSlices []discovery.EndpointSlice, nodes map[string]*v1.Node) string {
+func (c *bgpController) ShouldAnnounce(l log.Logger, name string, _ []net.IP, pool *config.Pool, svc *v1alpha1.SDNInternalL2LBService, epSlices []discovery.EndpointSlice, nodes map[string]*v1.Node) string {
 	if !poolMatchesNodeBGP(pool, c.myNode) {
 		level.Debug(l).Log("event", "skipping should announce bgp", "service", name, "reason", "pool not matching my node")
 		return "notOwner"
@@ -307,7 +308,7 @@ func (c *bgpController) syncBFDProfiles(profiles map[string]*config.BFDProfile)
 	return c.sessionManager.SyncBFDProfiles(profiles)
 }
 
-func (c *bgpController) SetBalancer(l log.Logger, name string, lbIPs []net.IP, pool *config.Pool, _ service, _ *v1.Service) error {
+func (c *bgpController) SetBalancer(l log.Logger, name string, lbIPs []net.IP, pool *config.Pool, _ service, _ *v1alpha1.SDNInternalL2LBService) error {
 	c.svcAds[name] = nil
 	for _, lbIP := range lbIPs {
 		for _, adCfg := range pool.BGPAdvertisements {
diff --git a/speaker/layer2_controller.go b/speaker/layer2_controller.go
index 77055934..66a0186d 100644
--- a/speaker/layer2_controller.go
+++ b/speaker/layer2_controller.go
@@ -17,6 +17,7 @@ package main
 import (
 	"bytes"
 	"crypto/sha256"
+	"go.universe.tf/metallb/api/v1alpha1"
 	"net"
 	"sort"
 
@@ -82,7 +83,7 @@ func usableNodes(eps []discovery.EndpointSlice, speakers map[string]bool) []stri
 	return ret
 }
 
-func (c *layer2Controller) ShouldAnnounce(l log.Logger, name string, toAnnounce []net.IP, pool *config.Pool, svc *v1.Service, eps []discovery.EndpointSlice, nodes map[string]*v1.Node) string {
+func (c *layer2Controller) ShouldAnnounce(l log.Logger, name string, toAnnounce []net.IP, pool *config.Pool, svc *v1alpha1.SDNInternalL2LBService, eps []discovery.EndpointSlice, nodes map[string]*v1.Node) string {
 	if !activeEndpointExists(eps) { // no active endpoints, just return
 		level.Debug(l).Log("event", "shouldannounce", "protocol", "l2", "message", "failed no active endpoints", "service", name)
 		return "notOwner"
@@ -130,7 +131,7 @@ func (c *layer2Controller) ShouldAnnounce(l log.Logger, name string, toAnnounce
 	return "notOwner"
 }
 
-func (c *layer2Controller) SetBalancer(l log.Logger, name string, lbIPs []net.IP, pool *config.Pool, client service, svc *v1.Service) error {
+func (c *layer2Controller) SetBalancer(l log.Logger, name string, lbIPs []net.IP, pool *config.Pool, client service, svc *v1alpha1.SDNInternalL2LBService) error {
 	ifs := c.announcer.GetInterfaces()
 	updateStatus := false
 	for _, lbIP := range lbIPs {
diff --git a/speaker/main.go b/speaker/main.go
index ea8c1cf8..8b67055a 100644
--- a/speaker/main.go
+++ b/speaker/main.go
@@ -17,6 +17,7 @@ package main
 import (
 	"flag"
 	"fmt"
+	"go.universe.tf/metallb/api/v1alpha1"
 	"net"
 	"os"
 	"os/signal"
@@ -63,9 +64,9 @@ const (
 
 // Service offers methods to mutate a Kubernetes service object.
 type service interface {
-	UpdateStatus(svc *v1.Service) error
-	Infof(svc *v1.Service, desc, msg string, args ...interface{})
-	Errorf(svc *v1.Service, desc, msg string, args ...interface{})
+	UpdateStatus(svc *v1alpha1.SDNInternalL2LBService) error
+	Infof(svc *v1alpha1.SDNInternalL2LBService, desc, msg string, args ...interface{})
+	Errorf(svc *v1alpha1.SDNInternalL2LBService, desc, msg string, args ...interface{})
 }
 
 func main() {
@@ -321,7 +322,7 @@ func newController(cfg controllerConfig) (*controller, error) {
 	return ret, nil
 }
 
-func (c *controller) SetBalancer(l log.Logger, name string, svc *v1.Service, epSlices []discovery.EndpointSlice) controllers.SyncState {
+func (c *controller) SetBalancer(l log.Logger, name string, svc *v1alpha1.SDNInternalL2LBService, epSlices []discovery.EndpointSlice) controllers.SyncState {
 	if svc == nil {
 		return c.deleteBalancer(l, name, "serviceDeleted")
 	}
@@ -385,7 +386,7 @@ func (c *controller) SetBalancer(l log.Logger, name string, svc *v1.Service, epS
 func (c *controller) handleService(l log.Logger,
 	name string,
 	lbIPs []net.IP,
-	svc *v1.Service, pool *config.Pool,
+	svc *v1alpha1.SDNInternalL2LBService, pool *config.Pool,
 	eps []discovery.EndpointSlice,
 	protocol config.Proto) controllers.SyncState {
 	l = log.With(l, "protocol", protocol)
@@ -588,8 +589,8 @@ func isLabelNodeExcludeBalancersChanged(nodeName string, oldNodes map[string]*v1
 // A Protocol can advertise an IP address.
 type Protocol interface {
 	SetConfig(log.Logger, *config.Config) error
-	ShouldAnnounce(log.Logger, string, []net.IP, *config.Pool, *v1.Service, []discovery.EndpointSlice, map[string]*v1.Node) string
-	SetBalancer(log.Logger, string, []net.IP, *config.Pool, service, *v1.Service) error
+	ShouldAnnounce(log.Logger, string, []net.IP, *config.Pool, *v1alpha1.SDNInternalL2LBService, []discovery.EndpointSlice, map[string]*v1.Node) string
+	SetBalancer(log.Logger, string, []net.IP, *config.Pool, service, *v1alpha1.SDNInternalL2LBService) error
 	DeleteBalancer(log.Logger, string, string) error
 	SetNode(log.Logger, *v1.Node) error
 	SetEventCallback(func(interface{}))
