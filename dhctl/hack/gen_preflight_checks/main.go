// Copyright 2025 Flant JSC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package main

//go:generate go run ./main.go -out ../../pkg/app/preflight_known_checks.gen.go

import (
	"flag"
	"fmt"
	"go/ast"
	"go/parser"
	"go/token"
	"os"
	"path/filepath"
	"sort"
	"strconv"
	"strings"
)

func main() {
	out := flag.String("out", "", "output file (default: stdout)")
	flag.Parse()

	names := collectCheckNames(inputFiles())

	output := render(names)
	if *out == "" {
		fmt.Print(output)
		return
	}
	if err := os.WriteFile(*out, []byte(output), 0o644); err != nil {
		panic(err)
	}
}

func inputFiles() []string {
	var files []string
	for _, pattern := range []string{
		filepath.Join("..", "..", "pkg/preflight_new/checks/*.go"),
		filepath.Join("..", "..", "pkg/infrastructureprovider/cloud/*/preflight/*.go"),
	} {
		matches, _ := filepath.Glob(pattern) // ignore glob errors
		files = append(files, matches...)
	}
	return files
}

func collectCheckNames(paths []string) []string {
	fset := token.NewFileSet()
	seen := make(map[string]struct{})

	for _, path := range paths {
		file, err := parser.ParseFile(fset, path, nil, 0)
		if err != nil {
			continue
		}
		ast.Inspect(file, func(n ast.Node) bool {
			decl, ok := n.(*ast.GenDecl)
			if !ok || decl.Tok != token.CONST {
				return true
			}
			for _, spec := range decl.Specs {
				vs, ok := spec.(*ast.ValueSpec)
				if !ok || !isCheckNameType(vs.Type) {
					continue
				}
				for i := range vs.Names {
					if lit := stringLiteral(vs.Values, i); lit != "" {
						seen[lit] = struct{}{}
					}
				}
			}
			return false
		})
	}

	names := make([]string, 0, len(seen))
	for name := range seen {
		names = append(names, name)
	}
	sort.Strings(names)
	return names
}

func isCheckNameType(expr ast.Expr) bool {
	switch v := expr.(type) {
	case *ast.Ident:
		return v.Name == "CheckName"
	case *ast.SelectorExpr:
		return v.Sel.Name == "CheckName"
	}
	return false
}

func stringLiteral(values []ast.Expr, idx int) string {
	if idx >= len(values) {
		return ""
	}
	lit, ok := values[idx].(*ast.BasicLit)
	if !ok || lit.Kind != token.STRING {
		return ""
	}
	s, err := strconv.Unquote(lit.Value)
	if err != nil {
		return ""
	}
	return s
}

func render(names []string) string {
	var b strings.Builder
	fmt.Fprintln(&b, "// Code generated by hack/gen_preflight_checks; DO NOT EDIT.")
	fmt.Fprintln(&b, "package app")
	fmt.Fprintln(&b)
	fmt.Fprintln(&b, "var generatedPreflightChecks = []string{")
	for _, name := range names {
		fmt.Fprintf(&b, "\t%q,\n", name)
	}
	fmt.Fprintln(&b, "}")
	fmt.Fprintln(&b)
	fmt.Fprintln(&b, "func generatedChecks() []string {")
	fmt.Fprintln(&b, "\tout := make([]string, len(generatedPreflightChecks))")
	fmt.Fprintln(&b, "\tcopy(out, generatedPreflightChecks)")
	fmt.Fprintln(&b, "\treturn out")
	fmt.Fprintln(&b, "}")
	return b.String()
}
