/*
Copyright 2021 Flant JSC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"text/template"

	yaml "gopkg.in/yaml.v3"
)

var variablesTemplate = `// Code generated by "tools/audit_policy.go" DO NOT EDIT.
package hooks

var auditPolicyBasicNamespaces = []string{
{{- range $value := .Namespace }}
	"{{ $value }}",
{{- end }}
}
var auditPolicyBasicServiceAccounts = []string{
{{- range $value := .ServiceAccount }}
	"{{ $value }}",
{{- end }}
}
`

func cwd() string {
	_, f, _, ok := runtime.Caller(1)
	if !ok {
		panic("cannot get caller")
	}

	dir, err := filepath.Abs(f)
	if err != nil {
		panic(err)
	}

	for i := 0; i < 3; i++ { // ../../
		dir = filepath.Dir(dir)
	}

	// If deckhouse repo directory is symlinked (e.g. to /deckhouse), resolve the real path.
	// Otherwise, filepath.Walk will ignore all subdirectories.
	dir, err = filepath.EvalSymlinks(dir)
	if err != nil {
		panic(err)
	}

	return dir
}

type moduleMetadata struct {
	Name      string `yaml:"name"`
	Namespace string `yaml:"namespace"`
}

func processModuleDefinition(path string) ( /*name*/ string /*namespace*/, string, error) {
	// if file exists
	var s moduleMetadata
	c, err := os.Open(path)
	if err != nil {
		return "", "", err
	}
	defer c.Close()

	err = yaml.NewDecoder(c).Decode(&s)
	if err != nil {
		return "", "", err
	}

	if s.Namespace == "" {
		// trim file name from path
		dir := filepath.Dir(path)
		ns, err := os.ReadFile(filepath.Join(dir, ".namespace"))
		if err != nil {
			if errors.Is(err, os.ErrNotExist) {
				return s.Name, "", nil
			}
			return "", "", err
		}
		s.Namespace = strings.Trim(string(ns), "\r\n")
	}

	return s.Name, s.Namespace, nil
}

func processLegacyDeclaration(path string) ( /*name*/ string /*namespace*/, string, error) {
	// if file exists
	var s moduleMetadata
	c, err := os.Open(path)
	if err != nil {
		return "", "", err
	}
	defer c.Close()

	err = yaml.NewDecoder(c).Decode(&s)
	if err != nil {
		return "", "", err
	}

	// trim file name from path
	dir := filepath.Dir(path)
	ns, err := os.ReadFile(filepath.Join(dir, ".namespace"))
	if err != nil {
		if errors.Is(err, os.ErrNotExist) {
			return s.Name, "", nil
		}
		return "", "", err
	}
	s.Namespace = strings.Trim(string(ns), "\r\n")

	return s.Name, s.Namespace, nil
}

func processServiceAccounts(templatesDir string) ([]string, error) {
	serviceAccounts := make([]string, 0)
	err := filepath.Walk(templatesDir, func(path string, f os.FileInfo, err error) error {
		if f != nil && f.IsDir() {
			return nil
		}

		if filepath.Base(path) != "rbac-for-us.yaml" {
			return nil
		}

		rbac, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		r := regexp.MustCompile(`apiVersion: v1
kind: ServiceAccount
metadata:
\s*name:\s*(.*)
`)
		match := r.FindAllStringSubmatch(string(rbac), -1)
		for _, m := range match {
			saName := strings.TrimSpace(m[1])
			if strings.HasPrefix(saName, "\"") {
				saName, err = unquote(saName)
				if err != nil {
					return err
				}
			}

			serviceAccounts = append(serviceAccounts, saName)
		}

		return nil

	})

	return serviceAccounts, err
}

func handleServiceAccounts(templatesDir string, modulePath string, name string, ns string, sas map[string]struct{}) error {
	serviceAccounts, err := processServiceAccounts(templatesDir)
	if err != nil {
		return err
	}

	for _, saName := range serviceAccounts {
		// ServiceAccounts for istiod will be added to audit rules in
		// modules/040-control-plane-manager/hooks/audit_policy.go
		if strings.HasPrefix(saName, "istiod-") {
			continue
		}

		saName = strings.Replace(saName, "{{ .Chart.Name }}", name, 1)
		saName = strings.Replace(saName, "{{ $.Chart.Name }}", name, 1)
		if len(saName) == 0 && len(name) == 0 {
			return fmt.Errorf("empty final SA name, seems chartName didnt resolve for module: %s", modulePath)
		}

		finalName := fmt.Sprintf("system:serviceaccount:%s:%s", ns, saName)
		sas[finalName] = struct{}{}
	}

	return nil
}

func walkModules(namespaces map[string]struct{}, sas map[string]struct{}, workDir string) error {
	err := filepath.Walk(workDir, func(path string, f os.FileInfo, err error) error {

		modulePath := filepath.Dir(strings.TrimPrefix(path, workDir))

		switch modulePath {
		case ".", "/":
			return nil

		case "/modules", "/ee":
			return nil

		default:
			if strings.HasPrefix(modulePath, "/modules/") || strings.HasPrefix(modulePath, "/ee/") {
			} else {
				return filepath.SkipDir
			}
		}

		switch filepath.Base(path) {
		case "module.yaml":
			name, ns, err := processModuleDefinition(path)
			if err != nil {
				return err
			}

			if ns != "" {
				if strings.HasPrefix(ns, "d8-") || ns == "kube-system" {
					namespaces[ns] = struct{}{}
				}
			} else {
				panic("empty ns: " + modulePath)
			}

			templatesDir := filepath.Join(filepath.Dir(path), "templates")
			if err := handleServiceAccounts(templatesDir, modulePath, name, ns, sas); err != nil {
				return err
			}

			return filepath.SkipDir

		case "Chart.yaml":
			// if module.yaml exists, skip this
			if _, err := os.Stat(filepath.Join(filepath.Dir(path), "module.yaml")); err == nil {
				return nil
			}

			if strings.Contains(path, "/charts/") {
				// skip subcharts dir
				return filepath.SkipDir
			}

			name, ns, err := processLegacyDeclaration(path)
			if err != nil {
				return err
			}

			if ns != "" {
				if strings.HasPrefix(ns, "d8-") || ns == "kube-system" {
					namespaces[ns] = struct{}{}
				}
			} else {
				panic("empty legacy ns: " + modulePath)
			}

			templatesDir := filepath.Join(filepath.Dir(path), "templates")
			if err := handleServiceAccounts(templatesDir, modulePath, name, ns, sas); err != nil {
				return err
			}

			return filepath.SkipDir

		default:
			// not a module dir
			return nil
		}

		return nil
	})

	return err
}

func unquote(s string) (string, error) {
	var err error
	if strings.HasPrefix(s, `"`) && strings.HasSuffix(s, `"`) || strings.HasPrefix(s, `'`) && strings.HasSuffix(s, `'`) {
		s, err = strconv.Unquote(s)
		if err != nil {
			return "", err
		}
	}

	return s, err
}

func main() {
	workDir := cwd()

	var (
		output string
		stream = os.Stdout
	)
	flag.StringVar(&output, "output", "", "output file for generated code")
	flag.Parse()

	if output != "" {
		var err error
		stream, err = os.Create(output)
		if err != nil {
			panic(err)
		}

		defer stream.Close()
	}

	var namespacesMap = make(map[string]struct{})
	var sasMap = make(map[string]struct{})
	if err := walkModules(namespacesMap, sasMap, workDir); err != nil {
		panic(err)
	}

	namespaces := make([]string, 0, len(namespacesMap))
	sas := make([]string, 0, len(sasMap))

	for namespace := range namespacesMap {
		namespaces = append(namespaces, namespace)
	}
	for sa := range sasMap {
		sas = append(sas, sa)
	}

	sort.Strings(namespaces)
	sort.Strings(sas)

	t := template.New("variables")
	t, err := t.Parse(variablesTemplate)
	if err != nil {
		panic(err)
	}

	type Data struct {
		Namespace, ServiceAccount []string
	}
	data := Data{
		Namespace:      uniqueNonEmptyElementsOf(namespaces),
		ServiceAccount: uniqueNonEmptyElementsOf(sas),
	}
	err = t.Execute(stream, data)
	if err != nil {
		panic(err)
	}
}

func uniqueNonEmptyElementsOf(s []string) []string {
	unique := make(map[string]bool, len(s))
	us := make([]string, len(unique))
	for _, elem := range s {
		if len(elem) != 0 {
			if !unique[elem] {
				us = append(us, elem)
				unique[elem] = true
			}
		}
	}

	return us
}
