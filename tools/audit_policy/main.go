/*
Copyright 2021 Flant JSC

Licensed under the Apache License, Version 2.0 (the "License");
you may not use this file except in compliance with the License.
You may obtain a copy of the License at

    http://www.apache.org/licenses/LICENSE-2.0

Unless required by applicable law or agreed to in writing, software
distributed under the License is distributed on an "AS IS" BASIS,
WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
See the License for the specific language governing permissions and
limitations under the License.
*/

package main

import (
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strconv"
	"strings"
	"text/template"

	yaml "gopkg.in/yaml.v3"
)

var variablesTemplate = `// Code generated by "tools/audit_policy.go" DO NOT EDIT.
package hooks

var auditPolicyBasicNamespaces = []string{
{{- range $value := .Namespace }}
	"{{ $value }}",
{{- end }}
}
var auditPolicyBasicServiceAccounts = []string{
{{- range $value := .ServiceAccount }}
	"{{ $value }}",
{{- end }}
}
`

func main() {
	workDir := cwd()

	var (
		output string
		stream = os.Stdout
	)
	flag.StringVar(&output, "output", "", "output file for generated code")
	flag.Parse()

	if output != "" {
		var err error
		stream, err = os.Create(output)
		if err != nil {
			panic(err)
		}

		defer stream.Close()
	}

	var namespacesMap = make(map[string]struct{})
	var sasMap = make(map[string]struct{})

	// 1. find all modules
	res, err := findModules(workDir)
	if err != nil {
		panic(err)
	}

	// 2. find templates for each module and fill ServiceAccounts info
	for moduleYamlPath, moduleDirName := range res {
		err = processModule(workDir, moduleYamlPath, moduleDirName, sasMap, namespacesMap)
		if err != nil {
			fmt.Println("moduleYamlPath: ", moduleYamlPath)
			panic(err)
		}
	}

	namespaces := make([]string, 0, len(namespacesMap))
	sas := make([]string, 0, len(sasMap))

	for namespace := range namespacesMap {
		namespaces = append(namespaces, namespace)
	}
	for sa := range sasMap {
		sas = append(sas, sa)
	}

	sort.Strings(namespaces)
	sort.Strings(sas)

	t := template.New("variables")
	t, err = t.Parse(variablesTemplate)
	if err != nil {
		panic(err)
	}

	type Data struct {
		Namespace, ServiceAccount []string
	}
	data := Data{
		Namespace:      uniqueNonEmptyElementsOf(namespaces),
		ServiceAccount: uniqueNonEmptyElementsOf(sas),
	}
	err = t.Execute(stream, data)
	if err != nil {
		panic(err)
	}
}

func cwd() string {
	_, f, _, ok := runtime.Caller(1)
	if !ok {
		panic("cannot get caller")
	}

	dir, err := filepath.Abs(f)
	if err != nil {
		panic(err)
	}

	for i := 0; i < 3; i++ { // ../../
		dir = filepath.Dir(dir)
	}

	// If deckhouse repo directory is symlinked (e.g. to /deckhouse), resolve the real path.
	// Otherwise, filepath.Walk will ignore all subdirectories.
	dir, err = filepath.EvalSymlinks(dir)
	if err != nil {
		panic(err)
	}

	return dir
}

type moduleMetadata struct {
	Name      string `yaml:"name"`
	Namespace string `yaml:"namespace"`
}

func processModuleDefinition(path string) ( /*name*/ string /*namespace*/, string, error) {
	// if file exists
	var s moduleMetadata
	c, err := os.Open(path)
	if err != nil {
		return "", "", err
	}
	defer c.Close()

	err = yaml.NewDecoder(c).Decode(&s)
	if err != nil {
		return "", "", err
	}

	if s.Namespace == "" {
		// trim file name from path
		dir := filepath.Dir(path)
		ns, err := os.ReadFile(filepath.Join(dir, ".namespace"))
		if err != nil {
			if errors.Is(err, os.ErrNotExist) {
				return s.Name, "", nil
			}
			return "", "", err
		}
		s.Namespace = strings.Trim(string(ns), "\r\n")
	}

	return s.Name, s.Namespace, nil
}

func processServiceAccounts(templatesDir string) ([]string, error) {
	serviceAccounts := make([]string, 0)
	err := filepath.Walk(templatesDir, func(path string, f os.FileInfo, err error) error {
		if f != nil && f.IsDir() {
			return nil
		}

		if filepath.Base(path) != "rbac-for-us.yaml" {
			return nil
		}

		rbac, err := os.ReadFile(path)
		if err != nil {
			return err
		}

		r := regexp.MustCompile(`apiVersion: v1
kind: ServiceAccount
metadata:
\s*name:\s*(.*)
`)
		match := r.FindAllStringSubmatch(string(rbac), -1)
		for _, m := range match {
			saName := strings.TrimSpace(m[1])
			if strings.HasPrefix(saName, "\"") {
				saName, err = unquote(saName)
				if err != nil {
					return err
				}
			}

			serviceAccounts = append(serviceAccounts, saName)
		}

		return nil

	})

	return serviceAccounts, err
}

func handleServiceAccounts(templatesDir string, modulePath string, name string, ns string, sas map[string]struct{}) error {
	serviceAccounts, err := processServiceAccounts(templatesDir)
	if err != nil {
		return err
	}

	for _, saName := range serviceAccounts {
		// ServiceAccounts for istiod will be added to audit rules in
		// modules/040-control-plane-manager/hooks/audit_policy.go
		if strings.HasPrefix(saName, "istiod-") {
			continue
		}

		saName = strings.Replace(saName, "{{ .Chart.Name }}", name, 1)
		saName = strings.Replace(saName, "{{ $.Chart.Name }}", name, 1)
		if len(saName) == 0 && len(name) == 0 {
			return fmt.Errorf("empty final SA name, seems chartName didnt resolve for module: %s", modulePath)
		}

		finalName := fmt.Sprintf("system:serviceaccount:%s:%s", ns, saName)
		sas[finalName] = struct{}{}
	}

	return nil
}

func unquote(s string) (string, error) {
	var err error
	if strings.HasPrefix(s, `"`) && strings.HasSuffix(s, `"`) || strings.HasPrefix(s, `'`) && strings.HasSuffix(s, `'`) {
		s, err = strconv.Unquote(s)
		if err != nil {
			return "", err
		}
	}

	return s, err
}

// findModules find all directories, contains module.yaml
// return map of absoulute path to module.yaml -> last directory, where module.yaml is located (xxx-module-name)
func findModules(root string) (map[string]string, error) {
	modulesMap := make(map[string]string)

	err := filepath.Walk(root, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if !info.IsDir() {
			return nil
		}

		modulePath := filepath.Join(path, "module.yaml")
		if _, err := os.Stat(modulePath); err != nil {
			return nil
		}

		relPath, err := filepath.Rel(root, path)
		if err != nil {
			return err
		}

		parts := strings.Split(filepath.ToSlash(relPath), "/")
		for _, part := range parts {
			if part == "modules" {
				dirName := filepath.Base(path)
				modulesMap[modulePath] = dirName
				break
			}
		}

		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("error walking the path %s: %v", root, err)
	}

	return modulesMap, nil
}

func processModule(workDir, moduleYamlPath, moduleDirName string, sas, namespacesMap map[string]struct{}) error {
	name, namespace, err := processModuleDefinition(moduleYamlPath)
	if err != nil {
		return err
	}

	templateDirs, err := findModuleTemplatesDirs(workDir, moduleDirName)
	if err != nil {
		return err
	}

	// namespace is required only if module has templates
	if len(templateDirs) > 0 && namespace == "" {
		panic("Empty namespace for module " + moduleYamlPath)
	}

	for _, td := range templateDirs {
		err = handleServiceAccounts(td, moduleYamlPath, name, namespace, sas)
		if err != nil {
			return err
		}
	}

	if strings.HasPrefix(namespace, "d8-") || namespace == "kube-system" {
		namespacesMap[namespace] = struct{}{}
	}

	return nil
}

func uniqueNonEmptyElementsOf(s []string) []string {
	unique := make(map[string]bool, len(s))
	us := make([]string, len(unique))
	for _, elem := range s {
		if len(elem) != 0 {
			if !unique[elem] {
				us = append(us, elem)
				unique[elem] = true
			}
		}
	}

	return us
}

// findModuleTemplatesDirs finds all templates directories within moduleDir
// under workDir. Returns a slice of absolute paths to templates directories.
func findModuleTemplatesDirs(workDir, moduleDir string) ([]string, error) {
	var templatesDirs []string

	checkTemplates := func(modulePath string) error {
		templatesPath := filepath.Join(modulePath, "templates")

		info, err := os.Stat(templatesPath)
		if err != nil {
			if !os.IsNotExist(err) {
				return fmt.Errorf("error checking templates dir %s: %v", templatesPath, err)
			}

			return nil
		}

		if info.IsDir() {
			templatesDirs = append(templatesDirs, templatesPath)
		}

		return nil
	}

	// recursive find moduleDir
	err := filepath.Walk(workDir, func(path string, info os.FileInfo, err error) error {
		if err != nil {
			return err
		}

		if info.IsDir() && filepath.Base(path) == moduleDir {
			if err := checkTemplates(path); err != nil {
				return err
			}
		}
		return nil
	})

	if err != nil {
		return nil, fmt.Errorf("error searching for module dirs: %v", err)
	}

	return templatesDirs, nil
}
