package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type ComponentFeatures struct {
	Deprecated            []string `yaml:"deprecated"`
	Forbidden             []string `yaml:"forbidden"`
	Kubelet               []string `yaml:"kubelet"`
	APIServer             []string `yaml:"apiserver"`
	KubeControllerManager []string `yaml:"kubeControllerManager"`
	KubeScheduler         []string `yaml:"kubeScheduler"`
}

type FeatureGatesConfig map[string]ComponentFeatures

var (
	inputFile = flag.String("input", "feature_gates_map.yml", "Path to input YAML file")
	outputPy  = flag.String("output-py", "", "Path to output Python file")
	outputGo  = flag.String("output-go", "", "Path to output Go file")
)

const pythonTemplate = `# Code generated by go generate; DO NOT EDIT.
# This file is generated from {{ .InputFile }}

versions = {
{{- range $version, $features := .Versions }}
    "{{ $version }}": {
{{- if $features.Deprecated }}
        "deprecated": [
{{- range $features.Deprecated }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.Forbidden }}
        "forbidden": [
{{- range $features.Forbidden }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.Kubelet }}
        "kubelet": [
{{- range $features.Kubelet }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.APIServer }}
        "apiserver": [
{{- range $features.APIServer }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.KubeControllerManager }}
        "kubeControllerManager": [
{{- range $features.KubeControllerManager }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.KubeScheduler }}
        "kubeScheduler": [
{{- range $features.KubeScheduler }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
    },
{{- end }}
}

def is_forbidden(version: str, feature_name: str) -> bool:
    if version not in versions:
        return False
    
    features = versions[version]
    return "forbidden" in features and feature_name in features["forbidden"]


def is_deprecated(version: str, feature_name: str) -> bool:
    if version not in versions:
        return False
    
    features = versions[version]
    return "deprecated" in features and feature_name in features["deprecated"]


def exists_in_component(version: str, component: str, feature_name: str) -> bool:
    if version not in versions:
        return False
    
    if component not in ["kubelet", "apiserver", "kubeControllerManager", "kubeScheduler"]:
        return False
    
    features = versions[version]
    return component in features and feature_name in features[component]


def is_feature_gate_deprecated_up_to_version(feature_gate: str, target_version: str) -> bool:
    try:
        target_major, target_minor = map(int, target_version.split('.'))
    except Exception:
        return False
    
    for version in versions.keys():
        try:
            major, minor = map(int, version.split('.'))
            if (major, minor) <= (target_major, target_minor):
                if is_deprecated(version, feature_gate):
                    return True
        except Exception:
            continue
    
    return False
`

const goTemplate = `// Code generated by go generate; DO NOT EDIT.
// This file is generated from {{ .InputFile }}

package {{ .Package }}

import "fmt"

type ComponentFeatures struct {
	Deprecated            []string
	Forbidden             []string
	Kubelet               []string
	APIServer             []string
	KubeControllerManager []string
	KubeScheduler         []string
}

type FeatureGateInfo struct {
	Exists bool
	IsDeprecated bool
	IsForbidden  bool
}

func (cf *ComponentFeatures) IsForbidden(feature string) bool {
	for _, f := range cf.Forbidden {
		if f == feature {
			return true
		}
	}
	return false
}

func (cf *ComponentFeatures) IsDeprecated(feature string) bool {
	for _, f := range cf.Deprecated {
		if f == feature {
			return true
		}
	}
	return false
}

func (cf *ComponentFeatures) ValidateFeature(feature string) error {
	if cf.IsForbidden(feature) {
		return fmt.Errorf("feature gate %s is forbidden", feature)
	}
	if cf.IsDeprecated(feature) {
		return fmt.Errorf("feature gate %s is deprecated", feature)
	}
	return nil
}

func (cf *ComponentFeatures) GetFeatureGateInfo(component, featureName string) FeatureGateInfo {
	info := FeatureGateInfo{}
	
	if cf.IsDeprecated(featureName) {
		info.IsDeprecated = true
	}
	
	if cf.IsForbidden(featureName) {
		info.IsForbidden = true
	}

	var featureList []string
	switch component {
	case "kubelet":
		featureList = cf.Kubelet
	case "apiserver":
		featureList = cf.APIServer
	case "kubeControllerManager":
		featureList = cf.KubeControllerManager
	case "kubeScheduler":
		featureList = cf.KubeScheduler
	default:
		return info
	}
	
	for _, name := range featureList {
		if name == featureName {
			info.Exists = true
			return info
		}
	}
	
	return info
}

var FeatureGatesMap = map[string]ComponentFeatures{
{{- range $version, $features := .Versions }}
	"{{ $version }}": {
{{- if $features.Deprecated }}
		Deprecated: []string{
{{- range $features.Deprecated }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.Forbidden }}
		Forbidden: []string{
{{- range $features.Forbidden }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.Kubelet }}
		Kubelet: []string{
{{- range $features.Kubelet }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.APIServer }}
		APIServer: []string{
{{- range $features.APIServer }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.KubeControllerManager }}
		KubeControllerManager: []string{
{{- range $features.KubeControllerManager }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.KubeScheduler }}
		KubeScheduler: []string{
{{- range $features.KubeScheduler }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
	},
{{- end }}
}
`

type TemplateData struct {
	InputFile string
	Package   string
	Versions  map[string]ComponentFeatures
}

func main() {
	flag.Parse()

	if *inputFile == "" {
		fmt.Fprintf(os.Stderr, "Error: -input flag is required\n")
		os.Exit(1)
	}

	data, err := os.ReadFile(*inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading input file: %v\n", err)
		os.Exit(1)
	}

	var config FeatureGatesConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	versions := make([]string, 0, len(config))
	for v := range config {
		versions = append(versions, v)
	}
	sort.Strings(versions)

	orderedVersions := make(map[string]ComponentFeatures)
	for _, v := range versions {
		orderedVersions[v] = config[v]
	}

	if *outputPy != "" {
		if err := generateFile(pythonTemplate, TemplateData{
			InputFile: filepath.Base(*inputFile),
			Versions:  orderedVersions,
		}, *outputPy); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Python file: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Generated: %s\n", *outputPy)
	}

	if *outputGo != "" {
		packageName := "feature_gates"
		if dir := filepath.Dir(*outputGo); dir != "." && dir != "" {
			packageName = filepath.Base(dir)
		}

		if err := generateFile(goTemplate, TemplateData{
			InputFile: filepath.Base(*inputFile),
			Package:   packageName,
			Versions:  orderedVersions,
		}, *outputGo); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Go file: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Generated: %s\n", *outputGo)
	}
}

func generateFile(tmplStr string, data TemplateData, outputPath string) error {
	tmpl, err := template.New("output").Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	output := strings.ReplaceAll(buf.String(), "\n\n\n", "\n\n")

	dir := filepath.Dir(outputPath)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("creating directory: %w", err)
		}
	}

	if err := os.WriteFile(outputPath, []byte(output), 0644); err != nil {
		return fmt.Errorf("writing file: %w", err)
	}

	return nil
}
