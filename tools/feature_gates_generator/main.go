package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type ComponentFeatures struct {
	Deprecated            []string `yaml:"deprecated"`
	Forbidden             []string `yaml:"forbidden"`
	Kubelet               []string `yaml:"kubelet"`
	APIServer             []string `yaml:"apiserver"`
	KubeControllerManager []string `yaml:"kube-controller-manager"`
	KubeScheduler         []string `yaml:"kube-scheduler"`
}

type FeatureGatesConfig map[string]ComponentFeatures

var (
	inputFile = flag.String("input", "feature_gates_map.yml", "Path to input YAML file")
	outputPy  = flag.String("output-py", "", "Path to output Python file")
	outputGo  = flag.String("output-go", "", "Path to output Go file")
)

const pythonTemplate = `# Code generated by go generate; DO NOT EDIT.
# This file is generated from {{ .InputFile }}

versions = {
{{- range $version, $features := .Versions }}
    "{{ $version }}": {
{{- if $features.Deprecated }}
        "deprecated": [
{{- range $features.Deprecated }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.Forbidden }}
        "forbidden": [
{{- range $features.Forbidden }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.Kubelet }}
        "kubelet": [
{{- range $features.Kubelet }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.APIServer }}
        "apiserver": [
{{- range $features.APIServer }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.KubeControllerManager }}
        "kube-controller-manager": [
{{- range $features.KubeControllerManager }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.KubeScheduler }}
        "kube-scheduler": [
{{- range $features.KubeScheduler }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
    },
{{- end }}
}
`

const goTemplate = `// Code generated by go generate; DO NOT EDIT.
// This file is generated from {{ .InputFile }}

package {{ .Package }}

type ComponentFeatures struct {
	Deprecated            []string
	Forbidden             []string
	Kubelet               []string
	APIServer             []string
	KubeControllerManager []string
	KubeScheduler         []string
}

var FeatureGatesMap = map[string]ComponentFeatures{
{{- range $version, $features := .Versions }}
	"{{ $version }}": {
{{- if $features.Deprecated }}
		Deprecated: []string{
{{- range $features.Deprecated }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.Forbidden }}
		Forbidden: []string{
{{- range $features.Forbidden }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.Kubelet }}
		Kubelet: []string{
{{- range $features.Kubelet }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.APIServer }}
		APIServer: []string{
{{- range $features.APIServer }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.KubeControllerManager }}
		KubeControllerManager: []string{
{{- range $features.KubeControllerManager }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.KubeScheduler }}
		KubeScheduler: []string{
{{- range $features.KubeScheduler }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
	},
{{- end }}
}
`

type TemplateData struct {
	InputFile string
	Package   string
	Versions  map[string]ComponentFeatures
}

func main() {
	flag.Parse()

	if *inputFile == "" {
		fmt.Fprintf(os.Stderr, "Error: -input flag is required\n")
		os.Exit(1)
	}

	data, err := os.ReadFile(*inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading input file: %v\n", err)
		os.Exit(1)
	}

	var config FeatureGatesConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	versions := make([]string, 0, len(config))
	for v := range config {
		versions = append(versions, v)
	}
	sort.Strings(versions)

	orderedVersions := make(map[string]ComponentFeatures)
	for _, v := range versions {
		orderedVersions[v] = config[v]
	}

	if *outputPy != "" {
		if err := generateFile(pythonTemplate, TemplateData{
			InputFile: filepath.Base(*inputFile),
			Versions:  orderedVersions,
		}, *outputPy); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Python file: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Generated: %s\n", *outputPy)
	}

	if *outputGo != "" {
		packageName := "feature_gates"
		if dir := filepath.Dir(*outputGo); dir != "." && dir != "" {
			packageName = filepath.Base(dir)
		}

		if err := generateFile(goTemplate, TemplateData{
			InputFile: filepath.Base(*inputFile),
			Package:   packageName,
			Versions:  orderedVersions,
		}, *outputGo); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Go file: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Generated: %s\n", *outputGo)
	}
}

func generateFile(tmplStr string, data TemplateData, outputPath string) error {
	tmpl, err := template.New("output").Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	output := strings.ReplaceAll(buf.String(), "\n\n\n", "\n\n")

	dir := filepath.Dir(outputPath)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("creating directory: %w", err)
		}
	}

	if err := os.WriteFile(outputPath, []byte(output), 0644); err != nil {
		return fmt.Errorf("writing file: %w", err)
	}

	return nil
}
