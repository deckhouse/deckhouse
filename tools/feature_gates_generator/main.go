package main

import (
	"bytes"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"sort"
	"strings"
	"text/template"

	"gopkg.in/yaml.v3"
)

type ComponentFeatures struct {
	Deprecated            []string `yaml:"deprecated"`
	Forbidden             []string `yaml:"forbidden"`
	Kubelet               []string `yaml:"kubelet"`
	APIServer             []string `yaml:"apiserver"`
	KubeControllerManager []string `yaml:"kubeControllerManager"`
	KubeScheduler         []string `yaml:"kubeScheduler"`
}

type FeatureGatesConfig map[string]ComponentFeatures

var (
	inputFile = flag.String("input", "feature_gates_map.yml", "Path to input YAML file")
	outputPy  = flag.String("output-py", "", "Path to output Python file")
	outputGo  = flag.String("output-go", "", "Path to output Go file")
)

const pythonTemplate = `# Code generated by go generate; DO NOT EDIT.
# This file is generated from {{ .InputFile }}

versions = {
{{- range $version, $features := .Versions }}
    "{{ $version }}": {
{{- if $features.Deprecated }}
        "deprecated": [
{{- range $features.Deprecated }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.Forbidden }}
        "forbidden": [
{{- range $features.Forbidden }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.Kubelet }}
        "kubelet": [
{{- range $features.Kubelet }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.APIServer }}
        "apiserver": [
{{- range $features.APIServer }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.KubeControllerManager }}
        "kubeControllerManager": [
{{- range $features.KubeControllerManager }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
{{- if $features.KubeScheduler }}
        "kubeScheduler": [
{{- range $features.KubeScheduler }}
            "{{ . }}",
{{- end }}
        ],
{{- end }}
    },
{{- end }}
}


class FeatureGateInfo:
    
    def __init__(
        self,
        exists: bool = False,
        is_deprecated: bool = False,
        is_forbidden: bool = False,
    ):
        self.exists = exists
        self.is_deprecated = is_deprecated
        self.is_forbidden = is_forbidden
    
    def __repr__(self):
        return (
            f"FeatureGateInfo(exists={self.exists}, "
            f"is_deprecated={self.is_deprecated}, is_forbidden={self.is_forbidden})"
        )


def get_feature_gate_info(version: str, component: str, feature_name: str) -> FeatureGateInfo:
    info = FeatureGateInfo()
    
    if version not in versions:
        return info
    
    features = versions[version]
    
    if "deprecated" in features and feature_name in features["deprecated"]:
        info.is_deprecated = True
    
    if "forbidden" in features and feature_name in features["forbidden"]:
        info.is_forbidden = True
    
    if component not in ["kubelet", "apiserver", "kubeControllerManager", "kubeScheduler"]:
        return info
    
    if component in features and feature_name in features[component]:
        info.exists = True
    
    return info
`

const goTemplate = `// Code generated by go generate; DO NOT EDIT.
// This file is generated from {{ .InputFile }}

package {{ .Package }}

import (
	"fmt"
)

type ComponentFeatures struct {
	Deprecated            []string
	Forbidden             []string
	Kubelet               []string
	APIServer             []string
	KubeControllerManager []string
	KubeScheduler         []string
}

type FeatureGateInfo struct {
	Exists bool
	IsDeprecated bool
	IsForbidden bool
}

var FeatureGatesMap = map[string]ComponentFeatures{
{{- range $version, $features := .Versions }}
	"{{ $version }}": {
{{- if $features.Deprecated }}
		Deprecated: []string{
{{- range $features.Deprecated }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.Forbidden }}
		Forbidden: []string{
{{- range $features.Forbidden }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.Kubelet }}
		Kubelet: []string{
{{- range $features.Kubelet }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.APIServer }}
		APIServer: []string{
{{- range $features.APIServer }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.KubeControllerManager }}
		KubeControllerManager: []string{
{{- range $features.KubeControllerManager }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
{{- if $features.KubeScheduler }}
		KubeScheduler: []string{
{{- range $features.KubeScheduler }}
			"{{ . }}",
{{- end }}
		},
{{- end }}
	},
{{- end }}
}

func (cf *ComponentFeatures) GetFeatureGateInfo(component, featureName string) FeatureGateInfo {
	info := FeatureGateInfo{}
	for _, name := range cf.Deprecated {
		if name == featureName {
			info.IsDeprecated = true
			break
		}
	}

	for _, name := range cf.Forbidden {
		if name == featureName {
			info.IsForbidden = true
			break
		}
	}

	var featureList []string
	switch component {
	case "kubelet":
		featureList = cf.Kubelet
	case "apiserver":
		featureList = cf.APIServer
	case "kube-controller-manager":
		featureList = cf.KubeControllerManager
	case "kube-scheduler":
		featureList = cf.KubeScheduler
	default:
		return info
	}

	for _, name := range featureList {
		if name == featureName {
			info.Exists = true
			return info
		}
	}

	return info
}

func (cf *ComponentFeatures) IsForbidden(feature string) bool {
	for _, f := range cf.Forbidden {
		if f == feature {
			return true
		}
	}
	return false
}

func (cf *ComponentFeatures) IsDeprecated(feature string) bool {
	for _, f := range cf.Deprecated {
		if f == feature {
			return true
		}
	}
	return false
}

func (cf *ComponentFeatures) ValidateFeature(feature string) error {
	if cf.IsForbidden(feature) {
		return fmt.Errorf("feature gate %s is forbidden", feature)
	}
	if cf.IsDeprecated(feature) {
		return fmt.Errorf("feature gate %s is deprecated", feature)
	}
	return nil
}
`

type TemplateData struct {
	InputFile string
	Package   string
	Versions  map[string]ComponentFeatures
}

func main() {
	flag.Parse()

	if *inputFile == "" {
		fmt.Fprintf(os.Stderr, "Error: -input flag is required\n")
		os.Exit(1)
	}

	data, err := os.ReadFile(*inputFile)
	if err != nil {
		fmt.Fprintf(os.Stderr, "Error reading input file: %v\n", err)
		os.Exit(1)
	}

	var config FeatureGatesConfig
	if err := yaml.Unmarshal(data, &config); err != nil {
		fmt.Fprintf(os.Stderr, "Error parsing YAML: %v\n", err)
		os.Exit(1)
	}

	versions := make([]string, 0, len(config))
	for v := range config {
		versions = append(versions, v)
	}
	sort.Strings(versions)

	orderedVersions := make(map[string]ComponentFeatures)
	for _, v := range versions {
		orderedVersions[v] = config[v]
	}

	if *outputPy != "" {
		if err := generateFile(pythonTemplate, TemplateData{
			InputFile: filepath.Base(*inputFile),
			Versions:  orderedVersions,
		}, *outputPy); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Python file: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Generated: %s\n", *outputPy)
	}

	if *outputGo != "" {
		packageName := "feature_gates"
		if dir := filepath.Dir(*outputGo); dir != "." && dir != ""{
			packageName = filepath.Base(dir)
		}
		if packageName == "discovery" {
			packageName = "hooks"
		}

		if err := generateFile(goTemplate, TemplateData{
			InputFile: filepath.Base(*inputFile),
			Package:   packageName,
			Versions:  orderedVersions,
		}, *outputGo); err != nil {
			fmt.Fprintf(os.Stderr, "Error generating Go file: %v\n", err)
			os.Exit(1)
		}
		fmt.Printf("Generated: %s\n", *outputGo)
	}
}

func generateFile(tmplStr string, data TemplateData, outputPath string) error {
	tmpl, err := template.New("output").Parse(tmplStr)
	if err != nil {
		return fmt.Errorf("parsing template: %w", err)
	}

	var buf bytes.Buffer
	if err := tmpl.Execute(&buf, data); err != nil {
		return fmt.Errorf("executing template: %w", err)
	}

	output := strings.ReplaceAll(buf.String(), "\n\n\n", "\n\n")

	dir := filepath.Dir(outputPath)
	if dir != "." && dir != "" {
		if err := os.MkdirAll(dir, 0755); err != nil {
			return fmt.Errorf("creating directory: %w", err)
		}
	}

	if err := os.WriteFile(outputPath, []byte(output), 0644); err != nil {
		return fmt.Errorf("writing file: %w", err)
	}

	return nil
}
