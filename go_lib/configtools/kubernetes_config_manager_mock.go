// Code generated by http://github.com/gojuno/minimock ((devel)). DO NOT EDIT.

package configtools

//go:generate minimock -i github.com/flant/addon-operator/pkg/module_manager.KubeConfigManager -o kubernetes_config_manager_mock.go -n KubeConfigManagerMock -p configtools

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/flant/addon-operator/pkg/kube_config_manager/config"
	"github.com/flant/addon-operator/pkg/utils"
	"github.com/gojuno/minimock/v3"
)

// KubeConfigManagerMock implements mm_module_manager.KubeConfigManager
type KubeConfigManagerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcIsModuleEnabled          func(moduleName string) (bp1 *bool)
	funcIsModuleEnabledOrigin    string
	inspectFuncIsModuleEnabled   func(moduleName string)
	afterIsModuleEnabledCounter  uint64
	beforeIsModuleEnabledCounter uint64
	IsModuleEnabledMock          mKubeConfigManagerMockIsModuleEnabled

	funcKubeConfigEventCh          func() (ch1 chan config.KubeConfigEvent)
	funcKubeConfigEventChOrigin    string
	inspectFuncKubeConfigEventCh   func()
	afterKubeConfigEventChCounter  uint64
	beforeKubeConfigEventChCounter uint64
	KubeConfigEventChMock          mKubeConfigManagerMockKubeConfigEventCh

	funcSafeReadConfig          func(handler func(config *config.KubeConfig))
	funcSafeReadConfigOrigin    string
	inspectFuncSafeReadConfig   func(handler func(config *config.KubeConfig))
	afterSafeReadConfigCounter  uint64
	beforeSafeReadConfigCounter uint64
	SafeReadConfigMock          mKubeConfigManagerMockSafeReadConfig

	funcSaveConfigValues          func(key string, values utils.Values) (err error)
	funcSaveConfigValuesOrigin    string
	inspectFuncSaveConfigValues   func(key string, values utils.Values)
	afterSaveConfigValuesCounter  uint64
	beforeSaveConfigValuesCounter uint64
	SaveConfigValuesMock          mKubeConfigManagerMockSaveConfigValues

	funcUpdateModuleConfig          func(moduleName string) (err error)
	funcUpdateModuleConfigOrigin    string
	inspectFuncUpdateModuleConfig   func(moduleName string)
	afterUpdateModuleConfigCounter  uint64
	beforeUpdateModuleConfigCounter uint64
	UpdateModuleConfigMock          mKubeConfigManagerMockUpdateModuleConfig
}

// NewKubeConfigManagerMock returns a mock for mm_module_manager.KubeConfigManager
func NewKubeConfigManagerMock(t minimock.Tester) *KubeConfigManagerMock {
	m := &KubeConfigManagerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsModuleEnabledMock = mKubeConfigManagerMockIsModuleEnabled{mock: m}
	m.IsModuleEnabledMock.callArgs = []*KubeConfigManagerMockIsModuleEnabledParams{}

	m.KubeConfigEventChMock = mKubeConfigManagerMockKubeConfigEventCh{mock: m}

	m.SafeReadConfigMock = mKubeConfigManagerMockSafeReadConfig{mock: m}
	m.SafeReadConfigMock.callArgs = []*KubeConfigManagerMockSafeReadConfigParams{}

	m.SaveConfigValuesMock = mKubeConfigManagerMockSaveConfigValues{mock: m}
	m.SaveConfigValuesMock.callArgs = []*KubeConfigManagerMockSaveConfigValuesParams{}

	m.UpdateModuleConfigMock = mKubeConfigManagerMockUpdateModuleConfig{mock: m}
	m.UpdateModuleConfigMock.callArgs = []*KubeConfigManagerMockUpdateModuleConfigParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mKubeConfigManagerMockIsModuleEnabled struct {
	optional           bool
	mock               *KubeConfigManagerMock
	defaultExpectation *KubeConfigManagerMockIsModuleEnabledExpectation
	expectations       []*KubeConfigManagerMockIsModuleEnabledExpectation

	callArgs []*KubeConfigManagerMockIsModuleEnabledParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubeConfigManagerMockIsModuleEnabledExpectation specifies expectation struct of the KubeConfigManager.IsModuleEnabled
type KubeConfigManagerMockIsModuleEnabledExpectation struct {
	mock               *KubeConfigManagerMock
	params             *KubeConfigManagerMockIsModuleEnabledParams
	paramPtrs          *KubeConfigManagerMockIsModuleEnabledParamPtrs
	expectationOrigins KubeConfigManagerMockIsModuleEnabledExpectationOrigins
	results            *KubeConfigManagerMockIsModuleEnabledResults
	returnOrigin       string
	Counter            uint64
}

// KubeConfigManagerMockIsModuleEnabledParams contains parameters of the KubeConfigManager.IsModuleEnabled
type KubeConfigManagerMockIsModuleEnabledParams struct {
	moduleName string
}

// KubeConfigManagerMockIsModuleEnabledParamPtrs contains pointers to parameters of the KubeConfigManager.IsModuleEnabled
type KubeConfigManagerMockIsModuleEnabledParamPtrs struct {
	moduleName *string
}

// KubeConfigManagerMockIsModuleEnabledResults contains results of the KubeConfigManager.IsModuleEnabled
type KubeConfigManagerMockIsModuleEnabledResults struct {
	bp1 *bool
}

// KubeConfigManagerMockIsModuleEnabledOrigins contains origins of expectations of the KubeConfigManager.IsModuleEnabled
type KubeConfigManagerMockIsModuleEnabledExpectationOrigins struct {
	origin           string
	originModuleName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) Optional() *mKubeConfigManagerMockIsModuleEnabled {
	mmIsModuleEnabled.optional = true
	return mmIsModuleEnabled
}

// Expect sets up expected params for KubeConfigManager.IsModuleEnabled
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) Expect(moduleName string) *mKubeConfigManagerMockIsModuleEnabled {
	if mmIsModuleEnabled.mock.funcIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("KubeConfigManagerMock.IsModuleEnabled mock is already set by Set")
	}

	if mmIsModuleEnabled.defaultExpectation == nil {
		mmIsModuleEnabled.defaultExpectation = &KubeConfigManagerMockIsModuleEnabledExpectation{}
	}

	if mmIsModuleEnabled.defaultExpectation.paramPtrs != nil {
		mmIsModuleEnabled.mock.t.Fatalf("KubeConfigManagerMock.IsModuleEnabled mock is already set by ExpectParams functions")
	}

	mmIsModuleEnabled.defaultExpectation.params = &KubeConfigManagerMockIsModuleEnabledParams{moduleName}
	mmIsModuleEnabled.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsModuleEnabled.expectations {
		if minimock.Equal(e.params, mmIsModuleEnabled.defaultExpectation.params) {
			mmIsModuleEnabled.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsModuleEnabled.defaultExpectation.params)
		}
	}

	return mmIsModuleEnabled
}

// ExpectModuleNameParam1 sets up expected param moduleName for KubeConfigManager.IsModuleEnabled
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) ExpectModuleNameParam1(moduleName string) *mKubeConfigManagerMockIsModuleEnabled {
	if mmIsModuleEnabled.mock.funcIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("KubeConfigManagerMock.IsModuleEnabled mock is already set by Set")
	}

	if mmIsModuleEnabled.defaultExpectation == nil {
		mmIsModuleEnabled.defaultExpectation = &KubeConfigManagerMockIsModuleEnabledExpectation{}
	}

	if mmIsModuleEnabled.defaultExpectation.params != nil {
		mmIsModuleEnabled.mock.t.Fatalf("KubeConfigManagerMock.IsModuleEnabled mock is already set by Expect")
	}

	if mmIsModuleEnabled.defaultExpectation.paramPtrs == nil {
		mmIsModuleEnabled.defaultExpectation.paramPtrs = &KubeConfigManagerMockIsModuleEnabledParamPtrs{}
	}
	mmIsModuleEnabled.defaultExpectation.paramPtrs.moduleName = &moduleName
	mmIsModuleEnabled.defaultExpectation.expectationOrigins.originModuleName = minimock.CallerInfo(1)

	return mmIsModuleEnabled
}

// Inspect accepts an inspector function that has same arguments as the KubeConfigManager.IsModuleEnabled
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) Inspect(f func(moduleName string)) *mKubeConfigManagerMockIsModuleEnabled {
	if mmIsModuleEnabled.mock.inspectFuncIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("Inspect function is already set for KubeConfigManagerMock.IsModuleEnabled")
	}

	mmIsModuleEnabled.mock.inspectFuncIsModuleEnabled = f

	return mmIsModuleEnabled
}

// Return sets up results that will be returned by KubeConfigManager.IsModuleEnabled
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) Return(bp1 *bool) *KubeConfigManagerMock {
	if mmIsModuleEnabled.mock.funcIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("KubeConfigManagerMock.IsModuleEnabled mock is already set by Set")
	}

	if mmIsModuleEnabled.defaultExpectation == nil {
		mmIsModuleEnabled.defaultExpectation = &KubeConfigManagerMockIsModuleEnabledExpectation{mock: mmIsModuleEnabled.mock}
	}
	mmIsModuleEnabled.defaultExpectation.results = &KubeConfigManagerMockIsModuleEnabledResults{bp1}
	mmIsModuleEnabled.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsModuleEnabled.mock
}

// Set uses given function f to mock the KubeConfigManager.IsModuleEnabled method
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) Set(f func(moduleName string) (bp1 *bool)) *KubeConfigManagerMock {
	if mmIsModuleEnabled.defaultExpectation != nil {
		mmIsModuleEnabled.mock.t.Fatalf("Default expectation is already set for the KubeConfigManager.IsModuleEnabled method")
	}

	if len(mmIsModuleEnabled.expectations) > 0 {
		mmIsModuleEnabled.mock.t.Fatalf("Some expectations are already set for the KubeConfigManager.IsModuleEnabled method")
	}

	mmIsModuleEnabled.mock.funcIsModuleEnabled = f
	mmIsModuleEnabled.mock.funcIsModuleEnabledOrigin = minimock.CallerInfo(1)
	return mmIsModuleEnabled.mock
}

// When sets expectation for the KubeConfigManager.IsModuleEnabled which will trigger the result defined by the following
// Then helper
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) When(moduleName string) *KubeConfigManagerMockIsModuleEnabledExpectation {
	if mmIsModuleEnabled.mock.funcIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("KubeConfigManagerMock.IsModuleEnabled mock is already set by Set")
	}

	expectation := &KubeConfigManagerMockIsModuleEnabledExpectation{
		mock:               mmIsModuleEnabled.mock,
		params:             &KubeConfigManagerMockIsModuleEnabledParams{moduleName},
		expectationOrigins: KubeConfigManagerMockIsModuleEnabledExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsModuleEnabled.expectations = append(mmIsModuleEnabled.expectations, expectation)
	return expectation
}

// Then sets up KubeConfigManager.IsModuleEnabled return parameters for the expectation previously defined by the When method
func (e *KubeConfigManagerMockIsModuleEnabledExpectation) Then(bp1 *bool) *KubeConfigManagerMock {
	e.results = &KubeConfigManagerMockIsModuleEnabledResults{bp1}
	return e.mock
}

// Times sets number of times KubeConfigManager.IsModuleEnabled should be invoked
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) Times(n uint64) *mKubeConfigManagerMockIsModuleEnabled {
	if n == 0 {
		mmIsModuleEnabled.mock.t.Fatalf("Times of KubeConfigManagerMock.IsModuleEnabled mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsModuleEnabled.expectedInvocations, n)
	mmIsModuleEnabled.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsModuleEnabled
}

func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) invocationsDone() bool {
	if len(mmIsModuleEnabled.expectations) == 0 && mmIsModuleEnabled.defaultExpectation == nil && mmIsModuleEnabled.mock.funcIsModuleEnabled == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsModuleEnabled.mock.afterIsModuleEnabledCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsModuleEnabled.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsModuleEnabled implements mm_module_manager.KubeConfigManager
func (mmIsModuleEnabled *KubeConfigManagerMock) IsModuleEnabled(moduleName string) (bp1 *bool) {
	mm_atomic.AddUint64(&mmIsModuleEnabled.beforeIsModuleEnabledCounter, 1)
	defer mm_atomic.AddUint64(&mmIsModuleEnabled.afterIsModuleEnabledCounter, 1)

	mmIsModuleEnabled.t.Helper()

	if mmIsModuleEnabled.inspectFuncIsModuleEnabled != nil {
		mmIsModuleEnabled.inspectFuncIsModuleEnabled(moduleName)
	}

	mm_params := KubeConfigManagerMockIsModuleEnabledParams{moduleName}

	// Record call args
	mmIsModuleEnabled.IsModuleEnabledMock.mutex.Lock()
	mmIsModuleEnabled.IsModuleEnabledMock.callArgs = append(mmIsModuleEnabled.IsModuleEnabledMock.callArgs, &mm_params)
	mmIsModuleEnabled.IsModuleEnabledMock.mutex.Unlock()

	for _, e := range mmIsModuleEnabled.IsModuleEnabledMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.bp1
		}
	}

	if mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.Counter, 1)
		mm_want := mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.params
		mm_want_ptrs := mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.paramPtrs

		mm_got := KubeConfigManagerMockIsModuleEnabledParams{moduleName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.moduleName != nil && !minimock.Equal(*mm_want_ptrs.moduleName, mm_got.moduleName) {
				mmIsModuleEnabled.t.Errorf("KubeConfigManagerMock.IsModuleEnabled got unexpected parameter moduleName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.expectationOrigins.originModuleName, *mm_want_ptrs.moduleName, mm_got.moduleName, minimock.Diff(*mm_want_ptrs.moduleName, mm_got.moduleName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsModuleEnabled.t.Errorf("KubeConfigManagerMock.IsModuleEnabled got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.results
		if mm_results == nil {
			mmIsModuleEnabled.t.Fatal("No results are set for the KubeConfigManagerMock.IsModuleEnabled")
		}
		return (*mm_results).bp1
	}
	if mmIsModuleEnabled.funcIsModuleEnabled != nil {
		return mmIsModuleEnabled.funcIsModuleEnabled(moduleName)
	}
	mmIsModuleEnabled.t.Fatalf("Unexpected call to KubeConfigManagerMock.IsModuleEnabled. %v", moduleName)
	return
}

// IsModuleEnabledAfterCounter returns a count of finished KubeConfigManagerMock.IsModuleEnabled invocations
func (mmIsModuleEnabled *KubeConfigManagerMock) IsModuleEnabledAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsModuleEnabled.afterIsModuleEnabledCounter)
}

// IsModuleEnabledBeforeCounter returns a count of KubeConfigManagerMock.IsModuleEnabled invocations
func (mmIsModuleEnabled *KubeConfigManagerMock) IsModuleEnabledBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsModuleEnabled.beforeIsModuleEnabledCounter)
}

// Calls returns a list of arguments used in each call to KubeConfigManagerMock.IsModuleEnabled.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsModuleEnabled *mKubeConfigManagerMockIsModuleEnabled) Calls() []*KubeConfigManagerMockIsModuleEnabledParams {
	mmIsModuleEnabled.mutex.RLock()

	argCopy := make([]*KubeConfigManagerMockIsModuleEnabledParams, len(mmIsModuleEnabled.callArgs))
	copy(argCopy, mmIsModuleEnabled.callArgs)

	mmIsModuleEnabled.mutex.RUnlock()

	return argCopy
}

// MinimockIsModuleEnabledDone returns true if the count of the IsModuleEnabled invocations corresponds
// the number of defined expectations
func (m *KubeConfigManagerMock) MinimockIsModuleEnabledDone() bool {
	if m.IsModuleEnabledMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsModuleEnabledMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsModuleEnabledMock.invocationsDone()
}

// MinimockIsModuleEnabledInspect logs each unmet expectation
func (m *KubeConfigManagerMock) MinimockIsModuleEnabledInspect() {
	for _, e := range m.IsModuleEnabledMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubeConfigManagerMock.IsModuleEnabled at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsModuleEnabledCounter := mm_atomic.LoadUint64(&m.afterIsModuleEnabledCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsModuleEnabledMock.defaultExpectation != nil && afterIsModuleEnabledCounter < 1 {
		if m.IsModuleEnabledMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubeConfigManagerMock.IsModuleEnabled at\n%s", m.IsModuleEnabledMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubeConfigManagerMock.IsModuleEnabled at\n%s with params: %#v", m.IsModuleEnabledMock.defaultExpectation.expectationOrigins.origin, *m.IsModuleEnabledMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsModuleEnabled != nil && afterIsModuleEnabledCounter < 1 {
		m.t.Errorf("Expected call to KubeConfigManagerMock.IsModuleEnabled at\n%s", m.funcIsModuleEnabledOrigin)
	}

	if !m.IsModuleEnabledMock.invocationsDone() && afterIsModuleEnabledCounter > 0 {
		m.t.Errorf("Expected %d calls to KubeConfigManagerMock.IsModuleEnabled at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsModuleEnabledMock.expectedInvocations), m.IsModuleEnabledMock.expectedInvocationsOrigin, afterIsModuleEnabledCounter)
	}
}

type mKubeConfigManagerMockKubeConfigEventCh struct {
	optional           bool
	mock               *KubeConfigManagerMock
	defaultExpectation *KubeConfigManagerMockKubeConfigEventChExpectation
	expectations       []*KubeConfigManagerMockKubeConfigEventChExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubeConfigManagerMockKubeConfigEventChExpectation specifies expectation struct of the KubeConfigManager.KubeConfigEventCh
type KubeConfigManagerMockKubeConfigEventChExpectation struct {
	mock *KubeConfigManagerMock

	results      *KubeConfigManagerMockKubeConfigEventChResults
	returnOrigin string
	Counter      uint64
}

// KubeConfigManagerMockKubeConfigEventChResults contains results of the KubeConfigManager.KubeConfigEventCh
type KubeConfigManagerMockKubeConfigEventChResults struct {
	ch1 chan config.KubeConfigEvent
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmKubeConfigEventCh *mKubeConfigManagerMockKubeConfigEventCh) Optional() *mKubeConfigManagerMockKubeConfigEventCh {
	mmKubeConfigEventCh.optional = true
	return mmKubeConfigEventCh
}

// Expect sets up expected params for KubeConfigManager.KubeConfigEventCh
func (mmKubeConfigEventCh *mKubeConfigManagerMockKubeConfigEventCh) Expect() *mKubeConfigManagerMockKubeConfigEventCh {
	if mmKubeConfigEventCh.mock.funcKubeConfigEventCh != nil {
		mmKubeConfigEventCh.mock.t.Fatalf("KubeConfigManagerMock.KubeConfigEventCh mock is already set by Set")
	}

	if mmKubeConfigEventCh.defaultExpectation == nil {
		mmKubeConfigEventCh.defaultExpectation = &KubeConfigManagerMockKubeConfigEventChExpectation{}
	}

	return mmKubeConfigEventCh
}

// Inspect accepts an inspector function that has same arguments as the KubeConfigManager.KubeConfigEventCh
func (mmKubeConfigEventCh *mKubeConfigManagerMockKubeConfigEventCh) Inspect(f func()) *mKubeConfigManagerMockKubeConfigEventCh {
	if mmKubeConfigEventCh.mock.inspectFuncKubeConfigEventCh != nil {
		mmKubeConfigEventCh.mock.t.Fatalf("Inspect function is already set for KubeConfigManagerMock.KubeConfigEventCh")
	}

	mmKubeConfigEventCh.mock.inspectFuncKubeConfigEventCh = f

	return mmKubeConfigEventCh
}

// Return sets up results that will be returned by KubeConfigManager.KubeConfigEventCh
func (mmKubeConfigEventCh *mKubeConfigManagerMockKubeConfigEventCh) Return(ch1 chan config.KubeConfigEvent) *KubeConfigManagerMock {
	if mmKubeConfigEventCh.mock.funcKubeConfigEventCh != nil {
		mmKubeConfigEventCh.mock.t.Fatalf("KubeConfigManagerMock.KubeConfigEventCh mock is already set by Set")
	}

	if mmKubeConfigEventCh.defaultExpectation == nil {
		mmKubeConfigEventCh.defaultExpectation = &KubeConfigManagerMockKubeConfigEventChExpectation{mock: mmKubeConfigEventCh.mock}
	}
	mmKubeConfigEventCh.defaultExpectation.results = &KubeConfigManagerMockKubeConfigEventChResults{ch1}
	mmKubeConfigEventCh.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmKubeConfigEventCh.mock
}

// Set uses given function f to mock the KubeConfigManager.KubeConfigEventCh method
func (mmKubeConfigEventCh *mKubeConfigManagerMockKubeConfigEventCh) Set(f func() (ch1 chan config.KubeConfigEvent)) *KubeConfigManagerMock {
	if mmKubeConfigEventCh.defaultExpectation != nil {
		mmKubeConfigEventCh.mock.t.Fatalf("Default expectation is already set for the KubeConfigManager.KubeConfigEventCh method")
	}

	if len(mmKubeConfigEventCh.expectations) > 0 {
		mmKubeConfigEventCh.mock.t.Fatalf("Some expectations are already set for the KubeConfigManager.KubeConfigEventCh method")
	}

	mmKubeConfigEventCh.mock.funcKubeConfigEventCh = f
	mmKubeConfigEventCh.mock.funcKubeConfigEventChOrigin = minimock.CallerInfo(1)
	return mmKubeConfigEventCh.mock
}

// Times sets number of times KubeConfigManager.KubeConfigEventCh should be invoked
func (mmKubeConfigEventCh *mKubeConfigManagerMockKubeConfigEventCh) Times(n uint64) *mKubeConfigManagerMockKubeConfigEventCh {
	if n == 0 {
		mmKubeConfigEventCh.mock.t.Fatalf("Times of KubeConfigManagerMock.KubeConfigEventCh mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmKubeConfigEventCh.expectedInvocations, n)
	mmKubeConfigEventCh.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmKubeConfigEventCh
}

func (mmKubeConfigEventCh *mKubeConfigManagerMockKubeConfigEventCh) invocationsDone() bool {
	if len(mmKubeConfigEventCh.expectations) == 0 && mmKubeConfigEventCh.defaultExpectation == nil && mmKubeConfigEventCh.mock.funcKubeConfigEventCh == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmKubeConfigEventCh.mock.afterKubeConfigEventChCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmKubeConfigEventCh.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// KubeConfigEventCh implements mm_module_manager.KubeConfigManager
func (mmKubeConfigEventCh *KubeConfigManagerMock) KubeConfigEventCh() (ch1 chan config.KubeConfigEvent) {
	mm_atomic.AddUint64(&mmKubeConfigEventCh.beforeKubeConfigEventChCounter, 1)
	defer mm_atomic.AddUint64(&mmKubeConfigEventCh.afterKubeConfigEventChCounter, 1)

	mmKubeConfigEventCh.t.Helper()

	if mmKubeConfigEventCh.inspectFuncKubeConfigEventCh != nil {
		mmKubeConfigEventCh.inspectFuncKubeConfigEventCh()
	}

	if mmKubeConfigEventCh.KubeConfigEventChMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmKubeConfigEventCh.KubeConfigEventChMock.defaultExpectation.Counter, 1)

		mm_results := mmKubeConfigEventCh.KubeConfigEventChMock.defaultExpectation.results
		if mm_results == nil {
			mmKubeConfigEventCh.t.Fatal("No results are set for the KubeConfigManagerMock.KubeConfigEventCh")
		}
		return (*mm_results).ch1
	}
	if mmKubeConfigEventCh.funcKubeConfigEventCh != nil {
		return mmKubeConfigEventCh.funcKubeConfigEventCh()
	}
	mmKubeConfigEventCh.t.Fatalf("Unexpected call to KubeConfigManagerMock.KubeConfigEventCh.")
	return
}

// KubeConfigEventChAfterCounter returns a count of finished KubeConfigManagerMock.KubeConfigEventCh invocations
func (mmKubeConfigEventCh *KubeConfigManagerMock) KubeConfigEventChAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKubeConfigEventCh.afterKubeConfigEventChCounter)
}

// KubeConfigEventChBeforeCounter returns a count of KubeConfigManagerMock.KubeConfigEventCh invocations
func (mmKubeConfigEventCh *KubeConfigManagerMock) KubeConfigEventChBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmKubeConfigEventCh.beforeKubeConfigEventChCounter)
}

// MinimockKubeConfigEventChDone returns true if the count of the KubeConfigEventCh invocations corresponds
// the number of defined expectations
func (m *KubeConfigManagerMock) MinimockKubeConfigEventChDone() bool {
	if m.KubeConfigEventChMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.KubeConfigEventChMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.KubeConfigEventChMock.invocationsDone()
}

// MinimockKubeConfigEventChInspect logs each unmet expectation
func (m *KubeConfigManagerMock) MinimockKubeConfigEventChInspect() {
	for _, e := range m.KubeConfigEventChMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to KubeConfigManagerMock.KubeConfigEventCh")
		}
	}

	afterKubeConfigEventChCounter := mm_atomic.LoadUint64(&m.afterKubeConfigEventChCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.KubeConfigEventChMock.defaultExpectation != nil && afterKubeConfigEventChCounter < 1 {
		m.t.Errorf("Expected call to KubeConfigManagerMock.KubeConfigEventCh at\n%s", m.KubeConfigEventChMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcKubeConfigEventCh != nil && afterKubeConfigEventChCounter < 1 {
		m.t.Errorf("Expected call to KubeConfigManagerMock.KubeConfigEventCh at\n%s", m.funcKubeConfigEventChOrigin)
	}

	if !m.KubeConfigEventChMock.invocationsDone() && afterKubeConfigEventChCounter > 0 {
		m.t.Errorf("Expected %d calls to KubeConfigManagerMock.KubeConfigEventCh at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.KubeConfigEventChMock.expectedInvocations), m.KubeConfigEventChMock.expectedInvocationsOrigin, afterKubeConfigEventChCounter)
	}
}

type mKubeConfigManagerMockSafeReadConfig struct {
	optional           bool
	mock               *KubeConfigManagerMock
	defaultExpectation *KubeConfigManagerMockSafeReadConfigExpectation
	expectations       []*KubeConfigManagerMockSafeReadConfigExpectation

	callArgs []*KubeConfigManagerMockSafeReadConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubeConfigManagerMockSafeReadConfigExpectation specifies expectation struct of the KubeConfigManager.SafeReadConfig
type KubeConfigManagerMockSafeReadConfigExpectation struct {
	mock               *KubeConfigManagerMock
	params             *KubeConfigManagerMockSafeReadConfigParams
	paramPtrs          *KubeConfigManagerMockSafeReadConfigParamPtrs
	expectationOrigins KubeConfigManagerMockSafeReadConfigExpectationOrigins

	returnOrigin string
	Counter      uint64
}

// KubeConfigManagerMockSafeReadConfigParams contains parameters of the KubeConfigManager.SafeReadConfig
type KubeConfigManagerMockSafeReadConfigParams struct {
	handler func(config *config.KubeConfig)
}

// KubeConfigManagerMockSafeReadConfigParamPtrs contains pointers to parameters of the KubeConfigManager.SafeReadConfig
type KubeConfigManagerMockSafeReadConfigParamPtrs struct {
	handler *func(config *config.KubeConfig)
}

// KubeConfigManagerMockSafeReadConfigOrigins contains origins of expectations of the KubeConfigManager.SafeReadConfig
type KubeConfigManagerMockSafeReadConfigExpectationOrigins struct {
	origin        string
	originHandler string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) Optional() *mKubeConfigManagerMockSafeReadConfig {
	mmSafeReadConfig.optional = true
	return mmSafeReadConfig
}

// Expect sets up expected params for KubeConfigManager.SafeReadConfig
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) Expect(handler func(config *config.KubeConfig)) *mKubeConfigManagerMockSafeReadConfig {
	if mmSafeReadConfig.mock.funcSafeReadConfig != nil {
		mmSafeReadConfig.mock.t.Fatalf("KubeConfigManagerMock.SafeReadConfig mock is already set by Set")
	}

	if mmSafeReadConfig.defaultExpectation == nil {
		mmSafeReadConfig.defaultExpectation = &KubeConfigManagerMockSafeReadConfigExpectation{}
	}

	if mmSafeReadConfig.defaultExpectation.paramPtrs != nil {
		mmSafeReadConfig.mock.t.Fatalf("KubeConfigManagerMock.SafeReadConfig mock is already set by ExpectParams functions")
	}

	mmSafeReadConfig.defaultExpectation.params = &KubeConfigManagerMockSafeReadConfigParams{handler}
	mmSafeReadConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSafeReadConfig.expectations {
		if minimock.Equal(e.params, mmSafeReadConfig.defaultExpectation.params) {
			mmSafeReadConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSafeReadConfig.defaultExpectation.params)
		}
	}

	return mmSafeReadConfig
}

// ExpectHandlerParam1 sets up expected param handler for KubeConfigManager.SafeReadConfig
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) ExpectHandlerParam1(handler func(config *config.KubeConfig)) *mKubeConfigManagerMockSafeReadConfig {
	if mmSafeReadConfig.mock.funcSafeReadConfig != nil {
		mmSafeReadConfig.mock.t.Fatalf("KubeConfigManagerMock.SafeReadConfig mock is already set by Set")
	}

	if mmSafeReadConfig.defaultExpectation == nil {
		mmSafeReadConfig.defaultExpectation = &KubeConfigManagerMockSafeReadConfigExpectation{}
	}

	if mmSafeReadConfig.defaultExpectation.params != nil {
		mmSafeReadConfig.mock.t.Fatalf("KubeConfigManagerMock.SafeReadConfig mock is already set by Expect")
	}

	if mmSafeReadConfig.defaultExpectation.paramPtrs == nil {
		mmSafeReadConfig.defaultExpectation.paramPtrs = &KubeConfigManagerMockSafeReadConfigParamPtrs{}
	}
	mmSafeReadConfig.defaultExpectation.paramPtrs.handler = &handler
	mmSafeReadConfig.defaultExpectation.expectationOrigins.originHandler = minimock.CallerInfo(1)

	return mmSafeReadConfig
}

// Inspect accepts an inspector function that has same arguments as the KubeConfigManager.SafeReadConfig
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) Inspect(f func(handler func(config *config.KubeConfig))) *mKubeConfigManagerMockSafeReadConfig {
	if mmSafeReadConfig.mock.inspectFuncSafeReadConfig != nil {
		mmSafeReadConfig.mock.t.Fatalf("Inspect function is already set for KubeConfigManagerMock.SafeReadConfig")
	}

	mmSafeReadConfig.mock.inspectFuncSafeReadConfig = f

	return mmSafeReadConfig
}

// Return sets up results that will be returned by KubeConfigManager.SafeReadConfig
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) Return() *KubeConfigManagerMock {
	if mmSafeReadConfig.mock.funcSafeReadConfig != nil {
		mmSafeReadConfig.mock.t.Fatalf("KubeConfigManagerMock.SafeReadConfig mock is already set by Set")
	}

	if mmSafeReadConfig.defaultExpectation == nil {
		mmSafeReadConfig.defaultExpectation = &KubeConfigManagerMockSafeReadConfigExpectation{mock: mmSafeReadConfig.mock}
	}

	mmSafeReadConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSafeReadConfig.mock
}

// Set uses given function f to mock the KubeConfigManager.SafeReadConfig method
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) Set(f func(handler func(config *config.KubeConfig))) *KubeConfigManagerMock {
	if mmSafeReadConfig.defaultExpectation != nil {
		mmSafeReadConfig.mock.t.Fatalf("Default expectation is already set for the KubeConfigManager.SafeReadConfig method")
	}

	if len(mmSafeReadConfig.expectations) > 0 {
		mmSafeReadConfig.mock.t.Fatalf("Some expectations are already set for the KubeConfigManager.SafeReadConfig method")
	}

	mmSafeReadConfig.mock.funcSafeReadConfig = f
	mmSafeReadConfig.mock.funcSafeReadConfigOrigin = minimock.CallerInfo(1)
	return mmSafeReadConfig.mock
}

// When sets expectation for the KubeConfigManager.SafeReadConfig which will trigger the result defined by the following
// Then helper
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) When(handler func(config *config.KubeConfig)) *KubeConfigManagerMockSafeReadConfigExpectation {
	if mmSafeReadConfig.mock.funcSafeReadConfig != nil {
		mmSafeReadConfig.mock.t.Fatalf("KubeConfigManagerMock.SafeReadConfig mock is already set by Set")
	}

	expectation := &KubeConfigManagerMockSafeReadConfigExpectation{
		mock:               mmSafeReadConfig.mock,
		params:             &KubeConfigManagerMockSafeReadConfigParams{handler},
		expectationOrigins: KubeConfigManagerMockSafeReadConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSafeReadConfig.expectations = append(mmSafeReadConfig.expectations, expectation)
	return expectation
}

// Then sets up KubeConfigManager.SafeReadConfig return parameters for the expectation previously defined by the When method
func (e *KubeConfigManagerMockSafeReadConfigExpectation) Then() *KubeConfigManagerMock {
	return e.mock
}

// Times sets number of times KubeConfigManager.SafeReadConfig should be invoked
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) Times(n uint64) *mKubeConfigManagerMockSafeReadConfig {
	if n == 0 {
		mmSafeReadConfig.mock.t.Fatalf("Times of KubeConfigManagerMock.SafeReadConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSafeReadConfig.expectedInvocations, n)
	mmSafeReadConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSafeReadConfig
}

func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) invocationsDone() bool {
	if len(mmSafeReadConfig.expectations) == 0 && mmSafeReadConfig.defaultExpectation == nil && mmSafeReadConfig.mock.funcSafeReadConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSafeReadConfig.mock.afterSafeReadConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSafeReadConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SafeReadConfig implements mm_module_manager.KubeConfigManager
func (mmSafeReadConfig *KubeConfigManagerMock) SafeReadConfig(handler func(config *config.KubeConfig)) {
	mm_atomic.AddUint64(&mmSafeReadConfig.beforeSafeReadConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmSafeReadConfig.afterSafeReadConfigCounter, 1)

	mmSafeReadConfig.t.Helper()

	if mmSafeReadConfig.inspectFuncSafeReadConfig != nil {
		mmSafeReadConfig.inspectFuncSafeReadConfig(handler)
	}

	mm_params := KubeConfigManagerMockSafeReadConfigParams{handler}

	// Record call args
	mmSafeReadConfig.SafeReadConfigMock.mutex.Lock()
	mmSafeReadConfig.SafeReadConfigMock.callArgs = append(mmSafeReadConfig.SafeReadConfigMock.callArgs, &mm_params)
	mmSafeReadConfig.SafeReadConfigMock.mutex.Unlock()

	for _, e := range mmSafeReadConfig.SafeReadConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return
		}
	}

	if mmSafeReadConfig.SafeReadConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSafeReadConfig.SafeReadConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmSafeReadConfig.SafeReadConfigMock.defaultExpectation.params
		mm_want_ptrs := mmSafeReadConfig.SafeReadConfigMock.defaultExpectation.paramPtrs

		mm_got := KubeConfigManagerMockSafeReadConfigParams{handler}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.handler != nil && !minimock.Equal(*mm_want_ptrs.handler, mm_got.handler) {
				mmSafeReadConfig.t.Errorf("KubeConfigManagerMock.SafeReadConfig got unexpected parameter handler, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSafeReadConfig.SafeReadConfigMock.defaultExpectation.expectationOrigins.originHandler, *mm_want_ptrs.handler, mm_got.handler, minimock.Diff(*mm_want_ptrs.handler, mm_got.handler))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSafeReadConfig.t.Errorf("KubeConfigManagerMock.SafeReadConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSafeReadConfig.SafeReadConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		return

	}
	if mmSafeReadConfig.funcSafeReadConfig != nil {
		mmSafeReadConfig.funcSafeReadConfig(handler)
		return
	}
	mmSafeReadConfig.t.Fatalf("Unexpected call to KubeConfigManagerMock.SafeReadConfig. %v", handler)

}

// SafeReadConfigAfterCounter returns a count of finished KubeConfigManagerMock.SafeReadConfig invocations
func (mmSafeReadConfig *KubeConfigManagerMock) SafeReadConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSafeReadConfig.afterSafeReadConfigCounter)
}

// SafeReadConfigBeforeCounter returns a count of KubeConfigManagerMock.SafeReadConfig invocations
func (mmSafeReadConfig *KubeConfigManagerMock) SafeReadConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSafeReadConfig.beforeSafeReadConfigCounter)
}

// Calls returns a list of arguments used in each call to KubeConfigManagerMock.SafeReadConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSafeReadConfig *mKubeConfigManagerMockSafeReadConfig) Calls() []*KubeConfigManagerMockSafeReadConfigParams {
	mmSafeReadConfig.mutex.RLock()

	argCopy := make([]*KubeConfigManagerMockSafeReadConfigParams, len(mmSafeReadConfig.callArgs))
	copy(argCopy, mmSafeReadConfig.callArgs)

	mmSafeReadConfig.mutex.RUnlock()

	return argCopy
}

// MinimockSafeReadConfigDone returns true if the count of the SafeReadConfig invocations corresponds
// the number of defined expectations
func (m *KubeConfigManagerMock) MinimockSafeReadConfigDone() bool {
	if m.SafeReadConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SafeReadConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SafeReadConfigMock.invocationsDone()
}

// MinimockSafeReadConfigInspect logs each unmet expectation
func (m *KubeConfigManagerMock) MinimockSafeReadConfigInspect() {
	for _, e := range m.SafeReadConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubeConfigManagerMock.SafeReadConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSafeReadConfigCounter := mm_atomic.LoadUint64(&m.afterSafeReadConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SafeReadConfigMock.defaultExpectation != nil && afterSafeReadConfigCounter < 1 {
		if m.SafeReadConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubeConfigManagerMock.SafeReadConfig at\n%s", m.SafeReadConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubeConfigManagerMock.SafeReadConfig at\n%s with params: %#v", m.SafeReadConfigMock.defaultExpectation.expectationOrigins.origin, *m.SafeReadConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSafeReadConfig != nil && afterSafeReadConfigCounter < 1 {
		m.t.Errorf("Expected call to KubeConfigManagerMock.SafeReadConfig at\n%s", m.funcSafeReadConfigOrigin)
	}

	if !m.SafeReadConfigMock.invocationsDone() && afterSafeReadConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to KubeConfigManagerMock.SafeReadConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SafeReadConfigMock.expectedInvocations), m.SafeReadConfigMock.expectedInvocationsOrigin, afterSafeReadConfigCounter)
	}
}

type mKubeConfigManagerMockSaveConfigValues struct {
	optional           bool
	mock               *KubeConfigManagerMock
	defaultExpectation *KubeConfigManagerMockSaveConfigValuesExpectation
	expectations       []*KubeConfigManagerMockSaveConfigValuesExpectation

	callArgs []*KubeConfigManagerMockSaveConfigValuesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubeConfigManagerMockSaveConfigValuesExpectation specifies expectation struct of the KubeConfigManager.SaveConfigValues
type KubeConfigManagerMockSaveConfigValuesExpectation struct {
	mock               *KubeConfigManagerMock
	params             *KubeConfigManagerMockSaveConfigValuesParams
	paramPtrs          *KubeConfigManagerMockSaveConfigValuesParamPtrs
	expectationOrigins KubeConfigManagerMockSaveConfigValuesExpectationOrigins
	results            *KubeConfigManagerMockSaveConfigValuesResults
	returnOrigin       string
	Counter            uint64
}

// KubeConfigManagerMockSaveConfigValuesParams contains parameters of the KubeConfigManager.SaveConfigValues
type KubeConfigManagerMockSaveConfigValuesParams struct {
	key    string
	values utils.Values
}

// KubeConfigManagerMockSaveConfigValuesParamPtrs contains pointers to parameters of the KubeConfigManager.SaveConfigValues
type KubeConfigManagerMockSaveConfigValuesParamPtrs struct {
	key    *string
	values *utils.Values
}

// KubeConfigManagerMockSaveConfigValuesResults contains results of the KubeConfigManager.SaveConfigValues
type KubeConfigManagerMockSaveConfigValuesResults struct {
	err error
}

// KubeConfigManagerMockSaveConfigValuesOrigins contains origins of expectations of the KubeConfigManager.SaveConfigValues
type KubeConfigManagerMockSaveConfigValuesExpectationOrigins struct {
	origin       string
	originKey    string
	originValues string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) Optional() *mKubeConfigManagerMockSaveConfigValues {
	mmSaveConfigValues.optional = true
	return mmSaveConfigValues
}

// Expect sets up expected params for KubeConfigManager.SaveConfigValues
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) Expect(key string, values utils.Values) *mKubeConfigManagerMockSaveConfigValues {
	if mmSaveConfigValues.mock.funcSaveConfigValues != nil {
		mmSaveConfigValues.mock.t.Fatalf("KubeConfigManagerMock.SaveConfigValues mock is already set by Set")
	}

	if mmSaveConfigValues.defaultExpectation == nil {
		mmSaveConfigValues.defaultExpectation = &KubeConfigManagerMockSaveConfigValuesExpectation{}
	}

	if mmSaveConfigValues.defaultExpectation.paramPtrs != nil {
		mmSaveConfigValues.mock.t.Fatalf("KubeConfigManagerMock.SaveConfigValues mock is already set by ExpectParams functions")
	}

	mmSaveConfigValues.defaultExpectation.params = &KubeConfigManagerMockSaveConfigValuesParams{key, values}
	mmSaveConfigValues.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSaveConfigValues.expectations {
		if minimock.Equal(e.params, mmSaveConfigValues.defaultExpectation.params) {
			mmSaveConfigValues.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSaveConfigValues.defaultExpectation.params)
		}
	}

	return mmSaveConfigValues
}

// ExpectKeyParam1 sets up expected param key for KubeConfigManager.SaveConfigValues
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) ExpectKeyParam1(key string) *mKubeConfigManagerMockSaveConfigValues {
	if mmSaveConfigValues.mock.funcSaveConfigValues != nil {
		mmSaveConfigValues.mock.t.Fatalf("KubeConfigManagerMock.SaveConfigValues mock is already set by Set")
	}

	if mmSaveConfigValues.defaultExpectation == nil {
		mmSaveConfigValues.defaultExpectation = &KubeConfigManagerMockSaveConfigValuesExpectation{}
	}

	if mmSaveConfigValues.defaultExpectation.params != nil {
		mmSaveConfigValues.mock.t.Fatalf("KubeConfigManagerMock.SaveConfigValues mock is already set by Expect")
	}

	if mmSaveConfigValues.defaultExpectation.paramPtrs == nil {
		mmSaveConfigValues.defaultExpectation.paramPtrs = &KubeConfigManagerMockSaveConfigValuesParamPtrs{}
	}
	mmSaveConfigValues.defaultExpectation.paramPtrs.key = &key
	mmSaveConfigValues.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSaveConfigValues
}

// ExpectValuesParam2 sets up expected param values for KubeConfigManager.SaveConfigValues
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) ExpectValuesParam2(values utils.Values) *mKubeConfigManagerMockSaveConfigValues {
	if mmSaveConfigValues.mock.funcSaveConfigValues != nil {
		mmSaveConfigValues.mock.t.Fatalf("KubeConfigManagerMock.SaveConfigValues mock is already set by Set")
	}

	if mmSaveConfigValues.defaultExpectation == nil {
		mmSaveConfigValues.defaultExpectation = &KubeConfigManagerMockSaveConfigValuesExpectation{}
	}

	if mmSaveConfigValues.defaultExpectation.params != nil {
		mmSaveConfigValues.mock.t.Fatalf("KubeConfigManagerMock.SaveConfigValues mock is already set by Expect")
	}

	if mmSaveConfigValues.defaultExpectation.paramPtrs == nil {
		mmSaveConfigValues.defaultExpectation.paramPtrs = &KubeConfigManagerMockSaveConfigValuesParamPtrs{}
	}
	mmSaveConfigValues.defaultExpectation.paramPtrs.values = &values
	mmSaveConfigValues.defaultExpectation.expectationOrigins.originValues = minimock.CallerInfo(1)

	return mmSaveConfigValues
}

// Inspect accepts an inspector function that has same arguments as the KubeConfigManager.SaveConfigValues
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) Inspect(f func(key string, values utils.Values)) *mKubeConfigManagerMockSaveConfigValues {
	if mmSaveConfigValues.mock.inspectFuncSaveConfigValues != nil {
		mmSaveConfigValues.mock.t.Fatalf("Inspect function is already set for KubeConfigManagerMock.SaveConfigValues")
	}

	mmSaveConfigValues.mock.inspectFuncSaveConfigValues = f

	return mmSaveConfigValues
}

// Return sets up results that will be returned by KubeConfigManager.SaveConfigValues
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) Return(err error) *KubeConfigManagerMock {
	if mmSaveConfigValues.mock.funcSaveConfigValues != nil {
		mmSaveConfigValues.mock.t.Fatalf("KubeConfigManagerMock.SaveConfigValues mock is already set by Set")
	}

	if mmSaveConfigValues.defaultExpectation == nil {
		mmSaveConfigValues.defaultExpectation = &KubeConfigManagerMockSaveConfigValuesExpectation{mock: mmSaveConfigValues.mock}
	}
	mmSaveConfigValues.defaultExpectation.results = &KubeConfigManagerMockSaveConfigValuesResults{err}
	mmSaveConfigValues.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSaveConfigValues.mock
}

// Set uses given function f to mock the KubeConfigManager.SaveConfigValues method
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) Set(f func(key string, values utils.Values) (err error)) *KubeConfigManagerMock {
	if mmSaveConfigValues.defaultExpectation != nil {
		mmSaveConfigValues.mock.t.Fatalf("Default expectation is already set for the KubeConfigManager.SaveConfigValues method")
	}

	if len(mmSaveConfigValues.expectations) > 0 {
		mmSaveConfigValues.mock.t.Fatalf("Some expectations are already set for the KubeConfigManager.SaveConfigValues method")
	}

	mmSaveConfigValues.mock.funcSaveConfigValues = f
	mmSaveConfigValues.mock.funcSaveConfigValuesOrigin = minimock.CallerInfo(1)
	return mmSaveConfigValues.mock
}

// When sets expectation for the KubeConfigManager.SaveConfigValues which will trigger the result defined by the following
// Then helper
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) When(key string, values utils.Values) *KubeConfigManagerMockSaveConfigValuesExpectation {
	if mmSaveConfigValues.mock.funcSaveConfigValues != nil {
		mmSaveConfigValues.mock.t.Fatalf("KubeConfigManagerMock.SaveConfigValues mock is already set by Set")
	}

	expectation := &KubeConfigManagerMockSaveConfigValuesExpectation{
		mock:               mmSaveConfigValues.mock,
		params:             &KubeConfigManagerMockSaveConfigValuesParams{key, values},
		expectationOrigins: KubeConfigManagerMockSaveConfigValuesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSaveConfigValues.expectations = append(mmSaveConfigValues.expectations, expectation)
	return expectation
}

// Then sets up KubeConfigManager.SaveConfigValues return parameters for the expectation previously defined by the When method
func (e *KubeConfigManagerMockSaveConfigValuesExpectation) Then(err error) *KubeConfigManagerMock {
	e.results = &KubeConfigManagerMockSaveConfigValuesResults{err}
	return e.mock
}

// Times sets number of times KubeConfigManager.SaveConfigValues should be invoked
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) Times(n uint64) *mKubeConfigManagerMockSaveConfigValues {
	if n == 0 {
		mmSaveConfigValues.mock.t.Fatalf("Times of KubeConfigManagerMock.SaveConfigValues mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSaveConfigValues.expectedInvocations, n)
	mmSaveConfigValues.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSaveConfigValues
}

func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) invocationsDone() bool {
	if len(mmSaveConfigValues.expectations) == 0 && mmSaveConfigValues.defaultExpectation == nil && mmSaveConfigValues.mock.funcSaveConfigValues == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSaveConfigValues.mock.afterSaveConfigValuesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSaveConfigValues.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SaveConfigValues implements mm_module_manager.KubeConfigManager
func (mmSaveConfigValues *KubeConfigManagerMock) SaveConfigValues(key string, values utils.Values) (err error) {
	mm_atomic.AddUint64(&mmSaveConfigValues.beforeSaveConfigValuesCounter, 1)
	defer mm_atomic.AddUint64(&mmSaveConfigValues.afterSaveConfigValuesCounter, 1)

	mmSaveConfigValues.t.Helper()

	if mmSaveConfigValues.inspectFuncSaveConfigValues != nil {
		mmSaveConfigValues.inspectFuncSaveConfigValues(key, values)
	}

	mm_params := KubeConfigManagerMockSaveConfigValuesParams{key, values}

	// Record call args
	mmSaveConfigValues.SaveConfigValuesMock.mutex.Lock()
	mmSaveConfigValues.SaveConfigValuesMock.callArgs = append(mmSaveConfigValues.SaveConfigValuesMock.callArgs, &mm_params)
	mmSaveConfigValues.SaveConfigValuesMock.mutex.Unlock()

	for _, e := range mmSaveConfigValues.SaveConfigValuesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSaveConfigValues.SaveConfigValuesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSaveConfigValues.SaveConfigValuesMock.defaultExpectation.Counter, 1)
		mm_want := mmSaveConfigValues.SaveConfigValuesMock.defaultExpectation.params
		mm_want_ptrs := mmSaveConfigValues.SaveConfigValuesMock.defaultExpectation.paramPtrs

		mm_got := KubeConfigManagerMockSaveConfigValuesParams{key, values}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSaveConfigValues.t.Errorf("KubeConfigManagerMock.SaveConfigValues got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConfigValues.SaveConfigValuesMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.values != nil && !minimock.Equal(*mm_want_ptrs.values, mm_got.values) {
				mmSaveConfigValues.t.Errorf("KubeConfigManagerMock.SaveConfigValues got unexpected parameter values, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSaveConfigValues.SaveConfigValuesMock.defaultExpectation.expectationOrigins.originValues, *mm_want_ptrs.values, mm_got.values, minimock.Diff(*mm_want_ptrs.values, mm_got.values))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSaveConfigValues.t.Errorf("KubeConfigManagerMock.SaveConfigValues got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSaveConfigValues.SaveConfigValuesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSaveConfigValues.SaveConfigValuesMock.defaultExpectation.results
		if mm_results == nil {
			mmSaveConfigValues.t.Fatal("No results are set for the KubeConfigManagerMock.SaveConfigValues")
		}
		return (*mm_results).err
	}
	if mmSaveConfigValues.funcSaveConfigValues != nil {
		return mmSaveConfigValues.funcSaveConfigValues(key, values)
	}
	mmSaveConfigValues.t.Fatalf("Unexpected call to KubeConfigManagerMock.SaveConfigValues. %v %v", key, values)
	return
}

// SaveConfigValuesAfterCounter returns a count of finished KubeConfigManagerMock.SaveConfigValues invocations
func (mmSaveConfigValues *KubeConfigManagerMock) SaveConfigValuesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveConfigValues.afterSaveConfigValuesCounter)
}

// SaveConfigValuesBeforeCounter returns a count of KubeConfigManagerMock.SaveConfigValues invocations
func (mmSaveConfigValues *KubeConfigManagerMock) SaveConfigValuesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSaveConfigValues.beforeSaveConfigValuesCounter)
}

// Calls returns a list of arguments used in each call to KubeConfigManagerMock.SaveConfigValues.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSaveConfigValues *mKubeConfigManagerMockSaveConfigValues) Calls() []*KubeConfigManagerMockSaveConfigValuesParams {
	mmSaveConfigValues.mutex.RLock()

	argCopy := make([]*KubeConfigManagerMockSaveConfigValuesParams, len(mmSaveConfigValues.callArgs))
	copy(argCopy, mmSaveConfigValues.callArgs)

	mmSaveConfigValues.mutex.RUnlock()

	return argCopy
}

// MinimockSaveConfigValuesDone returns true if the count of the SaveConfigValues invocations corresponds
// the number of defined expectations
func (m *KubeConfigManagerMock) MinimockSaveConfigValuesDone() bool {
	if m.SaveConfigValuesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SaveConfigValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SaveConfigValuesMock.invocationsDone()
}

// MinimockSaveConfigValuesInspect logs each unmet expectation
func (m *KubeConfigManagerMock) MinimockSaveConfigValuesInspect() {
	for _, e := range m.SaveConfigValuesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubeConfigManagerMock.SaveConfigValues at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSaveConfigValuesCounter := mm_atomic.LoadUint64(&m.afterSaveConfigValuesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SaveConfigValuesMock.defaultExpectation != nil && afterSaveConfigValuesCounter < 1 {
		if m.SaveConfigValuesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubeConfigManagerMock.SaveConfigValues at\n%s", m.SaveConfigValuesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubeConfigManagerMock.SaveConfigValues at\n%s with params: %#v", m.SaveConfigValuesMock.defaultExpectation.expectationOrigins.origin, *m.SaveConfigValuesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSaveConfigValues != nil && afterSaveConfigValuesCounter < 1 {
		m.t.Errorf("Expected call to KubeConfigManagerMock.SaveConfigValues at\n%s", m.funcSaveConfigValuesOrigin)
	}

	if !m.SaveConfigValuesMock.invocationsDone() && afterSaveConfigValuesCounter > 0 {
		m.t.Errorf("Expected %d calls to KubeConfigManagerMock.SaveConfigValues at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SaveConfigValuesMock.expectedInvocations), m.SaveConfigValuesMock.expectedInvocationsOrigin, afterSaveConfigValuesCounter)
	}
}

type mKubeConfigManagerMockUpdateModuleConfig struct {
	optional           bool
	mock               *KubeConfigManagerMock
	defaultExpectation *KubeConfigManagerMockUpdateModuleConfigExpectation
	expectations       []*KubeConfigManagerMockUpdateModuleConfigExpectation

	callArgs []*KubeConfigManagerMockUpdateModuleConfigParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// KubeConfigManagerMockUpdateModuleConfigExpectation specifies expectation struct of the KubeConfigManager.UpdateModuleConfig
type KubeConfigManagerMockUpdateModuleConfigExpectation struct {
	mock               *KubeConfigManagerMock
	params             *KubeConfigManagerMockUpdateModuleConfigParams
	paramPtrs          *KubeConfigManagerMockUpdateModuleConfigParamPtrs
	expectationOrigins KubeConfigManagerMockUpdateModuleConfigExpectationOrigins
	results            *KubeConfigManagerMockUpdateModuleConfigResults
	returnOrigin       string
	Counter            uint64
}

// KubeConfigManagerMockUpdateModuleConfigParams contains parameters of the KubeConfigManager.UpdateModuleConfig
type KubeConfigManagerMockUpdateModuleConfigParams struct {
	moduleName string
}

// KubeConfigManagerMockUpdateModuleConfigParamPtrs contains pointers to parameters of the KubeConfigManager.UpdateModuleConfig
type KubeConfigManagerMockUpdateModuleConfigParamPtrs struct {
	moduleName *string
}

// KubeConfigManagerMockUpdateModuleConfigResults contains results of the KubeConfigManager.UpdateModuleConfig
type KubeConfigManagerMockUpdateModuleConfigResults struct {
	err error
}

// KubeConfigManagerMockUpdateModuleConfigOrigins contains origins of expectations of the KubeConfigManager.UpdateModuleConfig
type KubeConfigManagerMockUpdateModuleConfigExpectationOrigins struct {
	origin           string
	originModuleName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) Optional() *mKubeConfigManagerMockUpdateModuleConfig {
	mmUpdateModuleConfig.optional = true
	return mmUpdateModuleConfig
}

// Expect sets up expected params for KubeConfigManager.UpdateModuleConfig
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) Expect(moduleName string) *mKubeConfigManagerMockUpdateModuleConfig {
	if mmUpdateModuleConfig.mock.funcUpdateModuleConfig != nil {
		mmUpdateModuleConfig.mock.t.Fatalf("KubeConfigManagerMock.UpdateModuleConfig mock is already set by Set")
	}

	if mmUpdateModuleConfig.defaultExpectation == nil {
		mmUpdateModuleConfig.defaultExpectation = &KubeConfigManagerMockUpdateModuleConfigExpectation{}
	}

	if mmUpdateModuleConfig.defaultExpectation.paramPtrs != nil {
		mmUpdateModuleConfig.mock.t.Fatalf("KubeConfigManagerMock.UpdateModuleConfig mock is already set by ExpectParams functions")
	}

	mmUpdateModuleConfig.defaultExpectation.params = &KubeConfigManagerMockUpdateModuleConfigParams{moduleName}
	mmUpdateModuleConfig.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmUpdateModuleConfig.expectations {
		if minimock.Equal(e.params, mmUpdateModuleConfig.defaultExpectation.params) {
			mmUpdateModuleConfig.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmUpdateModuleConfig.defaultExpectation.params)
		}
	}

	return mmUpdateModuleConfig
}

// ExpectModuleNameParam1 sets up expected param moduleName for KubeConfigManager.UpdateModuleConfig
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) ExpectModuleNameParam1(moduleName string) *mKubeConfigManagerMockUpdateModuleConfig {
	if mmUpdateModuleConfig.mock.funcUpdateModuleConfig != nil {
		mmUpdateModuleConfig.mock.t.Fatalf("KubeConfigManagerMock.UpdateModuleConfig mock is already set by Set")
	}

	if mmUpdateModuleConfig.defaultExpectation == nil {
		mmUpdateModuleConfig.defaultExpectation = &KubeConfigManagerMockUpdateModuleConfigExpectation{}
	}

	if mmUpdateModuleConfig.defaultExpectation.params != nil {
		mmUpdateModuleConfig.mock.t.Fatalf("KubeConfigManagerMock.UpdateModuleConfig mock is already set by Expect")
	}

	if mmUpdateModuleConfig.defaultExpectation.paramPtrs == nil {
		mmUpdateModuleConfig.defaultExpectation.paramPtrs = &KubeConfigManagerMockUpdateModuleConfigParamPtrs{}
	}
	mmUpdateModuleConfig.defaultExpectation.paramPtrs.moduleName = &moduleName
	mmUpdateModuleConfig.defaultExpectation.expectationOrigins.originModuleName = minimock.CallerInfo(1)

	return mmUpdateModuleConfig
}

// Inspect accepts an inspector function that has same arguments as the KubeConfigManager.UpdateModuleConfig
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) Inspect(f func(moduleName string)) *mKubeConfigManagerMockUpdateModuleConfig {
	if mmUpdateModuleConfig.mock.inspectFuncUpdateModuleConfig != nil {
		mmUpdateModuleConfig.mock.t.Fatalf("Inspect function is already set for KubeConfigManagerMock.UpdateModuleConfig")
	}

	mmUpdateModuleConfig.mock.inspectFuncUpdateModuleConfig = f

	return mmUpdateModuleConfig
}

// Return sets up results that will be returned by KubeConfigManager.UpdateModuleConfig
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) Return(err error) *KubeConfigManagerMock {
	if mmUpdateModuleConfig.mock.funcUpdateModuleConfig != nil {
		mmUpdateModuleConfig.mock.t.Fatalf("KubeConfigManagerMock.UpdateModuleConfig mock is already set by Set")
	}

	if mmUpdateModuleConfig.defaultExpectation == nil {
		mmUpdateModuleConfig.defaultExpectation = &KubeConfigManagerMockUpdateModuleConfigExpectation{mock: mmUpdateModuleConfig.mock}
	}
	mmUpdateModuleConfig.defaultExpectation.results = &KubeConfigManagerMockUpdateModuleConfigResults{err}
	mmUpdateModuleConfig.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmUpdateModuleConfig.mock
}

// Set uses given function f to mock the KubeConfigManager.UpdateModuleConfig method
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) Set(f func(moduleName string) (err error)) *KubeConfigManagerMock {
	if mmUpdateModuleConfig.defaultExpectation != nil {
		mmUpdateModuleConfig.mock.t.Fatalf("Default expectation is already set for the KubeConfigManager.UpdateModuleConfig method")
	}

	if len(mmUpdateModuleConfig.expectations) > 0 {
		mmUpdateModuleConfig.mock.t.Fatalf("Some expectations are already set for the KubeConfigManager.UpdateModuleConfig method")
	}

	mmUpdateModuleConfig.mock.funcUpdateModuleConfig = f
	mmUpdateModuleConfig.mock.funcUpdateModuleConfigOrigin = minimock.CallerInfo(1)
	return mmUpdateModuleConfig.mock
}

// When sets expectation for the KubeConfigManager.UpdateModuleConfig which will trigger the result defined by the following
// Then helper
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) When(moduleName string) *KubeConfigManagerMockUpdateModuleConfigExpectation {
	if mmUpdateModuleConfig.mock.funcUpdateModuleConfig != nil {
		mmUpdateModuleConfig.mock.t.Fatalf("KubeConfigManagerMock.UpdateModuleConfig mock is already set by Set")
	}

	expectation := &KubeConfigManagerMockUpdateModuleConfigExpectation{
		mock:               mmUpdateModuleConfig.mock,
		params:             &KubeConfigManagerMockUpdateModuleConfigParams{moduleName},
		expectationOrigins: KubeConfigManagerMockUpdateModuleConfigExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmUpdateModuleConfig.expectations = append(mmUpdateModuleConfig.expectations, expectation)
	return expectation
}

// Then sets up KubeConfigManager.UpdateModuleConfig return parameters for the expectation previously defined by the When method
func (e *KubeConfigManagerMockUpdateModuleConfigExpectation) Then(err error) *KubeConfigManagerMock {
	e.results = &KubeConfigManagerMockUpdateModuleConfigResults{err}
	return e.mock
}

// Times sets number of times KubeConfigManager.UpdateModuleConfig should be invoked
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) Times(n uint64) *mKubeConfigManagerMockUpdateModuleConfig {
	if n == 0 {
		mmUpdateModuleConfig.mock.t.Fatalf("Times of KubeConfigManagerMock.UpdateModuleConfig mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmUpdateModuleConfig.expectedInvocations, n)
	mmUpdateModuleConfig.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmUpdateModuleConfig
}

func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) invocationsDone() bool {
	if len(mmUpdateModuleConfig.expectations) == 0 && mmUpdateModuleConfig.defaultExpectation == nil && mmUpdateModuleConfig.mock.funcUpdateModuleConfig == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmUpdateModuleConfig.mock.afterUpdateModuleConfigCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmUpdateModuleConfig.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// UpdateModuleConfig implements mm_module_manager.KubeConfigManager
func (mmUpdateModuleConfig *KubeConfigManagerMock) UpdateModuleConfig(moduleName string) (err error) {
	mm_atomic.AddUint64(&mmUpdateModuleConfig.beforeUpdateModuleConfigCounter, 1)
	defer mm_atomic.AddUint64(&mmUpdateModuleConfig.afterUpdateModuleConfigCounter, 1)

	mmUpdateModuleConfig.t.Helper()

	if mmUpdateModuleConfig.inspectFuncUpdateModuleConfig != nil {
		mmUpdateModuleConfig.inspectFuncUpdateModuleConfig(moduleName)
	}

	mm_params := KubeConfigManagerMockUpdateModuleConfigParams{moduleName}

	// Record call args
	mmUpdateModuleConfig.UpdateModuleConfigMock.mutex.Lock()
	mmUpdateModuleConfig.UpdateModuleConfigMock.callArgs = append(mmUpdateModuleConfig.UpdateModuleConfigMock.callArgs, &mm_params)
	mmUpdateModuleConfig.UpdateModuleConfigMock.mutex.Unlock()

	for _, e := range mmUpdateModuleConfig.UpdateModuleConfigMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmUpdateModuleConfig.UpdateModuleConfigMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmUpdateModuleConfig.UpdateModuleConfigMock.defaultExpectation.Counter, 1)
		mm_want := mmUpdateModuleConfig.UpdateModuleConfigMock.defaultExpectation.params
		mm_want_ptrs := mmUpdateModuleConfig.UpdateModuleConfigMock.defaultExpectation.paramPtrs

		mm_got := KubeConfigManagerMockUpdateModuleConfigParams{moduleName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.moduleName != nil && !minimock.Equal(*mm_want_ptrs.moduleName, mm_got.moduleName) {
				mmUpdateModuleConfig.t.Errorf("KubeConfigManagerMock.UpdateModuleConfig got unexpected parameter moduleName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmUpdateModuleConfig.UpdateModuleConfigMock.defaultExpectation.expectationOrigins.originModuleName, *mm_want_ptrs.moduleName, mm_got.moduleName, minimock.Diff(*mm_want_ptrs.moduleName, mm_got.moduleName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmUpdateModuleConfig.t.Errorf("KubeConfigManagerMock.UpdateModuleConfig got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmUpdateModuleConfig.UpdateModuleConfigMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmUpdateModuleConfig.UpdateModuleConfigMock.defaultExpectation.results
		if mm_results == nil {
			mmUpdateModuleConfig.t.Fatal("No results are set for the KubeConfigManagerMock.UpdateModuleConfig")
		}
		return (*mm_results).err
	}
	if mmUpdateModuleConfig.funcUpdateModuleConfig != nil {
		return mmUpdateModuleConfig.funcUpdateModuleConfig(moduleName)
	}
	mmUpdateModuleConfig.t.Fatalf("Unexpected call to KubeConfigManagerMock.UpdateModuleConfig. %v", moduleName)
	return
}

// UpdateModuleConfigAfterCounter returns a count of finished KubeConfigManagerMock.UpdateModuleConfig invocations
func (mmUpdateModuleConfig *KubeConfigManagerMock) UpdateModuleConfigAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModuleConfig.afterUpdateModuleConfigCounter)
}

// UpdateModuleConfigBeforeCounter returns a count of KubeConfigManagerMock.UpdateModuleConfig invocations
func (mmUpdateModuleConfig *KubeConfigManagerMock) UpdateModuleConfigBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmUpdateModuleConfig.beforeUpdateModuleConfigCounter)
}

// Calls returns a list of arguments used in each call to KubeConfigManagerMock.UpdateModuleConfig.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmUpdateModuleConfig *mKubeConfigManagerMockUpdateModuleConfig) Calls() []*KubeConfigManagerMockUpdateModuleConfigParams {
	mmUpdateModuleConfig.mutex.RLock()

	argCopy := make([]*KubeConfigManagerMockUpdateModuleConfigParams, len(mmUpdateModuleConfig.callArgs))
	copy(argCopy, mmUpdateModuleConfig.callArgs)

	mmUpdateModuleConfig.mutex.RUnlock()

	return argCopy
}

// MinimockUpdateModuleConfigDone returns true if the count of the UpdateModuleConfig invocations corresponds
// the number of defined expectations
func (m *KubeConfigManagerMock) MinimockUpdateModuleConfigDone() bool {
	if m.UpdateModuleConfigMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.UpdateModuleConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.UpdateModuleConfigMock.invocationsDone()
}

// MinimockUpdateModuleConfigInspect logs each unmet expectation
func (m *KubeConfigManagerMock) MinimockUpdateModuleConfigInspect() {
	for _, e := range m.UpdateModuleConfigMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to KubeConfigManagerMock.UpdateModuleConfig at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterUpdateModuleConfigCounter := mm_atomic.LoadUint64(&m.afterUpdateModuleConfigCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.UpdateModuleConfigMock.defaultExpectation != nil && afterUpdateModuleConfigCounter < 1 {
		if m.UpdateModuleConfigMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to KubeConfigManagerMock.UpdateModuleConfig at\n%s", m.UpdateModuleConfigMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to KubeConfigManagerMock.UpdateModuleConfig at\n%s with params: %#v", m.UpdateModuleConfigMock.defaultExpectation.expectationOrigins.origin, *m.UpdateModuleConfigMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcUpdateModuleConfig != nil && afterUpdateModuleConfigCounter < 1 {
		m.t.Errorf("Expected call to KubeConfigManagerMock.UpdateModuleConfig at\n%s", m.funcUpdateModuleConfigOrigin)
	}

	if !m.UpdateModuleConfigMock.invocationsDone() && afterUpdateModuleConfigCounter > 0 {
		m.t.Errorf("Expected %d calls to KubeConfigManagerMock.UpdateModuleConfig at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.UpdateModuleConfigMock.expectedInvocations), m.UpdateModuleConfigMock.expectedInvocationsOrigin, afterUpdateModuleConfigCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *KubeConfigManagerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockIsModuleEnabledInspect()

			m.MinimockKubeConfigEventChInspect()

			m.MinimockSafeReadConfigInspect()

			m.MinimockSaveConfigValuesInspect()

			m.MinimockUpdateModuleConfigInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *KubeConfigManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *KubeConfigManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsModuleEnabledDone() &&
		m.MinimockKubeConfigEventChDone() &&
		m.MinimockSafeReadConfigDone() &&
		m.MinimockSaveConfigValuesDone() &&
		m.MinimockUpdateModuleConfigDone()
}
