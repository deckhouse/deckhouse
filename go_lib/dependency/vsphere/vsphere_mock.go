// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package vsphere

//go:generate minimock -i github.com/deckhouse/deckhouse/go_lib/dependency/vsphere.Client -o vsphere_mock.go -n ClientMock -p vsphere

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetZonesDatastores          func() (op1 *Output, err error)
	funcGetZonesDatastoresOrigin    string
	inspectFuncGetZonesDatastores   func()
	afterGetZonesDatastoresCounter  uint64
	beforeGetZonesDatastoresCounter uint64
	GetZonesDatastoresMock          mClientMockGetZonesDatastores

	funcListPolicies          func() (sa1 []StoragePolicy, err error)
	funcListPoliciesOrigin    string
	inspectFuncListPolicies   func()
	afterListPoliciesCounter  uint64
	beforeListPoliciesCounter uint64
	ListPoliciesMock          mClientMockListPolicies

	funcLogin          func() (err error)
	funcLoginOrigin    string
	inspectFuncLogin   func()
	afterLoginCounter  uint64
	beforeLoginCounter uint64
	LoginMock          mClientMockLogin
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetZonesDatastoresMock = mClientMockGetZonesDatastores{mock: m}

	m.ListPoliciesMock = mClientMockListPolicies{mock: m}

	m.LoginMock = mClientMockLogin{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockGetZonesDatastores struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockGetZonesDatastoresExpectation
	expectations       []*ClientMockGetZonesDatastoresExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockGetZonesDatastoresExpectation specifies expectation struct of the Client.GetZonesDatastores
type ClientMockGetZonesDatastoresExpectation struct {
	mock *ClientMock

	results      *ClientMockGetZonesDatastoresResults
	returnOrigin string
	Counter      uint64
}

// ClientMockGetZonesDatastoresResults contains results of the Client.GetZonesDatastores
type ClientMockGetZonesDatastoresResults struct {
	op1 *Output
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetZonesDatastores *mClientMockGetZonesDatastores) Optional() *mClientMockGetZonesDatastores {
	mmGetZonesDatastores.optional = true
	return mmGetZonesDatastores
}

// Expect sets up expected params for Client.GetZonesDatastores
func (mmGetZonesDatastores *mClientMockGetZonesDatastores) Expect() *mClientMockGetZonesDatastores {
	if mmGetZonesDatastores.mock.funcGetZonesDatastores != nil {
		mmGetZonesDatastores.mock.t.Fatalf("ClientMock.GetZonesDatastores mock is already set by Set")
	}

	if mmGetZonesDatastores.defaultExpectation == nil {
		mmGetZonesDatastores.defaultExpectation = &ClientMockGetZonesDatastoresExpectation{}
	}

	return mmGetZonesDatastores
}

// Inspect accepts an inspector function that has same arguments as the Client.GetZonesDatastores
func (mmGetZonesDatastores *mClientMockGetZonesDatastores) Inspect(f func()) *mClientMockGetZonesDatastores {
	if mmGetZonesDatastores.mock.inspectFuncGetZonesDatastores != nil {
		mmGetZonesDatastores.mock.t.Fatalf("Inspect function is already set for ClientMock.GetZonesDatastores")
	}

	mmGetZonesDatastores.mock.inspectFuncGetZonesDatastores = f

	return mmGetZonesDatastores
}

// Return sets up results that will be returned by Client.GetZonesDatastores
func (mmGetZonesDatastores *mClientMockGetZonesDatastores) Return(op1 *Output, err error) *ClientMock {
	if mmGetZonesDatastores.mock.funcGetZonesDatastores != nil {
		mmGetZonesDatastores.mock.t.Fatalf("ClientMock.GetZonesDatastores mock is already set by Set")
	}

	if mmGetZonesDatastores.defaultExpectation == nil {
		mmGetZonesDatastores.defaultExpectation = &ClientMockGetZonesDatastoresExpectation{mock: mmGetZonesDatastores.mock}
	}
	mmGetZonesDatastores.defaultExpectation.results = &ClientMockGetZonesDatastoresResults{op1, err}
	mmGetZonesDatastores.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetZonesDatastores.mock
}

// Set uses given function f to mock the Client.GetZonesDatastores method
func (mmGetZonesDatastores *mClientMockGetZonesDatastores) Set(f func() (op1 *Output, err error)) *ClientMock {
	if mmGetZonesDatastores.defaultExpectation != nil {
		mmGetZonesDatastores.mock.t.Fatalf("Default expectation is already set for the Client.GetZonesDatastores method")
	}

	if len(mmGetZonesDatastores.expectations) > 0 {
		mmGetZonesDatastores.mock.t.Fatalf("Some expectations are already set for the Client.GetZonesDatastores method")
	}

	mmGetZonesDatastores.mock.funcGetZonesDatastores = f
	mmGetZonesDatastores.mock.funcGetZonesDatastoresOrigin = minimock.CallerInfo(1)
	return mmGetZonesDatastores.mock
}

// Times sets number of times Client.GetZonesDatastores should be invoked
func (mmGetZonesDatastores *mClientMockGetZonesDatastores) Times(n uint64) *mClientMockGetZonesDatastores {
	if n == 0 {
		mmGetZonesDatastores.mock.t.Fatalf("Times of ClientMock.GetZonesDatastores mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetZonesDatastores.expectedInvocations, n)
	mmGetZonesDatastores.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetZonesDatastores
}

func (mmGetZonesDatastores *mClientMockGetZonesDatastores) invocationsDone() bool {
	if len(mmGetZonesDatastores.expectations) == 0 && mmGetZonesDatastores.defaultExpectation == nil && mmGetZonesDatastores.mock.funcGetZonesDatastores == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetZonesDatastores.mock.afterGetZonesDatastoresCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetZonesDatastores.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetZonesDatastores implements Client
func (mmGetZonesDatastores *ClientMock) GetZonesDatastores() (op1 *Output, err error) {
	mm_atomic.AddUint64(&mmGetZonesDatastores.beforeGetZonesDatastoresCounter, 1)
	defer mm_atomic.AddUint64(&mmGetZonesDatastores.afterGetZonesDatastoresCounter, 1)

	mmGetZonesDatastores.t.Helper()

	if mmGetZonesDatastores.inspectFuncGetZonesDatastores != nil {
		mmGetZonesDatastores.inspectFuncGetZonesDatastores()
	}

	if mmGetZonesDatastores.GetZonesDatastoresMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetZonesDatastores.GetZonesDatastoresMock.defaultExpectation.Counter, 1)

		mm_results := mmGetZonesDatastores.GetZonesDatastoresMock.defaultExpectation.results
		if mm_results == nil {
			mmGetZonesDatastores.t.Fatal("No results are set for the ClientMock.GetZonesDatastores")
		}
		return (*mm_results).op1, (*mm_results).err
	}
	if mmGetZonesDatastores.funcGetZonesDatastores != nil {
		return mmGetZonesDatastores.funcGetZonesDatastores()
	}
	mmGetZonesDatastores.t.Fatalf("Unexpected call to ClientMock.GetZonesDatastores.")
	return
}

// GetZonesDatastoresAfterCounter returns a count of finished ClientMock.GetZonesDatastores invocations
func (mmGetZonesDatastores *ClientMock) GetZonesDatastoresAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetZonesDatastores.afterGetZonesDatastoresCounter)
}

// GetZonesDatastoresBeforeCounter returns a count of ClientMock.GetZonesDatastores invocations
func (mmGetZonesDatastores *ClientMock) GetZonesDatastoresBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetZonesDatastores.beforeGetZonesDatastoresCounter)
}

// MinimockGetZonesDatastoresDone returns true if the count of the GetZonesDatastores invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetZonesDatastoresDone() bool {
	if m.GetZonesDatastoresMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetZonesDatastoresMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetZonesDatastoresMock.invocationsDone()
}

// MinimockGetZonesDatastoresInspect logs each unmet expectation
func (m *ClientMock) MinimockGetZonesDatastoresInspect() {
	for _, e := range m.GetZonesDatastoresMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.GetZonesDatastores")
		}
	}

	afterGetZonesDatastoresCounter := mm_atomic.LoadUint64(&m.afterGetZonesDatastoresCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetZonesDatastoresMock.defaultExpectation != nil && afterGetZonesDatastoresCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetZonesDatastores at\n%s", m.GetZonesDatastoresMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetZonesDatastores != nil && afterGetZonesDatastoresCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.GetZonesDatastores at\n%s", m.funcGetZonesDatastoresOrigin)
	}

	if !m.GetZonesDatastoresMock.invocationsDone() && afterGetZonesDatastoresCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.GetZonesDatastores at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetZonesDatastoresMock.expectedInvocations), m.GetZonesDatastoresMock.expectedInvocationsOrigin, afterGetZonesDatastoresCounter)
	}
}

type mClientMockListPolicies struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockListPoliciesExpectation
	expectations       []*ClientMockListPoliciesExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockListPoliciesExpectation specifies expectation struct of the Client.ListPolicies
type ClientMockListPoliciesExpectation struct {
	mock *ClientMock

	results      *ClientMockListPoliciesResults
	returnOrigin string
	Counter      uint64
}

// ClientMockListPoliciesResults contains results of the Client.ListPolicies
type ClientMockListPoliciesResults struct {
	sa1 []StoragePolicy
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListPolicies *mClientMockListPolicies) Optional() *mClientMockListPolicies {
	mmListPolicies.optional = true
	return mmListPolicies
}

// Expect sets up expected params for Client.ListPolicies
func (mmListPolicies *mClientMockListPolicies) Expect() *mClientMockListPolicies {
	if mmListPolicies.mock.funcListPolicies != nil {
		mmListPolicies.mock.t.Fatalf("ClientMock.ListPolicies mock is already set by Set")
	}

	if mmListPolicies.defaultExpectation == nil {
		mmListPolicies.defaultExpectation = &ClientMockListPoliciesExpectation{}
	}

	return mmListPolicies
}

// Inspect accepts an inspector function that has same arguments as the Client.ListPolicies
func (mmListPolicies *mClientMockListPolicies) Inspect(f func()) *mClientMockListPolicies {
	if mmListPolicies.mock.inspectFuncListPolicies != nil {
		mmListPolicies.mock.t.Fatalf("Inspect function is already set for ClientMock.ListPolicies")
	}

	mmListPolicies.mock.inspectFuncListPolicies = f

	return mmListPolicies
}

// Return sets up results that will be returned by Client.ListPolicies
func (mmListPolicies *mClientMockListPolicies) Return(sa1 []StoragePolicy, err error) *ClientMock {
	if mmListPolicies.mock.funcListPolicies != nil {
		mmListPolicies.mock.t.Fatalf("ClientMock.ListPolicies mock is already set by Set")
	}

	if mmListPolicies.defaultExpectation == nil {
		mmListPolicies.defaultExpectation = &ClientMockListPoliciesExpectation{mock: mmListPolicies.mock}
	}
	mmListPolicies.defaultExpectation.results = &ClientMockListPoliciesResults{sa1, err}
	mmListPolicies.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListPolicies.mock
}

// Set uses given function f to mock the Client.ListPolicies method
func (mmListPolicies *mClientMockListPolicies) Set(f func() (sa1 []StoragePolicy, err error)) *ClientMock {
	if mmListPolicies.defaultExpectation != nil {
		mmListPolicies.mock.t.Fatalf("Default expectation is already set for the Client.ListPolicies method")
	}

	if len(mmListPolicies.expectations) > 0 {
		mmListPolicies.mock.t.Fatalf("Some expectations are already set for the Client.ListPolicies method")
	}

	mmListPolicies.mock.funcListPolicies = f
	mmListPolicies.mock.funcListPoliciesOrigin = minimock.CallerInfo(1)
	return mmListPolicies.mock
}

// Times sets number of times Client.ListPolicies should be invoked
func (mmListPolicies *mClientMockListPolicies) Times(n uint64) *mClientMockListPolicies {
	if n == 0 {
		mmListPolicies.mock.t.Fatalf("Times of ClientMock.ListPolicies mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListPolicies.expectedInvocations, n)
	mmListPolicies.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListPolicies
}

func (mmListPolicies *mClientMockListPolicies) invocationsDone() bool {
	if len(mmListPolicies.expectations) == 0 && mmListPolicies.defaultExpectation == nil && mmListPolicies.mock.funcListPolicies == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListPolicies.mock.afterListPoliciesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListPolicies.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListPolicies implements Client
func (mmListPolicies *ClientMock) ListPolicies() (sa1 []StoragePolicy, err error) {
	mm_atomic.AddUint64(&mmListPolicies.beforeListPoliciesCounter, 1)
	defer mm_atomic.AddUint64(&mmListPolicies.afterListPoliciesCounter, 1)

	mmListPolicies.t.Helper()

	if mmListPolicies.inspectFuncListPolicies != nil {
		mmListPolicies.inspectFuncListPolicies()
	}

	if mmListPolicies.ListPoliciesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListPolicies.ListPoliciesMock.defaultExpectation.Counter, 1)

		mm_results := mmListPolicies.ListPoliciesMock.defaultExpectation.results
		if mm_results == nil {
			mmListPolicies.t.Fatal("No results are set for the ClientMock.ListPolicies")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListPolicies.funcListPolicies != nil {
		return mmListPolicies.funcListPolicies()
	}
	mmListPolicies.t.Fatalf("Unexpected call to ClientMock.ListPolicies.")
	return
}

// ListPoliciesAfterCounter returns a count of finished ClientMock.ListPolicies invocations
func (mmListPolicies *ClientMock) ListPoliciesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPolicies.afterListPoliciesCounter)
}

// ListPoliciesBeforeCounter returns a count of ClientMock.ListPolicies invocations
func (mmListPolicies *ClientMock) ListPoliciesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListPolicies.beforeListPoliciesCounter)
}

// MinimockListPoliciesDone returns true if the count of the ListPolicies invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockListPoliciesDone() bool {
	if m.ListPoliciesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListPoliciesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListPoliciesMock.invocationsDone()
}

// MinimockListPoliciesInspect logs each unmet expectation
func (m *ClientMock) MinimockListPoliciesInspect() {
	for _, e := range m.ListPoliciesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.ListPolicies")
		}
	}

	afterListPoliciesCounter := mm_atomic.LoadUint64(&m.afterListPoliciesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListPoliciesMock.defaultExpectation != nil && afterListPoliciesCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ListPolicies at\n%s", m.ListPoliciesMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListPolicies != nil && afterListPoliciesCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ListPolicies at\n%s", m.funcListPoliciesOrigin)
	}

	if !m.ListPoliciesMock.invocationsDone() && afterListPoliciesCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ListPolicies at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListPoliciesMock.expectedInvocations), m.ListPoliciesMock.expectedInvocationsOrigin, afterListPoliciesCounter)
	}
}

type mClientMockLogin struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockLoginExpectation
	expectations       []*ClientMockLoginExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockLoginExpectation specifies expectation struct of the Client.Login
type ClientMockLoginExpectation struct {
	mock *ClientMock

	results      *ClientMockLoginResults
	returnOrigin string
	Counter      uint64
}

// ClientMockLoginResults contains results of the Client.Login
type ClientMockLoginResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmLogin *mClientMockLogin) Optional() *mClientMockLogin {
	mmLogin.optional = true
	return mmLogin
}

// Expect sets up expected params for Client.Login
func (mmLogin *mClientMockLogin) Expect() *mClientMockLogin {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ClientMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ClientMockLoginExpectation{}
	}

	return mmLogin
}

// Inspect accepts an inspector function that has same arguments as the Client.Login
func (mmLogin *mClientMockLogin) Inspect(f func()) *mClientMockLogin {
	if mmLogin.mock.inspectFuncLogin != nil {
		mmLogin.mock.t.Fatalf("Inspect function is already set for ClientMock.Login")
	}

	mmLogin.mock.inspectFuncLogin = f

	return mmLogin
}

// Return sets up results that will be returned by Client.Login
func (mmLogin *mClientMockLogin) Return(err error) *ClientMock {
	if mmLogin.mock.funcLogin != nil {
		mmLogin.mock.t.Fatalf("ClientMock.Login mock is already set by Set")
	}

	if mmLogin.defaultExpectation == nil {
		mmLogin.defaultExpectation = &ClientMockLoginExpectation{mock: mmLogin.mock}
	}
	mmLogin.defaultExpectation.results = &ClientMockLoginResults{err}
	mmLogin.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Set uses given function f to mock the Client.Login method
func (mmLogin *mClientMockLogin) Set(f func() (err error)) *ClientMock {
	if mmLogin.defaultExpectation != nil {
		mmLogin.mock.t.Fatalf("Default expectation is already set for the Client.Login method")
	}

	if len(mmLogin.expectations) > 0 {
		mmLogin.mock.t.Fatalf("Some expectations are already set for the Client.Login method")
	}

	mmLogin.mock.funcLogin = f
	mmLogin.mock.funcLoginOrigin = minimock.CallerInfo(1)
	return mmLogin.mock
}

// Times sets number of times Client.Login should be invoked
func (mmLogin *mClientMockLogin) Times(n uint64) *mClientMockLogin {
	if n == 0 {
		mmLogin.mock.t.Fatalf("Times of ClientMock.Login mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmLogin.expectedInvocations, n)
	mmLogin.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmLogin
}

func (mmLogin *mClientMockLogin) invocationsDone() bool {
	if len(mmLogin.expectations) == 0 && mmLogin.defaultExpectation == nil && mmLogin.mock.funcLogin == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmLogin.mock.afterLoginCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmLogin.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Login implements Client
func (mmLogin *ClientMock) Login() (err error) {
	mm_atomic.AddUint64(&mmLogin.beforeLoginCounter, 1)
	defer mm_atomic.AddUint64(&mmLogin.afterLoginCounter, 1)

	mmLogin.t.Helper()

	if mmLogin.inspectFuncLogin != nil {
		mmLogin.inspectFuncLogin()
	}

	if mmLogin.LoginMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmLogin.LoginMock.defaultExpectation.Counter, 1)

		mm_results := mmLogin.LoginMock.defaultExpectation.results
		if mm_results == nil {
			mmLogin.t.Fatal("No results are set for the ClientMock.Login")
		}
		return (*mm_results).err
	}
	if mmLogin.funcLogin != nil {
		return mmLogin.funcLogin()
	}
	mmLogin.t.Fatalf("Unexpected call to ClientMock.Login.")
	return
}

// LoginAfterCounter returns a count of finished ClientMock.Login invocations
func (mmLogin *ClientMock) LoginAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.afterLoginCounter)
}

// LoginBeforeCounter returns a count of ClientMock.Login invocations
func (mmLogin *ClientMock) LoginBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmLogin.beforeLoginCounter)
}

// MinimockLoginDone returns true if the count of the Login invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockLoginDone() bool {
	if m.LoginMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.LoginMock.invocationsDone()
}

// MinimockLoginInspect logs each unmet expectation
func (m *ClientMock) MinimockLoginInspect() {
	for _, e := range m.LoginMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Login")
		}
	}

	afterLoginCounter := mm_atomic.LoadUint64(&m.afterLoginCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.LoginMock.defaultExpectation != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Login at\n%s", m.LoginMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcLogin != nil && afterLoginCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Login at\n%s", m.funcLoginOrigin)
	}

	if !m.LoginMock.invocationsDone() && afterLoginCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Login at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.LoginMock.expectedInvocations), m.LoginMock.expectedInvocationsOrigin, afterLoginCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetZonesDatastoresInspect()

			m.MinimockListPoliciesInspect()

			m.MinimockLoginInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetZonesDatastoresDone() &&
		m.MinimockListPoliciesDone() &&
		m.MinimockLoginDone()
}
