package etcd

// Code generated by http://github.com/gojuno/minimock (3.0.10). DO NOT EDIT.

//go:generate minimock -i github.com/deckhouse/deckhouse/go_lib/dependency/etcd.Client -o ./etcd_mock.go -n ClientMock

import (
	"context"
	"io"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	clientv3 "go.etcd.io/etcd/client/v3"
)

// ClientMock implements Client
type ClientMock struct {
	t minimock.Tester

	funcAlarmDisarm          func(ctx context.Context, m *clientv3.AlarmMember) (ap1 *clientv3.AlarmResponse, err error)
	inspectFuncAlarmDisarm   func(ctx context.Context, m *clientv3.AlarmMember)
	afterAlarmDisarmCounter  uint64
	beforeAlarmDisarmCounter uint64
	AlarmDisarmMock          mClientMockAlarmDisarm

	funcAlarmList          func(ctx context.Context) (ap1 *clientv3.AlarmResponse, err error)
	inspectFuncAlarmList   func(ctx context.Context)
	afterAlarmListCounter  uint64
	beforeAlarmListCounter uint64
	AlarmListMock          mClientMockAlarmList

	funcClose          func() (err error)
	inspectFuncClose   func()
	afterCloseCounter  uint64
	beforeCloseCounter uint64
	CloseMock          mClientMockClose

	funcCompact          func(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error)
	inspectFuncCompact   func(ctx context.Context, rev int64, opts ...clientv3.CompactOption)
	afterCompactCounter  uint64
	beforeCompactCounter uint64
	CompactMock          mClientMockCompact

	funcDefragment          func(ctx context.Context, endpoint string) (dp1 *clientv3.DefragmentResponse, err error)
	inspectFuncDefragment   func(ctx context.Context, endpoint string)
	afterDefragmentCounter  uint64
	beforeDefragmentCounter uint64
	DefragmentMock          mClientMockDefragment

	funcDelete          func(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error)
	inspectFuncDelete   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterDeleteCounter  uint64
	beforeDeleteCounter uint64
	DeleteMock          mClientMockDelete

	funcDo          func(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error)
	inspectFuncDo   func(ctx context.Context, op clientv3.Op)
	afterDoCounter  uint64
	beforeDoCounter uint64
	DoMock          mClientMockDo

	funcGet          func(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error)
	inspectFuncGet   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterGetCounter  uint64
	beforeGetCounter uint64
	GetMock          mClientMockGet

	funcHashKV          func(ctx context.Context, endpoint string, rev int64) (hp1 *clientv3.HashKVResponse, err error)
	inspectFuncHashKV   func(ctx context.Context, endpoint string, rev int64)
	afterHashKVCounter  uint64
	beforeHashKVCounter uint64
	HashKVMock          mClientMockHashKV

	funcMemberAdd          func(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error)
	inspectFuncMemberAdd   func(ctx context.Context, peerAddrs []string)
	afterMemberAddCounter  uint64
	beforeMemberAddCounter uint64
	MemberAddMock          mClientMockMemberAdd

	funcMemberAddAsLearner          func(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error)
	inspectFuncMemberAddAsLearner   func(ctx context.Context, peerAddrs []string)
	afterMemberAddAsLearnerCounter  uint64
	beforeMemberAddAsLearnerCounter uint64
	MemberAddAsLearnerMock          mClientMockMemberAddAsLearner

	funcMemberList          func(ctx context.Context) (mp1 *clientv3.MemberListResponse, err error)
	inspectFuncMemberList   func(ctx context.Context)
	afterMemberListCounter  uint64
	beforeMemberListCounter uint64
	MemberListMock          mClientMockMemberList

	funcMemberPromote          func(ctx context.Context, id uint64) (mp1 *clientv3.MemberPromoteResponse, err error)
	inspectFuncMemberPromote   func(ctx context.Context, id uint64)
	afterMemberPromoteCounter  uint64
	beforeMemberPromoteCounter uint64
	MemberPromoteMock          mClientMockMemberPromote

	funcMemberRemove          func(ctx context.Context, id uint64) (mp1 *clientv3.MemberRemoveResponse, err error)
	inspectFuncMemberRemove   func(ctx context.Context, id uint64)
	afterMemberRemoveCounter  uint64
	beforeMemberRemoveCounter uint64
	MemberRemoveMock          mClientMockMemberRemove

	funcMemberUpdate          func(ctx context.Context, id uint64, peerAddrs []string) (mp1 *clientv3.MemberUpdateResponse, err error)
	inspectFuncMemberUpdate   func(ctx context.Context, id uint64, peerAddrs []string)
	afterMemberUpdateCounter  uint64
	beforeMemberUpdateCounter uint64
	MemberUpdateMock          mClientMockMemberUpdate

	funcMoveLeader          func(ctx context.Context, transfereeID uint64) (mp1 *clientv3.MoveLeaderResponse, err error)
	inspectFuncMoveLeader   func(ctx context.Context, transfereeID uint64)
	afterMoveLeaderCounter  uint64
	beforeMoveLeaderCounter uint64
	MoveLeaderMock          mClientMockMoveLeader

	funcPut          func(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error)
	inspectFuncPut   func(ctx context.Context, key string, val string, opts ...clientv3.OpOption)
	afterPutCounter  uint64
	beforePutCounter uint64
	PutMock          mClientMockPut

	funcRequestProgress          func(ctx context.Context) (err error)
	inspectFuncRequestProgress   func(ctx context.Context)
	afterRequestProgressCounter  uint64
	beforeRequestProgressCounter uint64
	RequestProgressMock          mClientMockRequestProgress

	funcSnapshot          func(ctx context.Context) (r1 io.ReadCloser, err error)
	inspectFuncSnapshot   func(ctx context.Context)
	afterSnapshotCounter  uint64
	beforeSnapshotCounter uint64
	SnapshotMock          mClientMockSnapshot

	funcStatus          func(ctx context.Context, endpoint string) (sp1 *clientv3.StatusResponse, err error)
	inspectFuncStatus   func(ctx context.Context, endpoint string)
	afterStatusCounter  uint64
	beforeStatusCounter uint64
	StatusMock          mClientMockStatus

	funcTxn          func(ctx context.Context) (t1 clientv3.Txn)
	inspectFuncTxn   func(ctx context.Context)
	afterTxnCounter  uint64
	beforeTxnCounter uint64
	TxnMock          mClientMockTxn

	funcWatch          func(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan)
	inspectFuncWatch   func(ctx context.Context, key string, opts ...clientv3.OpOption)
	afterWatchCounter  uint64
	beforeWatchCounter uint64
	WatchMock          mClientMockWatch
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}
	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.AlarmDisarmMock = mClientMockAlarmDisarm{mock: m}
	m.AlarmDisarmMock.callArgs = []*ClientMockAlarmDisarmParams{}

	m.AlarmListMock = mClientMockAlarmList{mock: m}
	m.AlarmListMock.callArgs = []*ClientMockAlarmListParams{}

	m.CloseMock = mClientMockClose{mock: m}

	m.CompactMock = mClientMockCompact{mock: m}
	m.CompactMock.callArgs = []*ClientMockCompactParams{}

	m.DefragmentMock = mClientMockDefragment{mock: m}
	m.DefragmentMock.callArgs = []*ClientMockDefragmentParams{}

	m.DeleteMock = mClientMockDelete{mock: m}
	m.DeleteMock.callArgs = []*ClientMockDeleteParams{}

	m.DoMock = mClientMockDo{mock: m}
	m.DoMock.callArgs = []*ClientMockDoParams{}

	m.GetMock = mClientMockGet{mock: m}
	m.GetMock.callArgs = []*ClientMockGetParams{}

	m.HashKVMock = mClientMockHashKV{mock: m}
	m.HashKVMock.callArgs = []*ClientMockHashKVParams{}

	m.MemberAddMock = mClientMockMemberAdd{mock: m}
	m.MemberAddMock.callArgs = []*ClientMockMemberAddParams{}

	m.MemberAddAsLearnerMock = mClientMockMemberAddAsLearner{mock: m}
	m.MemberAddAsLearnerMock.callArgs = []*ClientMockMemberAddAsLearnerParams{}

	m.MemberListMock = mClientMockMemberList{mock: m}
	m.MemberListMock.callArgs = []*ClientMockMemberListParams{}

	m.MemberPromoteMock = mClientMockMemberPromote{mock: m}
	m.MemberPromoteMock.callArgs = []*ClientMockMemberPromoteParams{}

	m.MemberRemoveMock = mClientMockMemberRemove{mock: m}
	m.MemberRemoveMock.callArgs = []*ClientMockMemberRemoveParams{}

	m.MemberUpdateMock = mClientMockMemberUpdate{mock: m}
	m.MemberUpdateMock.callArgs = []*ClientMockMemberUpdateParams{}

	m.MoveLeaderMock = mClientMockMoveLeader{mock: m}
	m.MoveLeaderMock.callArgs = []*ClientMockMoveLeaderParams{}

	m.PutMock = mClientMockPut{mock: m}
	m.PutMock.callArgs = []*ClientMockPutParams{}

	m.RequestProgressMock = mClientMockRequestProgress{mock: m}
	m.RequestProgressMock.callArgs = []*ClientMockRequestProgressParams{}

	m.SnapshotMock = mClientMockSnapshot{mock: m}
	m.SnapshotMock.callArgs = []*ClientMockSnapshotParams{}

	m.StatusMock = mClientMockStatus{mock: m}
	m.StatusMock.callArgs = []*ClientMockStatusParams{}

	m.TxnMock = mClientMockTxn{mock: m}
	m.TxnMock.callArgs = []*ClientMockTxnParams{}

	m.WatchMock = mClientMockWatch{mock: m}
	m.WatchMock.callArgs = []*ClientMockWatchParams{}

	return m
}

type mClientMockAlarmDisarm struct {
	mock               *ClientMock
	defaultExpectation *ClientMockAlarmDisarmExpectation
	expectations       []*ClientMockAlarmDisarmExpectation

	callArgs []*ClientMockAlarmDisarmParams
	mutex    sync.RWMutex
}

// ClientMockAlarmDisarmExpectation specifies expectation struct of the Client.AlarmDisarm
type ClientMockAlarmDisarmExpectation struct {
	mock    *ClientMock
	params  *ClientMockAlarmDisarmParams
	results *ClientMockAlarmDisarmResults
	Counter uint64
}

// ClientMockAlarmDisarmParams contains parameters of the Client.AlarmDisarm
type ClientMockAlarmDisarmParams struct {
	ctx context.Context
	m   *clientv3.AlarmMember
}

// ClientMockAlarmDisarmResults contains results of the Client.AlarmDisarm
type ClientMockAlarmDisarmResults struct {
	ap1 *clientv3.AlarmResponse
	err error
}

// Expect sets up expected params for Client.AlarmDisarm
func (mmAlarmDisarm *mClientMockAlarmDisarm) Expect(ctx context.Context, m *clientv3.AlarmMember) *mClientMockAlarmDisarm {
	if mmAlarmDisarm.mock.funcAlarmDisarm != nil {
		mmAlarmDisarm.mock.t.Fatalf("ClientMock.AlarmDisarm mock is already set by Set")
	}

	if mmAlarmDisarm.defaultExpectation == nil {
		mmAlarmDisarm.defaultExpectation = &ClientMockAlarmDisarmExpectation{}
	}

	mmAlarmDisarm.defaultExpectation.params = &ClientMockAlarmDisarmParams{ctx, m}
	for _, e := range mmAlarmDisarm.expectations {
		if minimock.Equal(e.params, mmAlarmDisarm.defaultExpectation.params) {
			mmAlarmDisarm.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAlarmDisarm.defaultExpectation.params)
		}
	}

	return mmAlarmDisarm
}

// Inspect accepts an inspector function that has same arguments as the Client.AlarmDisarm
func (mmAlarmDisarm *mClientMockAlarmDisarm) Inspect(f func(ctx context.Context, m *clientv3.AlarmMember)) *mClientMockAlarmDisarm {
	if mmAlarmDisarm.mock.inspectFuncAlarmDisarm != nil {
		mmAlarmDisarm.mock.t.Fatalf("Inspect function is already set for ClientMock.AlarmDisarm")
	}

	mmAlarmDisarm.mock.inspectFuncAlarmDisarm = f

	return mmAlarmDisarm
}

// Return sets up results that will be returned by Client.AlarmDisarm
func (mmAlarmDisarm *mClientMockAlarmDisarm) Return(ap1 *clientv3.AlarmResponse, err error) *ClientMock {
	if mmAlarmDisarm.mock.funcAlarmDisarm != nil {
		mmAlarmDisarm.mock.t.Fatalf("ClientMock.AlarmDisarm mock is already set by Set")
	}

	if mmAlarmDisarm.defaultExpectation == nil {
		mmAlarmDisarm.defaultExpectation = &ClientMockAlarmDisarmExpectation{mock: mmAlarmDisarm.mock}
	}
	mmAlarmDisarm.defaultExpectation.results = &ClientMockAlarmDisarmResults{ap1, err}
	return mmAlarmDisarm.mock
}

//Set uses given function f to mock the Client.AlarmDisarm method
func (mmAlarmDisarm *mClientMockAlarmDisarm) Set(f func(ctx context.Context, m *clientv3.AlarmMember) (ap1 *clientv3.AlarmResponse, err error)) *ClientMock {
	if mmAlarmDisarm.defaultExpectation != nil {
		mmAlarmDisarm.mock.t.Fatalf("Default expectation is already set for the Client.AlarmDisarm method")
	}

	if len(mmAlarmDisarm.expectations) > 0 {
		mmAlarmDisarm.mock.t.Fatalf("Some expectations are already set for the Client.AlarmDisarm method")
	}

	mmAlarmDisarm.mock.funcAlarmDisarm = f
	return mmAlarmDisarm.mock
}

// When sets expectation for the Client.AlarmDisarm which will trigger the result defined by the following
// Then helper
func (mmAlarmDisarm *mClientMockAlarmDisarm) When(ctx context.Context, m *clientv3.AlarmMember) *ClientMockAlarmDisarmExpectation {
	if mmAlarmDisarm.mock.funcAlarmDisarm != nil {
		mmAlarmDisarm.mock.t.Fatalf("ClientMock.AlarmDisarm mock is already set by Set")
	}

	expectation := &ClientMockAlarmDisarmExpectation{
		mock:   mmAlarmDisarm.mock,
		params: &ClientMockAlarmDisarmParams{ctx, m},
	}
	mmAlarmDisarm.expectations = append(mmAlarmDisarm.expectations, expectation)
	return expectation
}

// Then sets up Client.AlarmDisarm return parameters for the expectation previously defined by the When method
func (e *ClientMockAlarmDisarmExpectation) Then(ap1 *clientv3.AlarmResponse, err error) *ClientMock {
	e.results = &ClientMockAlarmDisarmResults{ap1, err}
	return e.mock
}

// AlarmDisarm implements Client
func (mmAlarmDisarm *ClientMock) AlarmDisarm(ctx context.Context, m *clientv3.AlarmMember) (ap1 *clientv3.AlarmResponse, err error) {
	mm_atomic.AddUint64(&mmAlarmDisarm.beforeAlarmDisarmCounter, 1)
	defer mm_atomic.AddUint64(&mmAlarmDisarm.afterAlarmDisarmCounter, 1)

	if mmAlarmDisarm.inspectFuncAlarmDisarm != nil {
		mmAlarmDisarm.inspectFuncAlarmDisarm(ctx, m)
	}

	mm_params := &ClientMockAlarmDisarmParams{ctx, m}

	// Record call args
	mmAlarmDisarm.AlarmDisarmMock.mutex.Lock()
	mmAlarmDisarm.AlarmDisarmMock.callArgs = append(mmAlarmDisarm.AlarmDisarmMock.callArgs, mm_params)
	mmAlarmDisarm.AlarmDisarmMock.mutex.Unlock()

	for _, e := range mmAlarmDisarm.AlarmDisarmMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmAlarmDisarm.AlarmDisarmMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAlarmDisarm.AlarmDisarmMock.defaultExpectation.Counter, 1)
		mm_want := mmAlarmDisarm.AlarmDisarmMock.defaultExpectation.params
		mm_got := ClientMockAlarmDisarmParams{ctx, m}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAlarmDisarm.t.Errorf("ClientMock.AlarmDisarm got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAlarmDisarm.AlarmDisarmMock.defaultExpectation.results
		if mm_results == nil {
			mmAlarmDisarm.t.Fatal("No results are set for the ClientMock.AlarmDisarm")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmAlarmDisarm.funcAlarmDisarm != nil {
		return mmAlarmDisarm.funcAlarmDisarm(ctx, m)
	}
	mmAlarmDisarm.t.Fatalf("Unexpected call to ClientMock.AlarmDisarm. %v %v", ctx, m)
	return
}

// AlarmDisarmAfterCounter returns a count of finished ClientMock.AlarmDisarm invocations
func (mmAlarmDisarm *ClientMock) AlarmDisarmAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAlarmDisarm.afterAlarmDisarmCounter)
}

// AlarmDisarmBeforeCounter returns a count of ClientMock.AlarmDisarm invocations
func (mmAlarmDisarm *ClientMock) AlarmDisarmBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAlarmDisarm.beforeAlarmDisarmCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.AlarmDisarm.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAlarmDisarm *mClientMockAlarmDisarm) Calls() []*ClientMockAlarmDisarmParams {
	mmAlarmDisarm.mutex.RLock()

	argCopy := make([]*ClientMockAlarmDisarmParams, len(mmAlarmDisarm.callArgs))
	copy(argCopy, mmAlarmDisarm.callArgs)

	mmAlarmDisarm.mutex.RUnlock()

	return argCopy
}

// MinimockAlarmDisarmDone returns true if the count of the AlarmDisarm invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockAlarmDisarmDone() bool {
	for _, e := range m.AlarmDisarmMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AlarmDisarmMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAlarmDisarmCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAlarmDisarm != nil && mm_atomic.LoadUint64(&m.afterAlarmDisarmCounter) < 1 {
		return false
	}
	return true
}

// MinimockAlarmDisarmInspect logs each unmet expectation
func (m *ClientMock) MinimockAlarmDisarmInspect() {
	for _, e := range m.AlarmDisarmMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.AlarmDisarm with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AlarmDisarmMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAlarmDisarmCounter) < 1 {
		if m.AlarmDisarmMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.AlarmDisarm")
		} else {
			m.t.Errorf("Expected call to ClientMock.AlarmDisarm with params: %#v", *m.AlarmDisarmMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAlarmDisarm != nil && mm_atomic.LoadUint64(&m.afterAlarmDisarmCounter) < 1 {
		m.t.Error("Expected call to ClientMock.AlarmDisarm")
	}
}

type mClientMockAlarmList struct {
	mock               *ClientMock
	defaultExpectation *ClientMockAlarmListExpectation
	expectations       []*ClientMockAlarmListExpectation

	callArgs []*ClientMockAlarmListParams
	mutex    sync.RWMutex
}

// ClientMockAlarmListExpectation specifies expectation struct of the Client.AlarmList
type ClientMockAlarmListExpectation struct {
	mock    *ClientMock
	params  *ClientMockAlarmListParams
	results *ClientMockAlarmListResults
	Counter uint64
}

// ClientMockAlarmListParams contains parameters of the Client.AlarmList
type ClientMockAlarmListParams struct {
	ctx context.Context
}

// ClientMockAlarmListResults contains results of the Client.AlarmList
type ClientMockAlarmListResults struct {
	ap1 *clientv3.AlarmResponse
	err error
}

// Expect sets up expected params for Client.AlarmList
func (mmAlarmList *mClientMockAlarmList) Expect(ctx context.Context) *mClientMockAlarmList {
	if mmAlarmList.mock.funcAlarmList != nil {
		mmAlarmList.mock.t.Fatalf("ClientMock.AlarmList mock is already set by Set")
	}

	if mmAlarmList.defaultExpectation == nil {
		mmAlarmList.defaultExpectation = &ClientMockAlarmListExpectation{}
	}

	mmAlarmList.defaultExpectation.params = &ClientMockAlarmListParams{ctx}
	for _, e := range mmAlarmList.expectations {
		if minimock.Equal(e.params, mmAlarmList.defaultExpectation.params) {
			mmAlarmList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmAlarmList.defaultExpectation.params)
		}
	}

	return mmAlarmList
}

// Inspect accepts an inspector function that has same arguments as the Client.AlarmList
func (mmAlarmList *mClientMockAlarmList) Inspect(f func(ctx context.Context)) *mClientMockAlarmList {
	if mmAlarmList.mock.inspectFuncAlarmList != nil {
		mmAlarmList.mock.t.Fatalf("Inspect function is already set for ClientMock.AlarmList")
	}

	mmAlarmList.mock.inspectFuncAlarmList = f

	return mmAlarmList
}

// Return sets up results that will be returned by Client.AlarmList
func (mmAlarmList *mClientMockAlarmList) Return(ap1 *clientv3.AlarmResponse, err error) *ClientMock {
	if mmAlarmList.mock.funcAlarmList != nil {
		mmAlarmList.mock.t.Fatalf("ClientMock.AlarmList mock is already set by Set")
	}

	if mmAlarmList.defaultExpectation == nil {
		mmAlarmList.defaultExpectation = &ClientMockAlarmListExpectation{mock: mmAlarmList.mock}
	}
	mmAlarmList.defaultExpectation.results = &ClientMockAlarmListResults{ap1, err}
	return mmAlarmList.mock
}

//Set uses given function f to mock the Client.AlarmList method
func (mmAlarmList *mClientMockAlarmList) Set(f func(ctx context.Context) (ap1 *clientv3.AlarmResponse, err error)) *ClientMock {
	if mmAlarmList.defaultExpectation != nil {
		mmAlarmList.mock.t.Fatalf("Default expectation is already set for the Client.AlarmList method")
	}

	if len(mmAlarmList.expectations) > 0 {
		mmAlarmList.mock.t.Fatalf("Some expectations are already set for the Client.AlarmList method")
	}

	mmAlarmList.mock.funcAlarmList = f
	return mmAlarmList.mock
}

// When sets expectation for the Client.AlarmList which will trigger the result defined by the following
// Then helper
func (mmAlarmList *mClientMockAlarmList) When(ctx context.Context) *ClientMockAlarmListExpectation {
	if mmAlarmList.mock.funcAlarmList != nil {
		mmAlarmList.mock.t.Fatalf("ClientMock.AlarmList mock is already set by Set")
	}

	expectation := &ClientMockAlarmListExpectation{
		mock:   mmAlarmList.mock,
		params: &ClientMockAlarmListParams{ctx},
	}
	mmAlarmList.expectations = append(mmAlarmList.expectations, expectation)
	return expectation
}

// Then sets up Client.AlarmList return parameters for the expectation previously defined by the When method
func (e *ClientMockAlarmListExpectation) Then(ap1 *clientv3.AlarmResponse, err error) *ClientMock {
	e.results = &ClientMockAlarmListResults{ap1, err}
	return e.mock
}

// AlarmList implements Client
func (mmAlarmList *ClientMock) AlarmList(ctx context.Context) (ap1 *clientv3.AlarmResponse, err error) {
	mm_atomic.AddUint64(&mmAlarmList.beforeAlarmListCounter, 1)
	defer mm_atomic.AddUint64(&mmAlarmList.afterAlarmListCounter, 1)

	if mmAlarmList.inspectFuncAlarmList != nil {
		mmAlarmList.inspectFuncAlarmList(ctx)
	}

	mm_params := &ClientMockAlarmListParams{ctx}

	// Record call args
	mmAlarmList.AlarmListMock.mutex.Lock()
	mmAlarmList.AlarmListMock.callArgs = append(mmAlarmList.AlarmListMock.callArgs, mm_params)
	mmAlarmList.AlarmListMock.mutex.Unlock()

	for _, e := range mmAlarmList.AlarmListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.ap1, e.results.err
		}
	}

	if mmAlarmList.AlarmListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmAlarmList.AlarmListMock.defaultExpectation.Counter, 1)
		mm_want := mmAlarmList.AlarmListMock.defaultExpectation.params
		mm_got := ClientMockAlarmListParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmAlarmList.t.Errorf("ClientMock.AlarmList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmAlarmList.AlarmListMock.defaultExpectation.results
		if mm_results == nil {
			mmAlarmList.t.Fatal("No results are set for the ClientMock.AlarmList")
		}
		return (*mm_results).ap1, (*mm_results).err
	}
	if mmAlarmList.funcAlarmList != nil {
		return mmAlarmList.funcAlarmList(ctx)
	}
	mmAlarmList.t.Fatalf("Unexpected call to ClientMock.AlarmList. %v", ctx)
	return
}

// AlarmListAfterCounter returns a count of finished ClientMock.AlarmList invocations
func (mmAlarmList *ClientMock) AlarmListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAlarmList.afterAlarmListCounter)
}

// AlarmListBeforeCounter returns a count of ClientMock.AlarmList invocations
func (mmAlarmList *ClientMock) AlarmListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmAlarmList.beforeAlarmListCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.AlarmList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmAlarmList *mClientMockAlarmList) Calls() []*ClientMockAlarmListParams {
	mmAlarmList.mutex.RLock()

	argCopy := make([]*ClientMockAlarmListParams, len(mmAlarmList.callArgs))
	copy(argCopy, mmAlarmList.callArgs)

	mmAlarmList.mutex.RUnlock()

	return argCopy
}

// MinimockAlarmListDone returns true if the count of the AlarmList invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockAlarmListDone() bool {
	for _, e := range m.AlarmListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AlarmListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAlarmListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAlarmList != nil && mm_atomic.LoadUint64(&m.afterAlarmListCounter) < 1 {
		return false
	}
	return true
}

// MinimockAlarmListInspect logs each unmet expectation
func (m *ClientMock) MinimockAlarmListInspect() {
	for _, e := range m.AlarmListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.AlarmList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.AlarmListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterAlarmListCounter) < 1 {
		if m.AlarmListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.AlarmList")
		} else {
			m.t.Errorf("Expected call to ClientMock.AlarmList with params: %#v", *m.AlarmListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcAlarmList != nil && mm_atomic.LoadUint64(&m.afterAlarmListCounter) < 1 {
		m.t.Error("Expected call to ClientMock.AlarmList")
	}
}

type mClientMockClose struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCloseExpectation
	expectations       []*ClientMockCloseExpectation
}

// ClientMockCloseExpectation specifies expectation struct of the Client.Close
type ClientMockCloseExpectation struct {
	mock *ClientMock

	results *ClientMockCloseResults
	Counter uint64
}

// ClientMockCloseResults contains results of the Client.Close
type ClientMockCloseResults struct {
	err error
}

// Expect sets up expected params for Client.Close
func (mmClose *mClientMockClose) Expect() *mClientMockClose {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{}
	}

	return mmClose
}

// Inspect accepts an inspector function that has same arguments as the Client.Close
func (mmClose *mClientMockClose) Inspect(f func()) *mClientMockClose {
	if mmClose.mock.inspectFuncClose != nil {
		mmClose.mock.t.Fatalf("Inspect function is already set for ClientMock.Close")
	}

	mmClose.mock.inspectFuncClose = f

	return mmClose
}

// Return sets up results that will be returned by Client.Close
func (mmClose *mClientMockClose) Return(err error) *ClientMock {
	if mmClose.mock.funcClose != nil {
		mmClose.mock.t.Fatalf("ClientMock.Close mock is already set by Set")
	}

	if mmClose.defaultExpectation == nil {
		mmClose.defaultExpectation = &ClientMockCloseExpectation{mock: mmClose.mock}
	}
	mmClose.defaultExpectation.results = &ClientMockCloseResults{err}
	return mmClose.mock
}

//Set uses given function f to mock the Client.Close method
func (mmClose *mClientMockClose) Set(f func() (err error)) *ClientMock {
	if mmClose.defaultExpectation != nil {
		mmClose.mock.t.Fatalf("Default expectation is already set for the Client.Close method")
	}

	if len(mmClose.expectations) > 0 {
		mmClose.mock.t.Fatalf("Some expectations are already set for the Client.Close method")
	}

	mmClose.mock.funcClose = f
	return mmClose.mock
}

// Close implements Client
func (mmClose *ClientMock) Close() (err error) {
	mm_atomic.AddUint64(&mmClose.beforeCloseCounter, 1)
	defer mm_atomic.AddUint64(&mmClose.afterCloseCounter, 1)

	if mmClose.inspectFuncClose != nil {
		mmClose.inspectFuncClose()
	}

	if mmClose.CloseMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClose.CloseMock.defaultExpectation.Counter, 1)

		mm_results := mmClose.CloseMock.defaultExpectation.results
		if mm_results == nil {
			mmClose.t.Fatal("No results are set for the ClientMock.Close")
		}
		return (*mm_results).err
	}
	if mmClose.funcClose != nil {
		return mmClose.funcClose()
	}
	mmClose.t.Fatalf("Unexpected call to ClientMock.Close.")
	return
}

// CloseAfterCounter returns a count of finished ClientMock.Close invocations
func (mmClose *ClientMock) CloseAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.afterCloseCounter)
}

// CloseBeforeCounter returns a count of ClientMock.Close invocations
func (mmClose *ClientMock) CloseBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClose.beforeCloseCounter)
}

// MinimockCloseDone returns true if the count of the Close invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCloseDone() bool {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		return false
	}
	return true
}

// MinimockCloseInspect logs each unmet expectation
func (m *ClientMock) MinimockCloseInspect() {
	for _, e := range m.CloseMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Close")
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CloseMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClose != nil && mm_atomic.LoadUint64(&m.afterCloseCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Close")
	}
}

type mClientMockCompact struct {
	mock               *ClientMock
	defaultExpectation *ClientMockCompactExpectation
	expectations       []*ClientMockCompactExpectation

	callArgs []*ClientMockCompactParams
	mutex    sync.RWMutex
}

// ClientMockCompactExpectation specifies expectation struct of the Client.Compact
type ClientMockCompactExpectation struct {
	mock    *ClientMock
	params  *ClientMockCompactParams
	results *ClientMockCompactResults
	Counter uint64
}

// ClientMockCompactParams contains parameters of the Client.Compact
type ClientMockCompactParams struct {
	ctx  context.Context
	rev  int64
	opts []clientv3.CompactOption
}

// ClientMockCompactResults contains results of the Client.Compact
type ClientMockCompactResults struct {
	cp1 *clientv3.CompactResponse
	err error
}

// Expect sets up expected params for Client.Compact
func (mmCompact *mClientMockCompact) Expect(ctx context.Context, rev int64, opts ...clientv3.CompactOption) *mClientMockCompact {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	if mmCompact.defaultExpectation == nil {
		mmCompact.defaultExpectation = &ClientMockCompactExpectation{}
	}

	mmCompact.defaultExpectation.params = &ClientMockCompactParams{ctx, rev, opts}
	for _, e := range mmCompact.expectations {
		if minimock.Equal(e.params, mmCompact.defaultExpectation.params) {
			mmCompact.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmCompact.defaultExpectation.params)
		}
	}

	return mmCompact
}

// Inspect accepts an inspector function that has same arguments as the Client.Compact
func (mmCompact *mClientMockCompact) Inspect(f func(ctx context.Context, rev int64, opts ...clientv3.CompactOption)) *mClientMockCompact {
	if mmCompact.mock.inspectFuncCompact != nil {
		mmCompact.mock.t.Fatalf("Inspect function is already set for ClientMock.Compact")
	}

	mmCompact.mock.inspectFuncCompact = f

	return mmCompact
}

// Return sets up results that will be returned by Client.Compact
func (mmCompact *mClientMockCompact) Return(cp1 *clientv3.CompactResponse, err error) *ClientMock {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	if mmCompact.defaultExpectation == nil {
		mmCompact.defaultExpectation = &ClientMockCompactExpectation{mock: mmCompact.mock}
	}
	mmCompact.defaultExpectation.results = &ClientMockCompactResults{cp1, err}
	return mmCompact.mock
}

//Set uses given function f to mock the Client.Compact method
func (mmCompact *mClientMockCompact) Set(f func(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error)) *ClientMock {
	if mmCompact.defaultExpectation != nil {
		mmCompact.mock.t.Fatalf("Default expectation is already set for the Client.Compact method")
	}

	if len(mmCompact.expectations) > 0 {
		mmCompact.mock.t.Fatalf("Some expectations are already set for the Client.Compact method")
	}

	mmCompact.mock.funcCompact = f
	return mmCompact.mock
}

// When sets expectation for the Client.Compact which will trigger the result defined by the following
// Then helper
func (mmCompact *mClientMockCompact) When(ctx context.Context, rev int64, opts ...clientv3.CompactOption) *ClientMockCompactExpectation {
	if mmCompact.mock.funcCompact != nil {
		mmCompact.mock.t.Fatalf("ClientMock.Compact mock is already set by Set")
	}

	expectation := &ClientMockCompactExpectation{
		mock:   mmCompact.mock,
		params: &ClientMockCompactParams{ctx, rev, opts},
	}
	mmCompact.expectations = append(mmCompact.expectations, expectation)
	return expectation
}

// Then sets up Client.Compact return parameters for the expectation previously defined by the When method
func (e *ClientMockCompactExpectation) Then(cp1 *clientv3.CompactResponse, err error) *ClientMock {
	e.results = &ClientMockCompactResults{cp1, err}
	return e.mock
}

// Compact implements Client
func (mmCompact *ClientMock) Compact(ctx context.Context, rev int64, opts ...clientv3.CompactOption) (cp1 *clientv3.CompactResponse, err error) {
	mm_atomic.AddUint64(&mmCompact.beforeCompactCounter, 1)
	defer mm_atomic.AddUint64(&mmCompact.afterCompactCounter, 1)

	if mmCompact.inspectFuncCompact != nil {
		mmCompact.inspectFuncCompact(ctx, rev, opts...)
	}

	mm_params := &ClientMockCompactParams{ctx, rev, opts}

	// Record call args
	mmCompact.CompactMock.mutex.Lock()
	mmCompact.CompactMock.callArgs = append(mmCompact.CompactMock.callArgs, mm_params)
	mmCompact.CompactMock.mutex.Unlock()

	for _, e := range mmCompact.CompactMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.cp1, e.results.err
		}
	}

	if mmCompact.CompactMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmCompact.CompactMock.defaultExpectation.Counter, 1)
		mm_want := mmCompact.CompactMock.defaultExpectation.params
		mm_got := ClientMockCompactParams{ctx, rev, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmCompact.t.Errorf("ClientMock.Compact got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmCompact.CompactMock.defaultExpectation.results
		if mm_results == nil {
			mmCompact.t.Fatal("No results are set for the ClientMock.Compact")
		}
		return (*mm_results).cp1, (*mm_results).err
	}
	if mmCompact.funcCompact != nil {
		return mmCompact.funcCompact(ctx, rev, opts...)
	}
	mmCompact.t.Fatalf("Unexpected call to ClientMock.Compact. %v %v %v", ctx, rev, opts)
	return
}

// CompactAfterCounter returns a count of finished ClientMock.Compact invocations
func (mmCompact *ClientMock) CompactAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompact.afterCompactCounter)
}

// CompactBeforeCounter returns a count of ClientMock.Compact invocations
func (mmCompact *ClientMock) CompactBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmCompact.beforeCompactCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Compact.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmCompact *mClientMockCompact) Calls() []*ClientMockCompactParams {
	mmCompact.mutex.RLock()

	argCopy := make([]*ClientMockCompactParams, len(mmCompact.callArgs))
	copy(argCopy, mmCompact.callArgs)

	mmCompact.mutex.RUnlock()

	return argCopy
}

// MinimockCompactDone returns true if the count of the Compact invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockCompactDone() bool {
	for _, e := range m.CompactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompactMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompact != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		return false
	}
	return true
}

// MinimockCompactInspect logs each unmet expectation
func (m *ClientMock) MinimockCompactInspect() {
	for _, e := range m.CompactMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Compact with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.CompactMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		if m.CompactMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Compact")
		} else {
			m.t.Errorf("Expected call to ClientMock.Compact with params: %#v", *m.CompactMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcCompact != nil && mm_atomic.LoadUint64(&m.afterCompactCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Compact")
	}
}

type mClientMockDefragment struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDefragmentExpectation
	expectations       []*ClientMockDefragmentExpectation

	callArgs []*ClientMockDefragmentParams
	mutex    sync.RWMutex
}

// ClientMockDefragmentExpectation specifies expectation struct of the Client.Defragment
type ClientMockDefragmentExpectation struct {
	mock    *ClientMock
	params  *ClientMockDefragmentParams
	results *ClientMockDefragmentResults
	Counter uint64
}

// ClientMockDefragmentParams contains parameters of the Client.Defragment
type ClientMockDefragmentParams struct {
	ctx      context.Context
	endpoint string
}

// ClientMockDefragmentResults contains results of the Client.Defragment
type ClientMockDefragmentResults struct {
	dp1 *clientv3.DefragmentResponse
	err error
}

// Expect sets up expected params for Client.Defragment
func (mmDefragment *mClientMockDefragment) Expect(ctx context.Context, endpoint string) *mClientMockDefragment {
	if mmDefragment.mock.funcDefragment != nil {
		mmDefragment.mock.t.Fatalf("ClientMock.Defragment mock is already set by Set")
	}

	if mmDefragment.defaultExpectation == nil {
		mmDefragment.defaultExpectation = &ClientMockDefragmentExpectation{}
	}

	mmDefragment.defaultExpectation.params = &ClientMockDefragmentParams{ctx, endpoint}
	for _, e := range mmDefragment.expectations {
		if minimock.Equal(e.params, mmDefragment.defaultExpectation.params) {
			mmDefragment.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDefragment.defaultExpectation.params)
		}
	}

	return mmDefragment
}

// Inspect accepts an inspector function that has same arguments as the Client.Defragment
func (mmDefragment *mClientMockDefragment) Inspect(f func(ctx context.Context, endpoint string)) *mClientMockDefragment {
	if mmDefragment.mock.inspectFuncDefragment != nil {
		mmDefragment.mock.t.Fatalf("Inspect function is already set for ClientMock.Defragment")
	}

	mmDefragment.mock.inspectFuncDefragment = f

	return mmDefragment
}

// Return sets up results that will be returned by Client.Defragment
func (mmDefragment *mClientMockDefragment) Return(dp1 *clientv3.DefragmentResponse, err error) *ClientMock {
	if mmDefragment.mock.funcDefragment != nil {
		mmDefragment.mock.t.Fatalf("ClientMock.Defragment mock is already set by Set")
	}

	if mmDefragment.defaultExpectation == nil {
		mmDefragment.defaultExpectation = &ClientMockDefragmentExpectation{mock: mmDefragment.mock}
	}
	mmDefragment.defaultExpectation.results = &ClientMockDefragmentResults{dp1, err}
	return mmDefragment.mock
}

//Set uses given function f to mock the Client.Defragment method
func (mmDefragment *mClientMockDefragment) Set(f func(ctx context.Context, endpoint string) (dp1 *clientv3.DefragmentResponse, err error)) *ClientMock {
	if mmDefragment.defaultExpectation != nil {
		mmDefragment.mock.t.Fatalf("Default expectation is already set for the Client.Defragment method")
	}

	if len(mmDefragment.expectations) > 0 {
		mmDefragment.mock.t.Fatalf("Some expectations are already set for the Client.Defragment method")
	}

	mmDefragment.mock.funcDefragment = f
	return mmDefragment.mock
}

// When sets expectation for the Client.Defragment which will trigger the result defined by the following
// Then helper
func (mmDefragment *mClientMockDefragment) When(ctx context.Context, endpoint string) *ClientMockDefragmentExpectation {
	if mmDefragment.mock.funcDefragment != nil {
		mmDefragment.mock.t.Fatalf("ClientMock.Defragment mock is already set by Set")
	}

	expectation := &ClientMockDefragmentExpectation{
		mock:   mmDefragment.mock,
		params: &ClientMockDefragmentParams{ctx, endpoint},
	}
	mmDefragment.expectations = append(mmDefragment.expectations, expectation)
	return expectation
}

// Then sets up Client.Defragment return parameters for the expectation previously defined by the When method
func (e *ClientMockDefragmentExpectation) Then(dp1 *clientv3.DefragmentResponse, err error) *ClientMock {
	e.results = &ClientMockDefragmentResults{dp1, err}
	return e.mock
}

// Defragment implements Client
func (mmDefragment *ClientMock) Defragment(ctx context.Context, endpoint string) (dp1 *clientv3.DefragmentResponse, err error) {
	mm_atomic.AddUint64(&mmDefragment.beforeDefragmentCounter, 1)
	defer mm_atomic.AddUint64(&mmDefragment.afterDefragmentCounter, 1)

	if mmDefragment.inspectFuncDefragment != nil {
		mmDefragment.inspectFuncDefragment(ctx, endpoint)
	}

	mm_params := &ClientMockDefragmentParams{ctx, endpoint}

	// Record call args
	mmDefragment.DefragmentMock.mutex.Lock()
	mmDefragment.DefragmentMock.callArgs = append(mmDefragment.DefragmentMock.callArgs, mm_params)
	mmDefragment.DefragmentMock.mutex.Unlock()

	for _, e := range mmDefragment.DefragmentMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDefragment.DefragmentMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDefragment.DefragmentMock.defaultExpectation.Counter, 1)
		mm_want := mmDefragment.DefragmentMock.defaultExpectation.params
		mm_got := ClientMockDefragmentParams{ctx, endpoint}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDefragment.t.Errorf("ClientMock.Defragment got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDefragment.DefragmentMock.defaultExpectation.results
		if mm_results == nil {
			mmDefragment.t.Fatal("No results are set for the ClientMock.Defragment")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDefragment.funcDefragment != nil {
		return mmDefragment.funcDefragment(ctx, endpoint)
	}
	mmDefragment.t.Fatalf("Unexpected call to ClientMock.Defragment. %v %v", ctx, endpoint)
	return
}

// DefragmentAfterCounter returns a count of finished ClientMock.Defragment invocations
func (mmDefragment *ClientMock) DefragmentAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDefragment.afterDefragmentCounter)
}

// DefragmentBeforeCounter returns a count of ClientMock.Defragment invocations
func (mmDefragment *ClientMock) DefragmentBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDefragment.beforeDefragmentCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Defragment.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDefragment *mClientMockDefragment) Calls() []*ClientMockDefragmentParams {
	mmDefragment.mutex.RLock()

	argCopy := make([]*ClientMockDefragmentParams, len(mmDefragment.callArgs))
	copy(argCopy, mmDefragment.callArgs)

	mmDefragment.mutex.RUnlock()

	return argCopy
}

// MinimockDefragmentDone returns true if the count of the Defragment invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDefragmentDone() bool {
	for _, e := range m.DefragmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DefragmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDefragmentCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDefragment != nil && mm_atomic.LoadUint64(&m.afterDefragmentCounter) < 1 {
		return false
	}
	return true
}

// MinimockDefragmentInspect logs each unmet expectation
func (m *ClientMock) MinimockDefragmentInspect() {
	for _, e := range m.DefragmentMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Defragment with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DefragmentMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDefragmentCounter) < 1 {
		if m.DefragmentMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Defragment")
		} else {
			m.t.Errorf("Expected call to ClientMock.Defragment with params: %#v", *m.DefragmentMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDefragment != nil && mm_atomic.LoadUint64(&m.afterDefragmentCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Defragment")
	}
}

type mClientMockDelete struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDeleteExpectation
	expectations       []*ClientMockDeleteExpectation

	callArgs []*ClientMockDeleteParams
	mutex    sync.RWMutex
}

// ClientMockDeleteExpectation specifies expectation struct of the Client.Delete
type ClientMockDeleteExpectation struct {
	mock    *ClientMock
	params  *ClientMockDeleteParams
	results *ClientMockDeleteResults
	Counter uint64
}

// ClientMockDeleteParams contains parameters of the Client.Delete
type ClientMockDeleteParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockDeleteResults contains results of the Client.Delete
type ClientMockDeleteResults struct {
	dp1 *clientv3.DeleteResponse
	err error
}

// Expect sets up expected params for Client.Delete
func (mmDelete *mClientMockDelete) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockDelete {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ClientMockDeleteExpectation{}
	}

	mmDelete.defaultExpectation.params = &ClientMockDeleteParams{ctx, key, opts}
	for _, e := range mmDelete.expectations {
		if minimock.Equal(e.params, mmDelete.defaultExpectation.params) {
			mmDelete.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDelete.defaultExpectation.params)
		}
	}

	return mmDelete
}

// Inspect accepts an inspector function that has same arguments as the Client.Delete
func (mmDelete *mClientMockDelete) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockDelete {
	if mmDelete.mock.inspectFuncDelete != nil {
		mmDelete.mock.t.Fatalf("Inspect function is already set for ClientMock.Delete")
	}

	mmDelete.mock.inspectFuncDelete = f

	return mmDelete
}

// Return sets up results that will be returned by Client.Delete
func (mmDelete *mClientMockDelete) Return(dp1 *clientv3.DeleteResponse, err error) *ClientMock {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	if mmDelete.defaultExpectation == nil {
		mmDelete.defaultExpectation = &ClientMockDeleteExpectation{mock: mmDelete.mock}
	}
	mmDelete.defaultExpectation.results = &ClientMockDeleteResults{dp1, err}
	return mmDelete.mock
}

//Set uses given function f to mock the Client.Delete method
func (mmDelete *mClientMockDelete) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error)) *ClientMock {
	if mmDelete.defaultExpectation != nil {
		mmDelete.mock.t.Fatalf("Default expectation is already set for the Client.Delete method")
	}

	if len(mmDelete.expectations) > 0 {
		mmDelete.mock.t.Fatalf("Some expectations are already set for the Client.Delete method")
	}

	mmDelete.mock.funcDelete = f
	return mmDelete.mock
}

// When sets expectation for the Client.Delete which will trigger the result defined by the following
// Then helper
func (mmDelete *mClientMockDelete) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockDeleteExpectation {
	if mmDelete.mock.funcDelete != nil {
		mmDelete.mock.t.Fatalf("ClientMock.Delete mock is already set by Set")
	}

	expectation := &ClientMockDeleteExpectation{
		mock:   mmDelete.mock,
		params: &ClientMockDeleteParams{ctx, key, opts},
	}
	mmDelete.expectations = append(mmDelete.expectations, expectation)
	return expectation
}

// Then sets up Client.Delete return parameters for the expectation previously defined by the When method
func (e *ClientMockDeleteExpectation) Then(dp1 *clientv3.DeleteResponse, err error) *ClientMock {
	e.results = &ClientMockDeleteResults{dp1, err}
	return e.mock
}

// Delete implements Client
func (mmDelete *ClientMock) Delete(ctx context.Context, key string, opts ...clientv3.OpOption) (dp1 *clientv3.DeleteResponse, err error) {
	mm_atomic.AddUint64(&mmDelete.beforeDeleteCounter, 1)
	defer mm_atomic.AddUint64(&mmDelete.afterDeleteCounter, 1)

	if mmDelete.inspectFuncDelete != nil {
		mmDelete.inspectFuncDelete(ctx, key, opts...)
	}

	mm_params := &ClientMockDeleteParams{ctx, key, opts}

	// Record call args
	mmDelete.DeleteMock.mutex.Lock()
	mmDelete.DeleteMock.callArgs = append(mmDelete.DeleteMock.callArgs, mm_params)
	mmDelete.DeleteMock.mutex.Unlock()

	for _, e := range mmDelete.DeleteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.dp1, e.results.err
		}
	}

	if mmDelete.DeleteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDelete.DeleteMock.defaultExpectation.Counter, 1)
		mm_want := mmDelete.DeleteMock.defaultExpectation.params
		mm_got := ClientMockDeleteParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDelete.t.Errorf("ClientMock.Delete got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDelete.DeleteMock.defaultExpectation.results
		if mm_results == nil {
			mmDelete.t.Fatal("No results are set for the ClientMock.Delete")
		}
		return (*mm_results).dp1, (*mm_results).err
	}
	if mmDelete.funcDelete != nil {
		return mmDelete.funcDelete(ctx, key, opts...)
	}
	mmDelete.t.Fatalf("Unexpected call to ClientMock.Delete. %v %v %v", ctx, key, opts)
	return
}

// DeleteAfterCounter returns a count of finished ClientMock.Delete invocations
func (mmDelete *ClientMock) DeleteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.afterDeleteCounter)
}

// DeleteBeforeCounter returns a count of ClientMock.Delete invocations
func (mmDelete *ClientMock) DeleteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDelete.beforeDeleteCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Delete.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDelete *mClientMockDelete) Calls() []*ClientMockDeleteParams {
	mmDelete.mutex.RLock()

	argCopy := make([]*ClientMockDeleteParams, len(mmDelete.callArgs))
	copy(argCopy, mmDelete.callArgs)

	mmDelete.mutex.RUnlock()

	return argCopy
}

// MinimockDeleteDone returns true if the count of the Delete invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDeleteDone() bool {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		return false
	}
	return true
}

// MinimockDeleteInspect logs each unmet expectation
func (m *ClientMock) MinimockDeleteInspect() {
	for _, e := range m.DeleteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Delete with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DeleteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		if m.DeleteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Delete")
		} else {
			m.t.Errorf("Expected call to ClientMock.Delete with params: %#v", *m.DeleteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDelete != nil && mm_atomic.LoadUint64(&m.afterDeleteCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Delete")
	}
}

type mClientMockDo struct {
	mock               *ClientMock
	defaultExpectation *ClientMockDoExpectation
	expectations       []*ClientMockDoExpectation

	callArgs []*ClientMockDoParams
	mutex    sync.RWMutex
}

// ClientMockDoExpectation specifies expectation struct of the Client.Do
type ClientMockDoExpectation struct {
	mock    *ClientMock
	params  *ClientMockDoParams
	results *ClientMockDoResults
	Counter uint64
}

// ClientMockDoParams contains parameters of the Client.Do
type ClientMockDoParams struct {
	ctx context.Context
	op  clientv3.Op
}

// ClientMockDoResults contains results of the Client.Do
type ClientMockDoResults struct {
	o1  clientv3.OpResponse
	err error
}

// Expect sets up expected params for Client.Do
func (mmDo *mClientMockDo) Expect(ctx context.Context, op clientv3.Op) *mClientMockDo {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &ClientMockDoExpectation{}
	}

	mmDo.defaultExpectation.params = &ClientMockDoParams{ctx, op}
	for _, e := range mmDo.expectations {
		if minimock.Equal(e.params, mmDo.defaultExpectation.params) {
			mmDo.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDo.defaultExpectation.params)
		}
	}

	return mmDo
}

// Inspect accepts an inspector function that has same arguments as the Client.Do
func (mmDo *mClientMockDo) Inspect(f func(ctx context.Context, op clientv3.Op)) *mClientMockDo {
	if mmDo.mock.inspectFuncDo != nil {
		mmDo.mock.t.Fatalf("Inspect function is already set for ClientMock.Do")
	}

	mmDo.mock.inspectFuncDo = f

	return mmDo
}

// Return sets up results that will be returned by Client.Do
func (mmDo *mClientMockDo) Return(o1 clientv3.OpResponse, err error) *ClientMock {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	if mmDo.defaultExpectation == nil {
		mmDo.defaultExpectation = &ClientMockDoExpectation{mock: mmDo.mock}
	}
	mmDo.defaultExpectation.results = &ClientMockDoResults{o1, err}
	return mmDo.mock
}

//Set uses given function f to mock the Client.Do method
func (mmDo *mClientMockDo) Set(f func(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error)) *ClientMock {
	if mmDo.defaultExpectation != nil {
		mmDo.mock.t.Fatalf("Default expectation is already set for the Client.Do method")
	}

	if len(mmDo.expectations) > 0 {
		mmDo.mock.t.Fatalf("Some expectations are already set for the Client.Do method")
	}

	mmDo.mock.funcDo = f
	return mmDo.mock
}

// When sets expectation for the Client.Do which will trigger the result defined by the following
// Then helper
func (mmDo *mClientMockDo) When(ctx context.Context, op clientv3.Op) *ClientMockDoExpectation {
	if mmDo.mock.funcDo != nil {
		mmDo.mock.t.Fatalf("ClientMock.Do mock is already set by Set")
	}

	expectation := &ClientMockDoExpectation{
		mock:   mmDo.mock,
		params: &ClientMockDoParams{ctx, op},
	}
	mmDo.expectations = append(mmDo.expectations, expectation)
	return expectation
}

// Then sets up Client.Do return parameters for the expectation previously defined by the When method
func (e *ClientMockDoExpectation) Then(o1 clientv3.OpResponse, err error) *ClientMock {
	e.results = &ClientMockDoResults{o1, err}
	return e.mock
}

// Do implements Client
func (mmDo *ClientMock) Do(ctx context.Context, op clientv3.Op) (o1 clientv3.OpResponse, err error) {
	mm_atomic.AddUint64(&mmDo.beforeDoCounter, 1)
	defer mm_atomic.AddUint64(&mmDo.afterDoCounter, 1)

	if mmDo.inspectFuncDo != nil {
		mmDo.inspectFuncDo(ctx, op)
	}

	mm_params := &ClientMockDoParams{ctx, op}

	// Record call args
	mmDo.DoMock.mutex.Lock()
	mmDo.DoMock.callArgs = append(mmDo.DoMock.callArgs, mm_params)
	mmDo.DoMock.mutex.Unlock()

	for _, e := range mmDo.DoMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.o1, e.results.err
		}
	}

	if mmDo.DoMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDo.DoMock.defaultExpectation.Counter, 1)
		mm_want := mmDo.DoMock.defaultExpectation.params
		mm_got := ClientMockDoParams{ctx, op}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDo.t.Errorf("ClientMock.Do got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDo.DoMock.defaultExpectation.results
		if mm_results == nil {
			mmDo.t.Fatal("No results are set for the ClientMock.Do")
		}
		return (*mm_results).o1, (*mm_results).err
	}
	if mmDo.funcDo != nil {
		return mmDo.funcDo(ctx, op)
	}
	mmDo.t.Fatalf("Unexpected call to ClientMock.Do. %v %v", ctx, op)
	return
}

// DoAfterCounter returns a count of finished ClientMock.Do invocations
func (mmDo *ClientMock) DoAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDo.afterDoCounter)
}

// DoBeforeCounter returns a count of ClientMock.Do invocations
func (mmDo *ClientMock) DoBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDo.beforeDoCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Do.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDo *mClientMockDo) Calls() []*ClientMockDoParams {
	mmDo.mutex.RLock()

	argCopy := make([]*ClientMockDoParams, len(mmDo.callArgs))
	copy(argCopy, mmDo.callArgs)

	mmDo.mutex.RUnlock()

	return argCopy
}

// MinimockDoDone returns true if the count of the Do invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDoDone() bool {
	for _, e := range m.DoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDo != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		return false
	}
	return true
}

// MinimockDoInspect logs each unmet expectation
func (m *ClientMock) MinimockDoInspect() {
	for _, e := range m.DoMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Do with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.DoMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		if m.DoMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Do")
		} else {
			m.t.Errorf("Expected call to ClientMock.Do with params: %#v", *m.DoMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDo != nil && mm_atomic.LoadUint64(&m.afterDoCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Do")
	}
}

type mClientMockGet struct {
	mock               *ClientMock
	defaultExpectation *ClientMockGetExpectation
	expectations       []*ClientMockGetExpectation

	callArgs []*ClientMockGetParams
	mutex    sync.RWMutex
}

// ClientMockGetExpectation specifies expectation struct of the Client.Get
type ClientMockGetExpectation struct {
	mock    *ClientMock
	params  *ClientMockGetParams
	results *ClientMockGetResults
	Counter uint64
}

// ClientMockGetParams contains parameters of the Client.Get
type ClientMockGetParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockGetResults contains results of the Client.Get
type ClientMockGetResults struct {
	gp1 *clientv3.GetResponse
	err error
}

// Expect sets up expected params for Client.Get
func (mmGet *mClientMockGet) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockGet {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{}
	}

	mmGet.defaultExpectation.params = &ClientMockGetParams{ctx, key, opts}
	for _, e := range mmGet.expectations {
		if minimock.Equal(e.params, mmGet.defaultExpectation.params) {
			mmGet.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmGet.defaultExpectation.params)
		}
	}

	return mmGet
}

// Inspect accepts an inspector function that has same arguments as the Client.Get
func (mmGet *mClientMockGet) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockGet {
	if mmGet.mock.inspectFuncGet != nil {
		mmGet.mock.t.Fatalf("Inspect function is already set for ClientMock.Get")
	}

	mmGet.mock.inspectFuncGet = f

	return mmGet
}

// Return sets up results that will be returned by Client.Get
func (mmGet *mClientMockGet) Return(gp1 *clientv3.GetResponse, err error) *ClientMock {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	if mmGet.defaultExpectation == nil {
		mmGet.defaultExpectation = &ClientMockGetExpectation{mock: mmGet.mock}
	}
	mmGet.defaultExpectation.results = &ClientMockGetResults{gp1, err}
	return mmGet.mock
}

//Set uses given function f to mock the Client.Get method
func (mmGet *mClientMockGet) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error)) *ClientMock {
	if mmGet.defaultExpectation != nil {
		mmGet.mock.t.Fatalf("Default expectation is already set for the Client.Get method")
	}

	if len(mmGet.expectations) > 0 {
		mmGet.mock.t.Fatalf("Some expectations are already set for the Client.Get method")
	}

	mmGet.mock.funcGet = f
	return mmGet.mock
}

// When sets expectation for the Client.Get which will trigger the result defined by the following
// Then helper
func (mmGet *mClientMockGet) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockGetExpectation {
	if mmGet.mock.funcGet != nil {
		mmGet.mock.t.Fatalf("ClientMock.Get mock is already set by Set")
	}

	expectation := &ClientMockGetExpectation{
		mock:   mmGet.mock,
		params: &ClientMockGetParams{ctx, key, opts},
	}
	mmGet.expectations = append(mmGet.expectations, expectation)
	return expectation
}

// Then sets up Client.Get return parameters for the expectation previously defined by the When method
func (e *ClientMockGetExpectation) Then(gp1 *clientv3.GetResponse, err error) *ClientMock {
	e.results = &ClientMockGetResults{gp1, err}
	return e.mock
}

// Get implements Client
func (mmGet *ClientMock) Get(ctx context.Context, key string, opts ...clientv3.OpOption) (gp1 *clientv3.GetResponse, err error) {
	mm_atomic.AddUint64(&mmGet.beforeGetCounter, 1)
	defer mm_atomic.AddUint64(&mmGet.afterGetCounter, 1)

	if mmGet.inspectFuncGet != nil {
		mmGet.inspectFuncGet(ctx, key, opts...)
	}

	mm_params := &ClientMockGetParams{ctx, key, opts}

	// Record call args
	mmGet.GetMock.mutex.Lock()
	mmGet.GetMock.callArgs = append(mmGet.GetMock.callArgs, mm_params)
	mmGet.GetMock.mutex.Unlock()

	for _, e := range mmGet.GetMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.gp1, e.results.err
		}
	}

	if mmGet.GetMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGet.GetMock.defaultExpectation.Counter, 1)
		mm_want := mmGet.GetMock.defaultExpectation.params
		mm_got := ClientMockGetParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmGet.t.Errorf("ClientMock.Get got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmGet.GetMock.defaultExpectation.results
		if mm_results == nil {
			mmGet.t.Fatal("No results are set for the ClientMock.Get")
		}
		return (*mm_results).gp1, (*mm_results).err
	}
	if mmGet.funcGet != nil {
		return mmGet.funcGet(ctx, key, opts...)
	}
	mmGet.t.Fatalf("Unexpected call to ClientMock.Get. %v %v %v", ctx, key, opts)
	return
}

// GetAfterCounter returns a count of finished ClientMock.Get invocations
func (mmGet *ClientMock) GetAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.afterGetCounter)
}

// GetBeforeCounter returns a count of ClientMock.Get invocations
func (mmGet *ClientMock) GetBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGet.beforeGetCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Get.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmGet *mClientMockGet) Calls() []*ClientMockGetParams {
	mmGet.mutex.RLock()

	argCopy := make([]*ClientMockGetParams, len(mmGet.callArgs))
	copy(argCopy, mmGet.callArgs)

	mmGet.mutex.RUnlock()

	return argCopy
}

// MinimockGetDone returns true if the count of the Get invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockGetDone() bool {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		return false
	}
	return true
}

// MinimockGetInspect logs each unmet expectation
func (m *ClientMock) MinimockGetInspect() {
	for _, e := range m.GetMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Get with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.GetMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		if m.GetMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Get")
		} else {
			m.t.Errorf("Expected call to ClientMock.Get with params: %#v", *m.GetMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGet != nil && mm_atomic.LoadUint64(&m.afterGetCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Get")
	}
}

type mClientMockHashKV struct {
	mock               *ClientMock
	defaultExpectation *ClientMockHashKVExpectation
	expectations       []*ClientMockHashKVExpectation

	callArgs []*ClientMockHashKVParams
	mutex    sync.RWMutex
}

// ClientMockHashKVExpectation specifies expectation struct of the Client.HashKV
type ClientMockHashKVExpectation struct {
	mock    *ClientMock
	params  *ClientMockHashKVParams
	results *ClientMockHashKVResults
	Counter uint64
}

// ClientMockHashKVParams contains parameters of the Client.HashKV
type ClientMockHashKVParams struct {
	ctx      context.Context
	endpoint string
	rev      int64
}

// ClientMockHashKVResults contains results of the Client.HashKV
type ClientMockHashKVResults struct {
	hp1 *clientv3.HashKVResponse
	err error
}

// Expect sets up expected params for Client.HashKV
func (mmHashKV *mClientMockHashKV) Expect(ctx context.Context, endpoint string, rev int64) *mClientMockHashKV {
	if mmHashKV.mock.funcHashKV != nil {
		mmHashKV.mock.t.Fatalf("ClientMock.HashKV mock is already set by Set")
	}

	if mmHashKV.defaultExpectation == nil {
		mmHashKV.defaultExpectation = &ClientMockHashKVExpectation{}
	}

	mmHashKV.defaultExpectation.params = &ClientMockHashKVParams{ctx, endpoint, rev}
	for _, e := range mmHashKV.expectations {
		if minimock.Equal(e.params, mmHashKV.defaultExpectation.params) {
			mmHashKV.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmHashKV.defaultExpectation.params)
		}
	}

	return mmHashKV
}

// Inspect accepts an inspector function that has same arguments as the Client.HashKV
func (mmHashKV *mClientMockHashKV) Inspect(f func(ctx context.Context, endpoint string, rev int64)) *mClientMockHashKV {
	if mmHashKV.mock.inspectFuncHashKV != nil {
		mmHashKV.mock.t.Fatalf("Inspect function is already set for ClientMock.HashKV")
	}

	mmHashKV.mock.inspectFuncHashKV = f

	return mmHashKV
}

// Return sets up results that will be returned by Client.HashKV
func (mmHashKV *mClientMockHashKV) Return(hp1 *clientv3.HashKVResponse, err error) *ClientMock {
	if mmHashKV.mock.funcHashKV != nil {
		mmHashKV.mock.t.Fatalf("ClientMock.HashKV mock is already set by Set")
	}

	if mmHashKV.defaultExpectation == nil {
		mmHashKV.defaultExpectation = &ClientMockHashKVExpectation{mock: mmHashKV.mock}
	}
	mmHashKV.defaultExpectation.results = &ClientMockHashKVResults{hp1, err}
	return mmHashKV.mock
}

//Set uses given function f to mock the Client.HashKV method
func (mmHashKV *mClientMockHashKV) Set(f func(ctx context.Context, endpoint string, rev int64) (hp1 *clientv3.HashKVResponse, err error)) *ClientMock {
	if mmHashKV.defaultExpectation != nil {
		mmHashKV.mock.t.Fatalf("Default expectation is already set for the Client.HashKV method")
	}

	if len(mmHashKV.expectations) > 0 {
		mmHashKV.mock.t.Fatalf("Some expectations are already set for the Client.HashKV method")
	}

	mmHashKV.mock.funcHashKV = f
	return mmHashKV.mock
}

// When sets expectation for the Client.HashKV which will trigger the result defined by the following
// Then helper
func (mmHashKV *mClientMockHashKV) When(ctx context.Context, endpoint string, rev int64) *ClientMockHashKVExpectation {
	if mmHashKV.mock.funcHashKV != nil {
		mmHashKV.mock.t.Fatalf("ClientMock.HashKV mock is already set by Set")
	}

	expectation := &ClientMockHashKVExpectation{
		mock:   mmHashKV.mock,
		params: &ClientMockHashKVParams{ctx, endpoint, rev},
	}
	mmHashKV.expectations = append(mmHashKV.expectations, expectation)
	return expectation
}

// Then sets up Client.HashKV return parameters for the expectation previously defined by the When method
func (e *ClientMockHashKVExpectation) Then(hp1 *clientv3.HashKVResponse, err error) *ClientMock {
	e.results = &ClientMockHashKVResults{hp1, err}
	return e.mock
}

// HashKV implements Client
func (mmHashKV *ClientMock) HashKV(ctx context.Context, endpoint string, rev int64) (hp1 *clientv3.HashKVResponse, err error) {
	mm_atomic.AddUint64(&mmHashKV.beforeHashKVCounter, 1)
	defer mm_atomic.AddUint64(&mmHashKV.afterHashKVCounter, 1)

	if mmHashKV.inspectFuncHashKV != nil {
		mmHashKV.inspectFuncHashKV(ctx, endpoint, rev)
	}

	mm_params := &ClientMockHashKVParams{ctx, endpoint, rev}

	// Record call args
	mmHashKV.HashKVMock.mutex.Lock()
	mmHashKV.HashKVMock.callArgs = append(mmHashKV.HashKVMock.callArgs, mm_params)
	mmHashKV.HashKVMock.mutex.Unlock()

	for _, e := range mmHashKV.HashKVMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.hp1, e.results.err
		}
	}

	if mmHashKV.HashKVMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmHashKV.HashKVMock.defaultExpectation.Counter, 1)
		mm_want := mmHashKV.HashKVMock.defaultExpectation.params
		mm_got := ClientMockHashKVParams{ctx, endpoint, rev}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmHashKV.t.Errorf("ClientMock.HashKV got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmHashKV.HashKVMock.defaultExpectation.results
		if mm_results == nil {
			mmHashKV.t.Fatal("No results are set for the ClientMock.HashKV")
		}
		return (*mm_results).hp1, (*mm_results).err
	}
	if mmHashKV.funcHashKV != nil {
		return mmHashKV.funcHashKV(ctx, endpoint, rev)
	}
	mmHashKV.t.Fatalf("Unexpected call to ClientMock.HashKV. %v %v %v", ctx, endpoint, rev)
	return
}

// HashKVAfterCounter returns a count of finished ClientMock.HashKV invocations
func (mmHashKV *ClientMock) HashKVAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashKV.afterHashKVCounter)
}

// HashKVBeforeCounter returns a count of ClientMock.HashKV invocations
func (mmHashKV *ClientMock) HashKVBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmHashKV.beforeHashKVCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.HashKV.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmHashKV *mClientMockHashKV) Calls() []*ClientMockHashKVParams {
	mmHashKV.mutex.RLock()

	argCopy := make([]*ClientMockHashKVParams, len(mmHashKV.callArgs))
	copy(argCopy, mmHashKV.callArgs)

	mmHashKV.mutex.RUnlock()

	return argCopy
}

// MinimockHashKVDone returns true if the count of the HashKV invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockHashKVDone() bool {
	for _, e := range m.HashKVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HashKVMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHashKVCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHashKV != nil && mm_atomic.LoadUint64(&m.afterHashKVCounter) < 1 {
		return false
	}
	return true
}

// MinimockHashKVInspect logs each unmet expectation
func (m *ClientMock) MinimockHashKVInspect() {
	for _, e := range m.HashKVMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.HashKV with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.HashKVMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterHashKVCounter) < 1 {
		if m.HashKVMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.HashKV")
		} else {
			m.t.Errorf("Expected call to ClientMock.HashKV with params: %#v", *m.HashKVMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcHashKV != nil && mm_atomic.LoadUint64(&m.afterHashKVCounter) < 1 {
		m.t.Error("Expected call to ClientMock.HashKV")
	}
}

type mClientMockMemberAdd struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberAddExpectation
	expectations       []*ClientMockMemberAddExpectation

	callArgs []*ClientMockMemberAddParams
	mutex    sync.RWMutex
}

// ClientMockMemberAddExpectation specifies expectation struct of the Client.MemberAdd
type ClientMockMemberAddExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberAddParams
	results *ClientMockMemberAddResults
	Counter uint64
}

// ClientMockMemberAddParams contains parameters of the Client.MemberAdd
type ClientMockMemberAddParams struct {
	ctx       context.Context
	peerAddrs []string
}

// ClientMockMemberAddResults contains results of the Client.MemberAdd
type ClientMockMemberAddResults struct {
	mp1 *clientv3.MemberAddResponse
	err error
}

// Expect sets up expected params for Client.MemberAdd
func (mmMemberAdd *mClientMockMemberAdd) Expect(ctx context.Context, peerAddrs []string) *mClientMockMemberAdd {
	if mmMemberAdd.mock.funcMemberAdd != nil {
		mmMemberAdd.mock.t.Fatalf("ClientMock.MemberAdd mock is already set by Set")
	}

	if mmMemberAdd.defaultExpectation == nil {
		mmMemberAdd.defaultExpectation = &ClientMockMemberAddExpectation{}
	}

	mmMemberAdd.defaultExpectation.params = &ClientMockMemberAddParams{ctx, peerAddrs}
	for _, e := range mmMemberAdd.expectations {
		if minimock.Equal(e.params, mmMemberAdd.defaultExpectation.params) {
			mmMemberAdd.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberAdd.defaultExpectation.params)
		}
	}

	return mmMemberAdd
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberAdd
func (mmMemberAdd *mClientMockMemberAdd) Inspect(f func(ctx context.Context, peerAddrs []string)) *mClientMockMemberAdd {
	if mmMemberAdd.mock.inspectFuncMemberAdd != nil {
		mmMemberAdd.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberAdd")
	}

	mmMemberAdd.mock.inspectFuncMemberAdd = f

	return mmMemberAdd
}

// Return sets up results that will be returned by Client.MemberAdd
func (mmMemberAdd *mClientMockMemberAdd) Return(mp1 *clientv3.MemberAddResponse, err error) *ClientMock {
	if mmMemberAdd.mock.funcMemberAdd != nil {
		mmMemberAdd.mock.t.Fatalf("ClientMock.MemberAdd mock is already set by Set")
	}

	if mmMemberAdd.defaultExpectation == nil {
		mmMemberAdd.defaultExpectation = &ClientMockMemberAddExpectation{mock: mmMemberAdd.mock}
	}
	mmMemberAdd.defaultExpectation.results = &ClientMockMemberAddResults{mp1, err}
	return mmMemberAdd.mock
}

//Set uses given function f to mock the Client.MemberAdd method
func (mmMemberAdd *mClientMockMemberAdd) Set(f func(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error)) *ClientMock {
	if mmMemberAdd.defaultExpectation != nil {
		mmMemberAdd.mock.t.Fatalf("Default expectation is already set for the Client.MemberAdd method")
	}

	if len(mmMemberAdd.expectations) > 0 {
		mmMemberAdd.mock.t.Fatalf("Some expectations are already set for the Client.MemberAdd method")
	}

	mmMemberAdd.mock.funcMemberAdd = f
	return mmMemberAdd.mock
}

// When sets expectation for the Client.MemberAdd which will trigger the result defined by the following
// Then helper
func (mmMemberAdd *mClientMockMemberAdd) When(ctx context.Context, peerAddrs []string) *ClientMockMemberAddExpectation {
	if mmMemberAdd.mock.funcMemberAdd != nil {
		mmMemberAdd.mock.t.Fatalf("ClientMock.MemberAdd mock is already set by Set")
	}

	expectation := &ClientMockMemberAddExpectation{
		mock:   mmMemberAdd.mock,
		params: &ClientMockMemberAddParams{ctx, peerAddrs},
	}
	mmMemberAdd.expectations = append(mmMemberAdd.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberAdd return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberAddExpectation) Then(mp1 *clientv3.MemberAddResponse, err error) *ClientMock {
	e.results = &ClientMockMemberAddResults{mp1, err}
	return e.mock
}

// MemberAdd implements Client
func (mmMemberAdd *ClientMock) MemberAdd(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error) {
	mm_atomic.AddUint64(&mmMemberAdd.beforeMemberAddCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberAdd.afterMemberAddCounter, 1)

	if mmMemberAdd.inspectFuncMemberAdd != nil {
		mmMemberAdd.inspectFuncMemberAdd(ctx, peerAddrs)
	}

	mm_params := &ClientMockMemberAddParams{ctx, peerAddrs}

	// Record call args
	mmMemberAdd.MemberAddMock.mutex.Lock()
	mmMemberAdd.MemberAddMock.callArgs = append(mmMemberAdd.MemberAddMock.callArgs, mm_params)
	mmMemberAdd.MemberAddMock.mutex.Unlock()

	for _, e := range mmMemberAdd.MemberAddMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberAdd.MemberAddMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberAdd.MemberAddMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberAdd.MemberAddMock.defaultExpectation.params
		mm_got := ClientMockMemberAddParams{ctx, peerAddrs}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberAdd.t.Errorf("ClientMock.MemberAdd got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberAdd.MemberAddMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberAdd.t.Fatal("No results are set for the ClientMock.MemberAdd")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberAdd.funcMemberAdd != nil {
		return mmMemberAdd.funcMemberAdd(ctx, peerAddrs)
	}
	mmMemberAdd.t.Fatalf("Unexpected call to ClientMock.MemberAdd. %v %v", ctx, peerAddrs)
	return
}

// MemberAddAfterCounter returns a count of finished ClientMock.MemberAdd invocations
func (mmMemberAdd *ClientMock) MemberAddAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberAdd.afterMemberAddCounter)
}

// MemberAddBeforeCounter returns a count of ClientMock.MemberAdd invocations
func (mmMemberAdd *ClientMock) MemberAddBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberAdd.beforeMemberAddCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberAdd.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberAdd *mClientMockMemberAdd) Calls() []*ClientMockMemberAddParams {
	mmMemberAdd.mutex.RLock()

	argCopy := make([]*ClientMockMemberAddParams, len(mmMemberAdd.callArgs))
	copy(argCopy, mmMemberAdd.callArgs)

	mmMemberAdd.mutex.RUnlock()

	return argCopy
}

// MinimockMemberAddDone returns true if the count of the MemberAdd invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberAddDone() bool {
	for _, e := range m.MemberAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberAddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberAddCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberAdd != nil && mm_atomic.LoadUint64(&m.afterMemberAddCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberAddInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberAddInspect() {
	for _, e := range m.MemberAddMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberAdd with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberAddMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberAddCounter) < 1 {
		if m.MemberAddMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberAdd")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberAdd with params: %#v", *m.MemberAddMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberAdd != nil && mm_atomic.LoadUint64(&m.afterMemberAddCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberAdd")
	}
}

type mClientMockMemberAddAsLearner struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberAddAsLearnerExpectation
	expectations       []*ClientMockMemberAddAsLearnerExpectation

	callArgs []*ClientMockMemberAddAsLearnerParams
	mutex    sync.RWMutex
}

// ClientMockMemberAddAsLearnerExpectation specifies expectation struct of the Client.MemberAddAsLearner
type ClientMockMemberAddAsLearnerExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberAddAsLearnerParams
	results *ClientMockMemberAddAsLearnerResults
	Counter uint64
}

// ClientMockMemberAddAsLearnerParams contains parameters of the Client.MemberAddAsLearner
type ClientMockMemberAddAsLearnerParams struct {
	ctx       context.Context
	peerAddrs []string
}

// ClientMockMemberAddAsLearnerResults contains results of the Client.MemberAddAsLearner
type ClientMockMemberAddAsLearnerResults struct {
	mp1 *clientv3.MemberAddResponse
	err error
}

// Expect sets up expected params for Client.MemberAddAsLearner
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Expect(ctx context.Context, peerAddrs []string) *mClientMockMemberAddAsLearner {
	if mmMemberAddAsLearner.mock.funcMemberAddAsLearner != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("ClientMock.MemberAddAsLearner mock is already set by Set")
	}

	if mmMemberAddAsLearner.defaultExpectation == nil {
		mmMemberAddAsLearner.defaultExpectation = &ClientMockMemberAddAsLearnerExpectation{}
	}

	mmMemberAddAsLearner.defaultExpectation.params = &ClientMockMemberAddAsLearnerParams{ctx, peerAddrs}
	for _, e := range mmMemberAddAsLearner.expectations {
		if minimock.Equal(e.params, mmMemberAddAsLearner.defaultExpectation.params) {
			mmMemberAddAsLearner.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberAddAsLearner.defaultExpectation.params)
		}
	}

	return mmMemberAddAsLearner
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberAddAsLearner
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Inspect(f func(ctx context.Context, peerAddrs []string)) *mClientMockMemberAddAsLearner {
	if mmMemberAddAsLearner.mock.inspectFuncMemberAddAsLearner != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberAddAsLearner")
	}

	mmMemberAddAsLearner.mock.inspectFuncMemberAddAsLearner = f

	return mmMemberAddAsLearner
}

// Return sets up results that will be returned by Client.MemberAddAsLearner
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Return(mp1 *clientv3.MemberAddResponse, err error) *ClientMock {
	if mmMemberAddAsLearner.mock.funcMemberAddAsLearner != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("ClientMock.MemberAddAsLearner mock is already set by Set")
	}

	if mmMemberAddAsLearner.defaultExpectation == nil {
		mmMemberAddAsLearner.defaultExpectation = &ClientMockMemberAddAsLearnerExpectation{mock: mmMemberAddAsLearner.mock}
	}
	mmMemberAddAsLearner.defaultExpectation.results = &ClientMockMemberAddAsLearnerResults{mp1, err}
	return mmMemberAddAsLearner.mock
}

//Set uses given function f to mock the Client.MemberAddAsLearner method
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Set(f func(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error)) *ClientMock {
	if mmMemberAddAsLearner.defaultExpectation != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("Default expectation is already set for the Client.MemberAddAsLearner method")
	}

	if len(mmMemberAddAsLearner.expectations) > 0 {
		mmMemberAddAsLearner.mock.t.Fatalf("Some expectations are already set for the Client.MemberAddAsLearner method")
	}

	mmMemberAddAsLearner.mock.funcMemberAddAsLearner = f
	return mmMemberAddAsLearner.mock
}

// When sets expectation for the Client.MemberAddAsLearner which will trigger the result defined by the following
// Then helper
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) When(ctx context.Context, peerAddrs []string) *ClientMockMemberAddAsLearnerExpectation {
	if mmMemberAddAsLearner.mock.funcMemberAddAsLearner != nil {
		mmMemberAddAsLearner.mock.t.Fatalf("ClientMock.MemberAddAsLearner mock is already set by Set")
	}

	expectation := &ClientMockMemberAddAsLearnerExpectation{
		mock:   mmMemberAddAsLearner.mock,
		params: &ClientMockMemberAddAsLearnerParams{ctx, peerAddrs},
	}
	mmMemberAddAsLearner.expectations = append(mmMemberAddAsLearner.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberAddAsLearner return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberAddAsLearnerExpectation) Then(mp1 *clientv3.MemberAddResponse, err error) *ClientMock {
	e.results = &ClientMockMemberAddAsLearnerResults{mp1, err}
	return e.mock
}

// MemberAddAsLearner implements Client
func (mmMemberAddAsLearner *ClientMock) MemberAddAsLearner(ctx context.Context, peerAddrs []string) (mp1 *clientv3.MemberAddResponse, err error) {
	mm_atomic.AddUint64(&mmMemberAddAsLearner.beforeMemberAddAsLearnerCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberAddAsLearner.afterMemberAddAsLearnerCounter, 1)

	if mmMemberAddAsLearner.inspectFuncMemberAddAsLearner != nil {
		mmMemberAddAsLearner.inspectFuncMemberAddAsLearner(ctx, peerAddrs)
	}

	mm_params := &ClientMockMemberAddAsLearnerParams{ctx, peerAddrs}

	// Record call args
	mmMemberAddAsLearner.MemberAddAsLearnerMock.mutex.Lock()
	mmMemberAddAsLearner.MemberAddAsLearnerMock.callArgs = append(mmMemberAddAsLearner.MemberAddAsLearnerMock.callArgs, mm_params)
	mmMemberAddAsLearner.MemberAddAsLearnerMock.mutex.Unlock()

	for _, e := range mmMemberAddAsLearner.MemberAddAsLearnerMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberAddAsLearner.MemberAddAsLearnerMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberAddAsLearner.MemberAddAsLearnerMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberAddAsLearner.MemberAddAsLearnerMock.defaultExpectation.params
		mm_got := ClientMockMemberAddAsLearnerParams{ctx, peerAddrs}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberAddAsLearner.t.Errorf("ClientMock.MemberAddAsLearner got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberAddAsLearner.MemberAddAsLearnerMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberAddAsLearner.t.Fatal("No results are set for the ClientMock.MemberAddAsLearner")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberAddAsLearner.funcMemberAddAsLearner != nil {
		return mmMemberAddAsLearner.funcMemberAddAsLearner(ctx, peerAddrs)
	}
	mmMemberAddAsLearner.t.Fatalf("Unexpected call to ClientMock.MemberAddAsLearner. %v %v", ctx, peerAddrs)
	return
}

// MemberAddAsLearnerAfterCounter returns a count of finished ClientMock.MemberAddAsLearner invocations
func (mmMemberAddAsLearner *ClientMock) MemberAddAsLearnerAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberAddAsLearner.afterMemberAddAsLearnerCounter)
}

// MemberAddAsLearnerBeforeCounter returns a count of ClientMock.MemberAddAsLearner invocations
func (mmMemberAddAsLearner *ClientMock) MemberAddAsLearnerBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberAddAsLearner.beforeMemberAddAsLearnerCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberAddAsLearner.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberAddAsLearner *mClientMockMemberAddAsLearner) Calls() []*ClientMockMemberAddAsLearnerParams {
	mmMemberAddAsLearner.mutex.RLock()

	argCopy := make([]*ClientMockMemberAddAsLearnerParams, len(mmMemberAddAsLearner.callArgs))
	copy(argCopy, mmMemberAddAsLearner.callArgs)

	mmMemberAddAsLearner.mutex.RUnlock()

	return argCopy
}

// MinimockMemberAddAsLearnerDone returns true if the count of the MemberAddAsLearner invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberAddAsLearnerDone() bool {
	for _, e := range m.MemberAddAsLearnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberAddAsLearnerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberAddAsLearnerCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberAddAsLearner != nil && mm_atomic.LoadUint64(&m.afterMemberAddAsLearnerCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberAddAsLearnerInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberAddAsLearnerInspect() {
	for _, e := range m.MemberAddAsLearnerMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberAddAsLearner with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberAddAsLearnerMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberAddAsLearnerCounter) < 1 {
		if m.MemberAddAsLearnerMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberAddAsLearner")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberAddAsLearner with params: %#v", *m.MemberAddAsLearnerMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberAddAsLearner != nil && mm_atomic.LoadUint64(&m.afterMemberAddAsLearnerCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberAddAsLearner")
	}
}

type mClientMockMemberList struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberListExpectation
	expectations       []*ClientMockMemberListExpectation

	callArgs []*ClientMockMemberListParams
	mutex    sync.RWMutex
}

// ClientMockMemberListExpectation specifies expectation struct of the Client.MemberList
type ClientMockMemberListExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberListParams
	results *ClientMockMemberListResults
	Counter uint64
}

// ClientMockMemberListParams contains parameters of the Client.MemberList
type ClientMockMemberListParams struct {
	ctx context.Context
}

// ClientMockMemberListResults contains results of the Client.MemberList
type ClientMockMemberListResults struct {
	mp1 *clientv3.MemberListResponse
	err error
}

// Expect sets up expected params for Client.MemberList
func (mmMemberList *mClientMockMemberList) Expect(ctx context.Context) *mClientMockMemberList {
	if mmMemberList.mock.funcMemberList != nil {
		mmMemberList.mock.t.Fatalf("ClientMock.MemberList mock is already set by Set")
	}

	if mmMemberList.defaultExpectation == nil {
		mmMemberList.defaultExpectation = &ClientMockMemberListExpectation{}
	}

	mmMemberList.defaultExpectation.params = &ClientMockMemberListParams{ctx}
	for _, e := range mmMemberList.expectations {
		if minimock.Equal(e.params, mmMemberList.defaultExpectation.params) {
			mmMemberList.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberList.defaultExpectation.params)
		}
	}

	return mmMemberList
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberList
func (mmMemberList *mClientMockMemberList) Inspect(f func(ctx context.Context)) *mClientMockMemberList {
	if mmMemberList.mock.inspectFuncMemberList != nil {
		mmMemberList.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberList")
	}

	mmMemberList.mock.inspectFuncMemberList = f

	return mmMemberList
}

// Return sets up results that will be returned by Client.MemberList
func (mmMemberList *mClientMockMemberList) Return(mp1 *clientv3.MemberListResponse, err error) *ClientMock {
	if mmMemberList.mock.funcMemberList != nil {
		mmMemberList.mock.t.Fatalf("ClientMock.MemberList mock is already set by Set")
	}

	if mmMemberList.defaultExpectation == nil {
		mmMemberList.defaultExpectation = &ClientMockMemberListExpectation{mock: mmMemberList.mock}
	}
	mmMemberList.defaultExpectation.results = &ClientMockMemberListResults{mp1, err}
	return mmMemberList.mock
}

//Set uses given function f to mock the Client.MemberList method
func (mmMemberList *mClientMockMemberList) Set(f func(ctx context.Context) (mp1 *clientv3.MemberListResponse, err error)) *ClientMock {
	if mmMemberList.defaultExpectation != nil {
		mmMemberList.mock.t.Fatalf("Default expectation is already set for the Client.MemberList method")
	}

	if len(mmMemberList.expectations) > 0 {
		mmMemberList.mock.t.Fatalf("Some expectations are already set for the Client.MemberList method")
	}

	mmMemberList.mock.funcMemberList = f
	return mmMemberList.mock
}

// When sets expectation for the Client.MemberList which will trigger the result defined by the following
// Then helper
func (mmMemberList *mClientMockMemberList) When(ctx context.Context) *ClientMockMemberListExpectation {
	if mmMemberList.mock.funcMemberList != nil {
		mmMemberList.mock.t.Fatalf("ClientMock.MemberList mock is already set by Set")
	}

	expectation := &ClientMockMemberListExpectation{
		mock:   mmMemberList.mock,
		params: &ClientMockMemberListParams{ctx},
	}
	mmMemberList.expectations = append(mmMemberList.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberList return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberListExpectation) Then(mp1 *clientv3.MemberListResponse, err error) *ClientMock {
	e.results = &ClientMockMemberListResults{mp1, err}
	return e.mock
}

// MemberList implements Client
func (mmMemberList *ClientMock) MemberList(ctx context.Context) (mp1 *clientv3.MemberListResponse, err error) {
	mm_atomic.AddUint64(&mmMemberList.beforeMemberListCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberList.afterMemberListCounter, 1)

	if mmMemberList.inspectFuncMemberList != nil {
		mmMemberList.inspectFuncMemberList(ctx)
	}

	mm_params := &ClientMockMemberListParams{ctx}

	// Record call args
	mmMemberList.MemberListMock.mutex.Lock()
	mmMemberList.MemberListMock.callArgs = append(mmMemberList.MemberListMock.callArgs, mm_params)
	mmMemberList.MemberListMock.mutex.Unlock()

	for _, e := range mmMemberList.MemberListMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberList.MemberListMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberList.MemberListMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberList.MemberListMock.defaultExpectation.params
		mm_got := ClientMockMemberListParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberList.t.Errorf("ClientMock.MemberList got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberList.MemberListMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberList.t.Fatal("No results are set for the ClientMock.MemberList")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberList.funcMemberList != nil {
		return mmMemberList.funcMemberList(ctx)
	}
	mmMemberList.t.Fatalf("Unexpected call to ClientMock.MemberList. %v", ctx)
	return
}

// MemberListAfterCounter returns a count of finished ClientMock.MemberList invocations
func (mmMemberList *ClientMock) MemberListAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberList.afterMemberListCounter)
}

// MemberListBeforeCounter returns a count of ClientMock.MemberList invocations
func (mmMemberList *ClientMock) MemberListBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberList.beforeMemberListCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberList.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberList *mClientMockMemberList) Calls() []*ClientMockMemberListParams {
	mmMemberList.mutex.RLock()

	argCopy := make([]*ClientMockMemberListParams, len(mmMemberList.callArgs))
	copy(argCopy, mmMemberList.callArgs)

	mmMemberList.mutex.RUnlock()

	return argCopy
}

// MinimockMemberListDone returns true if the count of the MemberList invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberListDone() bool {
	for _, e := range m.MemberListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberListCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberList != nil && mm_atomic.LoadUint64(&m.afterMemberListCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberListInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberListInspect() {
	for _, e := range m.MemberListMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberList with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberListMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberListCounter) < 1 {
		if m.MemberListMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberList")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberList with params: %#v", *m.MemberListMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberList != nil && mm_atomic.LoadUint64(&m.afterMemberListCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberList")
	}
}

type mClientMockMemberPromote struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberPromoteExpectation
	expectations       []*ClientMockMemberPromoteExpectation

	callArgs []*ClientMockMemberPromoteParams
	mutex    sync.RWMutex
}

// ClientMockMemberPromoteExpectation specifies expectation struct of the Client.MemberPromote
type ClientMockMemberPromoteExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberPromoteParams
	results *ClientMockMemberPromoteResults
	Counter uint64
}

// ClientMockMemberPromoteParams contains parameters of the Client.MemberPromote
type ClientMockMemberPromoteParams struct {
	ctx context.Context
	id  uint64
}

// ClientMockMemberPromoteResults contains results of the Client.MemberPromote
type ClientMockMemberPromoteResults struct {
	mp1 *clientv3.MemberPromoteResponse
	err error
}

// Expect sets up expected params for Client.MemberPromote
func (mmMemberPromote *mClientMockMemberPromote) Expect(ctx context.Context, id uint64) *mClientMockMemberPromote {
	if mmMemberPromote.mock.funcMemberPromote != nil {
		mmMemberPromote.mock.t.Fatalf("ClientMock.MemberPromote mock is already set by Set")
	}

	if mmMemberPromote.defaultExpectation == nil {
		mmMemberPromote.defaultExpectation = &ClientMockMemberPromoteExpectation{}
	}

	mmMemberPromote.defaultExpectation.params = &ClientMockMemberPromoteParams{ctx, id}
	for _, e := range mmMemberPromote.expectations {
		if minimock.Equal(e.params, mmMemberPromote.defaultExpectation.params) {
			mmMemberPromote.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberPromote.defaultExpectation.params)
		}
	}

	return mmMemberPromote
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberPromote
func (mmMemberPromote *mClientMockMemberPromote) Inspect(f func(ctx context.Context, id uint64)) *mClientMockMemberPromote {
	if mmMemberPromote.mock.inspectFuncMemberPromote != nil {
		mmMemberPromote.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberPromote")
	}

	mmMemberPromote.mock.inspectFuncMemberPromote = f

	return mmMemberPromote
}

// Return sets up results that will be returned by Client.MemberPromote
func (mmMemberPromote *mClientMockMemberPromote) Return(mp1 *clientv3.MemberPromoteResponse, err error) *ClientMock {
	if mmMemberPromote.mock.funcMemberPromote != nil {
		mmMemberPromote.mock.t.Fatalf("ClientMock.MemberPromote mock is already set by Set")
	}

	if mmMemberPromote.defaultExpectation == nil {
		mmMemberPromote.defaultExpectation = &ClientMockMemberPromoteExpectation{mock: mmMemberPromote.mock}
	}
	mmMemberPromote.defaultExpectation.results = &ClientMockMemberPromoteResults{mp1, err}
	return mmMemberPromote.mock
}

//Set uses given function f to mock the Client.MemberPromote method
func (mmMemberPromote *mClientMockMemberPromote) Set(f func(ctx context.Context, id uint64) (mp1 *clientv3.MemberPromoteResponse, err error)) *ClientMock {
	if mmMemberPromote.defaultExpectation != nil {
		mmMemberPromote.mock.t.Fatalf("Default expectation is already set for the Client.MemberPromote method")
	}

	if len(mmMemberPromote.expectations) > 0 {
		mmMemberPromote.mock.t.Fatalf("Some expectations are already set for the Client.MemberPromote method")
	}

	mmMemberPromote.mock.funcMemberPromote = f
	return mmMemberPromote.mock
}

// When sets expectation for the Client.MemberPromote which will trigger the result defined by the following
// Then helper
func (mmMemberPromote *mClientMockMemberPromote) When(ctx context.Context, id uint64) *ClientMockMemberPromoteExpectation {
	if mmMemberPromote.mock.funcMemberPromote != nil {
		mmMemberPromote.mock.t.Fatalf("ClientMock.MemberPromote mock is already set by Set")
	}

	expectation := &ClientMockMemberPromoteExpectation{
		mock:   mmMemberPromote.mock,
		params: &ClientMockMemberPromoteParams{ctx, id},
	}
	mmMemberPromote.expectations = append(mmMemberPromote.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberPromote return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberPromoteExpectation) Then(mp1 *clientv3.MemberPromoteResponse, err error) *ClientMock {
	e.results = &ClientMockMemberPromoteResults{mp1, err}
	return e.mock
}

// MemberPromote implements Client
func (mmMemberPromote *ClientMock) MemberPromote(ctx context.Context, id uint64) (mp1 *clientv3.MemberPromoteResponse, err error) {
	mm_atomic.AddUint64(&mmMemberPromote.beforeMemberPromoteCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberPromote.afterMemberPromoteCounter, 1)

	if mmMemberPromote.inspectFuncMemberPromote != nil {
		mmMemberPromote.inspectFuncMemberPromote(ctx, id)
	}

	mm_params := &ClientMockMemberPromoteParams{ctx, id}

	// Record call args
	mmMemberPromote.MemberPromoteMock.mutex.Lock()
	mmMemberPromote.MemberPromoteMock.callArgs = append(mmMemberPromote.MemberPromoteMock.callArgs, mm_params)
	mmMemberPromote.MemberPromoteMock.mutex.Unlock()

	for _, e := range mmMemberPromote.MemberPromoteMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberPromote.MemberPromoteMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberPromote.MemberPromoteMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberPromote.MemberPromoteMock.defaultExpectation.params
		mm_got := ClientMockMemberPromoteParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberPromote.t.Errorf("ClientMock.MemberPromote got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberPromote.MemberPromoteMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberPromote.t.Fatal("No results are set for the ClientMock.MemberPromote")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberPromote.funcMemberPromote != nil {
		return mmMemberPromote.funcMemberPromote(ctx, id)
	}
	mmMemberPromote.t.Fatalf("Unexpected call to ClientMock.MemberPromote. %v %v", ctx, id)
	return
}

// MemberPromoteAfterCounter returns a count of finished ClientMock.MemberPromote invocations
func (mmMemberPromote *ClientMock) MemberPromoteAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberPromote.afterMemberPromoteCounter)
}

// MemberPromoteBeforeCounter returns a count of ClientMock.MemberPromote invocations
func (mmMemberPromote *ClientMock) MemberPromoteBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberPromote.beforeMemberPromoteCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberPromote.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberPromote *mClientMockMemberPromote) Calls() []*ClientMockMemberPromoteParams {
	mmMemberPromote.mutex.RLock()

	argCopy := make([]*ClientMockMemberPromoteParams, len(mmMemberPromote.callArgs))
	copy(argCopy, mmMemberPromote.callArgs)

	mmMemberPromote.mutex.RUnlock()

	return argCopy
}

// MinimockMemberPromoteDone returns true if the count of the MemberPromote invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberPromoteDone() bool {
	for _, e := range m.MemberPromoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberPromoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberPromoteCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberPromote != nil && mm_atomic.LoadUint64(&m.afterMemberPromoteCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberPromoteInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberPromoteInspect() {
	for _, e := range m.MemberPromoteMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberPromote with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberPromoteMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberPromoteCounter) < 1 {
		if m.MemberPromoteMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberPromote")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberPromote with params: %#v", *m.MemberPromoteMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberPromote != nil && mm_atomic.LoadUint64(&m.afterMemberPromoteCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberPromote")
	}
}

type mClientMockMemberRemove struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberRemoveExpectation
	expectations       []*ClientMockMemberRemoveExpectation

	callArgs []*ClientMockMemberRemoveParams
	mutex    sync.RWMutex
}

// ClientMockMemberRemoveExpectation specifies expectation struct of the Client.MemberRemove
type ClientMockMemberRemoveExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberRemoveParams
	results *ClientMockMemberRemoveResults
	Counter uint64
}

// ClientMockMemberRemoveParams contains parameters of the Client.MemberRemove
type ClientMockMemberRemoveParams struct {
	ctx context.Context
	id  uint64
}

// ClientMockMemberRemoveResults contains results of the Client.MemberRemove
type ClientMockMemberRemoveResults struct {
	mp1 *clientv3.MemberRemoveResponse
	err error
}

// Expect sets up expected params for Client.MemberRemove
func (mmMemberRemove *mClientMockMemberRemove) Expect(ctx context.Context, id uint64) *mClientMockMemberRemove {
	if mmMemberRemove.mock.funcMemberRemove != nil {
		mmMemberRemove.mock.t.Fatalf("ClientMock.MemberRemove mock is already set by Set")
	}

	if mmMemberRemove.defaultExpectation == nil {
		mmMemberRemove.defaultExpectation = &ClientMockMemberRemoveExpectation{}
	}

	mmMemberRemove.defaultExpectation.params = &ClientMockMemberRemoveParams{ctx, id}
	for _, e := range mmMemberRemove.expectations {
		if minimock.Equal(e.params, mmMemberRemove.defaultExpectation.params) {
			mmMemberRemove.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberRemove.defaultExpectation.params)
		}
	}

	return mmMemberRemove
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberRemove
func (mmMemberRemove *mClientMockMemberRemove) Inspect(f func(ctx context.Context, id uint64)) *mClientMockMemberRemove {
	if mmMemberRemove.mock.inspectFuncMemberRemove != nil {
		mmMemberRemove.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberRemove")
	}

	mmMemberRemove.mock.inspectFuncMemberRemove = f

	return mmMemberRemove
}

// Return sets up results that will be returned by Client.MemberRemove
func (mmMemberRemove *mClientMockMemberRemove) Return(mp1 *clientv3.MemberRemoveResponse, err error) *ClientMock {
	if mmMemberRemove.mock.funcMemberRemove != nil {
		mmMemberRemove.mock.t.Fatalf("ClientMock.MemberRemove mock is already set by Set")
	}

	if mmMemberRemove.defaultExpectation == nil {
		mmMemberRemove.defaultExpectation = &ClientMockMemberRemoveExpectation{mock: mmMemberRemove.mock}
	}
	mmMemberRemove.defaultExpectation.results = &ClientMockMemberRemoveResults{mp1, err}
	return mmMemberRemove.mock
}

//Set uses given function f to mock the Client.MemberRemove method
func (mmMemberRemove *mClientMockMemberRemove) Set(f func(ctx context.Context, id uint64) (mp1 *clientv3.MemberRemoveResponse, err error)) *ClientMock {
	if mmMemberRemove.defaultExpectation != nil {
		mmMemberRemove.mock.t.Fatalf("Default expectation is already set for the Client.MemberRemove method")
	}

	if len(mmMemberRemove.expectations) > 0 {
		mmMemberRemove.mock.t.Fatalf("Some expectations are already set for the Client.MemberRemove method")
	}

	mmMemberRemove.mock.funcMemberRemove = f
	return mmMemberRemove.mock
}

// When sets expectation for the Client.MemberRemove which will trigger the result defined by the following
// Then helper
func (mmMemberRemove *mClientMockMemberRemove) When(ctx context.Context, id uint64) *ClientMockMemberRemoveExpectation {
	if mmMemberRemove.mock.funcMemberRemove != nil {
		mmMemberRemove.mock.t.Fatalf("ClientMock.MemberRemove mock is already set by Set")
	}

	expectation := &ClientMockMemberRemoveExpectation{
		mock:   mmMemberRemove.mock,
		params: &ClientMockMemberRemoveParams{ctx, id},
	}
	mmMemberRemove.expectations = append(mmMemberRemove.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberRemove return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberRemoveExpectation) Then(mp1 *clientv3.MemberRemoveResponse, err error) *ClientMock {
	e.results = &ClientMockMemberRemoveResults{mp1, err}
	return e.mock
}

// MemberRemove implements Client
func (mmMemberRemove *ClientMock) MemberRemove(ctx context.Context, id uint64) (mp1 *clientv3.MemberRemoveResponse, err error) {
	mm_atomic.AddUint64(&mmMemberRemove.beforeMemberRemoveCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberRemove.afterMemberRemoveCounter, 1)

	if mmMemberRemove.inspectFuncMemberRemove != nil {
		mmMemberRemove.inspectFuncMemberRemove(ctx, id)
	}

	mm_params := &ClientMockMemberRemoveParams{ctx, id}

	// Record call args
	mmMemberRemove.MemberRemoveMock.mutex.Lock()
	mmMemberRemove.MemberRemoveMock.callArgs = append(mmMemberRemove.MemberRemoveMock.callArgs, mm_params)
	mmMemberRemove.MemberRemoveMock.mutex.Unlock()

	for _, e := range mmMemberRemove.MemberRemoveMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberRemove.MemberRemoveMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberRemove.MemberRemoveMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberRemove.MemberRemoveMock.defaultExpectation.params
		mm_got := ClientMockMemberRemoveParams{ctx, id}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberRemove.t.Errorf("ClientMock.MemberRemove got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberRemove.MemberRemoveMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberRemove.t.Fatal("No results are set for the ClientMock.MemberRemove")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberRemove.funcMemberRemove != nil {
		return mmMemberRemove.funcMemberRemove(ctx, id)
	}
	mmMemberRemove.t.Fatalf("Unexpected call to ClientMock.MemberRemove. %v %v", ctx, id)
	return
}

// MemberRemoveAfterCounter returns a count of finished ClientMock.MemberRemove invocations
func (mmMemberRemove *ClientMock) MemberRemoveAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberRemove.afterMemberRemoveCounter)
}

// MemberRemoveBeforeCounter returns a count of ClientMock.MemberRemove invocations
func (mmMemberRemove *ClientMock) MemberRemoveBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberRemove.beforeMemberRemoveCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberRemove.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberRemove *mClientMockMemberRemove) Calls() []*ClientMockMemberRemoveParams {
	mmMemberRemove.mutex.RLock()

	argCopy := make([]*ClientMockMemberRemoveParams, len(mmMemberRemove.callArgs))
	copy(argCopy, mmMemberRemove.callArgs)

	mmMemberRemove.mutex.RUnlock()

	return argCopy
}

// MinimockMemberRemoveDone returns true if the count of the MemberRemove invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberRemoveDone() bool {
	for _, e := range m.MemberRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberRemoveCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberRemove != nil && mm_atomic.LoadUint64(&m.afterMemberRemoveCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberRemoveInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberRemoveInspect() {
	for _, e := range m.MemberRemoveMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberRemove with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberRemoveMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberRemoveCounter) < 1 {
		if m.MemberRemoveMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberRemove")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberRemove with params: %#v", *m.MemberRemoveMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberRemove != nil && mm_atomic.LoadUint64(&m.afterMemberRemoveCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberRemove")
	}
}

type mClientMockMemberUpdate struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMemberUpdateExpectation
	expectations       []*ClientMockMemberUpdateExpectation

	callArgs []*ClientMockMemberUpdateParams
	mutex    sync.RWMutex
}

// ClientMockMemberUpdateExpectation specifies expectation struct of the Client.MemberUpdate
type ClientMockMemberUpdateExpectation struct {
	mock    *ClientMock
	params  *ClientMockMemberUpdateParams
	results *ClientMockMemberUpdateResults
	Counter uint64
}

// ClientMockMemberUpdateParams contains parameters of the Client.MemberUpdate
type ClientMockMemberUpdateParams struct {
	ctx       context.Context
	id        uint64
	peerAddrs []string
}

// ClientMockMemberUpdateResults contains results of the Client.MemberUpdate
type ClientMockMemberUpdateResults struct {
	mp1 *clientv3.MemberUpdateResponse
	err error
}

// Expect sets up expected params for Client.MemberUpdate
func (mmMemberUpdate *mClientMockMemberUpdate) Expect(ctx context.Context, id uint64, peerAddrs []string) *mClientMockMemberUpdate {
	if mmMemberUpdate.mock.funcMemberUpdate != nil {
		mmMemberUpdate.mock.t.Fatalf("ClientMock.MemberUpdate mock is already set by Set")
	}

	if mmMemberUpdate.defaultExpectation == nil {
		mmMemberUpdate.defaultExpectation = &ClientMockMemberUpdateExpectation{}
	}

	mmMemberUpdate.defaultExpectation.params = &ClientMockMemberUpdateParams{ctx, id, peerAddrs}
	for _, e := range mmMemberUpdate.expectations {
		if minimock.Equal(e.params, mmMemberUpdate.defaultExpectation.params) {
			mmMemberUpdate.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMemberUpdate.defaultExpectation.params)
		}
	}

	return mmMemberUpdate
}

// Inspect accepts an inspector function that has same arguments as the Client.MemberUpdate
func (mmMemberUpdate *mClientMockMemberUpdate) Inspect(f func(ctx context.Context, id uint64, peerAddrs []string)) *mClientMockMemberUpdate {
	if mmMemberUpdate.mock.inspectFuncMemberUpdate != nil {
		mmMemberUpdate.mock.t.Fatalf("Inspect function is already set for ClientMock.MemberUpdate")
	}

	mmMemberUpdate.mock.inspectFuncMemberUpdate = f

	return mmMemberUpdate
}

// Return sets up results that will be returned by Client.MemberUpdate
func (mmMemberUpdate *mClientMockMemberUpdate) Return(mp1 *clientv3.MemberUpdateResponse, err error) *ClientMock {
	if mmMemberUpdate.mock.funcMemberUpdate != nil {
		mmMemberUpdate.mock.t.Fatalf("ClientMock.MemberUpdate mock is already set by Set")
	}

	if mmMemberUpdate.defaultExpectation == nil {
		mmMemberUpdate.defaultExpectation = &ClientMockMemberUpdateExpectation{mock: mmMemberUpdate.mock}
	}
	mmMemberUpdate.defaultExpectation.results = &ClientMockMemberUpdateResults{mp1, err}
	return mmMemberUpdate.mock
}

//Set uses given function f to mock the Client.MemberUpdate method
func (mmMemberUpdate *mClientMockMemberUpdate) Set(f func(ctx context.Context, id uint64, peerAddrs []string) (mp1 *clientv3.MemberUpdateResponse, err error)) *ClientMock {
	if mmMemberUpdate.defaultExpectation != nil {
		mmMemberUpdate.mock.t.Fatalf("Default expectation is already set for the Client.MemberUpdate method")
	}

	if len(mmMemberUpdate.expectations) > 0 {
		mmMemberUpdate.mock.t.Fatalf("Some expectations are already set for the Client.MemberUpdate method")
	}

	mmMemberUpdate.mock.funcMemberUpdate = f
	return mmMemberUpdate.mock
}

// When sets expectation for the Client.MemberUpdate which will trigger the result defined by the following
// Then helper
func (mmMemberUpdate *mClientMockMemberUpdate) When(ctx context.Context, id uint64, peerAddrs []string) *ClientMockMemberUpdateExpectation {
	if mmMemberUpdate.mock.funcMemberUpdate != nil {
		mmMemberUpdate.mock.t.Fatalf("ClientMock.MemberUpdate mock is already set by Set")
	}

	expectation := &ClientMockMemberUpdateExpectation{
		mock:   mmMemberUpdate.mock,
		params: &ClientMockMemberUpdateParams{ctx, id, peerAddrs},
	}
	mmMemberUpdate.expectations = append(mmMemberUpdate.expectations, expectation)
	return expectation
}

// Then sets up Client.MemberUpdate return parameters for the expectation previously defined by the When method
func (e *ClientMockMemberUpdateExpectation) Then(mp1 *clientv3.MemberUpdateResponse, err error) *ClientMock {
	e.results = &ClientMockMemberUpdateResults{mp1, err}
	return e.mock
}

// MemberUpdate implements Client
func (mmMemberUpdate *ClientMock) MemberUpdate(ctx context.Context, id uint64, peerAddrs []string) (mp1 *clientv3.MemberUpdateResponse, err error) {
	mm_atomic.AddUint64(&mmMemberUpdate.beforeMemberUpdateCounter, 1)
	defer mm_atomic.AddUint64(&mmMemberUpdate.afterMemberUpdateCounter, 1)

	if mmMemberUpdate.inspectFuncMemberUpdate != nil {
		mmMemberUpdate.inspectFuncMemberUpdate(ctx, id, peerAddrs)
	}

	mm_params := &ClientMockMemberUpdateParams{ctx, id, peerAddrs}

	// Record call args
	mmMemberUpdate.MemberUpdateMock.mutex.Lock()
	mmMemberUpdate.MemberUpdateMock.callArgs = append(mmMemberUpdate.MemberUpdateMock.callArgs, mm_params)
	mmMemberUpdate.MemberUpdateMock.mutex.Unlock()

	for _, e := range mmMemberUpdate.MemberUpdateMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMemberUpdate.MemberUpdateMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMemberUpdate.MemberUpdateMock.defaultExpectation.Counter, 1)
		mm_want := mmMemberUpdate.MemberUpdateMock.defaultExpectation.params
		mm_got := ClientMockMemberUpdateParams{ctx, id, peerAddrs}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMemberUpdate.t.Errorf("ClientMock.MemberUpdate got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMemberUpdate.MemberUpdateMock.defaultExpectation.results
		if mm_results == nil {
			mmMemberUpdate.t.Fatal("No results are set for the ClientMock.MemberUpdate")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMemberUpdate.funcMemberUpdate != nil {
		return mmMemberUpdate.funcMemberUpdate(ctx, id, peerAddrs)
	}
	mmMemberUpdate.t.Fatalf("Unexpected call to ClientMock.MemberUpdate. %v %v %v", ctx, id, peerAddrs)
	return
}

// MemberUpdateAfterCounter returns a count of finished ClientMock.MemberUpdate invocations
func (mmMemberUpdate *ClientMock) MemberUpdateAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberUpdate.afterMemberUpdateCounter)
}

// MemberUpdateBeforeCounter returns a count of ClientMock.MemberUpdate invocations
func (mmMemberUpdate *ClientMock) MemberUpdateBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMemberUpdate.beforeMemberUpdateCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MemberUpdate.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMemberUpdate *mClientMockMemberUpdate) Calls() []*ClientMockMemberUpdateParams {
	mmMemberUpdate.mutex.RLock()

	argCopy := make([]*ClientMockMemberUpdateParams, len(mmMemberUpdate.callArgs))
	copy(argCopy, mmMemberUpdate.callArgs)

	mmMemberUpdate.mutex.RUnlock()

	return argCopy
}

// MinimockMemberUpdateDone returns true if the count of the MemberUpdate invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMemberUpdateDone() bool {
	for _, e := range m.MemberUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberUpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberUpdateCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberUpdate != nil && mm_atomic.LoadUint64(&m.afterMemberUpdateCounter) < 1 {
		return false
	}
	return true
}

// MinimockMemberUpdateInspect logs each unmet expectation
func (m *ClientMock) MinimockMemberUpdateInspect() {
	for _, e := range m.MemberUpdateMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MemberUpdate with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MemberUpdateMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMemberUpdateCounter) < 1 {
		if m.MemberUpdateMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MemberUpdate")
		} else {
			m.t.Errorf("Expected call to ClientMock.MemberUpdate with params: %#v", *m.MemberUpdateMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMemberUpdate != nil && mm_atomic.LoadUint64(&m.afterMemberUpdateCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MemberUpdate")
	}
}

type mClientMockMoveLeader struct {
	mock               *ClientMock
	defaultExpectation *ClientMockMoveLeaderExpectation
	expectations       []*ClientMockMoveLeaderExpectation

	callArgs []*ClientMockMoveLeaderParams
	mutex    sync.RWMutex
}

// ClientMockMoveLeaderExpectation specifies expectation struct of the Client.MoveLeader
type ClientMockMoveLeaderExpectation struct {
	mock    *ClientMock
	params  *ClientMockMoveLeaderParams
	results *ClientMockMoveLeaderResults
	Counter uint64
}

// ClientMockMoveLeaderParams contains parameters of the Client.MoveLeader
type ClientMockMoveLeaderParams struct {
	ctx          context.Context
	transfereeID uint64
}

// ClientMockMoveLeaderResults contains results of the Client.MoveLeader
type ClientMockMoveLeaderResults struct {
	mp1 *clientv3.MoveLeaderResponse
	err error
}

// Expect sets up expected params for Client.MoveLeader
func (mmMoveLeader *mClientMockMoveLeader) Expect(ctx context.Context, transfereeID uint64) *mClientMockMoveLeader {
	if mmMoveLeader.mock.funcMoveLeader != nil {
		mmMoveLeader.mock.t.Fatalf("ClientMock.MoveLeader mock is already set by Set")
	}

	if mmMoveLeader.defaultExpectation == nil {
		mmMoveLeader.defaultExpectation = &ClientMockMoveLeaderExpectation{}
	}

	mmMoveLeader.defaultExpectation.params = &ClientMockMoveLeaderParams{ctx, transfereeID}
	for _, e := range mmMoveLeader.expectations {
		if minimock.Equal(e.params, mmMoveLeader.defaultExpectation.params) {
			mmMoveLeader.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmMoveLeader.defaultExpectation.params)
		}
	}

	return mmMoveLeader
}

// Inspect accepts an inspector function that has same arguments as the Client.MoveLeader
func (mmMoveLeader *mClientMockMoveLeader) Inspect(f func(ctx context.Context, transfereeID uint64)) *mClientMockMoveLeader {
	if mmMoveLeader.mock.inspectFuncMoveLeader != nil {
		mmMoveLeader.mock.t.Fatalf("Inspect function is already set for ClientMock.MoveLeader")
	}

	mmMoveLeader.mock.inspectFuncMoveLeader = f

	return mmMoveLeader
}

// Return sets up results that will be returned by Client.MoveLeader
func (mmMoveLeader *mClientMockMoveLeader) Return(mp1 *clientv3.MoveLeaderResponse, err error) *ClientMock {
	if mmMoveLeader.mock.funcMoveLeader != nil {
		mmMoveLeader.mock.t.Fatalf("ClientMock.MoveLeader mock is already set by Set")
	}

	if mmMoveLeader.defaultExpectation == nil {
		mmMoveLeader.defaultExpectation = &ClientMockMoveLeaderExpectation{mock: mmMoveLeader.mock}
	}
	mmMoveLeader.defaultExpectation.results = &ClientMockMoveLeaderResults{mp1, err}
	return mmMoveLeader.mock
}

//Set uses given function f to mock the Client.MoveLeader method
func (mmMoveLeader *mClientMockMoveLeader) Set(f func(ctx context.Context, transfereeID uint64) (mp1 *clientv3.MoveLeaderResponse, err error)) *ClientMock {
	if mmMoveLeader.defaultExpectation != nil {
		mmMoveLeader.mock.t.Fatalf("Default expectation is already set for the Client.MoveLeader method")
	}

	if len(mmMoveLeader.expectations) > 0 {
		mmMoveLeader.mock.t.Fatalf("Some expectations are already set for the Client.MoveLeader method")
	}

	mmMoveLeader.mock.funcMoveLeader = f
	return mmMoveLeader.mock
}

// When sets expectation for the Client.MoveLeader which will trigger the result defined by the following
// Then helper
func (mmMoveLeader *mClientMockMoveLeader) When(ctx context.Context, transfereeID uint64) *ClientMockMoveLeaderExpectation {
	if mmMoveLeader.mock.funcMoveLeader != nil {
		mmMoveLeader.mock.t.Fatalf("ClientMock.MoveLeader mock is already set by Set")
	}

	expectation := &ClientMockMoveLeaderExpectation{
		mock:   mmMoveLeader.mock,
		params: &ClientMockMoveLeaderParams{ctx, transfereeID},
	}
	mmMoveLeader.expectations = append(mmMoveLeader.expectations, expectation)
	return expectation
}

// Then sets up Client.MoveLeader return parameters for the expectation previously defined by the When method
func (e *ClientMockMoveLeaderExpectation) Then(mp1 *clientv3.MoveLeaderResponse, err error) *ClientMock {
	e.results = &ClientMockMoveLeaderResults{mp1, err}
	return e.mock
}

// MoveLeader implements Client
func (mmMoveLeader *ClientMock) MoveLeader(ctx context.Context, transfereeID uint64) (mp1 *clientv3.MoveLeaderResponse, err error) {
	mm_atomic.AddUint64(&mmMoveLeader.beforeMoveLeaderCounter, 1)
	defer mm_atomic.AddUint64(&mmMoveLeader.afterMoveLeaderCounter, 1)

	if mmMoveLeader.inspectFuncMoveLeader != nil {
		mmMoveLeader.inspectFuncMoveLeader(ctx, transfereeID)
	}

	mm_params := &ClientMockMoveLeaderParams{ctx, transfereeID}

	// Record call args
	mmMoveLeader.MoveLeaderMock.mutex.Lock()
	mmMoveLeader.MoveLeaderMock.callArgs = append(mmMoveLeader.MoveLeaderMock.callArgs, mm_params)
	mmMoveLeader.MoveLeaderMock.mutex.Unlock()

	for _, e := range mmMoveLeader.MoveLeaderMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.mp1, e.results.err
		}
	}

	if mmMoveLeader.MoveLeaderMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmMoveLeader.MoveLeaderMock.defaultExpectation.Counter, 1)
		mm_want := mmMoveLeader.MoveLeaderMock.defaultExpectation.params
		mm_got := ClientMockMoveLeaderParams{ctx, transfereeID}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmMoveLeader.t.Errorf("ClientMock.MoveLeader got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmMoveLeader.MoveLeaderMock.defaultExpectation.results
		if mm_results == nil {
			mmMoveLeader.t.Fatal("No results are set for the ClientMock.MoveLeader")
		}
		return (*mm_results).mp1, (*mm_results).err
	}
	if mmMoveLeader.funcMoveLeader != nil {
		return mmMoveLeader.funcMoveLeader(ctx, transfereeID)
	}
	mmMoveLeader.t.Fatalf("Unexpected call to ClientMock.MoveLeader. %v %v", ctx, transfereeID)
	return
}

// MoveLeaderAfterCounter returns a count of finished ClientMock.MoveLeader invocations
func (mmMoveLeader *ClientMock) MoveLeaderAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMoveLeader.afterMoveLeaderCounter)
}

// MoveLeaderBeforeCounter returns a count of ClientMock.MoveLeader invocations
func (mmMoveLeader *ClientMock) MoveLeaderBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmMoveLeader.beforeMoveLeaderCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.MoveLeader.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmMoveLeader *mClientMockMoveLeader) Calls() []*ClientMockMoveLeaderParams {
	mmMoveLeader.mutex.RLock()

	argCopy := make([]*ClientMockMoveLeaderParams, len(mmMoveLeader.callArgs))
	copy(argCopy, mmMoveLeader.callArgs)

	mmMoveLeader.mutex.RUnlock()

	return argCopy
}

// MinimockMoveLeaderDone returns true if the count of the MoveLeader invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockMoveLeaderDone() bool {
	for _, e := range m.MoveLeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MoveLeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMoveLeaderCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMoveLeader != nil && mm_atomic.LoadUint64(&m.afterMoveLeaderCounter) < 1 {
		return false
	}
	return true
}

// MinimockMoveLeaderInspect logs each unmet expectation
func (m *ClientMock) MinimockMoveLeaderInspect() {
	for _, e := range m.MoveLeaderMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.MoveLeader with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.MoveLeaderMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterMoveLeaderCounter) < 1 {
		if m.MoveLeaderMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.MoveLeader")
		} else {
			m.t.Errorf("Expected call to ClientMock.MoveLeader with params: %#v", *m.MoveLeaderMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcMoveLeader != nil && mm_atomic.LoadUint64(&m.afterMoveLeaderCounter) < 1 {
		m.t.Error("Expected call to ClientMock.MoveLeader")
	}
}

type mClientMockPut struct {
	mock               *ClientMock
	defaultExpectation *ClientMockPutExpectation
	expectations       []*ClientMockPutExpectation

	callArgs []*ClientMockPutParams
	mutex    sync.RWMutex
}

// ClientMockPutExpectation specifies expectation struct of the Client.Put
type ClientMockPutExpectation struct {
	mock    *ClientMock
	params  *ClientMockPutParams
	results *ClientMockPutResults
	Counter uint64
}

// ClientMockPutParams contains parameters of the Client.Put
type ClientMockPutParams struct {
	ctx  context.Context
	key  string
	val  string
	opts []clientv3.OpOption
}

// ClientMockPutResults contains results of the Client.Put
type ClientMockPutResults struct {
	pp1 *clientv3.PutResponse
	err error
}

// Expect sets up expected params for Client.Put
func (mmPut *mClientMockPut) Expect(ctx context.Context, key string, val string, opts ...clientv3.OpOption) *mClientMockPut {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &ClientMockPutExpectation{}
	}

	mmPut.defaultExpectation.params = &ClientMockPutParams{ctx, key, val, opts}
	for _, e := range mmPut.expectations {
		if minimock.Equal(e.params, mmPut.defaultExpectation.params) {
			mmPut.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmPut.defaultExpectation.params)
		}
	}

	return mmPut
}

// Inspect accepts an inspector function that has same arguments as the Client.Put
func (mmPut *mClientMockPut) Inspect(f func(ctx context.Context, key string, val string, opts ...clientv3.OpOption)) *mClientMockPut {
	if mmPut.mock.inspectFuncPut != nil {
		mmPut.mock.t.Fatalf("Inspect function is already set for ClientMock.Put")
	}

	mmPut.mock.inspectFuncPut = f

	return mmPut
}

// Return sets up results that will be returned by Client.Put
func (mmPut *mClientMockPut) Return(pp1 *clientv3.PutResponse, err error) *ClientMock {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	if mmPut.defaultExpectation == nil {
		mmPut.defaultExpectation = &ClientMockPutExpectation{mock: mmPut.mock}
	}
	mmPut.defaultExpectation.results = &ClientMockPutResults{pp1, err}
	return mmPut.mock
}

//Set uses given function f to mock the Client.Put method
func (mmPut *mClientMockPut) Set(f func(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error)) *ClientMock {
	if mmPut.defaultExpectation != nil {
		mmPut.mock.t.Fatalf("Default expectation is already set for the Client.Put method")
	}

	if len(mmPut.expectations) > 0 {
		mmPut.mock.t.Fatalf("Some expectations are already set for the Client.Put method")
	}

	mmPut.mock.funcPut = f
	return mmPut.mock
}

// When sets expectation for the Client.Put which will trigger the result defined by the following
// Then helper
func (mmPut *mClientMockPut) When(ctx context.Context, key string, val string, opts ...clientv3.OpOption) *ClientMockPutExpectation {
	if mmPut.mock.funcPut != nil {
		mmPut.mock.t.Fatalf("ClientMock.Put mock is already set by Set")
	}

	expectation := &ClientMockPutExpectation{
		mock:   mmPut.mock,
		params: &ClientMockPutParams{ctx, key, val, opts},
	}
	mmPut.expectations = append(mmPut.expectations, expectation)
	return expectation
}

// Then sets up Client.Put return parameters for the expectation previously defined by the When method
func (e *ClientMockPutExpectation) Then(pp1 *clientv3.PutResponse, err error) *ClientMock {
	e.results = &ClientMockPutResults{pp1, err}
	return e.mock
}

// Put implements Client
func (mmPut *ClientMock) Put(ctx context.Context, key string, val string, opts ...clientv3.OpOption) (pp1 *clientv3.PutResponse, err error) {
	mm_atomic.AddUint64(&mmPut.beforePutCounter, 1)
	defer mm_atomic.AddUint64(&mmPut.afterPutCounter, 1)

	if mmPut.inspectFuncPut != nil {
		mmPut.inspectFuncPut(ctx, key, val, opts...)
	}

	mm_params := &ClientMockPutParams{ctx, key, val, opts}

	// Record call args
	mmPut.PutMock.mutex.Lock()
	mmPut.PutMock.callArgs = append(mmPut.PutMock.callArgs, mm_params)
	mmPut.PutMock.mutex.Unlock()

	for _, e := range mmPut.PutMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.pp1, e.results.err
		}
	}

	if mmPut.PutMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmPut.PutMock.defaultExpectation.Counter, 1)
		mm_want := mmPut.PutMock.defaultExpectation.params
		mm_got := ClientMockPutParams{ctx, key, val, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmPut.t.Errorf("ClientMock.Put got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmPut.PutMock.defaultExpectation.results
		if mm_results == nil {
			mmPut.t.Fatal("No results are set for the ClientMock.Put")
		}
		return (*mm_results).pp1, (*mm_results).err
	}
	if mmPut.funcPut != nil {
		return mmPut.funcPut(ctx, key, val, opts...)
	}
	mmPut.t.Fatalf("Unexpected call to ClientMock.Put. %v %v %v %v", ctx, key, val, opts)
	return
}

// PutAfterCounter returns a count of finished ClientMock.Put invocations
func (mmPut *ClientMock) PutAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.afterPutCounter)
}

// PutBeforeCounter returns a count of ClientMock.Put invocations
func (mmPut *ClientMock) PutBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmPut.beforePutCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Put.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmPut *mClientMockPut) Calls() []*ClientMockPutParams {
	mmPut.mutex.RLock()

	argCopy := make([]*ClientMockPutParams, len(mmPut.callArgs))
	copy(argCopy, mmPut.callArgs)

	mmPut.mutex.RUnlock()

	return argCopy
}

// MinimockPutDone returns true if the count of the Put invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockPutDone() bool {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		return false
	}
	return true
}

// MinimockPutInspect logs each unmet expectation
func (m *ClientMock) MinimockPutInspect() {
	for _, e := range m.PutMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Put with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.PutMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		if m.PutMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Put")
		} else {
			m.t.Errorf("Expected call to ClientMock.Put with params: %#v", *m.PutMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcPut != nil && mm_atomic.LoadUint64(&m.afterPutCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Put")
	}
}

type mClientMockRequestProgress struct {
	mock               *ClientMock
	defaultExpectation *ClientMockRequestProgressExpectation
	expectations       []*ClientMockRequestProgressExpectation

	callArgs []*ClientMockRequestProgressParams
	mutex    sync.RWMutex
}

// ClientMockRequestProgressExpectation specifies expectation struct of the Client.RequestProgress
type ClientMockRequestProgressExpectation struct {
	mock    *ClientMock
	params  *ClientMockRequestProgressParams
	results *ClientMockRequestProgressResults
	Counter uint64
}

// ClientMockRequestProgressParams contains parameters of the Client.RequestProgress
type ClientMockRequestProgressParams struct {
	ctx context.Context
}

// ClientMockRequestProgressResults contains results of the Client.RequestProgress
type ClientMockRequestProgressResults struct {
	err error
}

// Expect sets up expected params for Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Expect(ctx context.Context) *mClientMockRequestProgress {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	if mmRequestProgress.defaultExpectation == nil {
		mmRequestProgress.defaultExpectation = &ClientMockRequestProgressExpectation{}
	}

	mmRequestProgress.defaultExpectation.params = &ClientMockRequestProgressParams{ctx}
	for _, e := range mmRequestProgress.expectations {
		if minimock.Equal(e.params, mmRequestProgress.defaultExpectation.params) {
			mmRequestProgress.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRequestProgress.defaultExpectation.params)
		}
	}

	return mmRequestProgress
}

// Inspect accepts an inspector function that has same arguments as the Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Inspect(f func(ctx context.Context)) *mClientMockRequestProgress {
	if mmRequestProgress.mock.inspectFuncRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("Inspect function is already set for ClientMock.RequestProgress")
	}

	mmRequestProgress.mock.inspectFuncRequestProgress = f

	return mmRequestProgress
}

// Return sets up results that will be returned by Client.RequestProgress
func (mmRequestProgress *mClientMockRequestProgress) Return(err error) *ClientMock {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	if mmRequestProgress.defaultExpectation == nil {
		mmRequestProgress.defaultExpectation = &ClientMockRequestProgressExpectation{mock: mmRequestProgress.mock}
	}
	mmRequestProgress.defaultExpectation.results = &ClientMockRequestProgressResults{err}
	return mmRequestProgress.mock
}

//Set uses given function f to mock the Client.RequestProgress method
func (mmRequestProgress *mClientMockRequestProgress) Set(f func(ctx context.Context) (err error)) *ClientMock {
	if mmRequestProgress.defaultExpectation != nil {
		mmRequestProgress.mock.t.Fatalf("Default expectation is already set for the Client.RequestProgress method")
	}

	if len(mmRequestProgress.expectations) > 0 {
		mmRequestProgress.mock.t.Fatalf("Some expectations are already set for the Client.RequestProgress method")
	}

	mmRequestProgress.mock.funcRequestProgress = f
	return mmRequestProgress.mock
}

// When sets expectation for the Client.RequestProgress which will trigger the result defined by the following
// Then helper
func (mmRequestProgress *mClientMockRequestProgress) When(ctx context.Context) *ClientMockRequestProgressExpectation {
	if mmRequestProgress.mock.funcRequestProgress != nil {
		mmRequestProgress.mock.t.Fatalf("ClientMock.RequestProgress mock is already set by Set")
	}

	expectation := &ClientMockRequestProgressExpectation{
		mock:   mmRequestProgress.mock,
		params: &ClientMockRequestProgressParams{ctx},
	}
	mmRequestProgress.expectations = append(mmRequestProgress.expectations, expectation)
	return expectation
}

// Then sets up Client.RequestProgress return parameters for the expectation previously defined by the When method
func (e *ClientMockRequestProgressExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockRequestProgressResults{err}
	return e.mock
}

// RequestProgress implements Client
func (mmRequestProgress *ClientMock) RequestProgress(ctx context.Context) (err error) {
	mm_atomic.AddUint64(&mmRequestProgress.beforeRequestProgressCounter, 1)
	defer mm_atomic.AddUint64(&mmRequestProgress.afterRequestProgressCounter, 1)

	if mmRequestProgress.inspectFuncRequestProgress != nil {
		mmRequestProgress.inspectFuncRequestProgress(ctx)
	}

	mm_params := &ClientMockRequestProgressParams{ctx}

	// Record call args
	mmRequestProgress.RequestProgressMock.mutex.Lock()
	mmRequestProgress.RequestProgressMock.callArgs = append(mmRequestProgress.RequestProgressMock.callArgs, mm_params)
	mmRequestProgress.RequestProgressMock.mutex.Unlock()

	for _, e := range mmRequestProgress.RequestProgressMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRequestProgress.RequestProgressMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRequestProgress.RequestProgressMock.defaultExpectation.Counter, 1)
		mm_want := mmRequestProgress.RequestProgressMock.defaultExpectation.params
		mm_got := ClientMockRequestProgressParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRequestProgress.t.Errorf("ClientMock.RequestProgress got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRequestProgress.RequestProgressMock.defaultExpectation.results
		if mm_results == nil {
			mmRequestProgress.t.Fatal("No results are set for the ClientMock.RequestProgress")
		}
		return (*mm_results).err
	}
	if mmRequestProgress.funcRequestProgress != nil {
		return mmRequestProgress.funcRequestProgress(ctx)
	}
	mmRequestProgress.t.Fatalf("Unexpected call to ClientMock.RequestProgress. %v", ctx)
	return
}

// RequestProgressAfterCounter returns a count of finished ClientMock.RequestProgress invocations
func (mmRequestProgress *ClientMock) RequestProgressAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestProgress.afterRequestProgressCounter)
}

// RequestProgressBeforeCounter returns a count of ClientMock.RequestProgress invocations
func (mmRequestProgress *ClientMock) RequestProgressBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRequestProgress.beforeRequestProgressCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.RequestProgress.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRequestProgress *mClientMockRequestProgress) Calls() []*ClientMockRequestProgressParams {
	mmRequestProgress.mutex.RLock()

	argCopy := make([]*ClientMockRequestProgressParams, len(mmRequestProgress.callArgs))
	copy(argCopy, mmRequestProgress.callArgs)

	mmRequestProgress.mutex.RUnlock()

	return argCopy
}

// MinimockRequestProgressDone returns true if the count of the RequestProgress invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockRequestProgressDone() bool {
	for _, e := range m.RequestProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestProgressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestProgress != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		return false
	}
	return true
}

// MinimockRequestProgressInspect logs each unmet expectation
func (m *ClientMock) MinimockRequestProgressInspect() {
	for _, e := range m.RequestProgressMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.RequestProgress with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.RequestProgressMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		if m.RequestProgressMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.RequestProgress")
		} else {
			m.t.Errorf("Expected call to ClientMock.RequestProgress with params: %#v", *m.RequestProgressMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRequestProgress != nil && mm_atomic.LoadUint64(&m.afterRequestProgressCounter) < 1 {
		m.t.Error("Expected call to ClientMock.RequestProgress")
	}
}

type mClientMockSnapshot struct {
	mock               *ClientMock
	defaultExpectation *ClientMockSnapshotExpectation
	expectations       []*ClientMockSnapshotExpectation

	callArgs []*ClientMockSnapshotParams
	mutex    sync.RWMutex
}

// ClientMockSnapshotExpectation specifies expectation struct of the Client.Snapshot
type ClientMockSnapshotExpectation struct {
	mock    *ClientMock
	params  *ClientMockSnapshotParams
	results *ClientMockSnapshotResults
	Counter uint64
}

// ClientMockSnapshotParams contains parameters of the Client.Snapshot
type ClientMockSnapshotParams struct {
	ctx context.Context
}

// ClientMockSnapshotResults contains results of the Client.Snapshot
type ClientMockSnapshotResults struct {
	r1  io.ReadCloser
	err error
}

// Expect sets up expected params for Client.Snapshot
func (mmSnapshot *mClientMockSnapshot) Expect(ctx context.Context) *mClientMockSnapshot {
	if mmSnapshot.mock.funcSnapshot != nil {
		mmSnapshot.mock.t.Fatalf("ClientMock.Snapshot mock is already set by Set")
	}

	if mmSnapshot.defaultExpectation == nil {
		mmSnapshot.defaultExpectation = &ClientMockSnapshotExpectation{}
	}

	mmSnapshot.defaultExpectation.params = &ClientMockSnapshotParams{ctx}
	for _, e := range mmSnapshot.expectations {
		if minimock.Equal(e.params, mmSnapshot.defaultExpectation.params) {
			mmSnapshot.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSnapshot.defaultExpectation.params)
		}
	}

	return mmSnapshot
}

// Inspect accepts an inspector function that has same arguments as the Client.Snapshot
func (mmSnapshot *mClientMockSnapshot) Inspect(f func(ctx context.Context)) *mClientMockSnapshot {
	if mmSnapshot.mock.inspectFuncSnapshot != nil {
		mmSnapshot.mock.t.Fatalf("Inspect function is already set for ClientMock.Snapshot")
	}

	mmSnapshot.mock.inspectFuncSnapshot = f

	return mmSnapshot
}

// Return sets up results that will be returned by Client.Snapshot
func (mmSnapshot *mClientMockSnapshot) Return(r1 io.ReadCloser, err error) *ClientMock {
	if mmSnapshot.mock.funcSnapshot != nil {
		mmSnapshot.mock.t.Fatalf("ClientMock.Snapshot mock is already set by Set")
	}

	if mmSnapshot.defaultExpectation == nil {
		mmSnapshot.defaultExpectation = &ClientMockSnapshotExpectation{mock: mmSnapshot.mock}
	}
	mmSnapshot.defaultExpectation.results = &ClientMockSnapshotResults{r1, err}
	return mmSnapshot.mock
}

//Set uses given function f to mock the Client.Snapshot method
func (mmSnapshot *mClientMockSnapshot) Set(f func(ctx context.Context) (r1 io.ReadCloser, err error)) *ClientMock {
	if mmSnapshot.defaultExpectation != nil {
		mmSnapshot.mock.t.Fatalf("Default expectation is already set for the Client.Snapshot method")
	}

	if len(mmSnapshot.expectations) > 0 {
		mmSnapshot.mock.t.Fatalf("Some expectations are already set for the Client.Snapshot method")
	}

	mmSnapshot.mock.funcSnapshot = f
	return mmSnapshot.mock
}

// When sets expectation for the Client.Snapshot which will trigger the result defined by the following
// Then helper
func (mmSnapshot *mClientMockSnapshot) When(ctx context.Context) *ClientMockSnapshotExpectation {
	if mmSnapshot.mock.funcSnapshot != nil {
		mmSnapshot.mock.t.Fatalf("ClientMock.Snapshot mock is already set by Set")
	}

	expectation := &ClientMockSnapshotExpectation{
		mock:   mmSnapshot.mock,
		params: &ClientMockSnapshotParams{ctx},
	}
	mmSnapshot.expectations = append(mmSnapshot.expectations, expectation)
	return expectation
}

// Then sets up Client.Snapshot return parameters for the expectation previously defined by the When method
func (e *ClientMockSnapshotExpectation) Then(r1 io.ReadCloser, err error) *ClientMock {
	e.results = &ClientMockSnapshotResults{r1, err}
	return e.mock
}

// Snapshot implements Client
func (mmSnapshot *ClientMock) Snapshot(ctx context.Context) (r1 io.ReadCloser, err error) {
	mm_atomic.AddUint64(&mmSnapshot.beforeSnapshotCounter, 1)
	defer mm_atomic.AddUint64(&mmSnapshot.afterSnapshotCounter, 1)

	if mmSnapshot.inspectFuncSnapshot != nil {
		mmSnapshot.inspectFuncSnapshot(ctx)
	}

	mm_params := &ClientMockSnapshotParams{ctx}

	// Record call args
	mmSnapshot.SnapshotMock.mutex.Lock()
	mmSnapshot.SnapshotMock.callArgs = append(mmSnapshot.SnapshotMock.callArgs, mm_params)
	mmSnapshot.SnapshotMock.mutex.Unlock()

	for _, e := range mmSnapshot.SnapshotMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.r1, e.results.err
		}
	}

	if mmSnapshot.SnapshotMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSnapshot.SnapshotMock.defaultExpectation.Counter, 1)
		mm_want := mmSnapshot.SnapshotMock.defaultExpectation.params
		mm_got := ClientMockSnapshotParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSnapshot.t.Errorf("ClientMock.Snapshot got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSnapshot.SnapshotMock.defaultExpectation.results
		if mm_results == nil {
			mmSnapshot.t.Fatal("No results are set for the ClientMock.Snapshot")
		}
		return (*mm_results).r1, (*mm_results).err
	}
	if mmSnapshot.funcSnapshot != nil {
		return mmSnapshot.funcSnapshot(ctx)
	}
	mmSnapshot.t.Fatalf("Unexpected call to ClientMock.Snapshot. %v", ctx)
	return
}

// SnapshotAfterCounter returns a count of finished ClientMock.Snapshot invocations
func (mmSnapshot *ClientMock) SnapshotAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSnapshot.afterSnapshotCounter)
}

// SnapshotBeforeCounter returns a count of ClientMock.Snapshot invocations
func (mmSnapshot *ClientMock) SnapshotBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSnapshot.beforeSnapshotCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Snapshot.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSnapshot *mClientMockSnapshot) Calls() []*ClientMockSnapshotParams {
	mmSnapshot.mutex.RLock()

	argCopy := make([]*ClientMockSnapshotParams, len(mmSnapshot.callArgs))
	copy(argCopy, mmSnapshot.callArgs)

	mmSnapshot.mutex.RUnlock()

	return argCopy
}

// MinimockSnapshotDone returns true if the count of the Snapshot invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockSnapshotDone() bool {
	for _, e := range m.SnapshotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SnapshotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSnapshotCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSnapshot != nil && mm_atomic.LoadUint64(&m.afterSnapshotCounter) < 1 {
		return false
	}
	return true
}

// MinimockSnapshotInspect logs each unmet expectation
func (m *ClientMock) MinimockSnapshotInspect() {
	for _, e := range m.SnapshotMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Snapshot with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.SnapshotMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterSnapshotCounter) < 1 {
		if m.SnapshotMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Snapshot")
		} else {
			m.t.Errorf("Expected call to ClientMock.Snapshot with params: %#v", *m.SnapshotMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSnapshot != nil && mm_atomic.LoadUint64(&m.afterSnapshotCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Snapshot")
	}
}

type mClientMockStatus struct {
	mock               *ClientMock
	defaultExpectation *ClientMockStatusExpectation
	expectations       []*ClientMockStatusExpectation

	callArgs []*ClientMockStatusParams
	mutex    sync.RWMutex
}

// ClientMockStatusExpectation specifies expectation struct of the Client.Status
type ClientMockStatusExpectation struct {
	mock    *ClientMock
	params  *ClientMockStatusParams
	results *ClientMockStatusResults
	Counter uint64
}

// ClientMockStatusParams contains parameters of the Client.Status
type ClientMockStatusParams struct {
	ctx      context.Context
	endpoint string
}

// ClientMockStatusResults contains results of the Client.Status
type ClientMockStatusResults struct {
	sp1 *clientv3.StatusResponse
	err error
}

// Expect sets up expected params for Client.Status
func (mmStatus *mClientMockStatus) Expect(ctx context.Context, endpoint string) *mClientMockStatus {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("ClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &ClientMockStatusExpectation{}
	}

	mmStatus.defaultExpectation.params = &ClientMockStatusParams{ctx, endpoint}
	for _, e := range mmStatus.expectations {
		if minimock.Equal(e.params, mmStatus.defaultExpectation.params) {
			mmStatus.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmStatus.defaultExpectation.params)
		}
	}

	return mmStatus
}

// Inspect accepts an inspector function that has same arguments as the Client.Status
func (mmStatus *mClientMockStatus) Inspect(f func(ctx context.Context, endpoint string)) *mClientMockStatus {
	if mmStatus.mock.inspectFuncStatus != nil {
		mmStatus.mock.t.Fatalf("Inspect function is already set for ClientMock.Status")
	}

	mmStatus.mock.inspectFuncStatus = f

	return mmStatus
}

// Return sets up results that will be returned by Client.Status
func (mmStatus *mClientMockStatus) Return(sp1 *clientv3.StatusResponse, err error) *ClientMock {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("ClientMock.Status mock is already set by Set")
	}

	if mmStatus.defaultExpectation == nil {
		mmStatus.defaultExpectation = &ClientMockStatusExpectation{mock: mmStatus.mock}
	}
	mmStatus.defaultExpectation.results = &ClientMockStatusResults{sp1, err}
	return mmStatus.mock
}

//Set uses given function f to mock the Client.Status method
func (mmStatus *mClientMockStatus) Set(f func(ctx context.Context, endpoint string) (sp1 *clientv3.StatusResponse, err error)) *ClientMock {
	if mmStatus.defaultExpectation != nil {
		mmStatus.mock.t.Fatalf("Default expectation is already set for the Client.Status method")
	}

	if len(mmStatus.expectations) > 0 {
		mmStatus.mock.t.Fatalf("Some expectations are already set for the Client.Status method")
	}

	mmStatus.mock.funcStatus = f
	return mmStatus.mock
}

// When sets expectation for the Client.Status which will trigger the result defined by the following
// Then helper
func (mmStatus *mClientMockStatus) When(ctx context.Context, endpoint string) *ClientMockStatusExpectation {
	if mmStatus.mock.funcStatus != nil {
		mmStatus.mock.t.Fatalf("ClientMock.Status mock is already set by Set")
	}

	expectation := &ClientMockStatusExpectation{
		mock:   mmStatus.mock,
		params: &ClientMockStatusParams{ctx, endpoint},
	}
	mmStatus.expectations = append(mmStatus.expectations, expectation)
	return expectation
}

// Then sets up Client.Status return parameters for the expectation previously defined by the When method
func (e *ClientMockStatusExpectation) Then(sp1 *clientv3.StatusResponse, err error) *ClientMock {
	e.results = &ClientMockStatusResults{sp1, err}
	return e.mock
}

// Status implements Client
func (mmStatus *ClientMock) Status(ctx context.Context, endpoint string) (sp1 *clientv3.StatusResponse, err error) {
	mm_atomic.AddUint64(&mmStatus.beforeStatusCounter, 1)
	defer mm_atomic.AddUint64(&mmStatus.afterStatusCounter, 1)

	if mmStatus.inspectFuncStatus != nil {
		mmStatus.inspectFuncStatus(ctx, endpoint)
	}

	mm_params := &ClientMockStatusParams{ctx, endpoint}

	// Record call args
	mmStatus.StatusMock.mutex.Lock()
	mmStatus.StatusMock.callArgs = append(mmStatus.StatusMock.callArgs, mm_params)
	mmStatus.StatusMock.mutex.Unlock()

	for _, e := range mmStatus.StatusMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sp1, e.results.err
		}
	}

	if mmStatus.StatusMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStatus.StatusMock.defaultExpectation.Counter, 1)
		mm_want := mmStatus.StatusMock.defaultExpectation.params
		mm_got := ClientMockStatusParams{ctx, endpoint}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmStatus.t.Errorf("ClientMock.Status got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmStatus.StatusMock.defaultExpectation.results
		if mm_results == nil {
			mmStatus.t.Fatal("No results are set for the ClientMock.Status")
		}
		return (*mm_results).sp1, (*mm_results).err
	}
	if mmStatus.funcStatus != nil {
		return mmStatus.funcStatus(ctx, endpoint)
	}
	mmStatus.t.Fatalf("Unexpected call to ClientMock.Status. %v %v", ctx, endpoint)
	return
}

// StatusAfterCounter returns a count of finished ClientMock.Status invocations
func (mmStatus *ClientMock) StatusAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.afterStatusCounter)
}

// StatusBeforeCounter returns a count of ClientMock.Status invocations
func (mmStatus *ClientMock) StatusBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStatus.beforeStatusCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Status.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmStatus *mClientMockStatus) Calls() []*ClientMockStatusParams {
	mmStatus.mutex.RLock()

	argCopy := make([]*ClientMockStatusParams, len(mmStatus.callArgs))
	copy(argCopy, mmStatus.callArgs)

	mmStatus.mutex.RUnlock()

	return argCopy
}

// MinimockStatusDone returns true if the count of the Status invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockStatusDone() bool {
	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatusCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatus != nil && mm_atomic.LoadUint64(&m.afterStatusCounter) < 1 {
		return false
	}
	return true
}

// MinimockStatusInspect logs each unmet expectation
func (m *ClientMock) MinimockStatusInspect() {
	for _, e := range m.StatusMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Status with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.StatusMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterStatusCounter) < 1 {
		if m.StatusMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Status")
		} else {
			m.t.Errorf("Expected call to ClientMock.Status with params: %#v", *m.StatusMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStatus != nil && mm_atomic.LoadUint64(&m.afterStatusCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Status")
	}
}

type mClientMockTxn struct {
	mock               *ClientMock
	defaultExpectation *ClientMockTxnExpectation
	expectations       []*ClientMockTxnExpectation

	callArgs []*ClientMockTxnParams
	mutex    sync.RWMutex
}

// ClientMockTxnExpectation specifies expectation struct of the Client.Txn
type ClientMockTxnExpectation struct {
	mock    *ClientMock
	params  *ClientMockTxnParams
	results *ClientMockTxnResults
	Counter uint64
}

// ClientMockTxnParams contains parameters of the Client.Txn
type ClientMockTxnParams struct {
	ctx context.Context
}

// ClientMockTxnResults contains results of the Client.Txn
type ClientMockTxnResults struct {
	t1 clientv3.Txn
}

// Expect sets up expected params for Client.Txn
func (mmTxn *mClientMockTxn) Expect(ctx context.Context) *mClientMockTxn {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	if mmTxn.defaultExpectation == nil {
		mmTxn.defaultExpectation = &ClientMockTxnExpectation{}
	}

	mmTxn.defaultExpectation.params = &ClientMockTxnParams{ctx}
	for _, e := range mmTxn.expectations {
		if minimock.Equal(e.params, mmTxn.defaultExpectation.params) {
			mmTxn.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmTxn.defaultExpectation.params)
		}
	}

	return mmTxn
}

// Inspect accepts an inspector function that has same arguments as the Client.Txn
func (mmTxn *mClientMockTxn) Inspect(f func(ctx context.Context)) *mClientMockTxn {
	if mmTxn.mock.inspectFuncTxn != nil {
		mmTxn.mock.t.Fatalf("Inspect function is already set for ClientMock.Txn")
	}

	mmTxn.mock.inspectFuncTxn = f

	return mmTxn
}

// Return sets up results that will be returned by Client.Txn
func (mmTxn *mClientMockTxn) Return(t1 clientv3.Txn) *ClientMock {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	if mmTxn.defaultExpectation == nil {
		mmTxn.defaultExpectation = &ClientMockTxnExpectation{mock: mmTxn.mock}
	}
	mmTxn.defaultExpectation.results = &ClientMockTxnResults{t1}
	return mmTxn.mock
}

//Set uses given function f to mock the Client.Txn method
func (mmTxn *mClientMockTxn) Set(f func(ctx context.Context) (t1 clientv3.Txn)) *ClientMock {
	if mmTxn.defaultExpectation != nil {
		mmTxn.mock.t.Fatalf("Default expectation is already set for the Client.Txn method")
	}

	if len(mmTxn.expectations) > 0 {
		mmTxn.mock.t.Fatalf("Some expectations are already set for the Client.Txn method")
	}

	mmTxn.mock.funcTxn = f
	return mmTxn.mock
}

// When sets expectation for the Client.Txn which will trigger the result defined by the following
// Then helper
func (mmTxn *mClientMockTxn) When(ctx context.Context) *ClientMockTxnExpectation {
	if mmTxn.mock.funcTxn != nil {
		mmTxn.mock.t.Fatalf("ClientMock.Txn mock is already set by Set")
	}

	expectation := &ClientMockTxnExpectation{
		mock:   mmTxn.mock,
		params: &ClientMockTxnParams{ctx},
	}
	mmTxn.expectations = append(mmTxn.expectations, expectation)
	return expectation
}

// Then sets up Client.Txn return parameters for the expectation previously defined by the When method
func (e *ClientMockTxnExpectation) Then(t1 clientv3.Txn) *ClientMock {
	e.results = &ClientMockTxnResults{t1}
	return e.mock
}

// Txn implements Client
func (mmTxn *ClientMock) Txn(ctx context.Context) (t1 clientv3.Txn) {
	mm_atomic.AddUint64(&mmTxn.beforeTxnCounter, 1)
	defer mm_atomic.AddUint64(&mmTxn.afterTxnCounter, 1)

	if mmTxn.inspectFuncTxn != nil {
		mmTxn.inspectFuncTxn(ctx)
	}

	mm_params := &ClientMockTxnParams{ctx}

	// Record call args
	mmTxn.TxnMock.mutex.Lock()
	mmTxn.TxnMock.callArgs = append(mmTxn.TxnMock.callArgs, mm_params)
	mmTxn.TxnMock.mutex.Unlock()

	for _, e := range mmTxn.TxnMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.t1
		}
	}

	if mmTxn.TxnMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmTxn.TxnMock.defaultExpectation.Counter, 1)
		mm_want := mmTxn.TxnMock.defaultExpectation.params
		mm_got := ClientMockTxnParams{ctx}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmTxn.t.Errorf("ClientMock.Txn got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmTxn.TxnMock.defaultExpectation.results
		if mm_results == nil {
			mmTxn.t.Fatal("No results are set for the ClientMock.Txn")
		}
		return (*mm_results).t1
	}
	if mmTxn.funcTxn != nil {
		return mmTxn.funcTxn(ctx)
	}
	mmTxn.t.Fatalf("Unexpected call to ClientMock.Txn. %v", ctx)
	return
}

// TxnAfterCounter returns a count of finished ClientMock.Txn invocations
func (mmTxn *ClientMock) TxnAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxn.afterTxnCounter)
}

// TxnBeforeCounter returns a count of ClientMock.Txn invocations
func (mmTxn *ClientMock) TxnBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmTxn.beforeTxnCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Txn.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmTxn *mClientMockTxn) Calls() []*ClientMockTxnParams {
	mmTxn.mutex.RLock()

	argCopy := make([]*ClientMockTxnParams, len(mmTxn.callArgs))
	copy(argCopy, mmTxn.callArgs)

	mmTxn.mutex.RUnlock()

	return argCopy
}

// MinimockTxnDone returns true if the count of the Txn invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockTxnDone() bool {
	for _, e := range m.TxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TxnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxn != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		return false
	}
	return true
}

// MinimockTxnInspect logs each unmet expectation
func (m *ClientMock) MinimockTxnInspect() {
	for _, e := range m.TxnMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Txn with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.TxnMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		if m.TxnMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Txn")
		} else {
			m.t.Errorf("Expected call to ClientMock.Txn with params: %#v", *m.TxnMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcTxn != nil && mm_atomic.LoadUint64(&m.afterTxnCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Txn")
	}
}

type mClientMockWatch struct {
	mock               *ClientMock
	defaultExpectation *ClientMockWatchExpectation
	expectations       []*ClientMockWatchExpectation

	callArgs []*ClientMockWatchParams
	mutex    sync.RWMutex
}

// ClientMockWatchExpectation specifies expectation struct of the Client.Watch
type ClientMockWatchExpectation struct {
	mock    *ClientMock
	params  *ClientMockWatchParams
	results *ClientMockWatchResults
	Counter uint64
}

// ClientMockWatchParams contains parameters of the Client.Watch
type ClientMockWatchParams struct {
	ctx  context.Context
	key  string
	opts []clientv3.OpOption
}

// ClientMockWatchResults contains results of the Client.Watch
type ClientMockWatchResults struct {
	w1 clientv3.WatchChan
}

// Expect sets up expected params for Client.Watch
func (mmWatch *mClientMockWatch) Expect(ctx context.Context, key string, opts ...clientv3.OpOption) *mClientMockWatch {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &ClientMockWatchExpectation{}
	}

	mmWatch.defaultExpectation.params = &ClientMockWatchParams{ctx, key, opts}
	for _, e := range mmWatch.expectations {
		if minimock.Equal(e.params, mmWatch.defaultExpectation.params) {
			mmWatch.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmWatch.defaultExpectation.params)
		}
	}

	return mmWatch
}

// Inspect accepts an inspector function that has same arguments as the Client.Watch
func (mmWatch *mClientMockWatch) Inspect(f func(ctx context.Context, key string, opts ...clientv3.OpOption)) *mClientMockWatch {
	if mmWatch.mock.inspectFuncWatch != nil {
		mmWatch.mock.t.Fatalf("Inspect function is already set for ClientMock.Watch")
	}

	mmWatch.mock.inspectFuncWatch = f

	return mmWatch
}

// Return sets up results that will be returned by Client.Watch
func (mmWatch *mClientMockWatch) Return(w1 clientv3.WatchChan) *ClientMock {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	if mmWatch.defaultExpectation == nil {
		mmWatch.defaultExpectation = &ClientMockWatchExpectation{mock: mmWatch.mock}
	}
	mmWatch.defaultExpectation.results = &ClientMockWatchResults{w1}
	return mmWatch.mock
}

//Set uses given function f to mock the Client.Watch method
func (mmWatch *mClientMockWatch) Set(f func(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan)) *ClientMock {
	if mmWatch.defaultExpectation != nil {
		mmWatch.mock.t.Fatalf("Default expectation is already set for the Client.Watch method")
	}

	if len(mmWatch.expectations) > 0 {
		mmWatch.mock.t.Fatalf("Some expectations are already set for the Client.Watch method")
	}

	mmWatch.mock.funcWatch = f
	return mmWatch.mock
}

// When sets expectation for the Client.Watch which will trigger the result defined by the following
// Then helper
func (mmWatch *mClientMockWatch) When(ctx context.Context, key string, opts ...clientv3.OpOption) *ClientMockWatchExpectation {
	if mmWatch.mock.funcWatch != nil {
		mmWatch.mock.t.Fatalf("ClientMock.Watch mock is already set by Set")
	}

	expectation := &ClientMockWatchExpectation{
		mock:   mmWatch.mock,
		params: &ClientMockWatchParams{ctx, key, opts},
	}
	mmWatch.expectations = append(mmWatch.expectations, expectation)
	return expectation
}

// Then sets up Client.Watch return parameters for the expectation previously defined by the When method
func (e *ClientMockWatchExpectation) Then(w1 clientv3.WatchChan) *ClientMock {
	e.results = &ClientMockWatchResults{w1}
	return e.mock
}

// Watch implements Client
func (mmWatch *ClientMock) Watch(ctx context.Context, key string, opts ...clientv3.OpOption) (w1 clientv3.WatchChan) {
	mm_atomic.AddUint64(&mmWatch.beforeWatchCounter, 1)
	defer mm_atomic.AddUint64(&mmWatch.afterWatchCounter, 1)

	if mmWatch.inspectFuncWatch != nil {
		mmWatch.inspectFuncWatch(ctx, key, opts...)
	}

	mm_params := &ClientMockWatchParams{ctx, key, opts}

	// Record call args
	mmWatch.WatchMock.mutex.Lock()
	mmWatch.WatchMock.callArgs = append(mmWatch.WatchMock.callArgs, mm_params)
	mmWatch.WatchMock.mutex.Unlock()

	for _, e := range mmWatch.WatchMock.expectations {
		if minimock.Equal(e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.w1
		}
	}

	if mmWatch.WatchMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmWatch.WatchMock.defaultExpectation.Counter, 1)
		mm_want := mmWatch.WatchMock.defaultExpectation.params
		mm_got := ClientMockWatchParams{ctx, key, opts}
		if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmWatch.t.Errorf("ClientMock.Watch got unexpected parameters, want: %#v, got: %#v%s\n", *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmWatch.WatchMock.defaultExpectation.results
		if mm_results == nil {
			mmWatch.t.Fatal("No results are set for the ClientMock.Watch")
		}
		return (*mm_results).w1
	}
	if mmWatch.funcWatch != nil {
		return mmWatch.funcWatch(ctx, key, opts...)
	}
	mmWatch.t.Fatalf("Unexpected call to ClientMock.Watch. %v %v %v", ctx, key, opts)
	return
}

// WatchAfterCounter returns a count of finished ClientMock.Watch invocations
func (mmWatch *ClientMock) WatchAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatch.afterWatchCounter)
}

// WatchBeforeCounter returns a count of ClientMock.Watch invocations
func (mmWatch *ClientMock) WatchBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmWatch.beforeWatchCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Watch.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmWatch *mClientMockWatch) Calls() []*ClientMockWatchParams {
	mmWatch.mutex.RLock()

	argCopy := make([]*ClientMockWatchParams, len(mmWatch.callArgs))
	copy(argCopy, mmWatch.callArgs)

	mmWatch.mutex.RUnlock()

	return argCopy
}

// MinimockWatchDone returns true if the count of the Watch invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockWatchDone() bool {
	for _, e := range m.WatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		return false
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatch != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		return false
	}
	return true
}

// MinimockWatchInspect logs each unmet expectation
func (m *ClientMock) MinimockWatchInspect() {
	for _, e := range m.WatchMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Watch with params: %#v", *e.params)
		}
	}

	// if default expectation was set then invocations count should be greater than zero
	if m.WatchMock.defaultExpectation != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		if m.WatchMock.defaultExpectation.params == nil {
			m.t.Error("Expected call to ClientMock.Watch")
		} else {
			m.t.Errorf("Expected call to ClientMock.Watch with params: %#v", *m.WatchMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcWatch != nil && mm_atomic.LoadUint64(&m.afterWatchCounter) < 1 {
		m.t.Error("Expected call to ClientMock.Watch")
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	if !m.minimockDone() {
		m.MinimockAlarmDisarmInspect()

		m.MinimockAlarmListInspect()

		m.MinimockCloseInspect()

		m.MinimockCompactInspect()

		m.MinimockDefragmentInspect()

		m.MinimockDeleteInspect()

		m.MinimockDoInspect()

		m.MinimockGetInspect()

		m.MinimockHashKVInspect()

		m.MinimockMemberAddInspect()

		m.MinimockMemberAddAsLearnerInspect()

		m.MinimockMemberListInspect()

		m.MinimockMemberPromoteInspect()

		m.MinimockMemberRemoveInspect()

		m.MinimockMemberUpdateInspect()

		m.MinimockMoveLeaderInspect()

		m.MinimockPutInspect()

		m.MinimockRequestProgressInspect()

		m.MinimockSnapshotInspect()

		m.MinimockStatusInspect()

		m.MinimockTxnInspect()

		m.MinimockWatchInspect()
		m.t.FailNow()
	}
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockAlarmDisarmDone() &&
		m.MinimockAlarmListDone() &&
		m.MinimockCloseDone() &&
		m.MinimockCompactDone() &&
		m.MinimockDefragmentDone() &&
		m.MinimockDeleteDone() &&
		m.MinimockDoDone() &&
		m.MinimockGetDone() &&
		m.MinimockHashKVDone() &&
		m.MinimockMemberAddDone() &&
		m.MinimockMemberAddAsLearnerDone() &&
		m.MinimockMemberListDone() &&
		m.MinimockMemberPromoteDone() &&
		m.MinimockMemberRemoveDone() &&
		m.MinimockMemberUpdateDone() &&
		m.MinimockMoveLeaderDone() &&
		m.MinimockPutDone() &&
		m.MinimockRequestProgressDone() &&
		m.MinimockSnapshotDone() &&
		m.MinimockStatusDone() &&
		m.MinimockTxnDone() &&
		m.MinimockWatchDone()
}
