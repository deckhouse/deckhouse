// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package cr

//go:generate minimock -i github.com/deckhouse/deckhouse/go_lib/dependency/cr.Client -o cr_mock.go -n ClientMock -p cr

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	v1 "github.com/google/go-containerregistry/pkg/v1"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcDigest          func(ctx context.Context, tag string) (s1 string, err error)
	funcDigestOrigin    string
	inspectFuncDigest   func(ctx context.Context, tag string)
	afterDigestCounter  uint64
	beforeDigestCounter uint64
	DigestMock          mClientMockDigest

	funcImage          func(ctx context.Context, tag string) (i1 v1.Image, err error)
	funcImageOrigin    string
	inspectFuncImage   func(ctx context.Context, tag string)
	afterImageCounter  uint64
	beforeImageCounter uint64
	ImageMock          mClientMockImage

	funcListTags          func(ctx context.Context) (sa1 []string, err error)
	funcListTagsOrigin    string
	inspectFuncListTags   func(ctx context.Context)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mClientMockListTags
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.DigestMock = mClientMockDigest{mock: m}
	m.DigestMock.callArgs = []*ClientMockDigestParams{}

	m.ImageMock = mClientMockImage{mock: m}
	m.ImageMock.callArgs = []*ClientMockImageParams{}

	m.ListTagsMock = mClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*ClientMockListTagsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockDigest struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDigestExpectation
	expectations       []*ClientMockDigestExpectation

	callArgs []*ClientMockDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDigestExpectation specifies expectation struct of the Client.Digest
type ClientMockDigestExpectation struct {
	mock               *ClientMock
	params             *ClientMockDigestParams
	paramPtrs          *ClientMockDigestParamPtrs
	expectationOrigins ClientMockDigestExpectationOrigins
	results            *ClientMockDigestResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDigestParams contains parameters of the Client.Digest
type ClientMockDigestParams struct {
	ctx context.Context
	tag string
}

// ClientMockDigestParamPtrs contains pointers to parameters of the Client.Digest
type ClientMockDigestParamPtrs struct {
	ctx *context.Context
	tag *string
}

// ClientMockDigestResults contains results of the Client.Digest
type ClientMockDigestResults struct {
	s1  string
	err error
}

// ClientMockDigestOrigins contains origins of expectations of the Client.Digest
type ClientMockDigestExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDigest *mClientMockDigest) Optional() *mClientMockDigest {
	mmDigest.optional = true
	return mmDigest
}

// Expect sets up expected params for Client.Digest
func (mmDigest *mClientMockDigest) Expect(ctx context.Context, tag string) *mClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &ClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.paramPtrs != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by ExpectParams functions")
	}

	mmDigest.defaultExpectation.params = &ClientMockDigestParams{ctx, tag}
	mmDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDigest.expectations {
		if minimock.Equal(e.params, mmDigest.defaultExpectation.params) {
			mmDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDigest.defaultExpectation.params)
		}
	}

	return mmDigest
}

// ExpectCtxParam1 sets up expected param ctx for Client.Digest
func (mmDigest *mClientMockDigest) ExpectCtxParam1(ctx context.Context) *mClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &ClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.params != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Expect")
	}

	if mmDigest.defaultExpectation.paramPtrs == nil {
		mmDigest.defaultExpectation.paramPtrs = &ClientMockDigestParamPtrs{}
	}
	mmDigest.defaultExpectation.paramPtrs.ctx = &ctx
	mmDigest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDigest
}

// ExpectTagParam2 sets up expected param tag for Client.Digest
func (mmDigest *mClientMockDigest) ExpectTagParam2(tag string) *mClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &ClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.params != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Expect")
	}

	if mmDigest.defaultExpectation.paramPtrs == nil {
		mmDigest.defaultExpectation.paramPtrs = &ClientMockDigestParamPtrs{}
	}
	mmDigest.defaultExpectation.paramPtrs.tag = &tag
	mmDigest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmDigest
}

// Inspect accepts an inspector function that has same arguments as the Client.Digest
func (mmDigest *mClientMockDigest) Inspect(f func(ctx context.Context, tag string)) *mClientMockDigest {
	if mmDigest.mock.inspectFuncDigest != nil {
		mmDigest.mock.t.Fatalf("Inspect function is already set for ClientMock.Digest")
	}

	mmDigest.mock.inspectFuncDigest = f

	return mmDigest
}

// Return sets up results that will be returned by Client.Digest
func (mmDigest *mClientMockDigest) Return(s1 string, err error) *ClientMock {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &ClientMockDigestExpectation{mock: mmDigest.mock}
	}
	mmDigest.defaultExpectation.results = &ClientMockDigestResults{s1, err}
	mmDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDigest.mock
}

// Set uses given function f to mock the Client.Digest method
func (mmDigest *mClientMockDigest) Set(f func(ctx context.Context, tag string) (s1 string, err error)) *ClientMock {
	if mmDigest.defaultExpectation != nil {
		mmDigest.mock.t.Fatalf("Default expectation is already set for the Client.Digest method")
	}

	if len(mmDigest.expectations) > 0 {
		mmDigest.mock.t.Fatalf("Some expectations are already set for the Client.Digest method")
	}

	mmDigest.mock.funcDigest = f
	mmDigest.mock.funcDigestOrigin = minimock.CallerInfo(1)
	return mmDigest.mock
}

// When sets expectation for the Client.Digest which will trigger the result defined by the following
// Then helper
func (mmDigest *mClientMockDigest) When(ctx context.Context, tag string) *ClientMockDigestExpectation {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	expectation := &ClientMockDigestExpectation{
		mock:               mmDigest.mock,
		params:             &ClientMockDigestParams{ctx, tag},
		expectationOrigins: ClientMockDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDigest.expectations = append(mmDigest.expectations, expectation)
	return expectation
}

// Then sets up Client.Digest return parameters for the expectation previously defined by the When method
func (e *ClientMockDigestExpectation) Then(s1 string, err error) *ClientMock {
	e.results = &ClientMockDigestResults{s1, err}
	return e.mock
}

// Times sets number of times Client.Digest should be invoked
func (mmDigest *mClientMockDigest) Times(n uint64) *mClientMockDigest {
	if n == 0 {
		mmDigest.mock.t.Fatalf("Times of ClientMock.Digest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDigest.expectedInvocations, n)
	mmDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDigest
}

func (mmDigest *mClientMockDigest) invocationsDone() bool {
	if len(mmDigest.expectations) == 0 && mmDigest.defaultExpectation == nil && mmDigest.mock.funcDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDigest.mock.afterDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Digest implements Client
func (mmDigest *ClientMock) Digest(ctx context.Context, tag string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmDigest.beforeDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmDigest.afterDigestCounter, 1)

	mmDigest.t.Helper()

	if mmDigest.inspectFuncDigest != nil {
		mmDigest.inspectFuncDigest(ctx, tag)
	}

	mm_params := ClientMockDigestParams{ctx, tag}

	// Record call args
	mmDigest.DigestMock.mutex.Lock()
	mmDigest.DigestMock.callArgs = append(mmDigest.DigestMock.callArgs, &mm_params)
	mmDigest.DigestMock.mutex.Unlock()

	for _, e := range mmDigest.DigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmDigest.DigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigest.DigestMock.defaultExpectation.Counter, 1)
		mm_want := mmDigest.DigestMock.defaultExpectation.params
		mm_want_ptrs := mmDigest.DigestMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDigestParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDigest.t.Errorf("ClientMock.Digest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDigest.DigestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmDigest.t.Errorf("ClientMock.Digest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDigest.DigestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDigest.t.Errorf("ClientMock.Digest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDigest.DigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDigest.DigestMock.defaultExpectation.results
		if mm_results == nil {
			mmDigest.t.Fatal("No results are set for the ClientMock.Digest")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmDigest.funcDigest != nil {
		return mmDigest.funcDigest(ctx, tag)
	}
	mmDigest.t.Fatalf("Unexpected call to ClientMock.Digest. %v %v", ctx, tag)
	return
}

// DigestAfterCounter returns a count of finished ClientMock.Digest invocations
func (mmDigest *ClientMock) DigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigest.afterDigestCounter)
}

// DigestBeforeCounter returns a count of ClientMock.Digest invocations
func (mmDigest *ClientMock) DigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigest.beforeDigestCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Digest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDigest *mClientMockDigest) Calls() []*ClientMockDigestParams {
	mmDigest.mutex.RLock()

	argCopy := make([]*ClientMockDigestParams, len(mmDigest.callArgs))
	copy(argCopy, mmDigest.callArgs)

	mmDigest.mutex.RUnlock()

	return argCopy
}

// MinimockDigestDone returns true if the count of the Digest invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDigestDone() bool {
	if m.DigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DigestMock.invocationsDone()
}

// MinimockDigestInspect logs each unmet expectation
func (m *ClientMock) MinimockDigestInspect() {
	for _, e := range m.DigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Digest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDigestCounter := mm_atomic.LoadUint64(&m.afterDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DigestMock.defaultExpectation != nil && afterDigestCounter < 1 {
		if m.DigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Digest at\n%s", m.DigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Digest at\n%s with params: %#v", m.DigestMock.defaultExpectation.expectationOrigins.origin, *m.DigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigest != nil && afterDigestCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Digest at\n%s", m.funcDigestOrigin)
	}

	if !m.DigestMock.invocationsDone() && afterDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Digest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DigestMock.expectedInvocations), m.DigestMock.expectedInvocationsOrigin, afterDigestCounter)
	}
}

type mClientMockImage struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockImageExpectation
	expectations       []*ClientMockImageExpectation

	callArgs []*ClientMockImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockImageExpectation specifies expectation struct of the Client.Image
type ClientMockImageExpectation struct {
	mock               *ClientMock
	params             *ClientMockImageParams
	paramPtrs          *ClientMockImageParamPtrs
	expectationOrigins ClientMockImageExpectationOrigins
	results            *ClientMockImageResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockImageParams contains parameters of the Client.Image
type ClientMockImageParams struct {
	ctx context.Context
	tag string
}

// ClientMockImageParamPtrs contains pointers to parameters of the Client.Image
type ClientMockImageParamPtrs struct {
	ctx *context.Context
	tag *string
}

// ClientMockImageResults contains results of the Client.Image
type ClientMockImageResults struct {
	i1  v1.Image
	err error
}

// ClientMockImageOrigins contains origins of expectations of the Client.Image
type ClientMockImageExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImage *mClientMockImage) Optional() *mClientMockImage {
	mmImage.optional = true
	return mmImage
}

// Expect sets up expected params for Client.Image
func (mmImage *mClientMockImage) Expect(ctx context.Context, tag string) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.paramPtrs != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by ExpectParams functions")
	}

	mmImage.defaultExpectation.params = &ClientMockImageParams{ctx, tag}
	mmImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImage.expectations {
		if minimock.Equal(e.params, mmImage.defaultExpectation.params) {
			mmImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImage.defaultExpectation.params)
		}
	}

	return mmImage
}

// ExpectCtxParam1 sets up expected param ctx for Client.Image
func (mmImage *mClientMockImage) ExpectCtxParam1(ctx context.Context) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &ClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImage
}

// ExpectTagParam2 sets up expected param tag for Client.Image
func (mmImage *mClientMockImage) ExpectTagParam2(tag string) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &ClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.tag = &tag
	mmImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmImage
}

// Inspect accepts an inspector function that has same arguments as the Client.Image
func (mmImage *mClientMockImage) Inspect(f func(ctx context.Context, tag string)) *mClientMockImage {
	if mmImage.mock.inspectFuncImage != nil {
		mmImage.mock.t.Fatalf("Inspect function is already set for ClientMock.Image")
	}

	mmImage.mock.inspectFuncImage = f

	return mmImage
}

// Return sets up results that will be returned by Client.Image
func (mmImage *mClientMockImage) Return(i1 v1.Image, err error) *ClientMock {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{mock: mmImage.mock}
	}
	mmImage.defaultExpectation.results = &ClientMockImageResults{i1, err}
	mmImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImage.mock
}

// Set uses given function f to mock the Client.Image method
func (mmImage *mClientMockImage) Set(f func(ctx context.Context, tag string) (i1 v1.Image, err error)) *ClientMock {
	if mmImage.defaultExpectation != nil {
		mmImage.mock.t.Fatalf("Default expectation is already set for the Client.Image method")
	}

	if len(mmImage.expectations) > 0 {
		mmImage.mock.t.Fatalf("Some expectations are already set for the Client.Image method")
	}

	mmImage.mock.funcImage = f
	mmImage.mock.funcImageOrigin = minimock.CallerInfo(1)
	return mmImage.mock
}

// When sets expectation for the Client.Image which will trigger the result defined by the following
// Then helper
func (mmImage *mClientMockImage) When(ctx context.Context, tag string) *ClientMockImageExpectation {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	expectation := &ClientMockImageExpectation{
		mock:               mmImage.mock,
		params:             &ClientMockImageParams{ctx, tag},
		expectationOrigins: ClientMockImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImage.expectations = append(mmImage.expectations, expectation)
	return expectation
}

// Then sets up Client.Image return parameters for the expectation previously defined by the When method
func (e *ClientMockImageExpectation) Then(i1 v1.Image, err error) *ClientMock {
	e.results = &ClientMockImageResults{i1, err}
	return e.mock
}

// Times sets number of times Client.Image should be invoked
func (mmImage *mClientMockImage) Times(n uint64) *mClientMockImage {
	if n == 0 {
		mmImage.mock.t.Fatalf("Times of ClientMock.Image mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImage.expectedInvocations, n)
	mmImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImage
}

func (mmImage *mClientMockImage) invocationsDone() bool {
	if len(mmImage.expectations) == 0 && mmImage.defaultExpectation == nil && mmImage.mock.funcImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImage.mock.afterImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Image implements Client
func (mmImage *ClientMock) Image(ctx context.Context, tag string) (i1 v1.Image, err error) {
	mm_atomic.AddUint64(&mmImage.beforeImageCounter, 1)
	defer mm_atomic.AddUint64(&mmImage.afterImageCounter, 1)

	mmImage.t.Helper()

	if mmImage.inspectFuncImage != nil {
		mmImage.inspectFuncImage(ctx, tag)
	}

	mm_params := ClientMockImageParams{ctx, tag}

	// Record call args
	mmImage.ImageMock.mutex.Lock()
	mmImage.ImageMock.callArgs = append(mmImage.ImageMock.callArgs, &mm_params)
	mmImage.ImageMock.mutex.Unlock()

	for _, e := range mmImage.ImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmImage.ImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImage.ImageMock.defaultExpectation.Counter, 1)
		mm_want := mmImage.ImageMock.defaultExpectation.params
		mm_want_ptrs := mmImage.ImageMock.defaultExpectation.paramPtrs

		mm_got := ClientMockImageParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImage.t.Errorf("ClientMock.Image got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmImage.t.Errorf("ClientMock.Image got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImage.t.Errorf("ClientMock.Image got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImage.ImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImage.ImageMock.defaultExpectation.results
		if mm_results == nil {
			mmImage.t.Fatal("No results are set for the ClientMock.Image")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmImage.funcImage != nil {
		return mmImage.funcImage(ctx, tag)
	}
	mmImage.t.Fatalf("Unexpected call to ClientMock.Image. %v %v", ctx, tag)
	return
}

// ImageAfterCounter returns a count of finished ClientMock.Image invocations
func (mmImage *ClientMock) ImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImage.afterImageCounter)
}

// ImageBeforeCounter returns a count of ClientMock.Image invocations
func (mmImage *ClientMock) ImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImage.beforeImageCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Image.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImage *mClientMockImage) Calls() []*ClientMockImageParams {
	mmImage.mutex.RLock()

	argCopy := make([]*ClientMockImageParams, len(mmImage.callArgs))
	copy(argCopy, mmImage.callArgs)

	mmImage.mutex.RUnlock()

	return argCopy
}

// MinimockImageDone returns true if the count of the Image invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockImageDone() bool {
	if m.ImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImageMock.invocationsDone()
}

// MinimockImageInspect logs each unmet expectation
func (m *ClientMock) MinimockImageInspect() {
	for _, e := range m.ImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImageCounter := mm_atomic.LoadUint64(&m.afterImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImageMock.defaultExpectation != nil && afterImageCounter < 1 {
		if m.ImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s", m.ImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s with params: %#v", m.ImageMock.defaultExpectation.expectationOrigins.origin, *m.ImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImage != nil && afterImageCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Image at\n%s", m.funcImageOrigin)
	}

	if !m.ImageMock.invocationsDone() && afterImageCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Image at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImageMock.expectedInvocations), m.ImageMock.expectedInvocationsOrigin, afterImageCounter)
	}
}

type mClientMockListTags struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockListTagsExpectation
	expectations       []*ClientMockListTagsExpectation

	callArgs []*ClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockListTagsExpectation specifies expectation struct of the Client.ListTags
type ClientMockListTagsExpectation struct {
	mock               *ClientMock
	params             *ClientMockListTagsParams
	paramPtrs          *ClientMockListTagsParamPtrs
	expectationOrigins ClientMockListTagsExpectationOrigins
	results            *ClientMockListTagsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockListTagsParams contains parameters of the Client.ListTags
type ClientMockListTagsParams struct {
	ctx context.Context
}

// ClientMockListTagsParamPtrs contains pointers to parameters of the Client.ListTags
type ClientMockListTagsParamPtrs struct {
	ctx *context.Context
}

// ClientMockListTagsResults contains results of the Client.ListTags
type ClientMockListTagsResults struct {
	sa1 []string
	err error
}

// ClientMockListTagsOrigins contains origins of expectations of the Client.ListTags
type ClientMockListTagsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTags *mClientMockListTags) Optional() *mClientMockListTags {
	mmListTags.optional = true
	return mmListTags
}

// Expect sets up expected params for Client.ListTags
func (mmListTags *mClientMockListTags) Expect(ctx context.Context) *mClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &ClientMockListTagsParams{ctx}
	mmListTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for Client.ListTags
func (mmListTags *mClientMockListTags) ExpectCtxParam1(ctx context.Context) *mClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &ClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the Client.ListTags
func (mmListTags *mClientMockListTags) Inspect(f func(ctx context.Context)) *mClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for ClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by Client.ListTags
func (mmListTags *mClientMockListTags) Return(sa1 []string, err error) *ClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &ClientMockListTagsResults{sa1, err}
	mmListTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// Set uses given function f to mock the Client.ListTags method
func (mmListTags *mClientMockListTags) Set(f func(ctx context.Context) (sa1 []string, err error)) *ClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the Client.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the Client.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	mmListTags.mock.funcListTagsOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// When sets expectation for the Client.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mClientMockListTags) When(ctx context.Context) *ClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	expectation := &ClientMockListTagsExpectation{
		mock:               mmListTags.mock,
		params:             &ClientMockListTagsParams{ctx},
		expectationOrigins: ClientMockListTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up Client.ListTags return parameters for the expectation previously defined by the When method
func (e *ClientMockListTagsExpectation) Then(sa1 []string, err error) *ClientMock {
	e.results = &ClientMockListTagsResults{sa1, err}
	return e.mock
}

// Times sets number of times Client.ListTags should be invoked
func (mmListTags *mClientMockListTags) Times(n uint64) *mClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of ClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	mmListTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTags
}

func (mmListTags *mClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements Client
func (mmListTags *ClientMock) ListTags(ctx context.Context) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	mmListTags.t.Helper()

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx)
	}

	mm_params := ClientMockListTagsParams{ctx}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockListTagsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("ClientMock.ListTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("ClientMock.ListTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the ClientMock.ListTags")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx)
	}
	mmListTags.t.Fatalf("Unexpected call to ClientMock.ListTags. %v", ctx)
	return
}

// ListTagsAfterCounter returns a count of finished ClientMock.ListTags invocations
func (mmListTags *ClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of ClientMock.ListTags invocations
func (mmListTags *ClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mClientMockListTags) Calls() []*ClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*ClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockListTagsDone() bool {
	if m.ListTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *ClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s", m.ListTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s with params: %#v", m.ListTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ListTags at\n%s", m.funcListTagsOrigin)
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ListTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), m.ListTagsMock.expectedInvocationsOrigin, afterListTagsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockDigestInspect()

			m.MinimockImageInspect()

			m.MinimockListTagsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockDigestDone() &&
		m.MinimockImageDone() &&
		m.MinimockListTagsDone()
}
