// Code generated by http://github.com/gojuno/minimock (v3.4.5). DO NOT EDIT.

package cr

//go:generate minimock -i github.com/deckhouse/deckhouse/go_lib/dependency/cr.Client -o cr_mock.go -n ClientMock -p cr

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	crv1 "github.com/google/go-containerregistry/pkg/v1"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcClearCache          func()
	funcClearCacheOrigin    string
	inspectFuncClearCache   func()
	afterClearCacheCounter  uint64
	beforeClearCacheCounter uint64
	ClearCacheMock          mClientMockClearCache

	funcDigest          func(ctx context.Context, tag string) (s1 string, err error)
	funcDigestOrigin    string
	inspectFuncDigest   func(ctx context.Context, tag string)
	afterDigestCounter  uint64
	beforeDigestCounter uint64
	DigestMock          mClientMockDigest

	funcImage          func(ctx context.Context, tag string) (i1 crv1.Image, err error)
	funcImageOrigin    string
	inspectFuncImage   func(ctx context.Context, tag string)
	afterImageCounter  uint64
	beforeImageCounter uint64
	ImageMock          mClientMockImage

	funcImageExists          func(ctx context.Context, tag string) (err error)
	funcImageExistsOrigin    string
	inspectFuncImageExists   func(ctx context.Context, tag string)
	afterImageExistsCounter  uint64
	beforeImageExistsCounter uint64
	ImageExistsMock          mClientMockImageExists

	funcListTags          func(ctx context.Context) (sa1 []string, err error)
	funcListTagsOrigin    string
	inspectFuncListTags   func(ctx context.Context)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mClientMockListTags
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ClearCacheMock = mClientMockClearCache{mock: m}

	m.DigestMock = mClientMockDigest{mock: m}
	m.DigestMock.callArgs = []*ClientMockDigestParams{}

	m.ImageMock = mClientMockImage{mock: m}
	m.ImageMock.callArgs = []*ClientMockImageParams{}

	m.ImageExistsMock = mClientMockImageExists{mock: m}
	m.ImageExistsMock.callArgs = []*ClientMockImageExistsParams{}

	m.ListTagsMock = mClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*ClientMockListTagsParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockClearCache struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockClearCacheExpectation
	expectations       []*ClientMockClearCacheExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockClearCacheExpectation specifies expectation struct of the Client.ClearCache
type ClientMockClearCacheExpectation struct {
	mock *ClientMock

	returnOrigin string
	Counter      uint64
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmClearCache *mClientMockClearCache) Optional() *mClientMockClearCache {
	mmClearCache.optional = true
	return mmClearCache
}

// Expect sets up expected params for Client.ClearCache
func (mmClearCache *mClientMockClearCache) Expect() *mClientMockClearCache {
	if mmClearCache.mock.funcClearCache != nil {
		mmClearCache.mock.t.Fatalf("ClientMock.ClearCache mock is already set by Set")
	}

	if mmClearCache.defaultExpectation == nil {
		mmClearCache.defaultExpectation = &ClientMockClearCacheExpectation{}
	}

	return mmClearCache
}

// Inspect accepts an inspector function that has same arguments as the Client.ClearCache
func (mmClearCache *mClientMockClearCache) Inspect(f func()) *mClientMockClearCache {
	if mmClearCache.mock.inspectFuncClearCache != nil {
		mmClearCache.mock.t.Fatalf("Inspect function is already set for ClientMock.ClearCache")
	}

	mmClearCache.mock.inspectFuncClearCache = f

	return mmClearCache
}

// Return sets up results that will be returned by Client.ClearCache
func (mmClearCache *mClientMockClearCache) Return() *ClientMock {
	if mmClearCache.mock.funcClearCache != nil {
		mmClearCache.mock.t.Fatalf("ClientMock.ClearCache mock is already set by Set")
	}

	if mmClearCache.defaultExpectation == nil {
		mmClearCache.defaultExpectation = &ClientMockClearCacheExpectation{mock: mmClearCache.mock}
	}

	mmClearCache.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmClearCache.mock
}

// Set uses given function f to mock the Client.ClearCache method
func (mmClearCache *mClientMockClearCache) Set(f func()) *ClientMock {
	if mmClearCache.defaultExpectation != nil {
		mmClearCache.mock.t.Fatalf("Default expectation is already set for the Client.ClearCache method")
	}

	if len(mmClearCache.expectations) > 0 {
		mmClearCache.mock.t.Fatalf("Some expectations are already set for the Client.ClearCache method")
	}

	mmClearCache.mock.funcClearCache = f
	mmClearCache.mock.funcClearCacheOrigin = minimock.CallerInfo(1)
	return mmClearCache.mock
}

// Times sets number of times Client.ClearCache should be invoked
func (mmClearCache *mClientMockClearCache) Times(n uint64) *mClientMockClearCache {
	if n == 0 {
		mmClearCache.mock.t.Fatalf("Times of ClientMock.ClearCache mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmClearCache.expectedInvocations, n)
	mmClearCache.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmClearCache
}

func (mmClearCache *mClientMockClearCache) invocationsDone() bool {
	if len(mmClearCache.expectations) == 0 && mmClearCache.defaultExpectation == nil && mmClearCache.mock.funcClearCache == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmClearCache.mock.afterClearCacheCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmClearCache.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ClearCache implements Client
func (mmClearCache *ClientMock) ClearCache() {
	mm_atomic.AddUint64(&mmClearCache.beforeClearCacheCounter, 1)
	defer mm_atomic.AddUint64(&mmClearCache.afterClearCacheCounter, 1)

	mmClearCache.t.Helper()

	if mmClearCache.inspectFuncClearCache != nil {
		mmClearCache.inspectFuncClearCache()
	}

	if mmClearCache.ClearCacheMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmClearCache.ClearCacheMock.defaultExpectation.Counter, 1)

		return

	}
	if mmClearCache.funcClearCache != nil {
		mmClearCache.funcClearCache()
		return
	}
	mmClearCache.t.Fatalf("Unexpected call to ClientMock.ClearCache.")

}

// ClearCacheAfterCounter returns a count of finished ClientMock.ClearCache invocations
func (mmClearCache *ClientMock) ClearCacheAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCache.afterClearCacheCounter)
}

// ClearCacheBeforeCounter returns a count of ClientMock.ClearCache invocations
func (mmClearCache *ClientMock) ClearCacheBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmClearCache.beforeClearCacheCounter)
}

// MinimockClearCacheDone returns true if the count of the ClearCache invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockClearCacheDone() bool {
	if m.ClearCacheMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ClearCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ClearCacheMock.invocationsDone()
}

// MinimockClearCacheInspect logs each unmet expectation
func (m *ClientMock) MinimockClearCacheInspect() {
	for _, e := range m.ClearCacheMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.ClearCache")
		}
	}

	afterClearCacheCounter := mm_atomic.LoadUint64(&m.afterClearCacheCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ClearCacheMock.defaultExpectation != nil && afterClearCacheCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ClearCache at\n%s", m.ClearCacheMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcClearCache != nil && afterClearCacheCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ClearCache at\n%s", m.funcClearCacheOrigin)
	}

	if !m.ClearCacheMock.invocationsDone() && afterClearCacheCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ClearCache at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ClearCacheMock.expectedInvocations), m.ClearCacheMock.expectedInvocationsOrigin, afterClearCacheCounter)
	}
}

type mClientMockDigest struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockDigestExpectation
	expectations       []*ClientMockDigestExpectation

	callArgs []*ClientMockDigestParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockDigestExpectation specifies expectation struct of the Client.Digest
type ClientMockDigestExpectation struct {
	mock               *ClientMock
	params             *ClientMockDigestParams
	paramPtrs          *ClientMockDigestParamPtrs
	expectationOrigins ClientMockDigestExpectationOrigins
	results            *ClientMockDigestResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockDigestParams contains parameters of the Client.Digest
type ClientMockDigestParams struct {
	ctx context.Context
	tag string
}

// ClientMockDigestParamPtrs contains pointers to parameters of the Client.Digest
type ClientMockDigestParamPtrs struct {
	ctx *context.Context
	tag *string
}

// ClientMockDigestResults contains results of the Client.Digest
type ClientMockDigestResults struct {
	s1  string
	err error
}

// ClientMockDigestOrigins contains origins of expectations of the Client.Digest
type ClientMockDigestExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmDigest *mClientMockDigest) Optional() *mClientMockDigest {
	mmDigest.optional = true
	return mmDigest
}

// Expect sets up expected params for Client.Digest
func (mmDigest *mClientMockDigest) Expect(ctx context.Context, tag string) *mClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &ClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.paramPtrs != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by ExpectParams functions")
	}

	mmDigest.defaultExpectation.params = &ClientMockDigestParams{ctx, tag}
	mmDigest.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmDigest.expectations {
		if minimock.Equal(e.params, mmDigest.defaultExpectation.params) {
			mmDigest.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmDigest.defaultExpectation.params)
		}
	}

	return mmDigest
}

// ExpectCtxParam1 sets up expected param ctx for Client.Digest
func (mmDigest *mClientMockDigest) ExpectCtxParam1(ctx context.Context) *mClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &ClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.params != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Expect")
	}

	if mmDigest.defaultExpectation.paramPtrs == nil {
		mmDigest.defaultExpectation.paramPtrs = &ClientMockDigestParamPtrs{}
	}
	mmDigest.defaultExpectation.paramPtrs.ctx = &ctx
	mmDigest.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmDigest
}

// ExpectTagParam2 sets up expected param tag for Client.Digest
func (mmDigest *mClientMockDigest) ExpectTagParam2(tag string) *mClientMockDigest {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &ClientMockDigestExpectation{}
	}

	if mmDigest.defaultExpectation.params != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Expect")
	}

	if mmDigest.defaultExpectation.paramPtrs == nil {
		mmDigest.defaultExpectation.paramPtrs = &ClientMockDigestParamPtrs{}
	}
	mmDigest.defaultExpectation.paramPtrs.tag = &tag
	mmDigest.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmDigest
}

// Inspect accepts an inspector function that has same arguments as the Client.Digest
func (mmDigest *mClientMockDigest) Inspect(f func(ctx context.Context, tag string)) *mClientMockDigest {
	if mmDigest.mock.inspectFuncDigest != nil {
		mmDigest.mock.t.Fatalf("Inspect function is already set for ClientMock.Digest")
	}

	mmDigest.mock.inspectFuncDigest = f

	return mmDigest
}

// Return sets up results that will be returned by Client.Digest
func (mmDigest *mClientMockDigest) Return(s1 string, err error) *ClientMock {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	if mmDigest.defaultExpectation == nil {
		mmDigest.defaultExpectation = &ClientMockDigestExpectation{mock: mmDigest.mock}
	}
	mmDigest.defaultExpectation.results = &ClientMockDigestResults{s1, err}
	mmDigest.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmDigest.mock
}

// Set uses given function f to mock the Client.Digest method
func (mmDigest *mClientMockDigest) Set(f func(ctx context.Context, tag string) (s1 string, err error)) *ClientMock {
	if mmDigest.defaultExpectation != nil {
		mmDigest.mock.t.Fatalf("Default expectation is already set for the Client.Digest method")
	}

	if len(mmDigest.expectations) > 0 {
		mmDigest.mock.t.Fatalf("Some expectations are already set for the Client.Digest method")
	}

	mmDigest.mock.funcDigest = f
	mmDigest.mock.funcDigestOrigin = minimock.CallerInfo(1)
	return mmDigest.mock
}

// When sets expectation for the Client.Digest which will trigger the result defined by the following
// Then helper
func (mmDigest *mClientMockDigest) When(ctx context.Context, tag string) *ClientMockDigestExpectation {
	if mmDigest.mock.funcDigest != nil {
		mmDigest.mock.t.Fatalf("ClientMock.Digest mock is already set by Set")
	}

	expectation := &ClientMockDigestExpectation{
		mock:               mmDigest.mock,
		params:             &ClientMockDigestParams{ctx, tag},
		expectationOrigins: ClientMockDigestExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmDigest.expectations = append(mmDigest.expectations, expectation)
	return expectation
}

// Then sets up Client.Digest return parameters for the expectation previously defined by the When method
func (e *ClientMockDigestExpectation) Then(s1 string, err error) *ClientMock {
	e.results = &ClientMockDigestResults{s1, err}
	return e.mock
}

// Times sets number of times Client.Digest should be invoked
func (mmDigest *mClientMockDigest) Times(n uint64) *mClientMockDigest {
	if n == 0 {
		mmDigest.mock.t.Fatalf("Times of ClientMock.Digest mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmDigest.expectedInvocations, n)
	mmDigest.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmDigest
}

func (mmDigest *mClientMockDigest) invocationsDone() bool {
	if len(mmDigest.expectations) == 0 && mmDigest.defaultExpectation == nil && mmDigest.mock.funcDigest == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmDigest.mock.afterDigestCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmDigest.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Digest implements Client
func (mmDigest *ClientMock) Digest(ctx context.Context, tag string) (s1 string, err error) {
	mm_atomic.AddUint64(&mmDigest.beforeDigestCounter, 1)
	defer mm_atomic.AddUint64(&mmDigest.afterDigestCounter, 1)

	mmDigest.t.Helper()

	if mmDigest.inspectFuncDigest != nil {
		mmDigest.inspectFuncDigest(ctx, tag)
	}

	mm_params := ClientMockDigestParams{ctx, tag}

	// Record call args
	mmDigest.DigestMock.mutex.Lock()
	mmDigest.DigestMock.callArgs = append(mmDigest.DigestMock.callArgs, &mm_params)
	mmDigest.DigestMock.mutex.Unlock()

	for _, e := range mmDigest.DigestMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.s1, e.results.err
		}
	}

	if mmDigest.DigestMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmDigest.DigestMock.defaultExpectation.Counter, 1)
		mm_want := mmDigest.DigestMock.defaultExpectation.params
		mm_want_ptrs := mmDigest.DigestMock.defaultExpectation.paramPtrs

		mm_got := ClientMockDigestParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmDigest.t.Errorf("ClientMock.Digest got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDigest.DigestMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmDigest.t.Errorf("ClientMock.Digest got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmDigest.DigestMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmDigest.t.Errorf("ClientMock.Digest got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmDigest.DigestMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmDigest.DigestMock.defaultExpectation.results
		if mm_results == nil {
			mmDigest.t.Fatal("No results are set for the ClientMock.Digest")
		}
		return (*mm_results).s1, (*mm_results).err
	}
	if mmDigest.funcDigest != nil {
		return mmDigest.funcDigest(ctx, tag)
	}
	mmDigest.t.Fatalf("Unexpected call to ClientMock.Digest. %v %v", ctx, tag)
	return
}

// DigestAfterCounter returns a count of finished ClientMock.Digest invocations
func (mmDigest *ClientMock) DigestAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigest.afterDigestCounter)
}

// DigestBeforeCounter returns a count of ClientMock.Digest invocations
func (mmDigest *ClientMock) DigestBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmDigest.beforeDigestCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Digest.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmDigest *mClientMockDigest) Calls() []*ClientMockDigestParams {
	mmDigest.mutex.RLock()

	argCopy := make([]*ClientMockDigestParams, len(mmDigest.callArgs))
	copy(argCopy, mmDigest.callArgs)

	mmDigest.mutex.RUnlock()

	return argCopy
}

// MinimockDigestDone returns true if the count of the Digest invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockDigestDone() bool {
	if m.DigestMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.DigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.DigestMock.invocationsDone()
}

// MinimockDigestInspect logs each unmet expectation
func (m *ClientMock) MinimockDigestInspect() {
	for _, e := range m.DigestMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Digest at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterDigestCounter := mm_atomic.LoadUint64(&m.afterDigestCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.DigestMock.defaultExpectation != nil && afterDigestCounter < 1 {
		if m.DigestMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Digest at\n%s", m.DigestMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Digest at\n%s with params: %#v", m.DigestMock.defaultExpectation.expectationOrigins.origin, *m.DigestMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcDigest != nil && afterDigestCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Digest at\n%s", m.funcDigestOrigin)
	}

	if !m.DigestMock.invocationsDone() && afterDigestCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Digest at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.DigestMock.expectedInvocations), m.DigestMock.expectedInvocationsOrigin, afterDigestCounter)
	}
}

type mClientMockImage struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockImageExpectation
	expectations       []*ClientMockImageExpectation

	callArgs []*ClientMockImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockImageExpectation specifies expectation struct of the Client.Image
type ClientMockImageExpectation struct {
	mock               *ClientMock
	params             *ClientMockImageParams
	paramPtrs          *ClientMockImageParamPtrs
	expectationOrigins ClientMockImageExpectationOrigins
	results            *ClientMockImageResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockImageParams contains parameters of the Client.Image
type ClientMockImageParams struct {
	ctx context.Context
	tag string
}

// ClientMockImageParamPtrs contains pointers to parameters of the Client.Image
type ClientMockImageParamPtrs struct {
	ctx *context.Context
	tag *string
}

// ClientMockImageResults contains results of the Client.Image
type ClientMockImageResults struct {
	i1  crv1.Image
	err error
}

// ClientMockImageOrigins contains origins of expectations of the Client.Image
type ClientMockImageExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImage *mClientMockImage) Optional() *mClientMockImage {
	mmImage.optional = true
	return mmImage
}

// Expect sets up expected params for Client.Image
func (mmImage *mClientMockImage) Expect(ctx context.Context, tag string) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.paramPtrs != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by ExpectParams functions")
	}

	mmImage.defaultExpectation.params = &ClientMockImageParams{ctx, tag}
	mmImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImage.expectations {
		if minimock.Equal(e.params, mmImage.defaultExpectation.params) {
			mmImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImage.defaultExpectation.params)
		}
	}

	return mmImage
}

// ExpectCtxParam1 sets up expected param ctx for Client.Image
func (mmImage *mClientMockImage) ExpectCtxParam1(ctx context.Context) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &ClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImage
}

// ExpectTagParam2 sets up expected param tag for Client.Image
func (mmImage *mClientMockImage) ExpectTagParam2(tag string) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &ClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.tag = &tag
	mmImage.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmImage
}

// Inspect accepts an inspector function that has same arguments as the Client.Image
func (mmImage *mClientMockImage) Inspect(f func(ctx context.Context, tag string)) *mClientMockImage {
	if mmImage.mock.inspectFuncImage != nil {
		mmImage.mock.t.Fatalf("Inspect function is already set for ClientMock.Image")
	}

	mmImage.mock.inspectFuncImage = f

	return mmImage
}

// Return sets up results that will be returned by Client.Image
func (mmImage *mClientMockImage) Return(i1 crv1.Image, err error) *ClientMock {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{mock: mmImage.mock}
	}
	mmImage.defaultExpectation.results = &ClientMockImageResults{i1, err}
	mmImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImage.mock
}

// Set uses given function f to mock the Client.Image method
func (mmImage *mClientMockImage) Set(f func(ctx context.Context, tag string) (i1 crv1.Image, err error)) *ClientMock {
	if mmImage.defaultExpectation != nil {
		mmImage.mock.t.Fatalf("Default expectation is already set for the Client.Image method")
	}

	if len(mmImage.expectations) > 0 {
		mmImage.mock.t.Fatalf("Some expectations are already set for the Client.Image method")
	}

	mmImage.mock.funcImage = f
	mmImage.mock.funcImageOrigin = minimock.CallerInfo(1)
	return mmImage.mock
}

// When sets expectation for the Client.Image which will trigger the result defined by the following
// Then helper
func (mmImage *mClientMockImage) When(ctx context.Context, tag string) *ClientMockImageExpectation {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	expectation := &ClientMockImageExpectation{
		mock:               mmImage.mock,
		params:             &ClientMockImageParams{ctx, tag},
		expectationOrigins: ClientMockImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImage.expectations = append(mmImage.expectations, expectation)
	return expectation
}

// Then sets up Client.Image return parameters for the expectation previously defined by the When method
func (e *ClientMockImageExpectation) Then(i1 crv1.Image, err error) *ClientMock {
	e.results = &ClientMockImageResults{i1, err}
	return e.mock
}

// Times sets number of times Client.Image should be invoked
func (mmImage *mClientMockImage) Times(n uint64) *mClientMockImage {
	if n == 0 {
		mmImage.mock.t.Fatalf("Times of ClientMock.Image mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImage.expectedInvocations, n)
	mmImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImage
}

func (mmImage *mClientMockImage) invocationsDone() bool {
	if len(mmImage.expectations) == 0 && mmImage.defaultExpectation == nil && mmImage.mock.funcImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImage.mock.afterImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Image implements Client
func (mmImage *ClientMock) Image(ctx context.Context, tag string) (i1 crv1.Image, err error) {
	mm_atomic.AddUint64(&mmImage.beforeImageCounter, 1)
	defer mm_atomic.AddUint64(&mmImage.afterImageCounter, 1)

	mmImage.t.Helper()

	if mmImage.inspectFuncImage != nil {
		mmImage.inspectFuncImage(ctx, tag)
	}

	mm_params := ClientMockImageParams{ctx, tag}

	// Record call args
	mmImage.ImageMock.mutex.Lock()
	mmImage.ImageMock.callArgs = append(mmImage.ImageMock.callArgs, &mm_params)
	mmImage.ImageMock.mutex.Unlock()

	for _, e := range mmImage.ImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmImage.ImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImage.ImageMock.defaultExpectation.Counter, 1)
		mm_want := mmImage.ImageMock.defaultExpectation.params
		mm_want_ptrs := mmImage.ImageMock.defaultExpectation.paramPtrs

		mm_got := ClientMockImageParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImage.t.Errorf("ClientMock.Image got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmImage.t.Errorf("ClientMock.Image got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImage.t.Errorf("ClientMock.Image got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImage.ImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImage.ImageMock.defaultExpectation.results
		if mm_results == nil {
			mmImage.t.Fatal("No results are set for the ClientMock.Image")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmImage.funcImage != nil {
		return mmImage.funcImage(ctx, tag)
	}
	mmImage.t.Fatalf("Unexpected call to ClientMock.Image. %v %v", ctx, tag)
	return
}

// ImageAfterCounter returns a count of finished ClientMock.Image invocations
func (mmImage *ClientMock) ImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImage.afterImageCounter)
}

// ImageBeforeCounter returns a count of ClientMock.Image invocations
func (mmImage *ClientMock) ImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImage.beforeImageCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Image.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImage *mClientMockImage) Calls() []*ClientMockImageParams {
	mmImage.mutex.RLock()

	argCopy := make([]*ClientMockImageParams, len(mmImage.callArgs))
	copy(argCopy, mmImage.callArgs)

	mmImage.mutex.RUnlock()

	return argCopy
}

// MinimockImageDone returns true if the count of the Image invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockImageDone() bool {
	if m.ImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImageMock.invocationsDone()
}

// MinimockImageInspect logs each unmet expectation
func (m *ClientMock) MinimockImageInspect() {
	for _, e := range m.ImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImageCounter := mm_atomic.LoadUint64(&m.afterImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImageMock.defaultExpectation != nil && afterImageCounter < 1 {
		if m.ImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s", m.ImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s with params: %#v", m.ImageMock.defaultExpectation.expectationOrigins.origin, *m.ImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImage != nil && afterImageCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Image at\n%s", m.funcImageOrigin)
	}

	if !m.ImageMock.invocationsDone() && afterImageCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Image at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImageMock.expectedInvocations), m.ImageMock.expectedInvocationsOrigin, afterImageCounter)
	}
}

type mClientMockImageExists struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockImageExistsExpectation
	expectations       []*ClientMockImageExistsExpectation

	callArgs []*ClientMockImageExistsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockImageExistsExpectation specifies expectation struct of the Client.ImageExists
type ClientMockImageExistsExpectation struct {
	mock               *ClientMock
	params             *ClientMockImageExistsParams
	paramPtrs          *ClientMockImageExistsParamPtrs
	expectationOrigins ClientMockImageExistsExpectationOrigins
	results            *ClientMockImageExistsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockImageExistsParams contains parameters of the Client.ImageExists
type ClientMockImageExistsParams struct {
	ctx context.Context
	tag string
}

// ClientMockImageExistsParamPtrs contains pointers to parameters of the Client.ImageExists
type ClientMockImageExistsParamPtrs struct {
	ctx *context.Context
	tag *string
}

// ClientMockImageExistsResults contains results of the Client.ImageExists
type ClientMockImageExistsResults struct {
	err error
}

// ClientMockImageExistsOrigins contains origins of expectations of the Client.ImageExists
type ClientMockImageExistsExpectationOrigins struct {
	origin    string
	originCtx string
	originTag string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImageExists *mClientMockImageExists) Optional() *mClientMockImageExists {
	mmImageExists.optional = true
	return mmImageExists
}

// Expect sets up expected params for Client.ImageExists
func (mmImageExists *mClientMockImageExists) Expect(ctx context.Context, tag string) *mClientMockImageExists {
	if mmImageExists.mock.funcImageExists != nil {
		mmImageExists.mock.t.Fatalf("ClientMock.ImageExists mock is already set by Set")
	}

	if mmImageExists.defaultExpectation == nil {
		mmImageExists.defaultExpectation = &ClientMockImageExistsExpectation{}
	}

	if mmImageExists.defaultExpectation.paramPtrs != nil {
		mmImageExists.mock.t.Fatalf("ClientMock.ImageExists mock is already set by ExpectParams functions")
	}

	mmImageExists.defaultExpectation.params = &ClientMockImageExistsParams{ctx, tag}
	mmImageExists.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImageExists.expectations {
		if minimock.Equal(e.params, mmImageExists.defaultExpectation.params) {
			mmImageExists.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImageExists.defaultExpectation.params)
		}
	}

	return mmImageExists
}

// ExpectCtxParam1 sets up expected param ctx for Client.ImageExists
func (mmImageExists *mClientMockImageExists) ExpectCtxParam1(ctx context.Context) *mClientMockImageExists {
	if mmImageExists.mock.funcImageExists != nil {
		mmImageExists.mock.t.Fatalf("ClientMock.ImageExists mock is already set by Set")
	}

	if mmImageExists.defaultExpectation == nil {
		mmImageExists.defaultExpectation = &ClientMockImageExistsExpectation{}
	}

	if mmImageExists.defaultExpectation.params != nil {
		mmImageExists.mock.t.Fatalf("ClientMock.ImageExists mock is already set by Expect")
	}

	if mmImageExists.defaultExpectation.paramPtrs == nil {
		mmImageExists.defaultExpectation.paramPtrs = &ClientMockImageExistsParamPtrs{}
	}
	mmImageExists.defaultExpectation.paramPtrs.ctx = &ctx
	mmImageExists.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImageExists
}

// ExpectTagParam2 sets up expected param tag for Client.ImageExists
func (mmImageExists *mClientMockImageExists) ExpectTagParam2(tag string) *mClientMockImageExists {
	if mmImageExists.mock.funcImageExists != nil {
		mmImageExists.mock.t.Fatalf("ClientMock.ImageExists mock is already set by Set")
	}

	if mmImageExists.defaultExpectation == nil {
		mmImageExists.defaultExpectation = &ClientMockImageExistsExpectation{}
	}

	if mmImageExists.defaultExpectation.params != nil {
		mmImageExists.mock.t.Fatalf("ClientMock.ImageExists mock is already set by Expect")
	}

	if mmImageExists.defaultExpectation.paramPtrs == nil {
		mmImageExists.defaultExpectation.paramPtrs = &ClientMockImageExistsParamPtrs{}
	}
	mmImageExists.defaultExpectation.paramPtrs.tag = &tag
	mmImageExists.defaultExpectation.expectationOrigins.originTag = minimock.CallerInfo(1)

	return mmImageExists
}

// Inspect accepts an inspector function that has same arguments as the Client.ImageExists
func (mmImageExists *mClientMockImageExists) Inspect(f func(ctx context.Context, tag string)) *mClientMockImageExists {
	if mmImageExists.mock.inspectFuncImageExists != nil {
		mmImageExists.mock.t.Fatalf("Inspect function is already set for ClientMock.ImageExists")
	}

	mmImageExists.mock.inspectFuncImageExists = f

	return mmImageExists
}

// Return sets up results that will be returned by Client.ImageExists
func (mmImageExists *mClientMockImageExists) Return(err error) *ClientMock {
	if mmImageExists.mock.funcImageExists != nil {
		mmImageExists.mock.t.Fatalf("ClientMock.ImageExists mock is already set by Set")
	}

	if mmImageExists.defaultExpectation == nil {
		mmImageExists.defaultExpectation = &ClientMockImageExistsExpectation{mock: mmImageExists.mock}
	}
	mmImageExists.defaultExpectation.results = &ClientMockImageExistsResults{err}
	mmImageExists.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImageExists.mock
}

// Set uses given function f to mock the Client.ImageExists method
func (mmImageExists *mClientMockImageExists) Set(f func(ctx context.Context, tag string) (err error)) *ClientMock {
	if mmImageExists.defaultExpectation != nil {
		mmImageExists.mock.t.Fatalf("Default expectation is already set for the Client.ImageExists method")
	}

	if len(mmImageExists.expectations) > 0 {
		mmImageExists.mock.t.Fatalf("Some expectations are already set for the Client.ImageExists method")
	}

	mmImageExists.mock.funcImageExists = f
	mmImageExists.mock.funcImageExistsOrigin = minimock.CallerInfo(1)
	return mmImageExists.mock
}

// When sets expectation for the Client.ImageExists which will trigger the result defined by the following
// Then helper
func (mmImageExists *mClientMockImageExists) When(ctx context.Context, tag string) *ClientMockImageExistsExpectation {
	if mmImageExists.mock.funcImageExists != nil {
		mmImageExists.mock.t.Fatalf("ClientMock.ImageExists mock is already set by Set")
	}

	expectation := &ClientMockImageExistsExpectation{
		mock:               mmImageExists.mock,
		params:             &ClientMockImageExistsParams{ctx, tag},
		expectationOrigins: ClientMockImageExistsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImageExists.expectations = append(mmImageExists.expectations, expectation)
	return expectation
}

// Then sets up Client.ImageExists return parameters for the expectation previously defined by the When method
func (e *ClientMockImageExistsExpectation) Then(err error) *ClientMock {
	e.results = &ClientMockImageExistsResults{err}
	return e.mock
}

// Times sets number of times Client.ImageExists should be invoked
func (mmImageExists *mClientMockImageExists) Times(n uint64) *mClientMockImageExists {
	if n == 0 {
		mmImageExists.mock.t.Fatalf("Times of ClientMock.ImageExists mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImageExists.expectedInvocations, n)
	mmImageExists.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImageExists
}

func (mmImageExists *mClientMockImageExists) invocationsDone() bool {
	if len(mmImageExists.expectations) == 0 && mmImageExists.defaultExpectation == nil && mmImageExists.mock.funcImageExists == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImageExists.mock.afterImageExistsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImageExists.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ImageExists implements Client
func (mmImageExists *ClientMock) ImageExists(ctx context.Context, tag string) (err error) {
	mm_atomic.AddUint64(&mmImageExists.beforeImageExistsCounter, 1)
	defer mm_atomic.AddUint64(&mmImageExists.afterImageExistsCounter, 1)

	mmImageExists.t.Helper()

	if mmImageExists.inspectFuncImageExists != nil {
		mmImageExists.inspectFuncImageExists(ctx, tag)
	}

	mm_params := ClientMockImageExistsParams{ctx, tag}

	// Record call args
	mmImageExists.ImageExistsMock.mutex.Lock()
	mmImageExists.ImageExistsMock.callArgs = append(mmImageExists.ImageExistsMock.callArgs, &mm_params)
	mmImageExists.ImageExistsMock.mutex.Unlock()

	for _, e := range mmImageExists.ImageExistsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmImageExists.ImageExistsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImageExists.ImageExistsMock.defaultExpectation.Counter, 1)
		mm_want := mmImageExists.ImageExistsMock.defaultExpectation.params
		mm_want_ptrs := mmImageExists.ImageExistsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockImageExistsParams{ctx, tag}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImageExists.t.Errorf("ClientMock.ImageExists got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImageExists.ImageExistsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.tag != nil && !minimock.Equal(*mm_want_ptrs.tag, mm_got.tag) {
				mmImageExists.t.Errorf("ClientMock.ImageExists got unexpected parameter tag, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImageExists.ImageExistsMock.defaultExpectation.expectationOrigins.originTag, *mm_want_ptrs.tag, mm_got.tag, minimock.Diff(*mm_want_ptrs.tag, mm_got.tag))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImageExists.t.Errorf("ClientMock.ImageExists got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImageExists.ImageExistsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImageExists.ImageExistsMock.defaultExpectation.results
		if mm_results == nil {
			mmImageExists.t.Fatal("No results are set for the ClientMock.ImageExists")
		}
		return (*mm_results).err
	}
	if mmImageExists.funcImageExists != nil {
		return mmImageExists.funcImageExists(ctx, tag)
	}
	mmImageExists.t.Fatalf("Unexpected call to ClientMock.ImageExists. %v %v", ctx, tag)
	return
}

// ImageExistsAfterCounter returns a count of finished ClientMock.ImageExists invocations
func (mmImageExists *ClientMock) ImageExistsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImageExists.afterImageExistsCounter)
}

// ImageExistsBeforeCounter returns a count of ClientMock.ImageExists invocations
func (mmImageExists *ClientMock) ImageExistsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImageExists.beforeImageExistsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ImageExists.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImageExists *mClientMockImageExists) Calls() []*ClientMockImageExistsParams {
	mmImageExists.mutex.RLock()

	argCopy := make([]*ClientMockImageExistsParams, len(mmImageExists.callArgs))
	copy(argCopy, mmImageExists.callArgs)

	mmImageExists.mutex.RUnlock()

	return argCopy
}

// MinimockImageExistsDone returns true if the count of the ImageExists invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockImageExistsDone() bool {
	if m.ImageExistsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImageExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImageExistsMock.invocationsDone()
}

// MinimockImageExistsInspect logs each unmet expectation
func (m *ClientMock) MinimockImageExistsInspect() {
	for _, e := range m.ImageExistsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ImageExists at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImageExistsCounter := mm_atomic.LoadUint64(&m.afterImageExistsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImageExistsMock.defaultExpectation != nil && afterImageExistsCounter < 1 {
		if m.ImageExistsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ImageExists at\n%s", m.ImageExistsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ImageExists at\n%s with params: %#v", m.ImageExistsMock.defaultExpectation.expectationOrigins.origin, *m.ImageExistsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImageExists != nil && afterImageExistsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ImageExists at\n%s", m.funcImageExistsOrigin)
	}

	if !m.ImageExistsMock.invocationsDone() && afterImageExistsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ImageExists at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImageExistsMock.expectedInvocations), m.ImageExistsMock.expectedInvocationsOrigin, afterImageExistsCounter)
	}
}

type mClientMockListTags struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockListTagsExpectation
	expectations       []*ClientMockListTagsExpectation

	callArgs []*ClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockListTagsExpectation specifies expectation struct of the Client.ListTags
type ClientMockListTagsExpectation struct {
	mock               *ClientMock
	params             *ClientMockListTagsParams
	paramPtrs          *ClientMockListTagsParamPtrs
	expectationOrigins ClientMockListTagsExpectationOrigins
	results            *ClientMockListTagsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockListTagsParams contains parameters of the Client.ListTags
type ClientMockListTagsParams struct {
	ctx context.Context
}

// ClientMockListTagsParamPtrs contains pointers to parameters of the Client.ListTags
type ClientMockListTagsParamPtrs struct {
	ctx *context.Context
}

// ClientMockListTagsResults contains results of the Client.ListTags
type ClientMockListTagsResults struct {
	sa1 []string
	err error
}

// ClientMockListTagsOrigins contains origins of expectations of the Client.ListTags
type ClientMockListTagsExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTags *mClientMockListTags) Optional() *mClientMockListTags {
	mmListTags.optional = true
	return mmListTags
}

// Expect sets up expected params for Client.ListTags
func (mmListTags *mClientMockListTags) Expect(ctx context.Context) *mClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &ClientMockListTagsParams{ctx}
	mmListTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for Client.ListTags
func (mmListTags *mClientMockListTags) ExpectCtxParam1(ctx context.Context) *mClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &ClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the Client.ListTags
func (mmListTags *mClientMockListTags) Inspect(f func(ctx context.Context)) *mClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for ClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by Client.ListTags
func (mmListTags *mClientMockListTags) Return(sa1 []string, err error) *ClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &ClientMockListTagsResults{sa1, err}
	mmListTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// Set uses given function f to mock the Client.ListTags method
func (mmListTags *mClientMockListTags) Set(f func(ctx context.Context) (sa1 []string, err error)) *ClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the Client.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the Client.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	mmListTags.mock.funcListTagsOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// When sets expectation for the Client.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mClientMockListTags) When(ctx context.Context) *ClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	expectation := &ClientMockListTagsExpectation{
		mock:               mmListTags.mock,
		params:             &ClientMockListTagsParams{ctx},
		expectationOrigins: ClientMockListTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up Client.ListTags return parameters for the expectation previously defined by the When method
func (e *ClientMockListTagsExpectation) Then(sa1 []string, err error) *ClientMock {
	e.results = &ClientMockListTagsResults{sa1, err}
	return e.mock
}

// Times sets number of times Client.ListTags should be invoked
func (mmListTags *mClientMockListTags) Times(n uint64) *mClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of ClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	mmListTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTags
}

func (mmListTags *mClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements Client
func (mmListTags *ClientMock) ListTags(ctx context.Context) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	mmListTags.t.Helper()

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx)
	}

	mm_params := ClientMockListTagsParams{ctx}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockListTagsParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("ClientMock.ListTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("ClientMock.ListTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the ClientMock.ListTags")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx)
	}
	mmListTags.t.Fatalf("Unexpected call to ClientMock.ListTags. %v", ctx)
	return
}

// ListTagsAfterCounter returns a count of finished ClientMock.ListTags invocations
func (mmListTags *ClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of ClientMock.ListTags invocations
func (mmListTags *ClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mClientMockListTags) Calls() []*ClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*ClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockListTagsDone() bool {
	if m.ListTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *ClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s", m.ListTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s with params: %#v", m.ListTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ListTags at\n%s", m.funcListTagsOrigin)
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ListTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), m.ListTagsMock.expectedInvocationsOrigin, afterListTagsCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockClearCacheInspect()

			m.MinimockDigestInspect()

			m.MinimockImageInspect()

			m.MinimockImageExistsInspect()

			m.MinimockListTagsInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockClearCacheDone() &&
		m.MinimockDigestDone() &&
		m.MinimockImageDone() &&
		m.MinimockImageExistsDone() &&
		m.MinimockListTagsDone()
}
