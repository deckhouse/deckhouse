apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: d8allowedhostpaths
  labels:
    heritage: deckhouse
    module: admission-policy-engine
    security.deckhouse.io: security-policy
  annotations:
    metadata.gatekeeper.sh/title: "Allowed Host Paths"
    metadata.gatekeeper.sh/version: 1.0.0
    description: >-
      Controls what host paths are allowed to be mount inside a container. 
spec:
  crd:
    spec:
      names:
        kind: D8AllowedHostPaths
      validation:
        openAPIV3Schema:
          type: object
          description: >-
            Controls what host paths are allowed to be mounted inside a container. 
          properties:
            allowedHostPaths:
              type: array
              description: "The list of allowed hostpath prefixes."
              items:
                type: object
                properties:
                  pathPrefix:
                    type: string
                  readOnly:
                    type: boolean
  targets:
    - target: admission.k8s.gatekeeper.sh
      code:
        - engine: Rego
          source:
            version: "v1"
            rego: |
              package d8.security_policies

              violation[{"details": {}, "msg": msg}] if {
                volume := input_hostpath_volumes[_]
                not allowed_by_any(volume)
                allowedPaths := get_allowed_paths(input)
                msg := sprintf(
                  "HostPath volume %v is not allowed, pod: %v. Allowed paths: %v",
                  [volume, input.review.object.metadata.name, allowedPaths],
                )
              }

              ### SecurityPolicy logic

              allowed_by_any(volume) if {
                allowed_by_securitypolicy(volume)
              }

              allowed_by_securitypolicy(volume) if {
                allowedPaths := get_allowed_paths(input)
                input_hostpath_allowed(allowedPaths, volume)
              }

              get_allowed_paths(arg) := out if {
                not arg.parameters
                out = []
              }

              get_allowed_paths(arg) := out if {
                not arg.parameters.allowedHostPaths
                out = []
              }

              get_allowed_paths(arg) := out if {
                out = arg.parameters.allowedHostPaths
              }

              input_hostpath_allowed(allowedPaths, volume) if {
                allowedHostPath := allowedPaths[_]
                path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
                not allowedHostPath.readOnly == true
              }

              input_hostpath_allowed(allowedPaths, volume) if {
                allowedHostPath := allowedPaths[_]
                path_matches(allowedHostPath.pathPrefix, volume.hostPath.path)
                allowedHostPath.readOnly
                not writeable_input_volume_mounts(volume.name)
              }

              writeable_input_volume_mounts(volume_name) if {
                container := input_containers[_]
                mount := container.volumeMounts[_]
                mount.name == volume_name
                not mount.readOnly
              }

              # This allows "/foo", "/foo/", "/foo/bar" etc., but
              # disallows "/fool", "/etc/foo" etc.
              path_matches(prefix, path) if {
                a := path_array(prefix)
                b := path_array(path)
                prefix_matches(a, b)
              }

              path_array(p) := out if {
                p != "/"
                out := split(trim(p, "/"), "/")
              }

              # This handles the special case for "/", since
              # split(trim("/", "/"), "/") == [""]
              path_array("/") := []

              prefix_matches(a, b) if {
                count(a) <= count(b)
                not any_not_equal_upto(a, b, count(a))
              }

              any_not_equal_upto(a, b, n) if {
                a[i] != b[i]
                i < n
              }

              ### SecurityPolicyException logic

              allowed_by_any(volume) if {
                allowed_by_securitypolicyexception(volume)
              }

              allowed_by_securitypolicyexception(volume) if {
                label := input.review.object.metadata.labels["security.deckhouse.io/securityPolicyException"]
                exception := data.inventory.cluster["deckhouse.io/v1alpha1"].SecurityPolicyException[label]
                allowedPaths := exception.spec.volumes.hostPath.allowedValues
                input_hostpath_allowed_exact(allowedPaths, volume)
              }

              input_hostpath_allowed_exact(allowedPaths, volume) if {
                allowedHostPath := allowedPaths[_]
                allowedHostPath.path == volume.hostPath.path
                volume_mount_matches_read_only(allowedHostPath.readOnly, volume.name)
              }

              volume_mount_matches_read_only(expectedReadOnly, volume_name) if {
                container := input_containers[_]
                mount := container.volumeMounts[_]
                mount.name == volume_name
                mount.readOnly == expectedReadOnly
              }

              ### Common logic

              input_hostpath_volumes contains v if {
                v := input.review.object.spec.volumes[_]
                has_field(v, "hostPath")
              }

              # has_field returns whether an object has a field
              has_field(object, field) if {
                object[field]
              }

              input_containers contains c if {
                c := input.review.object.spec.containers[_]
              }

              input_containers contains c if {
                c := input.review.object.spec.initContainers[_]
              }

              input_containers contains c if {
                c := input.review.object.spec.ephemeralContainers[_]
              }

