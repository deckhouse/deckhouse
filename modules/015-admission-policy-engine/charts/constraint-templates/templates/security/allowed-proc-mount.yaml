apiVersion: templates.gatekeeper.sh/v1
kind: ConstraintTemplate
metadata:
  name: d8allowedprocmount
  labels:
    heritage: deckhouse
    module: admission-policy-engine
    security.deckhouse.io: security-policy
  annotations:
    metadata.gatekeeper.sh/title: "Proc Mount"
    metadata.gatekeeper.sh/version: 1.0.1
    description: >-
      Controls the allowed `procMount` types for the container. Corresponds to
      the `allowedProcMountTypes` field in a PodSecurityPolicy. For more
      information, see
      https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowedprocmounttypes
spec:
  crd:
    spec:
      names:
        kind: D8AllowedProcMount
      validation:
        # Schema for the `parameters` field
        openAPIV3Schema:
          type: object
          description: >-
            Controls the allowed `procMount` types for the container. Corresponds to
            the `allowedProcMountTypes` field in a PodSecurityPolicy. For more
            information, see
            https://kubernetes.io/docs/concepts/policy/pod-security-policy/#allowedprocmounttypes
          properties:
            allowedProcMount:
              type: string
              description: >-
                Defines the strategy for the security exposure of certain paths
                in `/proc` by the container runtime. Setting to `Default` uses
                the runtime defaults, where `Unmasked` bypasses the default
                behavior.
              enum:
                - Default
                - Unmasked
  targets:
    - target: admission.k8s.gatekeeper.sh
      code:
        - engine: Rego
          source:
            version: "v1"
            rego: |
              package d8.security_policies

              container_annotation_key_prefix := "container.seccomp.security.alpha.kubernetes.io/"

              pod_annotation_key := "seccomp.security.alpha.kubernetes.io/pod"

              naming_translation := {
                # securityContext -> annotation
                "RuntimeDefault": ["runtime/default", "docker/default"],
                "Unconfined": ["unconfined"],
                "Localhost": ["localhost"],
                # annotation -> securityContext
                "runtime/default": ["RuntimeDefault"],
                "docker/default": ["RuntimeDefault"],
                "unconfined": ["Unconfined"],
                "localhost": ["Localhost"],
              }

              violation contains {"msg": msg} if {
                not input_wildcard_allowed_profiles
                allowed_profiles := get_allowed_profiles
                container := input_containers[name]
                result := get_profile(container)
                not allowed_by_any(result.profile, result.file, allowed_profiles)
                msg := get_message(result.profile, result.file, name, result.location, allowed_profiles)
              }

              allowed_by_any(profile, file, _) if {
                allowed_by_securitypolicyexception(profile, file)
              }

              allowed_by_any(profile, file, allowed_profiles) if {
                allowed_by_securitypolicy(profile, file, allowed_profiles)
              }

              allowed_by_securitypolicy(profile, file, allowed_profiles) if {
                is_exception := false
                allowed_profile(profile, file, allowed_profiles, is_exception)
              }

              allowed_by_securitypolicyexception(profile, file) if {
                exception_allowed_profiles := get_allowed_profiles_exception
                is_exception := true
                allowed_profile(profile, file, exception_allowed_profiles, is_exception)
              } 

              get_allowed_profiles_exception contains allowed if {
                label := input.review.object.metadata.labels["security.deckhouse.io/securityPolicyException"]
                exception := data.inventory.cluster["deckhouse.io/v1alpha1"].SecurityPolicyException[label]
                exception_allowed_profiles := exception.spec.securityContext.seccompProfile.allowedValues[_]
                allowed := exception_allowed_profiles
              }

              get_allowed_profiles_exception contains allowed if {
                label := input.review.object.metadata.labels["security.deckhouse.io/securityPolicyException"]
                exception := data.inventory.cluster["deckhouse.io/v1alpha1"].SecurityPolicyException[label]
                exception_allowed_profiles := exception.spec.securityContext.seccompProfile.allowedValues[_]
                startswith(exception_allowed_profiles, "localhost")
                allowed := naming_translation.localhost[_]
              }

              get_message(profile, file, name, location, allowed_profiles) := message if {
                not profile == "Localhost"
                message := sprintf("Seccomp profile '%v' is not allowed for container '%v'. Found at: %v. Allowed profiles: %v", [profile, name, location, allowed_profiles])
              }

              get_message(profile, file, name, location, allowed_profiles) := message if {
                profile == "Localhost"
                message := sprintf("Seccomp profile '%v' with file '%v' is not allowed for container '%v'. Found at: %v. Allowed profiles: %v", [profile, file, name, location, allowed_profiles])
              }

              input_wildcard_allowed_profiles if {
                input.parameters.allowedProfiles[_] == "*"
              }

              input_wildcard_allowed_files if {
                input.parameters.allowedLocalhostFiles[_] == "*"
              }

              input_wildcard_allowed_files if {
                "localhost/*" == input.parameters.allowedProfiles[_]
              }

              # Simple allowed Profiles
              allowed_profile(profile, file, allowed, exception) if {
                not exception
                not startswith(lower(profile), "localhost")
                profile == allowed[_]
              }

              # Simple allowed Profiles from SecurityPolicyException
              allowed_profile(profile, file, allowed, exception) if {
                exception
                profile == allowed[_]
              }

              # seccomp Localhost without wildcard
              allowed_profile(profile, file, allowed, _) if {
                profile == "Localhost"
                not input_wildcard_allowed_files
                profile == allowed[_]
                allowed_files := {x | x := object.get(input.parameters, "allowedLocalhostFiles", [])[_]} | get_annotation_localhost_files
                file == allowed_files[_]
              }

              # seccomp Localhost with wildcard
              allowed_profile(profile, file, allowed, _) if {
                profile == "Localhost"
                input_wildcard_allowed_files
                profile == allowed[_]
              }

              # annotation localhost with wildcard
              allowed_profile(profile, file, allowed, _) if {
                "localhost/*" == allowed[_]
                startswith(profile, "localhost/")
              }

              # annotation localhost without wildcard
              allowed_profile(profile, file, allowed, _) if {
                startswith(profile, "localhost/")
                profile == allowed[_]
              }

              # Localhost files from annotation scheme
              get_annotation_localhost_files contains file if {
                profile := input.parameters.allowedProfiles[_]
                startswith(profile, "localhost/")
                file := replace(profile, "localhost/", "")
              }

              # The profiles explicitly in the list
              get_allowed_profiles contains allowed if {
                allowed := input.parameters.allowedProfiles[_]
              }

              # The simply translated profiles
              get_allowed_profiles contains allowed if {
                profile := input.parameters.allowedProfiles[_]
                not startswith(lower(profile), "localhost")
                allowed := naming_translation[profile][_]
              }

              # Seccomp Localhost to annotation translation
              get_allowed_profiles contains allowed if {
                profile := input.parameters.allowedProfiles[_]
                profile == "Localhost"
                file := object.get(input.parameters, "allowedLocalhostFiles", [])[_]
                allowed := sprintf("%v/%v", [naming_translation[profile][_], file])
              }

              # Annotation localhost to Seccomp translation
              get_allowed_profiles contains allowed if {
                profile := input.parameters.allowedProfiles[_]
                startswith(profile, "localhost")
                allowed := naming_translation.localhost[_]
              }

              # Container profile as defined in pod annotation
              get_profile(container) := {"profile": profile, "file": "", "location": location} if {
                not has_securitycontext_container(container)
                not has_annotation(get_container_annotation_key(container.name))
                not has_securitycontext_pod
                profile := input.review.object.metadata.annotations[pod_annotation_key]
                location := sprintf("annotation %v", [pod_annotation_key])
              }

              # Container profile as defined in container annotation
              get_profile(container) := {"profile": profile, "file": "", "location": location} if {
                not has_securitycontext_container(container)
                not has_securitycontext_pod
                container_annotation := get_container_annotation_key(container.name)
                has_annotation(container_annotation)
                profile := input.review.object.metadata.annotations[container_annotation]
                location := sprintf("annotation %v", [container_annotation])
              }

              # Container profile as defined in pods securityContext
              get_profile(container) := {"profile": profile, "file": file, "location": location} if {
                not has_securitycontext_container(container)
                profile := input.review.object.spec.securityContext.seccompProfile.type
                file := object.get(input.review.object.spec.securityContext.seccompProfile, "localhostProfile", "")
                location := "pod securityContext"
              }

              # Container profile as defined in containers securityContext
              get_profile(container) := {"profile": profile, "file": file, "location": location} if {
                has_securitycontext_container(container)
                profile := container.securityContext.seccompProfile.type
                file := object.get(container.securityContext.seccompProfile, "localhostProfile", "")
                location := "container securityContext"
              }

              # Container profile missing
              get_profile(container) := {"profile": "undefined", "file": "", "location": "no explicit profile found"} if {
                not has_annotation(get_container_annotation_key(container.name))
                not has_annotation(pod_annotation_key)
                not has_securitycontext_pod
                not has_securitycontext_container(container)
              }

              has_annotation(annotation) if {
                input.review.object.metadata.annotations[annotation]
              }

              has_securitycontext_pod if {
                input.review.object.spec.securityContext.seccompProfile
              }

              has_securitycontext_container(container) if {
                container.securityContext.seccompProfile
              }

              get_container_annotation_key(name) := annotation if {
                annotation := concat("", [container_annotation_key_prefix, name])
              }

              input_containers[container.name] := container if {
                container := input.review.object.spec.containers[_]
              }

              input_containers[container.name] := container if {
                container := input.review.object.spec.initContainers[_]
              }

              input_containers[container.name] := container if {
                container := input.review.object.spec.ephemeralContainers[_]
              }
