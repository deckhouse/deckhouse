Subject: [PATCH] add resourceKubernetesOwnerReferencesV1
---
Index: kubernetes/provider.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/kubernetes/provider.go b/kubernetes/provider.go
--- a/kubernetes/provider.go	(revision be88f44271050f69d52f410bca388834afedfe71)
+++ b/kubernetes/provider.go	(date 1768787659361)
@@ -352,13 +352,14 @@
 			"kubernetes_csi_driver_v1":    resourceKubernetesCSIDriverV1(),

 			// provider helper resources
-			"kubernetes_labels":      resourceKubernetesLabels(),
-			"kubernetes_annotations": resourceKubernetesAnnotations(),
+			"kubernetes_labels":              resourceKubernetesLabels(),
+			"kubernetes_annotations":         resourceKubernetesAnnotations(),
+			"kubernetes_owner_references_v1": resourceKubernetesOwnerReferencesV1(),

 			// authentication
 			"kubernetes_token_request_v1": resourceKubernetesTokenRequestV1(),

-			//node
+			// node
 			"kubernetes_runtime_class_v1": resourceKubernetesRuntimeClassV1(),
 		},
 	}
@@ -464,7 +465,7 @@
 		// This is a TEMPORARY measure to work around https://github.com/hashicorp/terraform/issues/24055
 		// IMPORTANT: this will NOT enable a workaround of issue: https://github.com/hashicorp/terraform/issues/4149
 		// IMPORTANT: if the supplied configuration is incomplete or invalid
-		///IMPORTANT: provider operations will fail or attempt to connect to localhost endpoints
+		// /IMPORTANT: provider operations will fail or attempt to connect to localhost endpoints
 		cfg = &restclient.Config{}
 	}

Index: kubernetes/resource_kubernetes_owner_references_v1.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/kubernetes/resource_kubernetes_owner_references_v1.go b/kubernetes/resource_kubernetes_owner_references_v1.go
new file mode 100644
--- /dev/null	(date 1770028896055)
+++ b/kubernetes/resource_kubernetes_owner_references_v1.go	(date 1770028896055)
@@ -0,0 +1,315 @@
+// Copyright (c) HashiCorp, Inc.
+// SPDX-License-Identifier: MPL-2.0
+
+package kubernetes
+
+import (
+	"context"
+	"fmt"
+
+	"github.com/hashicorp/terraform-plugin-sdk/v2/diag"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/schema"
+	"github.com/hashicorp/terraform-plugin-sdk/v2/helper/validation"
+	"k8s.io/apimachinery/pkg/api/errors"
+	"k8s.io/apimachinery/pkg/api/meta"
+	v1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apimachinery/pkg/apis/meta/v1/unstructured"
+	k8sschema "k8s.io/apimachinery/pkg/runtime/schema"
+	"k8s.io/apimachinery/pkg/types"
+	"k8s.io/client-go/dynamic"
+	"k8s.io/client-go/restmapper"
+	"k8s.io/utils/ptr"
+
+	"github.com/hashicorp/terraform-provider-kubernetes/util"
+)
+
+func resourceKubernetesOwnerReferencesV1() *schema.Resource {
+	return &schema.Resource{
+		Description:   "This resource allows Terraform to manage the owner references for a resource that already exists. This resource uses [field management](https://kubernetes.io/docs/reference/using-api/server-side-apply/#field-management) and [server-side apply](https://kubernetes.io/docs/reference/using-api/server-side-apply/) to manage only the ownerReferences that are defined in the Terraform configuration. Existing ownerReferences not specified in the configuration will be ignored. If an ownerReference specified in the config and is already managed by another client it will cause a conflict which can be overridden by setting `force` to true.",
+		CreateContext: resourceKubernetesOwnerReferencesCreate,
+		ReadContext:   resourceKubernetesOwnerReferencesRead,
+		UpdateContext: resourceKubernetesOwnerReferencesUpdate,
+		DeleteContext: resourceKubernetesOwnerReferencesDelete,
+		Schema: map[string]*schema.Schema{
+			"api_version": {
+				Type:        schema.TypeString,
+				Description: "The apiVersion of the resource.",
+				Required:    true,
+				ForceNew:    true,
+			},
+			"kind": {
+				Type:        schema.TypeString,
+				Description: "The kind of the resource.",
+				Required:    true,
+				ForceNew:    true,
+			},
+			"metadata": {
+				Type:     schema.TypeList,
+				Required: true,
+				MaxItems: 1,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"name": {
+							Type:        schema.TypeString,
+							Description: "The name of the resource.",
+							Required:    true,
+							ForceNew:    true,
+						},
+						"namespace": {
+							Type:        schema.TypeString,
+							Description: "The namespace of the resource.",
+							Optional:    true,
+							ForceNew:    true,
+						},
+					},
+				},
+			},
+			"owner_references": {
+				Type:        schema.TypeList,
+				Description: "A list of ownerReferences to apply to the resource.",
+				Optional:    true,
+				Elem: &schema.Resource{
+					Schema: map[string]*schema.Schema{
+						"api_version": {
+							Type:        schema.TypeString,
+							Description: "The apiVersion of the referenced resource.",
+							Required:    true,
+							ForceNew:    true,
+						},
+						"kind": {
+							Type:        schema.TypeString,
+							Description: "The kind of the referenced resource.",
+							Required:    true,
+							ForceNew:    true,
+						},
+						"name": {
+							Type:        schema.TypeString,
+							Description: "The name of the referenced resource.",
+							Required:    true,
+							ForceNew:    true,
+						},
+						"uid": {
+							Type:        schema.TypeString,
+							Description: "The uid of the referenced resource.",
+							Required:    true,
+							ForceNew:    true,
+						},
+					},
+				},
+			},
+			"force": {
+				Type:        schema.TypeBool,
+				Description: "Force overwriting labels that were created or edited outside of Terraform.",
+				Optional:    true,
+			},
+			"field_manager": {
+				Type:         schema.TypeString,
+				Description:  "Set the name of the field manager for the specified labels.",
+				Optional:     true,
+				Default:      defaultFieldManagerName,
+				ValidateFunc: validation.StringIsNotWhiteSpace,
+			},
+		},
+	}
+}
+
+func resourceKubernetesOwnerReferencesCreate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
+	metadata := expandMetadata(d.Get("metadata").([]interface{}))
+	d.SetId(buildIdWithVersionKind(metadata,
+		d.Get("api_version").(string),
+		d.Get("kind").(string)))
+	diag := resourceKubernetesOwnerReferencesUpdate(ctx, d, m)
+	if diag.HasError() {
+		d.SetId("")
+	}
+	return diag
+}
+
+func resourceKubernetesOwnerReferencesRead(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
+	conn, err := m.(KubeClientsets).DynamicClient()
+	if err != nil {
+		return diag.FromErr(err)
+	}
+
+	gvk, name, namespace, err := util.ParseResourceID(d.Id())
+	if err != nil {
+		return diag.FromErr(err)
+	}
+
+	// figure out which resource client to use
+	dc, err := m.(KubeClientsets).DiscoveryClient()
+	if err != nil {
+		return diag.FromErr(err)
+	}
+	agr, err := restmapper.GetAPIGroupResources(dc)
+	if err != nil {
+		return diag.FromErr(err)
+	}
+	restMapper := restmapper.NewDiscoveryRESTMapper(agr)
+	mapping, err := restMapper.RESTMapping(gvk.GroupKind(), gvk.Version)
+	if err != nil {
+		return diag.FromErr(err)
+	}
+
+	// determine if the resource is namespaced or not
+	var r dynamic.ResourceInterface
+	if mapping.Scope.Name() == meta.RESTScopeNameNamespace {
+		if namespace == "" {
+			namespace = "default"
+		}
+		r = conn.Resource(mapping.Resource).Namespace(namespace)
+	} else {
+		r = conn.Resource(mapping.Resource)
+	}
+
+	// get the resource
+	res, err := r.Get(ctx, name, v1.GetOptions{})
+	if err != nil {
+		if errors.IsNotFound(err) {
+			return diag.Diagnostics{{
+				Severity: diag.Warning,
+				Summary:  "Resource deleted",
+				Detail:   fmt.Sprintf("The underlying resource %q has been deleted. You should recreate the underlying resource, or remove it from your configuration.", name),
+			}}
+		}
+		return diag.FromErr(err)
+	}
+
+	ownerReferences := res.GetOwnerReferences()
+	ownerReferencesList := make([]interface{}, len(ownerReferences))
+	for _, ownerReference := range ownerReferences {
+		ownerReferencesList = append(ownerReferencesList, map[string]interface{}{
+			"api_version": ownerReference.APIVersion,
+			"kind":        ownerReference.Kind,
+			"name":        ownerReference.Name,
+			"uid":         string(ownerReference.UID),
+		})
+	}
+	d.Set("owner_references", ownerReferencesList)
+
+	return nil
+}
+
+func resourceKubernetesOwnerReferencesUpdate(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
+	conn, err := m.(KubeClientsets).DynamicClient()
+	if err != nil {
+		return diag.FromErr(err)
+	}
+
+	apiVersion := d.Get("api_version").(string)
+	kind := d.Get("kind").(string)
+	metadata := expandMetadata(d.Get("metadata").([]interface{}))
+	name := metadata.GetName()
+	namespace := metadata.GetNamespace()
+
+	// figure out which resource client to use
+	dc, err := m.(KubeClientsets).DiscoveryClient()
+	if err != nil {
+		return diag.FromErr(err)
+	}
+	agr, err := restmapper.GetAPIGroupResources(dc)
+	if err != nil {
+		return diag.FromErr(err)
+	}
+	restMapper := restmapper.NewDiscoveryRESTMapper(agr)
+	gv, err := k8sschema.ParseGroupVersion(apiVersion)
+	if err != nil {
+		return diag.FromErr(err)
+
+	}
+	mapping, err := restMapper.RESTMapping(gv.WithKind(kind).GroupKind(), gv.Version)
+	if err != nil {
+		return diag.FromErr(err)
+	}
+
+	// determine if the resource is namespaced or not
+	var r dynamic.ResourceInterface
+	namespacedResource := mapping.Scope.Name() == meta.RESTScopeNameNamespace
+	if namespacedResource {
+		if namespace == "" {
+			namespace = "default"
+		}
+		r = conn.Resource(mapping.Resource).Namespace(namespace)
+	} else {
+		r = conn.Resource(mapping.Resource)
+	}
+
+	// check the resource exists before we try and patch it
+	_, err = r.Get(ctx, name, v1.GetOptions{})
+	if err != nil {
+		if d.Id() == "" {
+			// if we are deleting then there is nothing to do
+			// if the resource is gone
+			return nil
+		}
+		return diag.Errorf("The resource %q does not exist", name)
+	}
+
+	// craft the patch to update the ownerReferences
+	ownerReferences := []v1.OwnerReference{}
+	if ownerReferencesList, ok := d.GetOk("owner_references"); ok {
+		for i := range ownerReferencesList.([]interface{}) {
+			ownerReferences = append(ownerReferences, v1.OwnerReference{
+				APIVersion: ownerReferencesList.([]interface{})[i].(map[string]interface{})["api_version"].(string),
+				Kind:       ownerReferencesList.([]interface{})[i].(map[string]interface{})["kind"].(string),
+				Name:       ownerReferencesList.([]interface{})[i].(map[string]interface{})["name"].(string),
+				UID:        types.UID(ownerReferencesList.([]interface{})[i].(map[string]interface{})["uid"].(string)),
+			})
+		}
+	}
+	if d.Id() == "" {
+		// if we're deleting then just we just patch
+		// with an empty ownerReferences map
+		ownerReferences = []v1.OwnerReference{}
+	}
+	patchmeta := map[string]interface{}{
+		"name":            name,
+		"ownerReferences": ownerReferences,
+	}
+	if namespacedResource {
+		patchmeta["namespace"] = namespace
+	}
+	patchobj := map[string]interface{}{
+		"apiVersion": apiVersion,
+		"kind":       kind,
+		"metadata":   patchmeta,
+	}
+
+	patch := unstructured.Unstructured{}
+	patch.Object = patchobj
+	patchbytes, err := patch.MarshalJSON()
+	if err != nil {
+		return diag.FromErr(fmt.Errorf("%s %v", patchbytes, err))
+	}
+	// apply the patch
+	_, err = r.Patch(ctx,
+		name,
+		types.ApplyPatchType,
+		patchbytes,
+		v1.PatchOptions{
+			FieldManager: d.Get("field_manager").(string),
+			Force:        ptr.To(d.Get("force").(bool)),
+		},
+	)
+	if err != nil {
+		if errors.IsConflict(err) {
+			return diag.Diagnostics{{
+				Severity: diag.Error,
+				Summary:  "Field manager conflict",
+				Detail:   fmt.Sprintf(`Another client is managing a field Terraform tried to update. Set "force" to true to override: %v`, err),
+			}}
+		}
+		return diag.FromErr(err)
+	}
+
+	if d.Id() == "" {
+		// don't try to read if we're deleting
+		return nil
+	}
+	return resourceKubernetesOwnerReferencesRead(ctx, d, m)
+}
+
+func resourceKubernetesOwnerReferencesDelete(ctx context.Context, d *schema.ResourceData, m interface{}) diag.Diagnostics {
+	d.SetId("")
+	return resourceKubernetesOwnerReferencesUpdate(ctx, d, m)
+}
