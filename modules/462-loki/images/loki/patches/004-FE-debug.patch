diff --git a/pkg/storage/stores/indexshipper/compactor/compactor.go b/pkg/storage/stores/indexshipper/compactor/compactor.go
index a3ba20ea8540e645a8a365991d53443b434f2a18..39ce81c624d366b3c1f03b23278c5dfde85fa503 100644
--- a/pkg/storage/stores/indexshipper/compactor/compactor.go
+++ b/pkg/storage/stores/indexshipper/compactor/compactor.go
@@ -834,7 +834,18 @@ func sortTablesByRange(tables []string) {
 		// less than if start time is after produces a most recent first sort order
 		return tableRanges[tables[i]].Start.After(tableRanges[tables[j]].Start)
 	})
+}
+
+func sortTablesByRangeOldestFirst(tables []string) {
+	tableRanges := make(map[string]model.Interval)
+	for _, table := range tables {
+		tableRanges[table] = retention.ExtractIntervalFromTableName(table)
+	}

+	sort.Slice(tables, func(i, j int) bool {
+		// less than if end time is before produces oldest first sort order
+		return tableRanges[tables[i]].End.Before(tableRanges[tables[j]].End)
+	})
 }

 func schemaPeriodForTable(cfg config.SchemaConfig, tableName string) (config.PeriodConfig, bool) {
diff --git a/pkg/storage/stores/indexshipper/compactor/force_expiration.go b/pkg/storage/stores/indexshipper/compactor/force_expiration.go
index c9aa63acd33a7c8ed4f718f04d82fadd8516d2db..2d5e3fcb6942031b5aa2a3cab615411d914e19dc 100644
--- a/pkg/storage/stores/indexshipper/compactor/force_expiration.go
+++ b/pkg/storage/stores/indexshipper/compactor/force_expiration.go
@@ -8,6 +8,7 @@ import (
 	"path"
 	"path/filepath"
 	"strings"
+	"sync/atomic"
 	"time"
 	"unsafe"

@@ -28,6 +29,9 @@ type forceExpirationHook struct {
 	dirUsageThresholdDir       string
 	dirUsageThresholdChunksDir string

+	firstExpiredChunkTs atomic.Int64
+	lastExpiredChunkTs  atomic.Int64
+
 	c  *Compactor
 	cm *retention.ForceExpirationCheckerManager
 	m  *forceExpirationHookMetrics
@@ -57,6 +61,9 @@ func (h *forceExpirationHook) apply(ctx context.Context) {
 		return
 	}

+	h.firstExpiredChunkTs.Store(0)
+	h.lastExpiredChunkTs.Store(0)
+
 	exceeded, bytesToDelete := h.isDirUsageThresholdExceeded()
 	if !exceeded {
 		return
@@ -88,6 +95,8 @@ func (h *forceExpirationHook) apply(ctx context.Context) {
 			)
 			continue
 		}
+		tables = excludeNewest(tables)
+		h.m.lastIndexRange.WithLabelValues(tables[0], tables[len(tables)-1]).SetToCurrentTime()
 		_ = level.Info(util_log.Logger).Log(
 			"msg", "found stored tables",
 			"tables", strings.Join(tables, ","),
@@ -165,10 +174,17 @@ func (h *forceExpirationHook) listTables(ctx context.Context, indexStorageClient
 		}
 		filteredTables = append(filteredTables, tableName)
 	}
-	sortTablesByRange(filteredTables)
+	sortTablesByRangeOldestFirst(filteredTables)
 	return filteredTables, nil
 }

+func excludeNewest(tables []string) []string {
+	if len(tables) == 1 {
+		return tables
+	}
+	return tables[:len(tables)-1]
+}
+
 func (h *forceExpirationHook) loadTableCompactedIndex(ctx context.Context, tableName string) (CompactedIndex, error) {
 	schemaCfg, ok := schemaPeriodForTable(h.c.schemaConfig, tableName)
 	if !ok {
@@ -257,7 +273,27 @@ func (h *forceExpirationHook) evaluateExpiredChunks(ctx context.Context, tableCo
 			return false, nil
 		}

-		h.m.lastExpiredChunkTimestampSeconds.Set(float64(chk.Through.Unix()))
+		currentChunkFrom := chk.From.Unix()
+		firstExpiredChunkTs := h.firstExpiredChunkTs.Load()
+		if firstExpiredChunkTs == 0 && currentChunkFrom > 0 {
+			firstExpiredChunkTs = currentChunkFrom
+		}
+		if currentChunkFrom > 0 && currentChunkFrom < firstExpiredChunkTs {
+			firstExpiredChunkTs = currentChunkFrom
+		}
+		h.firstExpiredChunkTs.Store(firstExpiredChunkTs)
+		h.m.firstExpiredChunkTimestampSeconds.Set(float64(firstExpiredChunkTs))
+
+		currentChunkTo := chk.Through.Unix()
+		lastExpiredChunkTs := h.lastExpiredChunkTs.Load()
+		if lastExpiredChunkTs == 0 && currentChunkTo > 0 {
+			lastExpiredChunkTs = currentChunkTo
+		}
+		if currentChunkTo > 0 && currentChunkTo > lastExpiredChunkTs {
+			lastExpiredChunkTs = currentChunkTo
+		}
+		h.lastExpiredChunkTs.Store(lastExpiredChunkTs)
+		h.m.lastExpiredChunkTimestampSeconds.Set(float64(lastExpiredChunkTs))

 		chunksToDelete = append(chunksToDelete, chunkID)
 		bytesDeleted = bytesDeleted + chkSize
@@ -350,17 +386,29 @@ var base64Encoder = func(key string) string {
 // metrics

 type forceExpirationHookMetrics struct {
-	lastExpiredChunkTimestampSeconds prometheus.Gauge
-	expiredChunksCount               prometheus.Counter
-	expiredChunksIncrement           prometheus.Counter
-	expiredChunksSizeBytes           prometheus.Counter
-	dirUsageThresholdBytes           *prometheus.GaugeVec
-	dirUsageBytes                    *prometheus.GaugeVec
-	dirUsageEvaluationDuration       *prometheus.HistogramVec
+	lastIndexRange                    *prometheus.GaugeVec
+	firstExpiredChunkTimestampSeconds prometheus.Gauge
+	lastExpiredChunkTimestampSeconds  prometheus.Gauge
+	expiredChunksCount                prometheus.Counter
+	expiredChunksIncrement            prometheus.Counter
+	expiredChunksSizeBytes            prometheus.Counter
+	dirUsageThresholdBytes            *prometheus.GaugeVec
+	dirUsageBytes                     *prometheus.GaugeVec
+	dirUsageEvaluationDuration        *prometheus.HistogramVec
 }

 func newForceExpirationHookMetrics(r prometheus.Registerer) *forceExpirationHookMetrics {
 	m := forceExpirationHookMetrics{
+		lastIndexRange: promauto.With(r).NewGaugeVec(prometheus.GaugeOpts{
+			Namespace: "force_expiration_hook",
+			Name:      "index_range",
+			Help:      "Index range",
+		}, []string{"first", "last"}),
+		firstExpiredChunkTimestampSeconds: promauto.With(r).NewGauge(prometheus.GaugeOpts{
+			Namespace: "force_expiration_hook",
+			Name:      "first_expired_chunk_timestamp_seconds",
+			Help:      "Unix epoch timestamp of first expired chunk",
+		}),
 		lastExpiredChunkTimestampSeconds: promauto.With(r).NewGauge(prometheus.GaugeOpts{
 			Namespace: "force_expiration_hook",
 			Name:      "last_expired_chunk_timestamp_seconds",
