diff --git a/pkg/storage/stores/indexshipper/compactor/force_expiration.go b/pkg/storage/stores/indexshipper/compactor/force_expiration.go
index 7faee517ea94c3c1faeb50d563d93ae40caad4e3..140984f305278af19975f7355c5dc52a97f2af4e 100644
--- a/pkg/storage/stores/indexshipper/compactor/force_expiration.go
+++ b/pkg/storage/stores/indexshipper/compactor/force_expiration.go
@@ -4,11 +4,13 @@ import (
 	"context"
 	"encoding/base64"
 	"fmt"
+	"io/fs"
 	"os"
 	"path"
 	"path/filepath"
 	"strings"
 	"sync/atomic"
+	"syscall"
 	"time"
 	"unsafe"

@@ -339,14 +341,32 @@ func (h *forceExpirationHook) isDirUsageThresholdExceeded() (exceeded bool, byte

 func evaluateDirSize(path string) (int64, error) {
 	var size int64
-	err := filepath.Walk(path, func(_ string, info os.FileInfo, err error) error {
+	err := filepath.WalkDir(path, func(_ string, entry os.DirEntry, err error) error {
 		if err != nil {
 			return err
 		}
-		if !info.IsDir() {
-			size += info.Size()
+		if entry.Type().IsRegular() {
+			info, infoGetErr := entry.Info()
+			if infoGetErr != nil {
+				_ = level.Warn(util_log.Logger).Log(
+					"msg", "unable to evaluate file size for dir size, skipping file",
+					"reason", fmt.Errorf("failed to get entry info: %w", infoGetErr),
+				)
+				// skip file
+				return nil
+			}
+			fileSize, extractFileSizeErr := extractFileSize(info)
+			if extractFileSizeErr != nil {
+				_ = level.Warn(util_log.Logger).Log(
+					"msg", "unable to evaluate file size for dir size, skipping file",
+					"reason", fmt.Errorf("failed to extract file size: %w", extractFileSizeErr),
+				)
+				// skip file
+				return nil
+			}
+			size += fileSize
 		}
-		return err
+		return nil
 	})
 	return size, err
 }
@@ -361,8 +381,23 @@ func evaluateFileSize(path string) (int64, error) {
 	case err != nil:
 		return 0, err
 	default:
-		return stat.Size(), nil
+		return extractFileSize(stat)
+	}
+}
+
+const (
+	statBlkSizeBytes = 512
+)
+
+// extractFileSize extracts file size from fs.FileInfo
+// we use this method since both evaluateDirSize and evaluateFileSize uses os.Lstat under the hood
+func extractFileSize(info fs.FileInfo) (int64, error) {
+	statResp, ok := info.Sys().(*syscall.Stat_t)
+	if !ok {
+		return 0, fmt.Errorf("failed to evaluate Stat_t info: %T", info.Sys())
 	}
+	// st_blocks indicates the number of blocks allocated to the file, in 512-byte units
+	return statResp.Blocks * statBlkSizeBytes, nil
 }

 // helper functions
