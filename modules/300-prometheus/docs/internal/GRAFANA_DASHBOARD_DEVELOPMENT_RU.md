---
title: "Prometheus-мониторинг: Разработка графиков Grafana"
type:
  - instruction
search: grafana разработка графиков
---

1. Для создания dashboard'ов в Grafana реализован ресурс [GrafanaDashboardDefinition](cr.html#grafanadashboarddefinition). У Pod'а с Grafana работает sidecar-контейнер с [shell-operator](https://github.com/flant/shell-operator), у которого есть хук, который следит за данным ресурсом. При соответствующем событии, хук создаёт/удаляет/правит соответствующий dashboard через специальный механизм.
2. В модулях манифесты dashboard лежат в директории `<module_root>/monitoring/grafana-dashboards/`. Они автоматически преобразуются в ресурсы [GrafanaDashboardDefinition](cr.html#grafanadashboarddefinition), при этом:
   * каждая поддиректория в этой директории соответствует Folder'у в Grafana,
   * а каждый файл — Dashboard'у в Grafana.
3. Если нужно добавить новый Folder, то просто создаём папку в каталоге `grafana-dashboards/` и добавляем туда хотя бы один JSON-манифест.
4. Править Dashboard'ы в файлах не нужно (если только это не какая-то совсем простая правка), вместо этого:
   * Открываем Dashboard в Grafana:
     * если это один из существующих — открываем его и [нажимаем кнопку Make editable](/docs/documentation/images/300-prometheus/grafana_make_editable.jpg);
     * если это новый — его необходимо просто создать (в любом Folder, это не важно, он потом переедет в тот, в который будет положен в репозитарии);
     * если это чужой готовый Dashboard — его можно импортировать в Grafana (там есть кнопка Import).
   * Меняем, меняем, меняем... до тех пор, пока не станем довольны Dashboard'ом. Лучше периодически нажимать на кнопку сохранить в Grafana чтобы, если браузер упадет, не потерять изменения.
   * [Выгружаем Dashboard в JSON](/docs/documentation/images/300-prometheus/grafana_export.jpg) и сохраняем в файл (новый или существующий).
5. Можно менять название Dashboard'а, название файла, переносить файл между Folder'ами — все подцепится автоматически.
6. Системные dashboard'ы должны хранится в ресурсах `GrafanaDashboardDefinition` с префиксом `d8` в имени.

## Как быстро привести чужой dashboard более-менее в порядок?

1. Заменить `irate` на `rate`:

   ```shell
   sed 's/irate(/rate(/g' -i *.json
   ```

2. Заменить `Resolution` на `1/1`:

   ```shell
   sed 's/"intervalFactor":\s[0-9]/"intervalFactor": 1/' -i *.json
   ```

3. Убрать `Min Step`:

   ```shell
   sed '/"interval":/d' -i *.json
   ```

4. Заменить все графики на `Staircase` (поломает графики `Stack` + `Percent`, которые придется поправить руками на `Bars`):

   ```shell
   sed 's/"steppedLine": false/"steppedLine": true/' -i *.json
   ```

## Лучшие практики

### Сохраняйте uid Dashboard'а

При любых изменениях (в том числе при переименовании и переносе между Folder'ами) сохраняйте uid Dashboard'а (он обычно на одной из последних строк в JSON-файле). В этом случае все старые ссылки продолжат работать. Для этого никаких специальных действий не требуется, просто не меняйте намерено.

### Следите за изменениями в JSON-файлах

Редактировать JSON-файлы напрямую не стоит (это неудобно), а вот после внесения изменений в интерфейсе Grafana и выгрузки JSON-файла — обязательно стоит внимательно посмотреть, что изменилось, чтобы удостовериться, что случайно не поправили лишнего. Для этого есть `git add -p` и diff'ы в MR'ах, кому как удобней.

При изменении сложных Dashboard'ов, использующих функционал шаблонизирования, старайтесь редактировать Dashboard там же, где он был создан (обычно это <https://prometheus.kube.domain.my/>) и с теми же значениями в Variables — тогда в MR'е не будет множества лишних изменений "динамических данных".

### Что делать если мне нужно при отсутствии данных "прятать" дашборд или часть дашборда?

Не нужно пытаться генерировать Grafana Dashboard средствами Helm'а. Лучше заведите Issue в Grafana, чтобы сделали поддержку такого функционала.

## Требования к Dashboard'ам

### Job должен быть явно указан

Как и при разработке правил для Prometheus, необходимо всегда [явно указывать job](prometheus_rules_development.html#всегда-явно-указывать-job), чтобы гарантированно избежать конфликтов в именах метрик.

### Prometheus должен выбираться

В наших Grafana может быть доступно несколько Prometheus'ов (с разной степенью детализации данных и разным периодом хранения), а значит должна быть возможность удобного выбора сервера Prometheus. Чтобы это сделать, нужно:
* [создать](/docs/documentation/images/300-prometheus/grafana_ds_prometheus_variable.jpg) переменную `$ds_prometheus`
* в каждой панели [указать](/docs/documentation/images/300-prometheus/grafana_ds_prometheus_select_in_panel.jpg) именно `$ds_prometheus` в качестве data source, а не один из конкретных Prometheus'ов

### Graph Tooltip должен быть в режиме Shared crosshair

Одна из важнейших возможностей, которую предоставляют графики — возможность визуального анализа корреляций. Но, чтобы проводить такой анализ — нужно сопоставлять одну точку во времени на разных графиках, и если графики все одного размера и показаны друг под другом — это не создает проблем, но делать все графики одного размера не всегда возможно (и всегда некрасиво).

[Включайте](/docs/documentation/images/300-prometheus/grafana_graph_tooltip.jpg) Graph Tooltip всегда в режим Shared crosshair — он очень сильно помогает в визуальном анализе корреляций: стоит только навести мышь на один график, как на всех остальных появится полоса показывающая это время.

Использовать более навороченный режим Shared tooltip не рекомендуется, так как он перегружает лишней информацией.

### Единица измерения — это очень важно

График, на котором не указана единица измерения, всегда вводит в заблуждение! Что показано на графике — rpm или rps, биты или байты, ...? Всегда, когда вы смотрите на график, вы задаете вопрос — "Что показано на этом графике?", на который и отвечает правильно проставленная единица измерения. В Grafana есть возможность четко указать единицу измерения и это обязательно нужно делать.

Кроме этого, старайтесь использовать общепринятые единицы измерения, например:
* Скорость передачи данных принято измерять в битах в секунду, а не в байтах в секунду;
* Количество операций — обычно указывают в секунду, а не в минуту (iops, rps и пр.);
* Объем данных — всегда измеряют в байтах, а не в битах.

### Точность данных и детализация

Конечно, бывают случаи когда степень детализации мешает отследить большие тренды, но гораздо чаще происходит обратное — из-за недостаточной детализации не видно часть данных, необходимых для анализа. Чтобы показывать данные без потери точности:
1. **всегда используйте функцию `rate`, а не `irate`**;
2. **в качестве диапазона для range-векторов используйте `$__rate_interval`**;
3. **всегда используйте Resolution 1/1**;
4. **никогда не устанавливайте Min step**.
5. **для функций avg/max/min_over_time в качестве диапазона для range-векторов используйте `$__range`**;

#### Отсутствие данных нужно тоже точно показывать

У Grafana есть три режима показа Null Value (отсутствия данных).
* Никогда не используйте `connected`, он сильно вводит в заблуждение!
* Нужно использовать `null` во всех случаях, кроме стекирования — четко видно, что данных нет.
* При стекировании обычно нужно использовать `null as zero` (иначе при null в одной метрике пропадут все).

| connected               | null          | null as zero                  |
|-------------------------|---------------|-------------------------------|
| ![connected][connected] | ![null][null] | ![null as zero][null as zero] |

[connected]: /docs/documentation/images/300-prometheus/grafana_null_value_connected.jpg
[null]: /docs/documentation/images/300-prometheus/grafana_null_value_null.jpg
[null as zero]: /docs/documentation/images/300-prometheus/grafana_null_value_as_zero.jpg

#### Точность значения должна соответствовать целям

* Если процент ошибок измеряется в диапазоне от 0 до 10%, то какой смысл показывать 5 знаков после запятой? Все будут следить за целой частью и одним-двумя знаками после запятой.
* Если количество запросов прошедших за 3 часа (период по умолчанию для показа Dashboard'а) обычно измеряется десятками тысяч (а на некоторых кластерах может быть и сотнями миллионов) — стоит ли показывать точное количество запросов, или достаточно показать порядок?

Точность отображения значения должна соответствовать целям использования показателя, следите за этим!

#### По умолчанию показывать данные за последние 3 часа (автоматически обновлять каждые 30 секунд)

Показ 3 часов является оптимальным по умолчанию, так как это максимальный период, который можно показать в полной детализации:
* При `scrape_interval` равном `30s` (это наше основное значение), при показе данных за 3 часа, данные показываются без аппроксимации и с полной детализацией — даже на графиках размером в 1/4 ширины экрана еще показываются все точки (данные за каждые 30 секунд).
* Больший масштаб (уменьшение периода показа) не имеет смысла, так как не увеличивает детализацию, но сужает диапазон видимости по времени.
* Меньший масштаб (увеличение периода показа) снижает детализацию и данные начинают аппроксимироваться.

Автоматическое обновление имеет смысл делать каждые 30 секунд, так как именно с такой частотой производится scrape и в Prometheus поступают новые данные.

#### Перед пушем новых дашбордов необходимо удалить упоминание реальных доменов

Перед пушем изменений в репозиторий необходимо убедиться, что домены, которые могли импортнуться из Grafana были удалены из json-файла.

Пример скрипта для удаления:

```shell
listOfDomains="
google.com
mycompany.com
"

listOfDashboards=$(find dashboards/* -name "*json")

for dashboard in $listOfDashboards; do
  for domain in $listOfDomains; do
    sed -i -E  "s/([^\"]+$domain)/example.com/g" $dashboard
  done
done
```

### TODO

* Использовать $__range и instant query, когда нужно посчитать данные за период показа (обычно это в singlestat'ах).
* Делать легенды одной ширины, чтобы графики были друг под другом.
* Проставлять ноль у оси Y.
* Указывать верхнюю границу у оси Y для графиков 0-100%.
* Как рисовать графики процентные (bars, вместо stepped lines).
* Трюк с использованием стекирования и показом Total.
* Не забывать ставить "On time range change", когда переменная получает значения, которые могут поменяться (например, имена Pod'ов).
* Цвета у CPU указывать как в okmeter.
* Когда использовать какой режим отрисовки и чем хорош staircase.
