---
title: "Prometheus-мониторинг: Разработка графиков Grafana"
type:
  - instruction
search: grafana разработка графиков
---

## Механизм самостоятельного управления дашбордами в модуле Observability

Модуль Observability добавляет новые типы дашбордов, включая ресурсы, ограниченные конкретным пространством имён.  
Это позволяет пользователям **создавать и управлять собственными дашбордами** без необходимости иметь права на объекты кластерного уровня.

Ранее дашборды можно было создавать только с помощью ресурса **GrafanaDashboardDefinition**, который требовал прав на объекты кластерного уровня. Новый механизм вводит ресурсы, работающие **в пределах конкретного пространства имён**.

### Поддерживаемые типы ресурсов

- **ObservabilityDashboard** — дашборды внутри пространства имён. Доступны в Веб-интерфейсе Deckhouse: **Мониторинг → Проекты**.

- **ClusterObservabilityDashboard** — дашборды для мониторинга компонентов кластера. Доступны в Веб-интерфейсе Deckhouse: **Мониторинг → Система**.

- **ClusterObservabilityPropagatedDashboard** — позволяет расширять список дашбордов из двух предыдущих категорий. Доступны пользователям с правами на соответствующее пространство имён или на системный раздел. Такие дашборды автоматически добавляются в Веб-интерфейсе Deckhouse и отображаются в разделах:
  - **Мониторинг → Система**
  - **Мониторинг → Проекты**

> Конвертация существующих дашбордов из ресурса GrafanaDashboardDefinition в новые типы выполняется вручную.

### Поддерживаемые аннотации

- **metadata.deckhouse.io/category** — задаёт папку (категорию) в интерфейсе;
- **metadata.deckhouse.io/title** — задаёт отображаемое название дашборда. Если не указано, будет использовано название из JSON-манифеста.

### Поддержка пользовательских источников данных

Источники данных, ранее созданные через ресурс **GrafanaAdditionalDatasource**, продолжают работать и доступны в Веб-интерфейсе Deckhouse:
- **Обзор данных**
- **Дашборды**

### Какой тип дашборда выбрать?

Выбор типа зависит от задач и контекста использования.

#### ObservabilityDashboard

- **Когда выбрать:** Для мониторинга ресурсов внутри конкретного пространства имён.
- **Преимущества:** Доступны пользователям, имеющим доступ только к этому пространству имён, упрощая управление и разграничение прав.

#### ClusterObservabilityDashboard

- **Когда выбрать:** Для мониторинга всех компонентов кластера с системным охватом.
- **Преимущества:** Подходит для операторов и администраторов, которым нужна глобальная видимость кластера.

#### ClusterObservabilityPropagatedDashboard

- **Когда выбрать:** Для автоматического распространения дашбордов среди всех пользователей, имеющих доступ к определённым пространствам имён или системным разделам.
- **Преимущества:** Удобство централизованного распространения общих дашбордов, полезных множеству пользователей.

Чтобы настроить создание дашборда в виде ClusterObservabilityPropagatedDashboard:

1. Добавьте префикс `propagated-` к JSON-файлу с моделью дашборда.

2. В lib-helm используется нормализация, при которой все слеши конвертируются в дефисы.

3. Определение типа дашборда:
    - Файл с именем `propagated-pod.json` создаст ClusterObservabilityPropagatedDashboard (COPD)
    - Файл с именем `pod.json` создаст ClusterObservabilityDashboard (COD)

## Как быстро привести чужой dashboard более-менее в порядок?

1. Заменить `irate` на `rate`:

   ```shell
   sed 's/irate(/rate(/g' -i *.json
   ```

2. Заменить `Resolution` на `1/1`:

   ```shell
   sed 's/"intervalFactor":\s[0-9]/"intervalFactor": 1/' -i *.json
   ```

3. Убрать `Min Step`:

   ```shell
   sed '/"interval":/d' -i *.json
   ```

4. Заменить все графики на `Staircase` (поломает графики `Stack` + `Percent`, которые придется поправить руками на `Bars`):

   ```shell
   sed 's/"steppedLine": false/"steppedLine": true/' -i *.json
   ```

## Лучшие практики

### Сохраняйте uid Dashboard'а

При любых изменениях (в том числе при переименовании и переносе между Folder'ами) сохраняйте uid Dashboard'а (он обычно на одной из последних строк в JSON-файле). В этом случае все старые ссылки продолжат работать. Для этого никаких специальных действий не требуется, просто не меняйте намерено.

### Следите за изменениями в JSON-файлах

Редактировать JSON-файлы напрямую не стоит (это неудобно), а вот после внесения изменений в интерфейсе Grafana и выгрузки JSON-файла — обязательно стоит внимательно посмотреть, что изменилось, чтобы удостовериться, что случайно не поправили лишнего. Для этого есть `git add -p` и diff'ы в MR'ах, кому как удобней.

При изменении сложных Dashboard'ов, использующих функционал шаблонизирования, старайтесь редактировать Dashboard там же, где он был создан (обычно это <https://prometheus.kube.domain.my/>) и с теми же значениями в Variables — тогда в MR'е не будет множества лишних изменений "динамических данных".

### Что делать если мне нужно при отсутствии данных "прятать" дашборд или часть дашборда?

Не нужно пытаться генерировать Grafana Dashboard средствами Helm'а. Лучше заведите Issue в Grafana, чтобы сделали поддержку такого функционала.

## Настройки перед добавлением первого графика

### Добавление переменной `ds_prometheus`

В Grafana может быть доступно несколько экземпляров Prometheus с различной степенью детализации данных и разным периодом хранения.  
Чтобы обеспечить удобный выбор источника данных, необходимо:

- Создать переменную `$ds_prometheus` (инструкция приведена ниже).
- Указывать именно `$ds_prometheus` в качестве **Data Source** для каждой панели, а не конкретный Prometheus.

Источник данных указывается через переменную `$ds_prometheus`.  
Настройка выполняется в **Dashboard settings → Variables**.

![Настройка переменной $ds_prometheus](/docs/documentation/images/prometheus/ds_prometheus_var.png)

### Настройки времени (Time options)

#### Time zone

Во вкладке **General** настроек дашборда найдите параметр **Time zone** и установите значение **Browser time**.

### Общий курсор (Shared crosshair)

Одна из ключевых возможностей графиков — визуальный анализ корреляций.  
Для эффективного сравнения данных важно иметь возможность сопоставлять одну и ту же точку во времени на разных графиках.

Если графики имеют одинаковый размер и расположены один под другим, это не вызывает сложностей. Однако не всегда возможно (и не всегда эстетично) делать все графики одинакового размера.

Рекомендуется включить режим **Shared crosshair** для параметра **Graph Tooltip** — он значительно упрощает визуальный анализ корреляций.  
При наведении курсора на один график на всех остальных появится вертикальная линия, отображающая то же самое время.

Настройка выполняется в:  
**Dashboard settings → Panel options → Shared Crosshair**

>️ Использование режима **Shared tooltip** не рекомендуется, так как он перегружает интерфейс лишней информацией.

## Основные правила для графиков

### Заголовок (Title)

- Должен быть **кратким, понятным и однозначным**, на **английском языке**.
- **Плохие примеры:**
  - `Network Stuff` — слишком обобщенно, неинформативно
  - `Router Data` — неясно, какие именно данные отображаются

- **Хорошие примеры:**
  - `Avg Upstream Response Time`
  - `Upstream Response Time`

### Легенда (Legend)

#### Основные принципы

- Отображать **только ключевые серии**, чтобы графики оставались читаемыми и не перегружались.
- Количество отображаемых серий должно быть ограничено.

#### Определение ключевых серий

1. **Total / Aggregate** — суммарные значения, например:
    - Общее количество подов в namespace (`sum by (namespace)`)
    - Общее потребление CPU (`sum by (cluster)`)
    - Общий объём памяти

2. **Основные разрезы** — метки, по которым чаще всего анализируют графики:
    - `namespace`
    - `node`
    - `cluster`

3. **Служебные метки** (например, `pod`, `container`) редко являются ключевыми и обычно перегружают график.

#### Ограничение количества серий

- Использовать **агрегирующие функции Prometheus**:
  - `sum by (namespace)` вместо отображения всех подов
  - `avg by (node)` для усреднения метрик по нодам

**Пример:**  
Вместо показа метрики `container_cpu_usage_seconds_total` по всем подам в кластере (сотни линий), строим график `sum by (namespace)` и оставляем только несколько ключевых `namespace`. Это делает график понятным и удобным для анализа.

#### Отображение суммарных значений (Total)

Для метрик, где важно видеть **суммарное значение** (например, количество подов, общий объём занятой памяти), рекомендуется добавлять отдельный Total.

**Правила оформления Total:**
- Цвет маркера — жёлтый
- Линия и область под графиком — прозрачные

> Подробная инструкция по настройке стиля отображения Total приведена в разделе «Дополнительные требования».

#### Размещение легенды

- Выбирается по принципу **максимальной информативности и удобства**:
  - **Сбоку** — если важно дать пользователю возможность скрывать/показывать элементы
  - **Внизу** — если это удобнее для обзора

- В легенде отображаются **ключевые показатели**: max, min, mean/avg.

### Описание (Description)

- Должно давать **полное понимание того, что отображает график**.
- **Плохой пример:** `This graph shows important data about network` — слишком общее, неинформативное
- **Хороший пример:** `This graph shows the requested CPU resources higher than the actual CPU consumption. In other words, it shows CPU resources that can be "freed" without affecting the service.`

### Источник данных и единицы измерения

#### Единицы измерения

- На графике обязательно указывать единицы измерения.
- Настройка выполняется через: **All → Standard options → Unit**

**Выбор единиц измерения:**

1. **Память (RAM, кэш, буферы, swap) и диск (FS usage, inode usage, volume usage)**  
   Использовать бинарные единицы: KiB, MiB, GiB, TiB

2. **Сеть (трафик, скорость, пакеты)**  
   Единицы измеряются в секунду: Kb/s, Mb/s, Gb/s (в Grafana — bits/sec SI)

3. **CPU**  
   Отображается в **cores** или **milliCPUs (m)**

### Выбор формы представления (проценты или абсолютные значения)

#### Определение формы

- При проектировании графика важно выбрать, что показать: **проценты** или **абсолютные значения**.

##### CPU

- **Проценты:** отображается загрузка, понятно, насколько ресурс используется, но сложно сравнивать разные графики
  - Настройка: **All → Standard options → Unit → percent**
- **Абсолютные значения:** ядра или CPU-секунды, обеспечивают сравнимость
  - Настройка: **All → Standard options → Unit → выбрать нужную величину или задать свою**

> Можно добавлять показатели дефицита/избытка: throttling, объём свободных ресурсов и т.д.

#### Несколько видов графиков

- По возможности показывать одновременно разные показатели: использование, недостаток, избыток.

### Типы визуализации

#### Выбор типа

- Выбирается исходя из **волатильности и характера данных**.

#### Сильно волатильные метрики (например, CPU)

- Рекомендуется отображать **барами**

#### Низко волатильные метрики

- Использовать **линии**

#### Дискретные или разовые значения

- Использовать стиль линий **step**

### Устранение визуального шума

- Лишние линии, создающие перегруженность графика, следует скрывать.

### Стековые графики

#### Общие правила

- Стековать **только значения, которые суммируются в итоговое (total)**
- Не стековать разнородные величины с разными единицами измерения

#### Гибридные ситуации

- В случаях, когда требуется сочетание различных метрик (например, сумма процессов и общий лимит), использовать **комбинированные решения** и явно указывать это на графике
- Настройка выполняется через **Overrides**: выбрать поле с нужным именем и применить нужный стиль

    ![Настройка стекинга](/docs/documentation/images/prometheus/grafana_stacking.png)

### Сортировка

#### Основные принципы

- Всегда продумывайте **порядок сортировки линий на графиках и строк в таблицах**.
- На первом месте следует отображать **наиболее значимые значения для пользователя**, чтобы график или таблица были максимально информативными и удобными для анализа.

### Точность данных и детализация

#### Отображение графика от нулевой отметки

Для большинства метрик корректнее отображать график, начиная от **нуля**.  
Чтобы задать такую настройку:

- Перейдите в **All → Axis → Scale**
- Установите параметр **Soft min = 0**

Это обеспечит начало графика с нулевой отметки, при этом верхняя граница будет определяться автоматически.

#### Масштаб

Выбор между **линейным** и **логарифмическим** масштабом должен быть осознанным.

Используйте **логарифмический масштаб**, если выполняется одно из следующих условий:

- **Широкий диапазон значений:**  
  Логарифмический масштаб полезен, когда данные охватывают широкий диапазон — например, значения варьируются от единиц до тысяч или миллионов.  
  Это позволяет лучше различать детали и тенденции.

- **Анализ пропорций и процентных изменений:**  
  В логарифмическом масштабе одинаковые расстояния на оси соответствуют одинаковым процентным изменениям.  
  Это удобно при анализе метрик, где важны относительные, а не абсолютные различия.

- **Визуализация экспоненциального роста:**  
  Логарифмическая шкала делает экспоненциальные тренды более наглядными — на линейной шкале такие данные выглядят как резкий скачок.

Используйте **линейный масштаб** во всех остальных случаях.

> Настройка выполняется через: **All → Axis → Scale**

Конечно, бывают случаи когда степень детализации мешает отследить большие тренды, но гораздо чаще происходит обратное — из-за недостаточной детализации не видно часть данных, необходимых для анализа. Чтобы показывать данные без потери точности:
1. **всегда используйте функцию `rate`, а не `irate`**;
2. **в качестве диапазона для range-векторов используйте `$__rate_interval`**;
3. **всегда используйте Resolution 1/1**;
4. **никогда не устанавливайте Min step**.

    ![Точность данных и детализация](/docs/documentation/images/prometheus/grafana_accuracy.jpg)

    **Объяснение деталей и причин:**
      <ul dir="auto">
        <li>В Prometheus в API в запросе можно указать <code>step</code>. Если мы загружаем данные за период в 3 часа и укажем <code>step</code> 30 секунд — получим 360 точек (3 часа *60 минут* 2 точки в минуту) и показать их на графике вполне реально. Однако если мы показываем данные за 24 часа — использовать шаг в 30 секунд уже нет никакого смысла, так как 2880 точек показать просто невозможно (если только на мониторе 4К полосками в один пиксель, но это ничего не дает, так-как человеческий глаз не может воспринимать такую информацию). Чтобы решить эту проблему, Grafana имеет хитрую механику автоматического определения <code>step</code> работающую примерно следующим образом:
        <ul>
          <li>В зависимости от размера графика (полная ширина, 1/2 ширины экрана, 1/4 ширины экрана и т.д.), размера окна браузера и разрешения экрана Grafana подсчитывает, сколько точек реально показать — например, на моем экране для графика на всю ширину Grafana считает нормальным показ 800 точек.</li>
          <li>Дальше она делит выбранный период показа на количество точек, которые реально показать, и получает "минимальный возможный для показа шаг" — например, на моем экране:
            <ul>
              <li>30 минут — 2.25 секунды,</li>
              <li>3 часа — 13.5 секунд,</li>
              <li>24 часа — 108 секунд,</li>
              <li>7 дней — 756 секунд.</li>
            </ul>
          </li>
          <li>Дальше Grafana смотрит настройки <code>Min step</code> и если он указан — делает <code>step</code> не меньше <code>Min step</code>. При этом <code>Min step</code> может быть указан в двух местах — глобально, в настройках data source'а и для каждого query в panel. У нас <code>Min step</code> указан глобально и соответствует <code>scrape_interval</code> у Prometheus (у основного это 30 секунд). Получаются следующие значения:
            <ul>
              <li>30 минут — 30 секунд (а не 2.25),</li>
              <li>3 часа — 30 секунд (а не 13.5 секунд),</li>
              <li>24 часа — 108 секунд,</li>
              <li>7 дней — 756 секунд.</li>
            </ul>
          </li>
          <li>Затем Grafana как-то хитро округляет получившиеся значения (до 5/15/30 секунд, 1/5/15 минут и т.д.), получаются следующие значения:
            <ul>
              <li>30 минут — 30 секунд,</li>
              <li>3 часа — 30 секунд,</li>
              <li>24 часа — 2 минуты,</li>
              <li>7 дней — 10 минут.</li>
            </ul>
          </li>
          <li>Затем Grafana смотрит параметр Resolution панели (там может быть 1/1, 1/2, ..., 1/10) и если там указано не 1/1 — увеличивает step (для 1/2 в два раза, для 1/10 в 10 раз).</li>
        </ul>
      </li>
      <li>Большая часть данных в Prometheus лежит в counter'ах (а не в gauge'ах), так что для получения текущего значения нужно использовать <code>rate</code> или <code>irate</code>. И тут начинается самое опасное и самое неприятное.
        <ul>
          <li>Функции <code>rate</code> и <code>irate</code> работают с range-векторами, но какой range передавать? В Grafana есть готовая переменная <code>$__interval</code> в которой уже хранится тот step, который будет отправлен в Prometheus, и казалось бы — используй!</li>
          <li>Но чтобы функции <code>rate</code> и <code>irate</code> работали — нужно чтобы в range-векторе обязательно было хотя бы две точки (что логично). А если мы возьмем range-вектор за 30 секунд в Prometheus со <code>scrape_interval</code> 30 секунд, в нем будет только одна точка и <code>rate</code>/<code>irate</code> ничего не выдадут. И тут есть множество НЕПРАВИЛЬНЫХ путей:
            <ul>
              <li>Кто-то ставит Resolution у всех query 1/2, чтобы в переменной <code>$__interval</code> при показе любого интервала было не меньше, чем 2 x <code>Min step</code>. Это помогает — графики начинают работать, но они всегда в два раза менее детальные, чем может хранит Prometheus.</li>
              <li>Кто-то ставит Min step равный двум <code>scrape_interval'ам</code> — это чуть лучше, но все равно шило на мыло.</li>
              <li>Кто-то начинает использовать <code>irate</code> и передает туда range-вектор за 1h (любое значение, заведомо больше периода) — и тут таится самый сильный подвох. В этом случае графики начинают показываться с абсолютной точностью, пока наш <code>step</code> меньше или равен <code>scrape_interval</code>, но если <code>step</code> больше <code>scrapte_interval</code> (показ данных за 24 часа и за 7 дней) — графит начинает жесточайше врать. Так как вместо того, чтобы показать в каждой точке rate за весь step, он показывает в каждой точке rate за последний <code>scrape_interval</code>. Проще говоря — получается, что при просмотре данных за 7 дней, вы видите на графике в каждой точке не среднее потребление CPU за 10 минут (<code>step</code>), а вы видите потребление за последние 30 секунд каждые 10 минут, а что было остальные 9 минут 30 секунд — просто не знаете!</li>
            </ul>
          </li>
          <li>Для решения этой проблемы надо использовать переменную <code>$__rate_interval</code> (rv = range vector). Эта переменная равна <code>max($__interval + Scrape interval, 4 * Scrape interval)</code>, то есть в ней то же самое, что в <code>$__interval</code> но не меньше периода, в который попадет хотя бы четыре точки. Это полностью решает проблему!</li>
        </ul>
      </li>
    </ul>

5. **для функций avg/max/min_over_time в качестве диапазона для range-векторов используйте `$__range`**;

### Отсутствие данных нужно тоже точно показывать

У Grafana есть три режима показа Null Value (отсутствия данных).
* Никогда не используйте `connected`, он сильно вводит в заблуждение!
* Нужно использовать `null` во всех случаях, кроме стекирования — четко видно, что данных нет.
* При стекировании обычно нужно использовать `null as zero` (иначе при null в одной метрике пропадут все).

| connected               | null          | null as zero                  |
|-------------------------|---------------|-------------------------------|
| ![connected][connected] | ![null][null] | ![null as zero][null as zero] |

[connected]: /docs/documentation/images/prometheus/grafana_null_value_connected.jpg
[null]: /docs/documentation/images/prometheus/grafana_null_value_null.jpg
[null as zero]: /docs/documentation/images/prometheus/grafana_null_value_as_zero.jpg

При отсутствии данных на графике должен присутствовать прочерк (“No Value”).

### Точность значения должна соответствовать целям

* Если процент ошибок измеряется в диапазоне от 0 до 10%, то какой смысл показывать 5 знаков после запятой? Все будут следить за целой частью и одним-двумя знаками после запятой.
* Если количество запросов прошедших за 3 часа (период по умолчанию для показа Dashboard'а) обычно измеряется десятками тысяч (а на некоторых кластерах может быть и сотнями миллионов) — стоит ли показывать точное количество запросов, или достаточно показать порядок?

Точность отображения значения должна соответствовать целям использования показателя, следите за этим!

### По умолчанию показывать данные за последние 3 часа (автоматически обновлять каждые 30 секунд)

Показ 3 часов является оптимальным по умолчанию, так как это максимальный период, который можно показать в полной детализации:
* При `scrape_interval` равном `30s` (это наше основное значение), при показе данных за 3 часа, данные показываются без аппроксимации и с полной детализацией — даже на графиках размером в 1/4 ширины экрана еще показываются все точки (данные за каждые 30 секунд).
* Больший масштаб (уменьшение периода показа) не имеет смысла, так как не увеличивает детализацию, но сужает диапазон видимости по времени.
* Меньший масштаб (увеличение периода показа) снижает детализацию и данные начинают аппроксимироваться.

Автоматическое обновление имеет смысл делать каждые 30 секунд, так как именно с такой частотой производится scrape и в Prometheus поступают новые данные.

## Дополнительные требования

### Свернутые неосновные ряды графиков

- Все **несущественные ряды** на дашбордах должны быть **свернуты по умолчанию**.
- Для этого в JSON-конфигурации ряда укажите:

```json
"collapsed": true
```

### Требования к Total Tooltip

- Для **Total Tooltip** необходимо выполнить дополнительные действия:
  - Сделать его **невидимым на графике** через **Edit panel → Overrides**

  ![Скрыть total](/docs/documentation/images/prometheus/hide_total.png)

  - Также добавить для него transform (Edit panel->Transform data)

  ![Transform для total](/docs/documentation/images/prometheus/transform_for_total.png)

### Требования к остальным тултипам

- Для всех **остальных тултипов** необходимо выполнить следующие действия:
  - Настроить **сортировку по убыванию** через **Edit panel → All**

  ![Sort для остальных tooltip](/docs/documentation/images/prometheus/sort_other_tooltip.png)

### Сортировка в легенде

- В легенде все значения должны быть **отсортированы по убыванию (descending)** по колонке **Mean**.

## Полезные примечания

### Перед пушем новых дашбордов необходимо удалить упоминание реальных доменов

Перед пушем изменений в репозиторий необходимо убедиться, что домены, которые могли импортироваться из Grafana были удалены из JSON-файла.

Пример скрипта для удаления:

```shell
listOfDomains="
google.com
mycompany.com
"

listOfDashboards=$(find dashboards/* -name "*json")

for dashboard in $listOfDashboards; do
  for domain in $listOfDomains; do
    sed -i -E  "s/([^\"]+$domain)/example.com/g" $dashboard
  done
done
```

### TODO

* Использовать $__range и instant query, когда нужно посчитать данные за период показа (обычно это в singlestat'ах).
* Делать легенды одной ширины, чтобы графики были друг под другом.
* Проставлять ноль у оси Y.
* Указывать верхнюю границу у оси Y для графиков 0-100%.
* Как рисовать графики процентные (bars, вместо stepped lines).
* Трюк с использованием стекирования и показом Total.
* Не забывать ставить "On time range change", когда переменная получает значения, которые могут поменяться (например, имена Pod'ов).
* Цвета у CPU указывать как в okmeter.
* Когда использовать какой режим отрисовки и чем хорош staircase.
