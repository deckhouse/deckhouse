diff --git a/cmd/dex/config.go b/cmd/dex/config.go
index aa49a181..c375dd57 100644
--- a/cmd/dex/config.go
+++ b/cmd/dex/config.go
@@ -51,6 +51,9 @@ type Config struct {
 	// querying the storage. Cannot be specified without enabling a passwords
 	// database.
 	StaticPasswords []password `json:"staticPasswords"`
+
+	// TOTP represents the configuration for two-factor authentication.
+	TOTP TOTP `json:"twoFactorAuthn"`
 }

 // Validate the configuration
@@ -474,3 +477,10 @@ type RefreshToken struct {
 	AbsoluteLifetime  string `json:"absoluteLifetime"`
 	ValidIfNotUsedFor string `json:"validIfNotUsedFor"`
 }
+
+type TOTP struct {
+	// Issuer is the name of the service (will be shown in the authenticator app).
+	Issuer string `json:"issuer"`
+	// Connectors is a list of connectors that will use TOTP.
+	Connectors []string `json:"connectors"`
+}
diff --git a/cmd/dex/config_test.go b/cmd/dex/config_test.go
index 68abe1f7..004330ce 100644
--- a/cmd/dex/config_test.go
+++ b/cmd/dex/config_test.go
@@ -345,6 +345,11 @@ expiry:
   idTokens: "25h"
   authRequests: "25h"

+twoFactorAuthn:
+  issuer: dex
+  connectors:
+  - mock
+
 logger:
   level: "debug"
   format: "json"
@@ -437,6 +442,10 @@ logger:
 			IDTokens:     "25h",
 			AuthRequests: "25h",
 		},
+		TOTP: TOTP{
+			Issuer:     "dex",
+			Connectors: []string{"mock"},
+		},
 		Logger: Logger{
 			Level:  slog.LevelDebug,
 			Format: "json",
diff --git a/cmd/dex/serve.go b/cmd/dex/serve.go
index 8a69c7ee..168008e5 100644
--- a/cmd/dex/serve.go
+++ b/cmd/dex/serve.go
@@ -287,21 +287,23 @@ func runServe(options serveOptions) error {
 	healthChecker := gosundheit.New()

 	serverConfig := server.Config{
-		AllowedGrantTypes:      c.OAuth2.GrantTypes,
-		SupportedResponseTypes: c.OAuth2.ResponseTypes,
-		SkipApprovalScreen:     c.OAuth2.SkipApprovalScreen,
-		AlwaysShowLoginScreen:  c.OAuth2.AlwaysShowLoginScreen,
-		PasswordConnector:      c.OAuth2.PasswordConnector,
-		Headers:                c.Web.Headers.ToHTTPHeader(),
-		AllowedOrigins:         c.Web.AllowedOrigins,
-		AllowedHeaders:         c.Web.AllowedHeaders,
-		Issuer:                 c.Issuer,
-		Storage:                s,
-		Web:                    c.Frontend,
-		Logger:                 logger,
-		Now:                    now,
-		PrometheusRegistry:     prometheusRegistry,
-		HealthChecker:          healthChecker,
+		AllowedGrantTypes:          c.OAuth2.GrantTypes,
+		SupportedResponseTypes:     c.OAuth2.ResponseTypes,
+		SkipApprovalScreen:         c.OAuth2.SkipApprovalScreen,
+		AlwaysShowLoginScreen:      c.OAuth2.AlwaysShowLoginScreen,
+		PasswordConnector:          c.OAuth2.PasswordConnector,
+		Headers:                    c.Web.Headers.ToHTTPHeader(),
+		AllowedOrigins:             c.Web.AllowedOrigins,
+		AllowedHeaders:             c.Web.AllowedHeaders,
+		Issuer:                     c.Issuer,
+		Storage:                    s,
+		Web:                        c.Frontend,
+		Logger:                     logger,
+		Now:                        now,
+		PrometheusRegistry:         prometheusRegistry,
+		HealthChecker:              healthChecker,
+		TOTPIssuer:                 c.TOTP.Issuer,
+		TOTPConnectors:             c.TOTP.Connectors,
 	}
 	if c.Expiry.SigningKeys != "" {
 		signingKeys, err := time.ParseDuration(c.Expiry.SigningKeys)
diff --git a/examples/config-dev.yaml b/examples/config-dev.yaml
index 147597a2..f57edb70 100644
--- a/examples/config-dev.yaml
+++ b/examples/config-dev.yaml
@@ -75,6 +75,12 @@ telemetry:
   http: 0.0.0.0:5558
   # enableProfiling: true

+# Configuration for the two-factor authentication
+twoFactorAuthn:
+  issuer: "dex"
+  connectors:
+  - mock
+
 # Uncomment this block to enable the gRPC API. This values MUST be different
 # from the HTTP endpoints.
 # grpc:
diff --git a/go.mod b/go.mod
index 8404620f..b8e20dd2 100644
--- a/go.mod
+++ b/go.mod
@@ -26,6 +26,7 @@ require (
 	github.com/mattn/go-sqlite3 v1.14.24
 	github.com/oklog/run v1.1.0
 	github.com/pkg/errors v0.9.1
+	github.com/pquerna/otp v1.4.0
 	github.com/prometheus/client_golang v1.20.5
 	github.com/russellhaering/goxmldsig v1.4.0
 	github.com/spf13/cobra v1.9.1
@@ -55,6 +56,7 @@ require (
 	github.com/apparentlymart/go-textseg/v15 v15.0.0 // indirect
 	github.com/beorn7/perks v1.0.1 // indirect
 	github.com/bmatcuk/doublestar v1.3.4 // indirect
+	github.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc // indirect
 	github.com/cespare/xxhash/v2 v2.3.0 // indirect
 	github.com/coreos/go-semver v0.3.0 // indirect
 	github.com/coreos/go-systemd/v22 v22.3.2 // indirect
diff --git a/go.sum b/go.sum
index 5ba3d05b..d455a00f 100644
--- a/go.sum
+++ b/go.sum
@@ -41,6 +41,8 @@ github.com/beorn7/perks v1.0.1 h1:VlbKKnNfV8bJzeqoa4cOKqO6bYr3WgKZxO8Z16+hsOM=
 github.com/beorn7/perks v1.0.1/go.mod h1:G2ZrVWU2WbWT9wwq4/hrbKbnv/1ERSJQ0ibhJ6rlkpw=
 github.com/bmatcuk/doublestar v1.3.4 h1:gPypJ5xD31uhX6Tf54sDPUOBXTqKH4c9aPY66CyQrS0=
 github.com/bmatcuk/doublestar v1.3.4/go.mod h1:wiQtGV+rzVYxB7WIlirSN++5HPtPlXEo9MEoZQC/PmE=
+github.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc h1:biVzkmvwrH8WK8raXaxBx6fRVTlJILwEwQGL1I/ByEI=
+github.com/boombuler/barcode v1.0.1-0.20190219062509-6c824513bacc/go.mod h1:paBWMcWSl3LHKBqUq+rly7CNSldXjb2rDl3JlRe0mD8=
 github.com/cespare/xxhash/v2 v2.3.0 h1:UL815xU9SqsFlibzuggzjXhog7bL6oX9BbNZnL2UFvs=
 github.com/cespare/xxhash/v2 v2.3.0/go.mod h1:VGX0DQ3Q6kWi7AoAeZDth3/j3BFtOZR5XLFGgcrjCOs=
 github.com/coreos/go-oidc/v3 v3.12.0 h1:sJk+8G2qq94rDI6ehZ71Bol3oUHy63qNYmkiSjrc/Jo=
@@ -168,6 +170,8 @@ github.com/pkg/errors v0.9.1 h1:FEBLx1zS214owpjy7qsBeixbURkuhQAwrK5UwLGTwt4=
 github.com/pkg/errors v0.9.1/go.mod h1:bwawxfHBFNV+L2hUp1rHADufV3IMtnDRdf1r5NINEl0=
 github.com/pmezard/go-difflib v1.0.0 h1:4DBwDE0NGyQoBHbLQYPwSUPoCMWR5BEzIk/f1lZbAQM=
 github.com/pmezard/go-difflib v1.0.0/go.mod h1:iKH77koFhYxTK1pcRnkKkqfTogsbg7gZNVY4sRDYZ/4=
+github.com/pquerna/otp v1.4.0 h1:wZvl1TIVxKRThZIBiwOOHOGP/1+nZyWBil9Y2XNEDzg=
+github.com/pquerna/otp v1.4.0/go.mod h1:dkJfzwRKNiegxyNb54X/3fLwhCynbMspSyWKnvi1AEg=
 github.com/prometheus/client_golang v1.20.5 h1:cxppBPuYhUnsO6yo/aoRol4L7q7UFfdm+bR9r+8l63Y=
 github.com/prometheus/client_golang v1.20.5/go.mod h1:PIEt8X02hGcP8JWbeHyeZ53Y/jReSnHgO035n//V5WE=
 github.com/prometheus/client_model v0.6.1 h1:ZKSh/rekM+n3CeS952MLRAdFwIKqeY8b62p8ais2e9E=
diff --git a/server/handlers.go b/server/handlers.go
index a00b290b..2db4d074 100644
--- a/server/handlers.go
+++ b/server/handlers.go
@@ -11,7 +11,6 @@ import (
 	"html/template"
 	"net/http"
 	"net/url"
-	"path"
 	"sort"
 	"strconv"
 	"strings"
@@ -521,6 +520,11 @@ func (s *Server) finalizeLogin(ctx context.Context, identity connector.Identity,
 		a.LoggedIn = true
 		a.Claims = claims
 		a.ConnectorData = identity.ConnectorData
+
+		if !s.totp.enabledForConnector(a.ConnectorID) {
+			a.TOTPValidated = true
+		}
+
 		return a, nil
 	}
 	if err := s.storage.UpdateAuthRequest(ctx, authReq.ID, updater); err != nil {
@@ -536,63 +540,82 @@ func (s *Server) finalizeLogin(ctx context.Context, identity connector.Identity,
 		"connector_id", authReq.ConnectorID, "username", claims.Username,
 		"preferred_username", claims.PreferredUsername, "email", email, "groups", claims.Groups)

-	offlineAccessRequested := false
-	for _, scope := range authReq.Scopes {
-		if scope == scopeOfflineAccess {
-			offlineAccessRequested = true
-			break
+	// Try to retrieve an existing OfflineSession object for the corresponding user.
+	// TODO(nabokihms): We create an offline session even if the offline access is not requested.
+	//   In the future it will be possible to migrate to sessions.
+	//   Sessions may contain attributes like approval status, etc.
+	_, err := s.storage.GetOfflineSessions(ctx, identity.UserID, authReq.ConnectorID)
+	if err != nil {
+		if err != storage.ErrNotFound {
+			s.logger.ErrorContext(ctx, "failed to get offline session", "err", err)
+			return "", false, err
+		}
+		offlineSessions := storage.OfflineSessions{
+			UserID:        identity.UserID,
+			ConnID:        authReq.ConnectorID,
+			Refresh:       make(map[string]*storage.RefreshTokenRef),
+			ConnectorData: identity.ConnectorData,
 		}
-	}
-	_, canRefresh := conn.(connector.RefreshConnector)
-
-	if offlineAccessRequested && canRefresh {
-		// Try to retrieve an existing OfflineSession object for the corresponding user.
-		session, err := s.storage.GetOfflineSessions(ctx, identity.UserID, authReq.ConnectorID)
-		switch {
-		case err != nil && err == storage.ErrNotFound:
-			offlineSessions := storage.OfflineSessions{
-				UserID:        identity.UserID,
-				ConnID:        authReq.ConnectorID,
-				Refresh:       make(map[string]*storage.RefreshTokenRef),
-				ConnectorData: identity.ConnectorData,
-			}

-			// Create a new OfflineSession object for the user and add a reference object for
-			// the newly received refreshtoken.
-			if err := s.storage.CreateOfflineSessions(ctx, offlineSessions); err != nil {
-				s.logger.ErrorContext(ctx, "failed to create offline session", "err", err)
-				return "", false, err
-			}
-		case err == nil:
-			// Update existing OfflineSession obj with new RefreshTokenRef.
-			if err := s.storage.UpdateOfflineSessions(ctx, session.UserID, session.ConnID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {
-				if len(identity.ConnectorData) > 0 {
-					old.ConnectorData = identity.ConnectorData
-				}
-				return old, nil
-			}); err != nil {
-				s.logger.ErrorContext(ctx, "failed to update offline session", "err", err)
+		if s.totp.enabledForConnector(authReq.ConnectorID) {
+			generated, err := s.totp.generate(authReq.ConnectorID, identity.Email)
+			if err != nil {
+				s.logger.ErrorContext(ctx, "failed to generate totp for offline session", "err", err)
 				return "", false, err
 			}
-		default:
-			s.logger.ErrorContext(ctx, "failed to get offline session", "err", err)
+			offlineSessions.TOTP = generated.String()
+		}
+
+		// Create a new OfflineSession object for the user and add a reference object for
+		// the newly received refreshtoken.
+		if err := s.storage.CreateOfflineSessions(ctx, offlineSessions); err != nil {
+			s.logger.ErrorContext(ctx, "failed to create offline session", "err", err)
 			return "", false, err
 		}
 	}

+	// Update existing OfflineSession obj with new RefreshTokenRef.
+	if err := s.storage.UpdateOfflineSessions(ctx, identity.UserID, authReq.ConnectorID, func(old storage.OfflineSessions) (storage.OfflineSessions, error) {
+		if len(identity.ConnectorData) > 0 {
+			old.ConnectorData = identity.ConnectorData
+		}
+		return old, nil
+	}); err != nil {
+		s.logger.ErrorContext(ctx, "failed to update offline session", "err", err)
+		return "", false, err
+	}
+
 	// we can skip the redirect to /approval and go ahead and send code if it's not required
 	if s.skipApproval && !authReq.ForceApprovalPrompt {
 		return "", true, nil
 	}

+	// we can skip the redirect to /approval and /totp and go ahead and send code if it's not required
+	if s.skipApproval && !authReq.ForceApprovalPrompt && !s.totp.enabledForConnector(authReq.ConnectorID) {
+		return "", true, nil
+	}
+
 	// an HMAC is used here to ensure that the request ID is unpredictable, ensuring that an attacker who intercepted the original
 	// flow would be unable to poll for the result at the /approval endpoint
 	h := hmac.New(sha256.New, authReq.HMACKey)
 	h.Write([]byte(authReq.ID))
 	mac := h.Sum(nil)

-	returnURL := path.Join(s.issuerURL.Path, "/approval") + "?req=" + authReq.ID + "&hmac=" + base64.RawURLEncoding.EncodeToString(mac)
-	return returnURL, false, nil
+	// Deep copy issuer URL to avoid modifying the global one.
+	returnURL, _ := url.Parse(s.issuerURL.String())
+	values := returnURL.Query()
+	values.Set("req", authReq.ID)
+	values.Set("hmac", base64.RawURLEncoding.EncodeToString(mac))
+
+	if s.totp.enabledForConnector(authReq.ConnectorID) {
+		values.Set("state", identity.UserID)
+		returnURL = returnURL.JoinPath("totp")
+	} else {
+		returnURL = returnURL.JoinPath("approval")
+	}
+
+	returnURL.RawQuery = values.Encode()
+	return returnURL.String(), false, nil
 }

 func (s *Server) handleApproval(w http.ResponseWriter, r *http.Request) {
@@ -614,7 +637,7 @@ func (s *Server) handleApproval(w http.ResponseWriter, r *http.Request) {
 		s.renderError(r, w, http.StatusInternalServerError, "Database error.")
 		return
 	}
-	if !authReq.LoggedIn {
+	if !authReq.LoggedIn || !authReq.TOTPValidated {
 		s.logger.ErrorContext(r.Context(), "auth request does not have an identity for approval")
 		s.renderError(r, w, http.StatusInternalServerError, "Login process not yet finalized.")
 		return
diff --git a/server/server.go b/server/server.go
index 8c046296..3b46ed18 100644
--- a/server/server.go
+++ b/server/server.go
@@ -119,6 +119,9 @@ type Config struct {
 	PrometheusRegistry *prometheus.Registry

 	HealthChecker gosundheit.Health
+
+	TOTPIssuer     string
+	TOTPConnectors []string
 }

 // WebConfig holds the server's frontend templates and asset configuration.
@@ -196,6 +199,8 @@ type Server struct {
 	refreshTokenPolicy *RefreshTokenPolicy

 	logger *slog.Logger
+
+	totp *secondFactorAuthenticator
 }

 // NewServer constructs a server from the provided config.
@@ -311,6 +316,7 @@ func newServer(ctx context.Context, c Config, rotationStrategy rotationStrategy)
 		now:                    now,
 		templates:              tmpls,
 		passwordConnector:      c.PasswordConnector,
+		totp:                   newSecondFactorAuthenticator(c.TOTPIssuer, c.TOTPConnectors),
 		logger:                 c.Logger,
 	}

@@ -486,6 +492,7 @@ func newServer(ctx context.Context, c Config, rotationStrategy rotationStrategy)
 	// "authproxy" connector.
 	handleFunc("/callback/{connector}", s.handleConnectorCallback)
 	handleFunc("/approval", s.handleApproval)
+	handleFunc("/totp", s.handleTOTPVerify)
 	handle("/healthz", http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
 		if !c.HealthChecker.IsHealthy() {
 			s.renderError(r, w, http.StatusInternalServerError, "Health check failed.")
diff --git a/server/templates.go b/server/templates.go
index b77663e1..46bca92e 100644
--- a/server/templates.go
+++ b/server/templates.go
@@ -22,6 +22,7 @@ const (
 	tmplError         = "error.html"
 	tmplDevice        = "device.html"
 	tmplDeviceSuccess = "device_success.html"
+	tmplTOTPVerify    = "totp_verify.html"
 )

 var requiredTmpls = []string{
@@ -32,6 +33,7 @@ var requiredTmpls = []string{
 	tmplError,
 	tmplDevice,
 	tmplDeviceSuccess,
+	tmplTOTPVerify,
 }

 type templates struct {
@@ -42,6 +44,7 @@ type templates struct {
 	errorTmpl         *template.Template
 	deviceTmpl        *template.Template
 	deviceSuccessTmpl *template.Template
+	tmplTOTPVerify    *template.Template
 }

 type webConfig struct {
@@ -169,6 +172,7 @@ func loadTemplates(c webConfig, templatesDir string) (*templates, error) {
 		errorTmpl:         tmpls.Lookup(tmplError),
 		deviceTmpl:        tmpls.Lookup(tmplDevice),
 		deviceSuccessTmpl: tmpls.Lookup(tmplDeviceSuccess),
+		tmplTOTPVerify:    tmpls.Lookup(tmplTOTPVerify),
 	}, nil
 }

@@ -282,6 +286,21 @@ func (t *templates) deviceSuccess(r *http.Request, w http.ResponseWriter, client
 	return renderTemplate(w, t.deviceSuccessTmpl, data)
 }

+func (t *templates) totpVerify(r *http.Request, w http.ResponseWriter, postURL, issuer, connector, qrCode string, lastWasInvalid bool) error {
+	if lastWasInvalid {
+		w.WriteHeader(http.StatusUnauthorized)
+	}
+	data := struct {
+		PostURL   string
+		Invalid   bool
+		Issuer    string
+		Connector string
+		QRCode    string
+		ReqPath   string
+	}{postURL, lastWasInvalid, issuer, connector, qrCode, r.URL.Path}
+	return renderTemplate(w, t.tmplTOTPVerify, data)
+}
+
 func (t *templates) login(r *http.Request, w http.ResponseWriter, connectors []connectorInfo) error {
 	sort.Sort(byName(connectors))
 	data := struct {
diff --git a/storage/ent/client/authrequest.go b/storage/ent/client/authrequest.go
index 25d3e415..1e17c8e4 100644
--- a/storage/ent/client/authrequest.go
+++ b/storage/ent/client/authrequest.go
@@ -32,6 +32,7 @@ func (d *Database) CreateAuthRequest(ctx context.Context, authRequest storage.Au
 		SetConnectorID(authRequest.ConnectorID).
 		SetConnectorData(authRequest.ConnectorData).
 		SetHmacKey(authRequest.HMACKey).
+		SetTotpValidated(authRequest.TOTPValidated).
 		Save(ctx)
 	if err != nil {
 		return convertDBError("create auth request: %w", err)
@@ -96,6 +97,7 @@ func (d *Database) UpdateAuthRequest(ctx context.Context, id string, updater fun
 		SetConnectorID(newAuthRequest.ConnectorID).
 		SetConnectorData(newAuthRequest.ConnectorData).
 		SetHmacKey(newAuthRequest.HMACKey).
+		SetTotpValidated(newAuthRequest.TOTPValidated).
 		Save(context.TODO())
 	if err != nil {
 		return rollback(tx, "update auth request uploading: %w", err)
diff --git a/storage/ent/client/offlinesession.go b/storage/ent/client/offlinesession.go
index 9d608cb6..c4fb9ef6 100644
--- a/storage/ent/client/offlinesession.go
+++ b/storage/ent/client/offlinesession.go
@@ -22,6 +22,8 @@ func (d *Database) CreateOfflineSessions(ctx context.Context, session storage.Of
 		SetConnID(session.ConnID).
 		SetConnectorData(session.ConnectorData).
 		SetRefresh(encodedRefresh).
+		SetTotp(session.TOTP).
+		SetTotpConfirmed(session.TOTPConfirmed).
 		Save(ctx)
 	if err != nil {
 		return convertDBError("create offline session: %w", err)
@@ -80,6 +82,8 @@ func (d *Database) UpdateOfflineSessions(ctx context.Context, userID string, con
 		SetConnID(newOfflineSession.ConnID).
 		SetConnectorData(newOfflineSession.ConnectorData).
 		SetRefresh(encodedRefresh).
+		SetTotp(newOfflineSession.TOTP).
+		SetTotpConfirmed(newOfflineSession.TOTPConfirmed).
 		Save(ctx)
 	if err != nil {
 		return rollback(tx, "update offline session uploading: %w", err)
diff --git a/storage/ent/client/types.go b/storage/ent/client/types.go
index 397d4d30..81bca0ae 100644
--- a/storage/ent/client/types.go
+++ b/storage/ent/client/types.go
@@ -45,7 +45,8 @@ func toStorageAuthRequest(a *db.AuthRequest) storage.AuthRequest {
 			CodeChallenge:       a.CodeChallenge,
 			CodeChallengeMethod: a.CodeChallengeMethod,
 		},
-		HMACKey: a.HmacKey,
+		HMACKey:       a.HmacKey,
+		TOTPValidated: a.TotpValidated,
 	}
 }

@@ -100,6 +101,8 @@ func toStorageOfflineSession(o *db.OfflineSession) storage.OfflineSessions {
 		UserID:        o.UserID,
 		ConnID:        o.ConnID,
 		ConnectorData: *o.ConnectorData,
+		TOTP:          o.Totp,
+		TOTPConfirmed: o.TotpConfirmed,
 	}

 	if o.Refresh != nil {
diff --git a/storage/ent/db/authrequest.go b/storage/ent/db/authrequest.go
index b95592e5..a0f25453 100644
--- a/storage/ent/db/authrequest.go
+++ b/storage/ent/db/authrequest.go
@@ -57,8 +57,10 @@ type AuthRequest struct {
 	// CodeChallengeMethod holds the value of the "code_challenge_method" field.
 	CodeChallengeMethod string `json:"code_challenge_method,omitempty"`
 	// HmacKey holds the value of the "hmac_key" field.
-	HmacKey      []byte `json:"hmac_key,omitempty"`
-	selectValues sql.SelectValues
+	HmacKey []byte `json:"hmac_key,omitempty"`
+	// TotpValidated holds the value of the "totp_validated" field.
+	TotpValidated bool `json:"totp_validated,omitempty"`
+	selectValues  sql.SelectValues
 }

 // scanValues returns the types for scanning values from sql.Rows.
@@ -68,7 +70,7 @@ func (*AuthRequest) scanValues(columns []string) ([]any, error) {
 		switch columns[i] {
 		case authrequest.FieldScopes, authrequest.FieldResponseTypes, authrequest.FieldClaimsGroups, authrequest.FieldConnectorData, authrequest.FieldHmacKey:
 			values[i] = new([]byte)
-		case authrequest.FieldForceApprovalPrompt, authrequest.FieldLoggedIn, authrequest.FieldClaimsEmailVerified:
+		case authrequest.FieldForceApprovalPrompt, authrequest.FieldLoggedIn, authrequest.FieldClaimsEmailVerified, authrequest.FieldTotpValidated:
 			values[i] = new(sql.NullBool)
 		case authrequest.FieldID, authrequest.FieldClientID, authrequest.FieldRedirectURI, authrequest.FieldNonce, authrequest.FieldState, authrequest.FieldClaimsUserID, authrequest.FieldClaimsUsername, authrequest.FieldClaimsEmail, authrequest.FieldClaimsPreferredUsername, authrequest.FieldConnectorID, authrequest.FieldCodeChallenge, authrequest.FieldCodeChallengeMethod:
 			values[i] = new(sql.NullString)
@@ -221,6 +223,12 @@ func (ar *AuthRequest) assignValues(columns []string, values []any) error {
 			} else if value != nil {
 				ar.HmacKey = *value
 			}
+		case authrequest.FieldTotpValidated:
+			if value, ok := values[i].(*sql.NullBool); !ok {
+				return fmt.Errorf("unexpected type %T for field totp_validated", values[i])
+			} else if value.Valid {
+				ar.TotpValidated = value.Bool
+			}
 		default:
 			ar.selectValues.Set(columns[i], values[i])
 		}
@@ -318,6 +326,9 @@ func (ar *AuthRequest) String() string {
 	builder.WriteString(", ")
 	builder.WriteString("hmac_key=")
 	builder.WriteString(fmt.Sprintf("%v", ar.HmacKey))
+	builder.WriteString(", ")
+	builder.WriteString("totp_validated=")
+	builder.WriteString(fmt.Sprintf("%v", ar.TotpValidated))
 	builder.WriteByte(')')
 	return builder.String()
 }
diff --git a/storage/ent/db/authrequest/authrequest.go b/storage/ent/db/authrequest/authrequest.go
index 0998c799..5ed7e4e9 100644
--- a/storage/ent/db/authrequest/authrequest.go
+++ b/storage/ent/db/authrequest/authrequest.go
@@ -51,6 +51,8 @@ const (
 	FieldCodeChallengeMethod = "code_challenge_method"
 	// FieldHmacKey holds the string denoting the hmac_key field in the database.
 	FieldHmacKey = "hmac_key"
+	// FieldTotpValidated holds the string denoting the totp_validated field in the database.
+	FieldTotpValidated = "totp_validated"
 	// Table holds the table name of the authrequest in the database.
 	Table = "auth_requests"
 )
@@ -78,6 +80,7 @@ var Columns = []string{
 	FieldCodeChallenge,
 	FieldCodeChallengeMethod,
 	FieldHmacKey,
+	FieldTotpValidated,
 }

 // ValidColumn reports if the column name is valid (part of the table columns).
@@ -97,6 +100,8 @@ var (
 	DefaultCodeChallenge string
 	// DefaultCodeChallengeMethod holds the default value on creation for the "code_challenge_method" field.
 	DefaultCodeChallengeMethod string
+	// DefaultTotpValidated holds the default value on creation for the "totp_validated" field.
+	DefaultTotpValidated bool
 	// IDValidator is a validator for the "id" field. It is called by the builders before save.
 	IDValidator func(string) error
 )
@@ -183,3 +188,8 @@ func ByCodeChallenge(opts ...sql.OrderTermOption) OrderOption {
 func ByCodeChallengeMethod(opts ...sql.OrderTermOption) OrderOption {
 	return sql.OrderByField(FieldCodeChallengeMethod, opts...).ToFunc()
 }
+
+// ByTotpValidated orders the results by the totp_validated field.
+func ByTotpValidated(opts ...sql.OrderTermOption) OrderOption {
+	return sql.OrderByField(FieldTotpValidated, opts...).ToFunc()
+}
diff --git a/storage/ent/db/authrequest/where.go b/storage/ent/db/authrequest/where.go
index 4d3a39be..1da8d249 100644
--- a/storage/ent/db/authrequest/where.go
+++ b/storage/ent/db/authrequest/where.go
@@ -149,6 +149,11 @@ func HmacKey(v []byte) predicate.AuthRequest {
 	return predicate.AuthRequest(sql.FieldEQ(FieldHmacKey, v))
 }

+// TotpValidated applies equality check predicate on the "totp_validated" field. It's identical to TotpValidatedEQ.
+func TotpValidated(v bool) predicate.AuthRequest {
+	return predicate.AuthRequest(sql.FieldEQ(FieldTotpValidated, v))
+}
+
 // ClientIDEQ applies the EQ predicate on the "client_id" field.
 func ClientIDEQ(v string) predicate.AuthRequest {
 	return predicate.AuthRequest(sql.FieldEQ(FieldClientID, v))
@@ -1054,6 +1059,16 @@ func HmacKeyLTE(v []byte) predicate.AuthRequest {
 	return predicate.AuthRequest(sql.FieldLTE(FieldHmacKey, v))
 }

+// TotpValidatedEQ applies the EQ predicate on the "totp_validated" field.
+func TotpValidatedEQ(v bool) predicate.AuthRequest {
+	return predicate.AuthRequest(sql.FieldEQ(FieldTotpValidated, v))
+}
+
+// TotpValidatedNEQ applies the NEQ predicate on the "totp_validated" field.
+func TotpValidatedNEQ(v bool) predicate.AuthRequest {
+	return predicate.AuthRequest(sql.FieldNEQ(FieldTotpValidated, v))
+}
+
 // And groups predicates with the AND operator between them.
 func And(predicates ...predicate.AuthRequest) predicate.AuthRequest {
 	return predicate.AuthRequest(sql.AndPredicates(predicates...))
diff --git a/storage/ent/db/authrequest_create.go b/storage/ent/db/authrequest_create.go
index 3fe0c2b1..62085c0b 100644
--- a/storage/ent/db/authrequest_create.go
+++ b/storage/ent/db/authrequest_create.go
@@ -164,6 +164,20 @@ func (arc *AuthRequestCreate) SetHmacKey(b []byte) *AuthRequestCreate {
 	return arc
 }

+// SetTotpValidated sets the "totp_validated" field.
+func (arc *AuthRequestCreate) SetTotpValidated(b bool) *AuthRequestCreate {
+	arc.mutation.SetTotpValidated(b)
+	return arc
+}
+
+// SetNillableTotpValidated sets the "totp_validated" field if the given value is not nil.
+func (arc *AuthRequestCreate) SetNillableTotpValidated(b *bool) *AuthRequestCreate {
+	if b != nil {
+		arc.SetTotpValidated(*b)
+	}
+	return arc
+}
+
 // SetID sets the "id" field.
 func (arc *AuthRequestCreate) SetID(s string) *AuthRequestCreate {
 	arc.mutation.SetID(s)
@@ -217,6 +231,10 @@ func (arc *AuthRequestCreate) defaults() {
 		v := authrequest.DefaultCodeChallengeMethod
 		arc.mutation.SetCodeChallengeMethod(v)
 	}
+	if _, ok := arc.mutation.TotpValidated(); !ok {
+		v := authrequest.DefaultTotpValidated
+		arc.mutation.SetTotpValidated(v)
+	}
 }

 // check runs all checks and user-defined validators on the builder.
@@ -269,6 +287,9 @@ func (arc *AuthRequestCreate) check() error {
 	if _, ok := arc.mutation.HmacKey(); !ok {
 		return &ValidationError{Name: "hmac_key", err: errors.New(`db: missing required field "AuthRequest.hmac_key"`)}
 	}
+	if _, ok := arc.mutation.TotpValidated(); !ok {
+		return &ValidationError{Name: "totp_validated", err: errors.New(`db: missing required field "AuthRequest.totp_validated"`)}
+	}
 	if v, ok := arc.mutation.ID(); ok {
 		if err := authrequest.IDValidator(v); err != nil {
 			return &ValidationError{Name: "id", err: fmt.Errorf(`db: validator failed for field "AuthRequest.id": %w`, err)}
@@ -389,6 +410,10 @@ func (arc *AuthRequestCreate) createSpec() (*AuthRequest, *sqlgraph.CreateSpec)
 		_spec.SetField(authrequest.FieldHmacKey, field.TypeBytes, value)
 		_node.HmacKey = value
 	}
+	if value, ok := arc.mutation.TotpValidated(); ok {
+		_spec.SetField(authrequest.FieldTotpValidated, field.TypeBool, value)
+		_node.TotpValidated = value
+	}
 	return _node, _spec
 }

diff --git a/storage/ent/db/authrequest_update.go b/storage/ent/db/authrequest_update.go
index 0f314a4f..ab40d5c4 100644
--- a/storage/ent/db/authrequest_update.go
+++ b/storage/ent/db/authrequest_update.go
@@ -311,6 +311,20 @@ func (aru *AuthRequestUpdate) SetHmacKey(b []byte) *AuthRequestUpdate {
 	return aru
 }

+// SetTotpValidated sets the "totp_validated" field.
+func (aru *AuthRequestUpdate) SetTotpValidated(b bool) *AuthRequestUpdate {
+	aru.mutation.SetTotpValidated(b)
+	return aru
+}
+
+// SetNillableTotpValidated sets the "totp_validated" field if the given value is not nil.
+func (aru *AuthRequestUpdate) SetNillableTotpValidated(b *bool) *AuthRequestUpdate {
+	if b != nil {
+		aru.SetTotpValidated(*b)
+	}
+	return aru
+}
+
 // Mutation returns the AuthRequestMutation object of the builder.
 func (aru *AuthRequestUpdate) Mutation() *AuthRequestMutation {
 	return aru.mutation
@@ -439,6 +453,9 @@ func (aru *AuthRequestUpdate) sqlSave(ctx context.Context) (n int, err error) {
 	if value, ok := aru.mutation.HmacKey(); ok {
 		_spec.SetField(authrequest.FieldHmacKey, field.TypeBytes, value)
 	}
+	if value, ok := aru.mutation.TotpValidated(); ok {
+		_spec.SetField(authrequest.FieldTotpValidated, field.TypeBool, value)
+	}
 	if n, err = sqlgraph.UpdateNodes(ctx, aru.driver, _spec); err != nil {
 		if _, ok := err.(*sqlgraph.NotFoundError); ok {
 			err = &NotFoundError{authrequest.Label}
@@ -741,6 +758,20 @@ func (aruo *AuthRequestUpdateOne) SetHmacKey(b []byte) *AuthRequestUpdateOne {
 	return aruo
 }

+// SetTotpValidated sets the "totp_validated" field.
+func (aruo *AuthRequestUpdateOne) SetTotpValidated(b bool) *AuthRequestUpdateOne {
+	aruo.mutation.SetTotpValidated(b)
+	return aruo
+}
+
+// SetNillableTotpValidated sets the "totp_validated" field if the given value is not nil.
+func (aruo *AuthRequestUpdateOne) SetNillableTotpValidated(b *bool) *AuthRequestUpdateOne {
+	if b != nil {
+		aruo.SetTotpValidated(*b)
+	}
+	return aruo
+}
+
 // Mutation returns the AuthRequestMutation object of the builder.
 func (aruo *AuthRequestUpdateOne) Mutation() *AuthRequestMutation {
 	return aruo.mutation
@@ -899,6 +930,9 @@ func (aruo *AuthRequestUpdateOne) sqlSave(ctx context.Context) (_node *AuthReque
 	if value, ok := aruo.mutation.HmacKey(); ok {
 		_spec.SetField(authrequest.FieldHmacKey, field.TypeBytes, value)
 	}
+	if value, ok := aruo.mutation.TotpValidated(); ok {
+		_spec.SetField(authrequest.FieldTotpValidated, field.TypeBool, value)
+	}
 	_node = &AuthRequest{config: aruo.config}
 	_spec.Assign = _node.assignValues
 	_spec.ScanValues = _node.scanValues
diff --git a/storage/ent/db/migrate/schema.go b/storage/ent/db/migrate/schema.go
index d3295a0c..ac9a80f4 100644
--- a/storage/ent/db/migrate/schema.go
+++ b/storage/ent/db/migrate/schema.go
@@ -56,6 +56,7 @@ var (
 		{Name: "code_challenge", Type: field.TypeString, Size: 2147483647, Default: "", SchemaType: map[string]string{"mysql": "varchar(384)", "postgres": "text", "sqlite3": "text"}},
 		{Name: "code_challenge_method", Type: field.TypeString, Size: 2147483647, Default: "", SchemaType: map[string]string{"mysql": "varchar(384)", "postgres": "text", "sqlite3": "text"}},
 		{Name: "hmac_key", Type: field.TypeBytes},
+		{Name: "totp_validated", Type: field.TypeBool, Default: false},
 	}
 	// AuthRequestsTable holds the schema information for the "auth_requests" table.
 	AuthRequestsTable = &schema.Table{
@@ -148,6 +149,8 @@ var (
 		{Name: "conn_id", Type: field.TypeString, Size: 2147483647, SchemaType: map[string]string{"mysql": "varchar(384)", "postgres": "text", "sqlite3": "text"}},
 		{Name: "refresh", Type: field.TypeBytes},
 		{Name: "connector_data", Type: field.TypeBytes, Nullable: true},
+		{Name: "totp", Type: field.TypeString, Nullable: true, Size: 2147483647},
+		{Name: "totp_confirmed", Type: field.TypeBool, Nullable: true, Default: false},
 	}
 	// OfflineSessionsTable holds the schema information for the "offline_sessions" table.
 	OfflineSessionsTable = &schema.Table{
diff --git a/storage/ent/db/mutation.go b/storage/ent/db/mutation.go
index 71203574..549c94d3 100644
--- a/storage/ent/db/mutation.go
+++ b/storage/ent/db/mutation.go
@@ -1258,6 +1258,7 @@ type AuthRequestMutation struct {
 	code_challenge            *string
 	code_challenge_method     *string
 	hmac_key                  *[]byte
+	totp_validated            *bool
 	clearedFields             map[string]struct{}
 	done                      bool
 	oldValue                  func(context.Context) (*AuthRequest, error)
@@ -2188,6 +2189,42 @@ func (m *AuthRequestMutation) ResetHmacKey() {
 	m.hmac_key = nil
 }

+// SetTotpValidated sets the "totp_validated" field.
+func (m *AuthRequestMutation) SetTotpValidated(b bool) {
+	m.totp_validated = &b
+}
+
+// TotpValidated returns the value of the "totp_validated" field in the mutation.
+func (m *AuthRequestMutation) TotpValidated() (r bool, exists bool) {
+	v := m.totp_validated
+	if v == nil {
+		return
+	}
+	return *v, true
+}
+
+// OldTotpValidated returns the old "totp_validated" field's value of the AuthRequest entity.
+// If the AuthRequest object wasn't provided to the builder, the object is fetched from the database.
+// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
+func (m *AuthRequestMutation) OldTotpValidated(ctx context.Context) (v bool, err error) {
+	if !m.op.Is(OpUpdateOne) {
+		return v, errors.New("OldTotpValidated is only allowed on UpdateOne operations")
+	}
+	if m.id == nil || m.oldValue == nil {
+		return v, errors.New("OldTotpValidated requires an ID field in the mutation")
+	}
+	oldValue, err := m.oldValue(ctx)
+	if err != nil {
+		return v, fmt.Errorf("querying old value for OldTotpValidated: %w", err)
+	}
+	return oldValue.TotpValidated, nil
+}
+
+// ResetTotpValidated resets all changes to the "totp_validated" field.
+func (m *AuthRequestMutation) ResetTotpValidated() {
+	m.totp_validated = nil
+}
+
 // Where appends a list predicates to the AuthRequestMutation builder.
 func (m *AuthRequestMutation) Where(ps ...predicate.AuthRequest) {
 	m.predicates = append(m.predicates, ps...)
@@ -2222,7 +2259,7 @@ func (m *AuthRequestMutation) Type() string {
 // order to get all numeric fields that were incremented/decremented, call
 // AddedFields().
 func (m *AuthRequestMutation) Fields() []string {
-	fields := make([]string, 0, 20)
+	fields := make([]string, 0, 21)
 	if m.client_id != nil {
 		fields = append(fields, authrequest.FieldClientID)
 	}
@@ -2283,6 +2320,9 @@ func (m *AuthRequestMutation) Fields() []string {
 	if m.hmac_key != nil {
 		fields = append(fields, authrequest.FieldHmacKey)
 	}
+	if m.totp_validated != nil {
+		fields = append(fields, authrequest.FieldTotpValidated)
+	}
 	return fields
 }

@@ -2331,6 +2371,8 @@ func (m *AuthRequestMutation) Field(name string) (ent.Value, bool) {
 		return m.CodeChallengeMethod()
 	case authrequest.FieldHmacKey:
 		return m.HmacKey()
+	case authrequest.FieldTotpValidated:
+		return m.TotpValidated()
 	}
 	return nil, false
 }
@@ -2380,6 +2422,8 @@ func (m *AuthRequestMutation) OldField(ctx context.Context, name string) (ent.Va
 		return m.OldCodeChallengeMethod(ctx)
 	case authrequest.FieldHmacKey:
 		return m.OldHmacKey(ctx)
+	case authrequest.FieldTotpValidated:
+		return m.OldTotpValidated(ctx)
 	}
 	return nil, fmt.Errorf("unknown AuthRequest field %s", name)
 }
@@ -2529,6 +2573,13 @@ func (m *AuthRequestMutation) SetField(name string, value ent.Value) error {
 		}
 		m.SetHmacKey(v)
 		return nil
+	case authrequest.FieldTotpValidated:
+		v, ok := value.(bool)
+		if !ok {
+			return fmt.Errorf("unexpected type %T for field %s", value, name)
+		}
+		m.SetTotpValidated(v)
+		return nil
 	}
 	return fmt.Errorf("unknown AuthRequest field %s", name)
 }
@@ -2665,6 +2716,9 @@ func (m *AuthRequestMutation) ResetField(name string) error {
 	case authrequest.FieldHmacKey:
 		m.ResetHmacKey()
 		return nil
+	case authrequest.FieldTotpValidated:
+		m.ResetTotpValidated()
+		return nil
 	}
 	return fmt.Errorf("unknown AuthRequest field %s", name)
 }
@@ -5805,6 +5859,8 @@ type OfflineSessionMutation struct {
 	conn_id        *string
 	refresh        *[]byte
 	connector_data *[]byte
+	totp           *string
+	totp_confirmed *bool
 	clearedFields  map[string]struct{}
 	done           bool
 	oldValue       func(context.Context) (*OfflineSession, error)
@@ -6072,6 +6128,104 @@ func (m *OfflineSessionMutation) ResetConnectorData() {
 	delete(m.clearedFields, offlinesession.FieldConnectorData)
 }

+// SetTotp sets the "totp" field.
+func (m *OfflineSessionMutation) SetTotp(s string) {
+	m.totp = &s
+}
+
+// Totp returns the value of the "totp" field in the mutation.
+func (m *OfflineSessionMutation) Totp() (r string, exists bool) {
+	v := m.totp
+	if v == nil {
+		return
+	}
+	return *v, true
+}
+
+// OldTotp returns the old "totp" field's value of the OfflineSession entity.
+// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.
+// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
+func (m *OfflineSessionMutation) OldTotp(ctx context.Context) (v string, err error) {
+	if !m.op.Is(OpUpdateOne) {
+		return v, errors.New("OldTotp is only allowed on UpdateOne operations")
+	}
+	if m.id == nil || m.oldValue == nil {
+		return v, errors.New("OldTotp requires an ID field in the mutation")
+	}
+	oldValue, err := m.oldValue(ctx)
+	if err != nil {
+		return v, fmt.Errorf("querying old value for OldTotp: %w", err)
+	}
+	return oldValue.Totp, nil
+}
+
+// ClearTotp clears the value of the "totp" field.
+func (m *OfflineSessionMutation) ClearTotp() {
+	m.totp = nil
+	m.clearedFields[offlinesession.FieldTotp] = struct{}{}
+}
+
+// TotpCleared returns if the "totp" field was cleared in this mutation.
+func (m *OfflineSessionMutation) TotpCleared() bool {
+	_, ok := m.clearedFields[offlinesession.FieldTotp]
+	return ok
+}
+
+// ResetTotp resets all changes to the "totp" field.
+func (m *OfflineSessionMutation) ResetTotp() {
+	m.totp = nil
+	delete(m.clearedFields, offlinesession.FieldTotp)
+}
+
+// SetTotpConfirmed sets the "totp_confirmed" field.
+func (m *OfflineSessionMutation) SetTotpConfirmed(b bool) {
+	m.totp_confirmed = &b
+}
+
+// TotpConfirmed returns the value of the "totp_confirmed" field in the mutation.
+func (m *OfflineSessionMutation) TotpConfirmed() (r bool, exists bool) {
+	v := m.totp_confirmed
+	if v == nil {
+		return
+	}
+	return *v, true
+}
+
+// OldTotpConfirmed returns the old "totp_confirmed" field's value of the OfflineSession entity.
+// If the OfflineSession object wasn't provided to the builder, the object is fetched from the database.
+// An error is returned if the mutation operation is not UpdateOne, or the database query fails.
+func (m *OfflineSessionMutation) OldTotpConfirmed(ctx context.Context) (v bool, err error) {
+	if !m.op.Is(OpUpdateOne) {
+		return v, errors.New("OldTotpConfirmed is only allowed on UpdateOne operations")
+	}
+	if m.id == nil || m.oldValue == nil {
+		return v, errors.New("OldTotpConfirmed requires an ID field in the mutation")
+	}
+	oldValue, err := m.oldValue(ctx)
+	if err != nil {
+		return v, fmt.Errorf("querying old value for OldTotpConfirmed: %w", err)
+	}
+	return oldValue.TotpConfirmed, nil
+}
+
+// ClearTotpConfirmed clears the value of the "totp_confirmed" field.
+func (m *OfflineSessionMutation) ClearTotpConfirmed() {
+	m.totp_confirmed = nil
+	m.clearedFields[offlinesession.FieldTotpConfirmed] = struct{}{}
+}
+
+// TotpConfirmedCleared returns if the "totp_confirmed" field was cleared in this mutation.
+func (m *OfflineSessionMutation) TotpConfirmedCleared() bool {
+	_, ok := m.clearedFields[offlinesession.FieldTotpConfirmed]
+	return ok
+}
+
+// ResetTotpConfirmed resets all changes to the "totp_confirmed" field.
+func (m *OfflineSessionMutation) ResetTotpConfirmed() {
+	m.totp_confirmed = nil
+	delete(m.clearedFields, offlinesession.FieldTotpConfirmed)
+}
+
 // Where appends a list predicates to the OfflineSessionMutation builder.
 func (m *OfflineSessionMutation) Where(ps ...predicate.OfflineSession) {
 	m.predicates = append(m.predicates, ps...)
@@ -6106,7 +6260,7 @@ func (m *OfflineSessionMutation) Type() string {
 // order to get all numeric fields that were incremented/decremented, call
 // AddedFields().
 func (m *OfflineSessionMutation) Fields() []string {
-	fields := make([]string, 0, 4)
+	fields := make([]string, 0, 6)
 	if m.user_id != nil {
 		fields = append(fields, offlinesession.FieldUserID)
 	}
@@ -6119,6 +6273,12 @@ func (m *OfflineSessionMutation) Fields() []string {
 	if m.connector_data != nil {
 		fields = append(fields, offlinesession.FieldConnectorData)
 	}
+	if m.totp != nil {
+		fields = append(fields, offlinesession.FieldTotp)
+	}
+	if m.totp_confirmed != nil {
+		fields = append(fields, offlinesession.FieldTotpConfirmed)
+	}
 	return fields
 }

@@ -6135,6 +6295,10 @@ func (m *OfflineSessionMutation) Field(name string) (ent.Value, bool) {
 		return m.Refresh()
 	case offlinesession.FieldConnectorData:
 		return m.ConnectorData()
+	case offlinesession.FieldTotp:
+		return m.Totp()
+	case offlinesession.FieldTotpConfirmed:
+		return m.TotpConfirmed()
 	}
 	return nil, false
 }
@@ -6152,6 +6316,10 @@ func (m *OfflineSessionMutation) OldField(ctx context.Context, name string) (ent
 		return m.OldRefresh(ctx)
 	case offlinesession.FieldConnectorData:
 		return m.OldConnectorData(ctx)
+	case offlinesession.FieldTotp:
+		return m.OldTotp(ctx)
+	case offlinesession.FieldTotpConfirmed:
+		return m.OldTotpConfirmed(ctx)
 	}
 	return nil, fmt.Errorf("unknown OfflineSession field %s", name)
 }
@@ -6189,6 +6357,20 @@ func (m *OfflineSessionMutation) SetField(name string, value ent.Value) error {
 		}
 		m.SetConnectorData(v)
 		return nil
+	case offlinesession.FieldTotp:
+		v, ok := value.(string)
+		if !ok {
+			return fmt.Errorf("unexpected type %T for field %s", value, name)
+		}
+		m.SetTotp(v)
+		return nil
+	case offlinesession.FieldTotpConfirmed:
+		v, ok := value.(bool)
+		if !ok {
+			return fmt.Errorf("unexpected type %T for field %s", value, name)
+		}
+		m.SetTotpConfirmed(v)
+		return nil
 	}
 	return fmt.Errorf("unknown OfflineSession field %s", name)
 }
@@ -6222,6 +6404,12 @@ func (m *OfflineSessionMutation) ClearedFields() []string {
 	if m.FieldCleared(offlinesession.FieldConnectorData) {
 		fields = append(fields, offlinesession.FieldConnectorData)
 	}
+	if m.FieldCleared(offlinesession.FieldTotp) {
+		fields = append(fields, offlinesession.FieldTotp)
+	}
+	if m.FieldCleared(offlinesession.FieldTotpConfirmed) {
+		fields = append(fields, offlinesession.FieldTotpConfirmed)
+	}
 	return fields
 }

@@ -6239,6 +6427,12 @@ func (m *OfflineSessionMutation) ClearField(name string) error {
 	case offlinesession.FieldConnectorData:
 		m.ClearConnectorData()
 		return nil
+	case offlinesession.FieldTotp:
+		m.ClearTotp()
+		return nil
+	case offlinesession.FieldTotpConfirmed:
+		m.ClearTotpConfirmed()
+		return nil
 	}
 	return fmt.Errorf("unknown OfflineSession nullable field %s", name)
 }
@@ -6259,6 +6453,12 @@ func (m *OfflineSessionMutation) ResetField(name string) error {
 	case offlinesession.FieldConnectorData:
 		m.ResetConnectorData()
 		return nil
+	case offlinesession.FieldTotp:
+		m.ResetTotp()
+		return nil
+	case offlinesession.FieldTotpConfirmed:
+		m.ResetTotpConfirmed()
+		return nil
 	}
 	return fmt.Errorf("unknown OfflineSession field %s", name)
 }
diff --git a/storage/ent/db/offlinesession.go b/storage/ent/db/offlinesession.go
index 7adc3afc..611636cf 100644
--- a/storage/ent/db/offlinesession.go
+++ b/storage/ent/db/offlinesession.go
@@ -24,6 +24,10 @@ type OfflineSession struct {
 	Refresh []byte `json:"refresh,omitempty"`
 	// ConnectorData holds the value of the "connector_data" field.
 	ConnectorData *[]byte `json:"connector_data,omitempty"`
+	// Totp holds the value of the "totp" field.
+	Totp string `json:"totp,omitempty"`
+	// TotpConfirmed holds the value of the "totp_confirmed" field.
+	TotpConfirmed bool `json:"totp_confirmed,omitempty"`
 	selectValues  sql.SelectValues
 }

@@ -34,7 +38,9 @@ func (*OfflineSession) scanValues(columns []string) ([]any, error) {
 		switch columns[i] {
 		case offlinesession.FieldRefresh, offlinesession.FieldConnectorData:
 			values[i] = new([]byte)
-		case offlinesession.FieldID, offlinesession.FieldUserID, offlinesession.FieldConnID:
+		case offlinesession.FieldTotpConfirmed:
+			values[i] = new(sql.NullBool)
+		case offlinesession.FieldID, offlinesession.FieldUserID, offlinesession.FieldConnID, offlinesession.FieldTotp:
 			values[i] = new(sql.NullString)
 		default:
 			values[i] = new(sql.UnknownType)
@@ -81,6 +87,18 @@ func (os *OfflineSession) assignValues(columns []string, values []any) error {
 			} else if value != nil {
 				os.ConnectorData = value
 			}
+		case offlinesession.FieldTotp:
+			if value, ok := values[i].(*sql.NullString); !ok {
+				return fmt.Errorf("unexpected type %T for field totp", values[i])
+			} else if value.Valid {
+				os.Totp = value.String
+			}
+		case offlinesession.FieldTotpConfirmed:
+			if value, ok := values[i].(*sql.NullBool); !ok {
+				return fmt.Errorf("unexpected type %T for field totp_confirmed", values[i])
+			} else if value.Valid {
+				os.TotpConfirmed = value.Bool
+			}
 		default:
 			os.selectValues.Set(columns[i], values[i])
 		}
@@ -130,6 +148,12 @@ func (os *OfflineSession) String() string {
 		builder.WriteString("connector_data=")
 		builder.WriteString(fmt.Sprintf("%v", *v))
 	}
+	builder.WriteString(", ")
+	builder.WriteString("totp=")
+	builder.WriteString(os.Totp)
+	builder.WriteString(", ")
+	builder.WriteString("totp_confirmed=")
+	builder.WriteString(fmt.Sprintf("%v", os.TotpConfirmed))
 	builder.WriteByte(')')
 	return builder.String()
 }
diff --git a/storage/ent/db/offlinesession/offlinesession.go b/storage/ent/db/offlinesession/offlinesession.go
index e7dbc446..fecf7cca 100644
--- a/storage/ent/db/offlinesession/offlinesession.go
+++ b/storage/ent/db/offlinesession/offlinesession.go
@@ -19,6 +19,10 @@ const (
 	FieldRefresh = "refresh"
 	// FieldConnectorData holds the string denoting the connector_data field in the database.
 	FieldConnectorData = "connector_data"
+	// FieldTotp holds the string denoting the totp field in the database.
+	FieldTotp = "totp"
+	// FieldTotpConfirmed holds the string denoting the totp_confirmed field in the database.
+	FieldTotpConfirmed = "totp_confirmed"
 	// Table holds the table name of the offlinesession in the database.
 	Table = "offline_sessions"
 )
@@ -30,6 +34,8 @@ var Columns = []string{
 	FieldConnID,
 	FieldRefresh,
 	FieldConnectorData,
+	FieldTotp,
+	FieldTotpConfirmed,
 }

 // ValidColumn reports if the column name is valid (part of the table columns).
@@ -47,6 +53,8 @@ var (
 	UserIDValidator func(string) error
 	// ConnIDValidator is a validator for the "conn_id" field. It is called by the builders before save.
 	ConnIDValidator func(string) error
+	// DefaultTotpConfirmed holds the default value on creation for the "totp_confirmed" field.
+	DefaultTotpConfirmed bool
 	// IDValidator is a validator for the "id" field. It is called by the builders before save.
 	IDValidator func(string) error
 )
@@ -68,3 +76,13 @@ func ByUserID(opts ...sql.OrderTermOption) OrderOption {
 func ByConnID(opts ...sql.OrderTermOption) OrderOption {
 	return sql.OrderByField(FieldConnID, opts...).ToFunc()
 }
+
+// ByTotp orders the results by the totp field.
+func ByTotp(opts ...sql.OrderTermOption) OrderOption {
+	return sql.OrderByField(FieldTotp, opts...).ToFunc()
+}
+
+// ByTotpConfirmed orders the results by the totp_confirmed field.
+func ByTotpConfirmed(opts ...sql.OrderTermOption) OrderOption {
+	return sql.OrderByField(FieldTotpConfirmed, opts...).ToFunc()
+}
diff --git a/storage/ent/db/offlinesession/where.go b/storage/ent/db/offlinesession/where.go
index e0f19ab2..d30f0bbb 100644
--- a/storage/ent/db/offlinesession/where.go
+++ b/storage/ent/db/offlinesession/where.go
@@ -82,6 +82,16 @@ func ConnectorData(v []byte) predicate.OfflineSession {
 	return predicate.OfflineSession(sql.FieldEQ(FieldConnectorData, v))
 }

+// Totp applies equality check predicate on the "totp" field. It's identical to TotpEQ.
+func Totp(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldEQ(FieldTotp, v))
+}
+
+// TotpConfirmed applies equality check predicate on the "totp_confirmed" field. It's identical to TotpConfirmedEQ.
+func TotpConfirmed(v bool) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldEQ(FieldTotpConfirmed, v))
+}
+
 // UserIDEQ applies the EQ predicate on the "user_id" field.
 func UserIDEQ(v string) predicate.OfflineSession {
 	return predicate.OfflineSession(sql.FieldEQ(FieldUserID, v))
@@ -302,6 +312,101 @@ func ConnectorDataNotNil() predicate.OfflineSession {
 	return predicate.OfflineSession(sql.FieldNotNull(FieldConnectorData))
 }

+// TotpEQ applies the EQ predicate on the "totp" field.
+func TotpEQ(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldEQ(FieldTotp, v))
+}
+
+// TotpNEQ applies the NEQ predicate on the "totp" field.
+func TotpNEQ(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldNEQ(FieldTotp, v))
+}
+
+// TotpIn applies the In predicate on the "totp" field.
+func TotpIn(vs ...string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldIn(FieldTotp, vs...))
+}
+
+// TotpNotIn applies the NotIn predicate on the "totp" field.
+func TotpNotIn(vs ...string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldNotIn(FieldTotp, vs...))
+}
+
+// TotpGT applies the GT predicate on the "totp" field.
+func TotpGT(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldGT(FieldTotp, v))
+}
+
+// TotpGTE applies the GTE predicate on the "totp" field.
+func TotpGTE(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldGTE(FieldTotp, v))
+}
+
+// TotpLT applies the LT predicate on the "totp" field.
+func TotpLT(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldLT(FieldTotp, v))
+}
+
+// TotpLTE applies the LTE predicate on the "totp" field.
+func TotpLTE(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldLTE(FieldTotp, v))
+}
+
+// TotpContains applies the Contains predicate on the "totp" field.
+func TotpContains(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldContains(FieldTotp, v))
+}
+
+// TotpHasPrefix applies the HasPrefix predicate on the "totp" field.
+func TotpHasPrefix(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldHasPrefix(FieldTotp, v))
+}
+
+// TotpHasSuffix applies the HasSuffix predicate on the "totp" field.
+func TotpHasSuffix(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldHasSuffix(FieldTotp, v))
+}
+
+// TotpIsNil applies the IsNil predicate on the "totp" field.
+func TotpIsNil() predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldIsNull(FieldTotp))
+}
+
+// TotpNotNil applies the NotNil predicate on the "totp" field.
+func TotpNotNil() predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldNotNull(FieldTotp))
+}
+
+// TotpEqualFold applies the EqualFold predicate on the "totp" field.
+func TotpEqualFold(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldEqualFold(FieldTotp, v))
+}
+
+// TotpContainsFold applies the ContainsFold predicate on the "totp" field.
+func TotpContainsFold(v string) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldContainsFold(FieldTotp, v))
+}
+
+// TotpConfirmedEQ applies the EQ predicate on the "totp_confirmed" field.
+func TotpConfirmedEQ(v bool) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldEQ(FieldTotpConfirmed, v))
+}
+
+// TotpConfirmedNEQ applies the NEQ predicate on the "totp_confirmed" field.
+func TotpConfirmedNEQ(v bool) predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldNEQ(FieldTotpConfirmed, v))
+}
+
+// TotpConfirmedIsNil applies the IsNil predicate on the "totp_confirmed" field.
+func TotpConfirmedIsNil() predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldIsNull(FieldTotpConfirmed))
+}
+
+// TotpConfirmedNotNil applies the NotNil predicate on the "totp_confirmed" field.
+func TotpConfirmedNotNil() predicate.OfflineSession {
+	return predicate.OfflineSession(sql.FieldNotNull(FieldTotpConfirmed))
+}
+
 // And groups predicates with the AND operator between them.
 func And(predicates ...predicate.OfflineSession) predicate.OfflineSession {
 	return predicate.OfflineSession(sql.AndPredicates(predicates...))
diff --git a/storage/ent/db/offlinesession_create.go b/storage/ent/db/offlinesession_create.go
index b8250aac..2fa25d31 100644
--- a/storage/ent/db/offlinesession_create.go
+++ b/storage/ent/db/offlinesession_create.go
@@ -43,6 +43,34 @@ func (osc *OfflineSessionCreate) SetConnectorData(b []byte) *OfflineSessionCreat
 	return osc
 }

+// SetTotp sets the "totp" field.
+func (osc *OfflineSessionCreate) SetTotp(s string) *OfflineSessionCreate {
+	osc.mutation.SetTotp(s)
+	return osc
+}
+
+// SetNillableTotp sets the "totp" field if the given value is not nil.
+func (osc *OfflineSessionCreate) SetNillableTotp(s *string) *OfflineSessionCreate {
+	if s != nil {
+		osc.SetTotp(*s)
+	}
+	return osc
+}
+
+// SetTotpConfirmed sets the "totp_confirmed" field.
+func (osc *OfflineSessionCreate) SetTotpConfirmed(b bool) *OfflineSessionCreate {
+	osc.mutation.SetTotpConfirmed(b)
+	return osc
+}
+
+// SetNillableTotpConfirmed sets the "totp_confirmed" field if the given value is not nil.
+func (osc *OfflineSessionCreate) SetNillableTotpConfirmed(b *bool) *OfflineSessionCreate {
+	if b != nil {
+		osc.SetTotpConfirmed(*b)
+	}
+	return osc
+}
+
 // SetID sets the "id" field.
 func (osc *OfflineSessionCreate) SetID(s string) *OfflineSessionCreate {
 	osc.mutation.SetID(s)
@@ -56,6 +84,7 @@ func (osc *OfflineSessionCreate) Mutation() *OfflineSessionMutation {

 // Save creates the OfflineSession in the database.
 func (osc *OfflineSessionCreate) Save(ctx context.Context) (*OfflineSession, error) {
+	osc.defaults()
 	return withHooks(ctx, osc.sqlSave, osc.mutation, osc.hooks)
 }

@@ -81,6 +110,14 @@ func (osc *OfflineSessionCreate) ExecX(ctx context.Context) {
 	}
 }

+// defaults sets the default values of the builder before save.
+func (osc *OfflineSessionCreate) defaults() {
+	if _, ok := osc.mutation.TotpConfirmed(); !ok {
+		v := offlinesession.DefaultTotpConfirmed
+		osc.mutation.SetTotpConfirmed(v)
+	}
+}
+
 // check runs all checks and user-defined validators on the builder.
 func (osc *OfflineSessionCreate) check() error {
 	if _, ok := osc.mutation.UserID(); !ok {
@@ -158,6 +195,14 @@ func (osc *OfflineSessionCreate) createSpec() (*OfflineSession, *sqlgraph.Create
 		_spec.SetField(offlinesession.FieldConnectorData, field.TypeBytes, value)
 		_node.ConnectorData = &value
 	}
+	if value, ok := osc.mutation.Totp(); ok {
+		_spec.SetField(offlinesession.FieldTotp, field.TypeString, value)
+		_node.Totp = value
+	}
+	if value, ok := osc.mutation.TotpConfirmed(); ok {
+		_spec.SetField(offlinesession.FieldTotpConfirmed, field.TypeBool, value)
+		_node.TotpConfirmed = value
+	}
 	return _node, _spec
 }

@@ -179,6 +224,7 @@ func (oscb *OfflineSessionCreateBulk) Save(ctx context.Context) ([]*OfflineSessi
 	for i := range oscb.builders {
 		func(i int, root context.Context) {
 			builder := oscb.builders[i]
+			builder.defaults()
 			var mut Mutator = MutateFunc(func(ctx context.Context, m Mutation) (Value, error) {
 				mutation, ok := m.(*OfflineSessionMutation)
 				if !ok {
diff --git a/storage/ent/db/offlinesession_update.go b/storage/ent/db/offlinesession_update.go
index d912acf1..76f77c60 100644
--- a/storage/ent/db/offlinesession_update.go
+++ b/storage/ent/db/offlinesession_update.go
@@ -73,6 +73,46 @@ func (osu *OfflineSessionUpdate) ClearConnectorData() *OfflineSessionUpdate {
 	return osu
 }

+// SetTotp sets the "totp" field.
+func (osu *OfflineSessionUpdate) SetTotp(s string) *OfflineSessionUpdate {
+	osu.mutation.SetTotp(s)
+	return osu
+}
+
+// SetNillableTotp sets the "totp" field if the given value is not nil.
+func (osu *OfflineSessionUpdate) SetNillableTotp(s *string) *OfflineSessionUpdate {
+	if s != nil {
+		osu.SetTotp(*s)
+	}
+	return osu
+}
+
+// ClearTotp clears the value of the "totp" field.
+func (osu *OfflineSessionUpdate) ClearTotp() *OfflineSessionUpdate {
+	osu.mutation.ClearTotp()
+	return osu
+}
+
+// SetTotpConfirmed sets the "totp_confirmed" field.
+func (osu *OfflineSessionUpdate) SetTotpConfirmed(b bool) *OfflineSessionUpdate {
+	osu.mutation.SetTotpConfirmed(b)
+	return osu
+}
+
+// SetNillableTotpConfirmed sets the "totp_confirmed" field if the given value is not nil.
+func (osu *OfflineSessionUpdate) SetNillableTotpConfirmed(b *bool) *OfflineSessionUpdate {
+	if b != nil {
+		osu.SetTotpConfirmed(*b)
+	}
+	return osu
+}
+
+// ClearTotpConfirmed clears the value of the "totp_confirmed" field.
+func (osu *OfflineSessionUpdate) ClearTotpConfirmed() *OfflineSessionUpdate {
+	osu.mutation.ClearTotpConfirmed()
+	return osu
+}
+
 // Mutation returns the OfflineSessionMutation object of the builder.
 func (osu *OfflineSessionUpdate) Mutation() *OfflineSessionMutation {
 	return osu.mutation
@@ -147,6 +187,18 @@ func (osu *OfflineSessionUpdate) sqlSave(ctx context.Context) (n int, err error)
 	if osu.mutation.ConnectorDataCleared() {
 		_spec.ClearField(offlinesession.FieldConnectorData, field.TypeBytes)
 	}
+	if value, ok := osu.mutation.Totp(); ok {
+		_spec.SetField(offlinesession.FieldTotp, field.TypeString, value)
+	}
+	if osu.mutation.TotpCleared() {
+		_spec.ClearField(offlinesession.FieldTotp, field.TypeString)
+	}
+	if value, ok := osu.mutation.TotpConfirmed(); ok {
+		_spec.SetField(offlinesession.FieldTotpConfirmed, field.TypeBool, value)
+	}
+	if osu.mutation.TotpConfirmedCleared() {
+		_spec.ClearField(offlinesession.FieldTotpConfirmed, field.TypeBool)
+	}
 	if n, err = sqlgraph.UpdateNodes(ctx, osu.driver, _spec); err != nil {
 		if _, ok := err.(*sqlgraph.NotFoundError); ok {
 			err = &NotFoundError{offlinesession.Label}
@@ -213,6 +265,46 @@ func (osuo *OfflineSessionUpdateOne) ClearConnectorData() *OfflineSessionUpdateO
 	return osuo
 }

+// SetTotp sets the "totp" field.
+func (osuo *OfflineSessionUpdateOne) SetTotp(s string) *OfflineSessionUpdateOne {
+	osuo.mutation.SetTotp(s)
+	return osuo
+}
+
+// SetNillableTotp sets the "totp" field if the given value is not nil.
+func (osuo *OfflineSessionUpdateOne) SetNillableTotp(s *string) *OfflineSessionUpdateOne {
+	if s != nil {
+		osuo.SetTotp(*s)
+	}
+	return osuo
+}
+
+// ClearTotp clears the value of the "totp" field.
+func (osuo *OfflineSessionUpdateOne) ClearTotp() *OfflineSessionUpdateOne {
+	osuo.mutation.ClearTotp()
+	return osuo
+}
+
+// SetTotpConfirmed sets the "totp_confirmed" field.
+func (osuo *OfflineSessionUpdateOne) SetTotpConfirmed(b bool) *OfflineSessionUpdateOne {
+	osuo.mutation.SetTotpConfirmed(b)
+	return osuo
+}
+
+// SetNillableTotpConfirmed sets the "totp_confirmed" field if the given value is not nil.
+func (osuo *OfflineSessionUpdateOne) SetNillableTotpConfirmed(b *bool) *OfflineSessionUpdateOne {
+	if b != nil {
+		osuo.SetTotpConfirmed(*b)
+	}
+	return osuo
+}
+
+// ClearTotpConfirmed clears the value of the "totp_confirmed" field.
+func (osuo *OfflineSessionUpdateOne) ClearTotpConfirmed() *OfflineSessionUpdateOne {
+	osuo.mutation.ClearTotpConfirmed()
+	return osuo
+}
+
 // Mutation returns the OfflineSessionMutation object of the builder.
 func (osuo *OfflineSessionUpdateOne) Mutation() *OfflineSessionMutation {
 	return osuo.mutation
@@ -317,6 +409,18 @@ func (osuo *OfflineSessionUpdateOne) sqlSave(ctx context.Context) (_node *Offlin
 	if osuo.mutation.ConnectorDataCleared() {
 		_spec.ClearField(offlinesession.FieldConnectorData, field.TypeBytes)
 	}
+	if value, ok := osuo.mutation.Totp(); ok {
+		_spec.SetField(offlinesession.FieldTotp, field.TypeString, value)
+	}
+	if osuo.mutation.TotpCleared() {
+		_spec.ClearField(offlinesession.FieldTotp, field.TypeString)
+	}
+	if value, ok := osuo.mutation.TotpConfirmed(); ok {
+		_spec.SetField(offlinesession.FieldTotpConfirmed, field.TypeBool, value)
+	}
+	if osuo.mutation.TotpConfirmedCleared() {
+		_spec.ClearField(offlinesession.FieldTotpConfirmed, field.TypeBool)
+	}
 	_node = &OfflineSession{config: osuo.config}
 	_spec.Assign = _node.assignValues
 	_spec.ScanValues = _node.scanValues
diff --git a/storage/ent/db/runtime.go b/storage/ent/db/runtime.go
index 797c9761..d2720152 100644
--- a/storage/ent/db/runtime.go
+++ b/storage/ent/db/runtime.go
@@ -82,6 +82,10 @@ func init() {
 	authrequestDescCodeChallengeMethod := authrequestFields[19].Descriptor()
 	// authrequest.DefaultCodeChallengeMethod holds the default value on creation for the code_challenge_method field.
 	authrequest.DefaultCodeChallengeMethod = authrequestDescCodeChallengeMethod.Default.(string)
+	// authrequestDescTotpValidated is the schema descriptor for totp_validated field.
+	authrequestDescTotpValidated := authrequestFields[21].Descriptor()
+	// authrequest.DefaultTotpValidated holds the default value on creation for the totp_validated field.
+	authrequest.DefaultTotpValidated = authrequestDescTotpValidated.Default.(bool)
 	// authrequestDescID is the schema descriptor for id field.
 	authrequestDescID := authrequestFields[0].Descriptor()
 	// authrequest.IDValidator is a validator for the "id" field. It is called by the builders before save.
@@ -198,6 +202,10 @@ func init() {
 	offlinesessionDescConnID := offlinesessionFields[2].Descriptor()
 	// offlinesession.ConnIDValidator is a validator for the "conn_id" field. It is called by the builders before save.
 	offlinesession.ConnIDValidator = offlinesessionDescConnID.Validators[0].(func(string) error)
+	// offlinesessionDescTotpConfirmed is the schema descriptor for totp_confirmed field.
+	offlinesessionDescTotpConfirmed := offlinesessionFields[6].Descriptor()
+	// offlinesession.DefaultTotpConfirmed holds the default value on creation for the totp_confirmed field.
+	offlinesession.DefaultTotpConfirmed = offlinesessionDescTotpConfirmed.Default.(bool)
 	// offlinesessionDescID is the schema descriptor for id field.
 	offlinesessionDescID := offlinesessionFields[0].Descriptor()
 	// offlinesession.IDValidator is a validator for the "id" field. It is called by the builders before save.
diff --git a/storage/ent/schema/authrequest.go b/storage/ent/schema/authrequest.go
index 2b75927b..7cdf3677 100644
--- a/storage/ent/schema/authrequest.go
+++ b/storage/ent/schema/authrequest.go
@@ -88,6 +88,7 @@ func (AuthRequest) Fields() []ent.Field {
 			SchemaType(textSchema).
 			Default(""),
 		field.Bytes("hmac_key"),
+		field.Bool("totp_validated").Default(false),
 	}
 }

diff --git a/storage/ent/schema/offlinesession.go b/storage/ent/schema/offlinesession.go
index e9a166c3..433a7f01 100644
--- a/storage/ent/schema/offlinesession.go
+++ b/storage/ent/schema/offlinesession.go
@@ -37,6 +37,8 @@ func (OfflineSession) Fields() []ent.Field {
 			NotEmpty(),
 		field.Bytes("refresh"),
 		field.Bytes("connector_data").Nillable().Optional(),
+		field.Text("totp").Optional(),
+		field.Bool("totp_confirmed").Default(false).Optional(),
 	}
 }

diff --git a/storage/etcd/types.go b/storage/etcd/types.go
index b3756604..acf1d6a7 100644
--- a/storage/etcd/types.go
+++ b/storage/etcd/types.go
@@ -86,6 +86,8 @@ type AuthRequest struct {
 	CodeChallengeMethod string `json:"code_challenge_method,omitempty"`

 	HMACKey []byte `json:"hmac_key"`
+
+	TOTPValidated bool `json:"totp_validated,omitempty"`
 }

 func fromStorageAuthRequest(a storage.AuthRequest) AuthRequest {
@@ -106,6 +108,7 @@ func fromStorageAuthRequest(a storage.AuthRequest) AuthRequest {
 		CodeChallenge:       a.PKCE.CodeChallenge,
 		CodeChallengeMethod: a.PKCE.CodeChallengeMethod,
 		HMACKey:             a.HMACKey,
+		TOTPValidated:       a.TOTPValidated,
 	}
 }

@@ -128,7 +131,8 @@ func toStorageAuthRequest(a AuthRequest) storage.AuthRequest {
 			CodeChallenge:       a.CodeChallenge,
 			CodeChallengeMethod: a.CodeChallengeMethod,
 		},
-		HMACKey: a.HMACKey,
+		HMACKey:       a.HMACKey,
+		TOTPValidated: a.TOTPValidated,
 	}
 }

@@ -231,6 +235,8 @@ type OfflineSessions struct {
 	ConnID        string                              `json:"conn_id,omitempty"`
 	Refresh       map[string]*storage.RefreshTokenRef `json:"refresh,omitempty"`
 	ConnectorData []byte                              `json:"connectorData,omitempty"`
+	TOTP          string                              `json:"totp,omitempty"`
+	TOTPConfirmed bool                                `json:"totp_confirmed,omitempty"`
 }

 func fromStorageOfflineSessions(o storage.OfflineSessions) OfflineSessions {
@@ -239,6 +245,8 @@ func fromStorageOfflineSessions(o storage.OfflineSessions) OfflineSessions {
 		ConnID:        o.ConnID,
 		Refresh:       o.Refresh,
 		ConnectorData: o.ConnectorData,
+		TOTP:          o.TOTP,
+		TOTPConfirmed: o.TOTPConfirmed,
 	}
 }

@@ -248,6 +256,8 @@ func toStorageOfflineSessions(o OfflineSessions) storage.OfflineSessions {
 		ConnID:        o.ConnID,
 		Refresh:       o.Refresh,
 		ConnectorData: o.ConnectorData,
+		TOTP:          o.TOTP,
+		TOTPConfirmed: o.TOTPConfirmed,
 	}
 	if s.Refresh == nil {
 		// Server code assumes this will be non-nil.
diff --git a/storage/kubernetes/types.go b/storage/kubernetes/types.go
index c126ddc0..79659126 100644
--- a/storage/kubernetes/types.go
+++ b/storage/kubernetes/types.go
@@ -358,6 +358,8 @@ type AuthRequest struct {
 	CodeChallengeMethod string `json:"code_challenge_method,omitempty"`

 	HMACKey []byte `json:"hmac_key"`
+
+	TOTPValidated bool `json:"totp_validated,omitempty"`
 }

 // AuthRequestList is a list of AuthRequests.
@@ -386,7 +388,8 @@ func toStorageAuthRequest(req AuthRequest) storage.AuthRequest {
 			CodeChallenge:       req.CodeChallenge,
 			CodeChallengeMethod: req.CodeChallengeMethod,
 		},
-		HMACKey: req.HMACKey,
+		HMACKey:       req.HMACKey,
+		TOTPValidated: req.TOTPValidated,
 	}
 	return a
 }
@@ -416,6 +419,7 @@ func (cli *client) fromStorageAuthRequest(a storage.AuthRequest) AuthRequest {
 		CodeChallenge:       a.PKCE.CodeChallenge,
 		CodeChallengeMethod: a.PKCE.CodeChallengeMethod,
 		HMACKey:             a.HMACKey,
+		TOTPValidated:       a.TOTPValidated,
 	}
 	return req
 }
@@ -665,6 +669,8 @@ type OfflineSessions struct {
 	ConnID        string                              `json:"connID,omitempty"`
 	Refresh       map[string]*storage.RefreshTokenRef `json:"refresh,omitempty"`
 	ConnectorData []byte                              `json:"connectorData,omitempty"`
+	TOTP          string                              `json:"totp,omitempty"`
+	TOTPConfirmed bool                                `json:"totpConfirmed,omitempty"`
 }

 func (cli *client) fromStorageOfflineSessions(o storage.OfflineSessions) OfflineSessions {
@@ -681,6 +687,8 @@ func (cli *client) fromStorageOfflineSessions(o storage.OfflineSessions) Offline
 		ConnID:        o.ConnID,
 		Refresh:       o.Refresh,
 		ConnectorData: o.ConnectorData,
+		TOTP:          o.TOTP,
+		TOTPConfirmed: o.TOTPConfirmed,
 	}
 }

@@ -690,6 +698,8 @@ func toStorageOfflineSessions(o OfflineSessions) storage.OfflineSessions {
 		ConnID:        o.ConnID,
 		Refresh:       o.Refresh,
 		ConnectorData: o.ConnectorData,
+		TOTP:          o.TOTP,
+		TOTPConfirmed: o.TOTPConfirmed,
 	}
 	if s.Refresh == nil {
 		// Server code assumes this will be non-nil.
diff --git a/storage/sql/crud.go b/storage/sql/crud.go
index a9ca3816..72161ca3 100644
--- a/storage/sql/crud.go
+++ b/storage/sql/crud.go
@@ -134,10 +134,10 @@ func (c *conn) CreateAuthRequest(ctx context.Context, a storage.AuthRequest) err
 			connector_id, connector_data,
 			expiry,
 			code_challenge, code_challenge_method,
-			hmac_key
+			hmac_key, totp_validated
 		)
 		values (
-			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21
+			$1, $2, $3, $4, $5, $6, $7, $8, $9, $10, $11, $12, $13, $14, $15, $16, $17, $18, $19, $20, $21, $22
 		);
 	`,
 		a.ID, a.ClientID, encoder(a.ResponseTypes), encoder(a.Scopes), a.RedirectURI, a.Nonce, a.State,
@@ -147,7 +147,7 @@ func (c *conn) CreateAuthRequest(ctx context.Context, a storage.AuthRequest) err
 		a.ConnectorID, a.ConnectorData,
 		a.Expiry,
 		a.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod,
-		a.HMACKey,
+		a.HMACKey, a.TOTPValidated,
 	)
 	if err != nil {
 		if c.alreadyExistsCheck(err) {
@@ -180,8 +180,9 @@ func (c *conn) UpdateAuthRequest(ctx context.Context, id string, updater func(a
 				connector_id = $15, connector_data = $16,
 				expiry = $17,
 				code_challenge = $18, code_challenge_method = $19,
-				hmac_key = $20
-			where id = $21;
+				hmac_key = $20,
+				totp_validated = $21
+			where id = $22;
 		`,
 			a.ClientID, encoder(a.ResponseTypes), encoder(a.Scopes), a.RedirectURI, a.Nonce, a.State,
 			a.ForceApprovalPrompt, a.LoggedIn,
@@ -190,7 +191,7 @@ func (c *conn) UpdateAuthRequest(ctx context.Context, id string, updater func(a
 			encoder(a.Claims.Groups),
 			a.ConnectorID, a.ConnectorData,
 			a.Expiry,
-			a.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod, a.HMACKey,
+			a.PKCE.CodeChallenge, a.PKCE.CodeChallengeMethod, a.HMACKey, a.TOTPValidated,
 			r.ID,
 		)
 		if err != nil {
@@ -212,7 +213,7 @@ func getAuthRequest(ctx context.Context, q querier, id string) (a storage.AuthRe
 			claims_user_id, claims_username, claims_preferred_username,
 			claims_email, claims_email_verified, claims_groups,
 			connector_id, connector_data, expiry,
-			code_challenge, code_challenge_method, hmac_key
+			code_challenge, code_challenge_method, hmac_key, totp_validated
 		from auth_request where id = $1;
 	`, id).Scan(
 		&a.ID, &a.ClientID, decoder(&a.ResponseTypes), decoder(&a.Scopes), &a.RedirectURI, &a.Nonce, &a.State,
@@ -221,7 +222,7 @@ func getAuthRequest(ctx context.Context, q querier, id string) (a storage.AuthRe
 		&a.Claims.Email, &a.Claims.EmailVerified,
 		decoder(&a.Claims.Groups),
 		&a.ConnectorID, &a.ConnectorData, &a.Expiry,
-		&a.PKCE.CodeChallenge, &a.PKCE.CodeChallengeMethod, &a.HMACKey,
+		&a.PKCE.CodeChallenge, &a.PKCE.CodeChallengeMethod, &a.HMACKey, &a.TOTPValidated,
 	)
 	if err != nil {
 		if err == sql.ErrNoRows {
@@ -694,13 +695,13 @@ func scanPassword(s scanner) (p storage.Password, err error) {
 func (c *conn) CreateOfflineSessions(ctx context.Context, s storage.OfflineSessions) error {
 	_, err := c.Exec(`
 		insert into offline_session (
-			user_id, conn_id, refresh, connector_data
+			user_id, conn_id, refresh, connector_data, totp, totp_confirmed
 		)
 		values (
-			$1, $2, $3, $4
+			$1, $2, $3, $4, $5, $6
 		);
 	`,
-		s.UserID, s.ConnID, encoder(s.Refresh), s.ConnectorData,
+		s.UserID, s.ConnID, encoder(s.Refresh), s.ConnectorData, s.TOTP, s.TOTPConfirmed,
 	)
 	if err != nil {
 		if c.alreadyExistsCheck(err) {
@@ -726,10 +727,12 @@ func (c *conn) UpdateOfflineSessions(ctx context.Context, userID string, connID
 			update offline_session
 			set
 				refresh = $1,
-				connector_data = $2
-			where user_id = $3 AND conn_id = $4;
+				connector_data = $2,
+				totp = $3,
+				totp_confirmed = $4
+			where user_id = $5 AND conn_id = $6;
 		`,
-			encoder(newSession.Refresh), newSession.ConnectorData, s.UserID, s.ConnID,
+			encoder(newSession.Refresh), newSession.ConnectorData, newSession.TOTP, newSession.TOTPConfirmed, s.UserID, s.ConnID,
 		)
 		if err != nil {
 			return fmt.Errorf("update offline session: %v", err)
@@ -745,7 +748,7 @@ func (c *conn) GetOfflineSessions(ctx context.Context, userID string, connID str
 func getOfflineSessions(ctx context.Context, q querier, userID string, connID string) (storage.OfflineSessions, error) {
 	return scanOfflineSessions(q.QueryRow(`
 		select
-			user_id, conn_id, refresh, connector_data
+			user_id, conn_id, refresh, connector_data, totp, totp_confirmed
 		from offline_session
 		where user_id = $1 AND conn_id = $2;
 		`, userID, connID))
@@ -753,7 +756,7 @@ func getOfflineSessions(ctx context.Context, q querier, userID string, connID st

 func scanOfflineSessions(s scanner) (o storage.OfflineSessions, err error) {
 	err = s.Scan(
-		&o.UserID, &o.ConnID, decoder(&o.Refresh), &o.ConnectorData,
+		&o.UserID, &o.ConnID, decoder(&o.Refresh), &o.ConnectorData, &o.TOTP, &o.TOTPConfirmed,
 	)
 	if err != nil {
 		if err == sql.ErrNoRows {
diff --git a/storage/storage.go b/storage/storage.go
index 574b0a5a..4ebc2eb4 100644
--- a/storage/storage.go
+++ b/storage/storage.go
@@ -233,6 +233,9 @@ type AuthRequest struct {

 	// HMACKey is used when generating an AuthRequest-specific HMAC
 	HMACKey []byte
+
+	// TOTPValidated is set to true if the user has validated their second authentication factor.
+	TOTPValidated bool
 }

 // AuthCode represents a code which can be exchanged for an OAuth2 token response.
@@ -330,6 +333,11 @@ type OfflineSessions struct {

 	// Authentication data provided by an upstream source.
 	ConnectorData []byte
+
+	// TOTP is the otp key used to generate TOTP codes for the user.
+	// The second factor is ignored if the field is empty.
+	TOTP          string
+	TOTPConfirmed bool
 }

 // Password is an email to password mapping managed by the storage.
