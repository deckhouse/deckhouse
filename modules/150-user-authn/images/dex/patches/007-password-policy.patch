diff --git a/cmd/dex/config.go b/cmd/dex/config.go
index be5441f9..861326e8 100644
--- a/cmd/dex/config.go
+++ b/cmd/dex/config.go
@@ -9,6 +9,7 @@ import (
 	"net/netip"
 	"os"
 	"strings"
+	"time"
 
 	"golang.org/x/crypto/bcrypt"
 
@@ -24,14 +25,15 @@ import (
 
 // Config is the config format for the main application.
 type Config struct {
-	Issuer    string    `json:"issuer"`
-	Storage   Storage   `json:"storage"`
-	Web       Web       `json:"web"`
-	Telemetry Telemetry `json:"telemetry"`
-	OAuth2    OAuth2    `json:"oauth2"`
-	GRPC      GRPC      `json:"grpc"`
-	Expiry    Expiry    `json:"expiry"`
-	Logger    Logger    `json:"logger"`
+	Issuer         string          `json:"issuer"`
+	Storage        Storage         `json:"storage"`
+	Web            Web             `json:"web"`
+	Telemetry      Telemetry       `json:"telemetry"`
+	OAuth2         OAuth2          `json:"oauth2"`
+	GRPC           GRPC            `json:"grpc"`
+	Expiry         Expiry          `json:"expiry"`
+	PasswordPolicy *PasswordPolicy `json:"passwordPolicy"`
+	Logger         Logger          `json:"logger"`
 
 	Frontend server.WebConfig `json:"frontend"`
 
@@ -486,3 +488,73 @@ type TOTP struct {
 	// Connectors is a list of connectors that will use TOTP.
 	Connectors []string `json:"connectors"`
 }
+
+// PasswordPolicy Defines security requirements for user passwords within the system.
+// This policy enforces password complexity rules, expiration intervals and rotation period.
+type PasswordPolicy struct {
+	ID              string  `json:"id"`
+	ComplexityLevel *string `json:"complexityLevel,omitempty"`
+	Lockout         *struct {
+		MaxAttempts uint64        `json:"maxAttempts"`
+		Duration    time.Duration `json:"duration"`
+	} `json:"lockout,omitempty"`
+	Rotation *struct {
+		Interval    time.Duration `json:"interval"`
+		RedirectURL *string       `json:"redirectURL,omitempty"`
+	} `json:"rotation,omitempty"`
+}
+
+func (p *PasswordPolicy) UnmarshalJSON(data []byte) error {
+	type Alias PasswordPolicy
+	aux := &struct {
+		Lockout *struct {
+			MaxAttempts uint64 `json:"maxAttempts"`
+			DurationStr string `json:"duration"`
+		} `json:"lockout,omitempty"`
+		Rotation *struct {
+			IntervalStr string  `json:"interval"`
+			RedirectURL *string `json:"redirectURL,omitempty"`
+		} `json:"rotation,omitempty"`
+		*Alias
+	}{
+		Alias: (*Alias)(p),
+	}
+
+	if err := json.Unmarshal(data, &aux); err != nil {
+		return err
+	}
+
+	// Parse lockout duration
+	if aux.Lockout != nil {
+		duration, err := time.ParseDuration(aux.Lockout.DurationStr)
+		if err != nil {
+			return fmt.Errorf("invalid lockout duration: %w", err)
+		}
+		if p.Lockout == nil {
+			p.Lockout = &struct {
+				MaxAttempts uint64        `json:"maxAttempts"`
+				Duration    time.Duration `json:"duration"`
+			}{}
+		}
+		p.Lockout.MaxAttempts = aux.Lockout.MaxAttempts
+		p.Lockout.Duration = duration
+	}
+
+	// Parse rotation interval
+	if aux.Rotation != nil {
+		interval, err := time.ParseDuration(aux.Rotation.IntervalStr)
+		if err != nil {
+			return fmt.Errorf("invalid rotation interval: %w", err)
+		}
+		if p.Rotation == nil {
+			p.Rotation = &struct {
+				Interval    time.Duration `json:"interval"`
+				RedirectURL *string       `json:"redirectURL,omitempty"`
+			}{}
+		}
+		p.Rotation.Interval = interval
+		p.Rotation.RedirectURL = aux.Rotation.RedirectURL
+	}
+
+	return nil
+}
diff --git a/cmd/dex/serve.go b/cmd/dex/serve.go
index 168008e5..eec3b32f 100644
--- a/cmd/dex/serve.go
+++ b/cmd/dex/serve.go
@@ -350,6 +350,29 @@ func runServe(options serveOptions) error {
 
 	serverConfig.RefreshTokenPolicy = refreshTokenPolicy
 
+	if c.PasswordPolicy != nil {
+		var opts []server.PasswordPolicyOption
+		if c.PasswordPolicy.ComplexityLevel != nil {
+			opts = append(opts, server.WithComplexityLevel(*c.PasswordPolicy.ComplexityLevel))
+		}
+		if c.PasswordPolicy.Lockout != nil {
+			opts = append(opts, server.WithLockoutSettings(
+				c.PasswordPolicy.Lockout.MaxAttempts, c.PasswordPolicy.Lockout.Duration,
+			))
+		}
+		if c.PasswordPolicy.Rotation != nil {
+			opts = append(opts, server.WithRotationSettings(
+				c.PasswordPolicy.Rotation.Interval, c.PasswordPolicy.Rotation.RedirectURL,
+			))
+		}
+		passwordPolicy, err := server.NewPasswordPolicy(c.PasswordPolicy.ID, opts...)
+		if err != nil {
+			return fmt.Errorf("invalid password policy config: %v", err)
+		}
+
+		serverConfig.PasswordPolicy = passwordPolicy
+	}
+
 	serverConfig.RealIPHeader = c.Web.ClientRemoteIP.Header
 	serverConfig.TrustedRealIPCIDRs, err = c.Web.ClientRemoteIP.ParseTrustedProxies()
 	if err != nil {
diff --git a/examples/config-dev.yaml b/examples/config-dev.yaml
index 147597a2..c1f01098 100644
--- a/examples/config-dev.yaml
+++ b/examples/config-dev.yaml
@@ -155,6 +155,15 @@ connectors:
 # Let dex keep a list of passwords which can be used to login to dex.
 enablePasswordDB: true
 
+# passwordPolicy:
+#   id: hello-kitty
+#   complexityLevel: low
+#   lockout:
+#     maxAttempts: 3
+#     duration: "1m"
+#   rotation:
+#     interval: "1s"
+
 # A static list of passwords to login the end user. By identifying here, dex
 # won't look in its underlying storage for passwords.
 #
diff --git a/server/handlers.go b/server/handlers.go
index 5352bef0..b8b4c005 100644
--- a/server/handlers.go
+++ b/server/handlers.go
@@ -373,6 +373,24 @@ func (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {
 		password := r.FormValue("password")
 		scopes := parseScopes(authReq.Scopes)
 
+		p, err := s.storage.GetPassword(ctx, username)
+		if err != nil {
+			s.logger.ErrorContext(r.Context(), "failed to get password", "err", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		if s.passwordPolicy != nil && s.passwordPolicy.IsPasswordLocked(p) {
+			s.logger.WarnContext(r.Context(),
+				"login attempt for locked account",
+				"username", username,
+				"locked_until", p.LockedUntil,
+			)
+			// TODO: maybe need to render error field in the login page (like incorrect pass error)
+			s.renderError(r, w, http.StatusTooManyRequests, "Account temporarily locked")
+			return
+		}
+
 		identity, ok, err := pwConn.Login(r.Context(), scopes, username, password)
 		if err != nil {
 			s.logger.ErrorContext(r.Context(), "failed to login user", "err", err)
@@ -380,12 +398,71 @@ func (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {
 			return
 		}
 		if !ok {
+			if s.passwordPolicy != nil && s.passwordPolicy.IsMaxLoginAttemptsExeeded(p.IncorrectPasswordLoginAttempts+1) {
+				lockedUntil := time.Now().Add(s.passwordPolicy.lockout.lockDuration)
+				updader := func(p storage.Password) (storage.Password, error) {
+					p.LockedUntil = &lockedUntil
+					p.IncorrectPasswordLoginAttempts = 0
+					return p, nil
+				}
+
+				// Update locked status in storage
+				if err := s.storage.UpdatePassword(ctx, username, updader); err != nil {
+					s.logger.ErrorContext(r.Context(),
+						"failed to lock account",
+						"username", username,
+						"error", err,
+					)
+				}
+
+				s.logger.WarnContext(r.Context(),
+					"account locked due to too many failed attempts",
+					"username", username,
+					"attempts", p.IncorrectPasswordLoginAttempts+1,
+					"locked_until", lockedUntil,
+				)
+				s.renderError(r, w, http.StatusTooManyRequests, "Account temporarily locked")
+				return
+			}
+
 			if err := s.templates.password(r, w, r.URL.String(), username, usernamePrompt(pwConn), true, backLink); err != nil {
 				s.logger.ErrorContext(r.Context(), "server template error", "err", err)
 			}
 			s.logger.ErrorContext(r.Context(), "failed login attempt: Invalid credentials.", "user", username)
 			return
 		}
+
+		if s.passwordPolicy != nil {
+			// TODO: move to password policy method
+			cl, err := GetComplexity(p.ComplexityLevel)
+			if err == nil {
+				if cl.level < s.passwordPolicy.complexity.level {
+					redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), complexityPolicyReason)
+					if err != nil {
+						s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
+						s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+						return
+					}
+					http.Redirect(w, r, redirectURL, http.StatusSeeOther)
+					s.logger.InfoContext(r.Context(), "user was forced to change password due to password complexity policy settings", "user", username)
+				}
+			} else {
+				s.logger.ErrorContext(ctx, "wrong password complexity level", "err", err)
+			}
+		}
+
+		if s.passwordPolicy != nil && s.passwordPolicy.IsPasswordExpired(p.HashUpdatedAt) {
+			redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), rotationPolicyReason)
+			if err != nil {
+				s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
+				s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+				return
+			}
+			http.Redirect(w, r, redirectURL, http.StatusSeeOther)
+			s.logger.InfoContext(r.Context(), "user was forced to change password due to password rotation policy settings", "user", username)
+			return
+		}
+
 		redirectURL, canSkipApproval, err := s.finalizeLogin(r.Context(), identity, authReq, conn.Connector)
 		if err != nil {
 			s.logger.ErrorContext(r.Context(), "failed to finalize login", "err", err)
diff --git a/server/passwordchangehandler.go b/server/passwordchangehandler.go
new file mode 100644
index 00000000..d409cde8
--- /dev/null
+++ b/server/passwordchangehandler.go
@@ -0,0 +1,171 @@
+package server
+
+import (
+	"errors"
+	"fmt"
+	"net/http"
+	"net/url"
+	"strings"
+	"time"
+
+	"github.com/dexidp/dex/storage"
+	"golang.org/x/crypto/bcrypt"
+)
+
+const passwordChangeURI = "/password/change"
+
+func buildPasswordChangeURI(issuerUrl, username, backURI string, changeReason passwordChangeReason) (string, error) {
+	retUrl, err := url.JoinPath(issuerUrl, passwordChangeURI)
+	if err != nil {
+		return "", err
+	}
+
+	return fmt.Sprintf(
+		"%s?username=%s&back=%s&changeReason=%s",
+		retUrl, url.QueryEscape(username), url.QueryEscape(backURI), changeReason,
+	), nil
+}
+
+func (s *Server) handlePasswordChange(w http.ResponseWriter, r *http.Request) {
+	ctx := r.Context()
+	err := r.ParseForm()
+	if err != nil {
+		s.logger.ErrorContext(ctx, "form parse error", "error", err)
+		s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+		return
+	}
+
+	username := r.Form.Get("username")
+	currentPassword := r.Form.Get("currentPassword")
+	newPassword := r.Form.Get("newPassword")
+	changeReason := r.Form.Get("changeReason")
+	backURL := r.Form.Get("back")
+	if backURL == "" {
+		backURL = s.issuerURL.String()
+	}
+
+	switch r.Method {
+	case http.MethodGet:
+		if err := s.templates.passwordChange(r, w, passwordChangeParams{
+			Username:        username,
+			NewPasswordHint: s.passwordPolicy.complexity.UserPrompt(),
+			ChangeReason:    passwordChangeReason(changeReason),
+			IssuerURL:       s.issuerURL.String(),
+		}); err != nil {
+			s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+		}
+		return
+	case http.MethodPost:
+		if currentPassword == newPassword {
+			if err := s.templates.passwordChange(r, w, passwordChangeParams{
+				Username:        username,
+				NewPasswordHint: s.passwordPolicy.complexity.UserPrompt(),
+				IssuerURL:       s.issuerURL.String(),
+				ChangeReason:    passwordChangeReason(changeReason),
+				Err:             ErrOldAndNewPassAreEq,
+			}); err != nil {
+				s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+			}
+			return
+		}
+
+		if strings.Contains(newPassword, " ") {
+			if err := s.templates.passwordChange(r, w, passwordChangeParams{
+				Username:        username,
+				NewPasswordHint: s.passwordPolicy.complexity.UserPrompt(),
+				IssuerURL:       s.issuerURL.String(),
+				ChangeReason:    passwordChangeReason(changeReason),
+				Err:             ErrNewPasswordContainsForbiddenChar,
+			}); err != nil {
+				s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+			}
+		}
+
+		if s.passwordPolicy != nil {
+			if err := s.passwordPolicy.complexity.Validate(newPassword); err != nil {
+				if err := s.templates.passwordChange(r, w, passwordChangeParams{
+					Username:        username,
+					NewPasswordHint: s.passwordPolicy.complexity.UserPrompt(),
+					IssuerURL:       s.issuerURL.String(),
+					ChangeReason:    passwordChangeReason(changeReason),
+					Err:             errors.Join(ErrPasswordTooWeak, err),
+				}); err != nil {
+					s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+				}
+				return
+			}
+		}
+
+		p, err := s.storage.GetPassword(ctx, username)
+		if err != nil {
+			s.logger.ErrorContext(r.Context(), "failed to get password", "username", username, "err", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		if err := checkCost(p.Hash); err != nil {
+			s.logger.ErrorContext(r.Context(), "checkCost failed", "username", username, "err", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		if err := bcrypt.CompareHashAndPassword(p.Hash, []byte(currentPassword)); err != nil {
+			if err := s.templates.passwordChange(r, w, passwordChangeParams{
+				Username:        username,
+				NewPasswordHint: s.passwordPolicy.complexity.UserPrompt(),
+				IssuerURL:       s.issuerURL.String(),
+				ChangeReason:    passwordChangeReason(changeReason),
+				Err:             ErrCurrentPasswordInvalid,
+			}); err != nil {
+				s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+			}
+			return
+		}
+
+		hash, err := bcrypt.GenerateFromPassword([]byte(newPassword), 10)
+		if err != nil {
+			s.logger.ErrorContext(ctx, "bcrypt.GenerateFromPassword", "username", username, "error", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		for _, el := range p.PreviousHashes {
+			if err := bcrypt.CompareHashAndPassword(el, []byte(newPassword)); err == nil {
+				if err := s.templates.passwordChange(r, w, passwordChangeParams{
+					Username:        username,
+					NewPasswordHint: s.passwordPolicy.complexity.UserPrompt(),
+					IssuerURL:       s.issuerURL.String(),
+					ChangeReason:    passwordChangeReason(changeReason),
+					Err:             ErrReusedPassword,
+				}); err != nil {
+					s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+				}
+				return
+			}
+		}
+
+		updater := func(p storage.Password) (storage.Password, error) {
+			p.PreviousHashes = append(p.PreviousHashes, p.Hash)
+			if len(p.PreviousHashes) > 5 {
+				p.PreviousHashes = p.PreviousHashes[1:]
+			}
+			p.HashUpdatedAt = time.Now()
+			p.Hash = hash
+			if s.passwordPolicy != nil {
+				p.ComplexityLevel = s.passwordPolicy.complexity.level.String()
+			}
+			return p, nil
+		}
+		if err := s.storage.UpdatePassword(ctx, username, updater); err != nil {
+			s.logger.ErrorContext(r.Context(), "failed to update password", "username", username, "err", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		s.logger.InfoContext(r.Context(), "password changed successfully", "username", username)
+
+		http.Redirect(w, r, backURL, http.StatusSeeOther)
+	default:
+		s.renderError(r, w, http.StatusBadRequest, "Method not supported")
+	}
+}
diff --git a/server/passwordpolicy.go b/server/passwordpolicy.go
new file mode 100644
index 00000000..598d05c1
--- /dev/null
+++ b/server/passwordpolicy.go
@@ -0,0 +1,304 @@
+package server
+
+import (
+	"errors"
+	"fmt"
+	"strings"
+	"time"
+	"unicode"
+
+	"github.com/dexidp/dex/storage"
+)
+
+type PasswordPolicyOption func(*PasswordPolicy) error
+
+type complexityLevel int
+
+const (
+	levelNone complexityLevel = iota
+	levelLow
+	levelFair
+	levelGood
+	levelExcellent
+)
+
+func (cl complexityLevel) String() string {
+	switch cl {
+	case levelNone:
+		return "none"
+	case levelLow:
+		return "low"
+	case levelFair:
+		return "fair"
+	case levelGood:
+		return "good"
+	case levelExcellent:
+		return "excellent"
+	default:
+		return "unknown"
+	}
+}
+
+type Complexity struct {
+	level      complexityLevel
+	userPrompt string
+}
+
+func (cl Complexity) UserPrompt() string {
+	return cl.userPrompt
+}
+
+var (
+	ComplexityNone = Complexity{levelNone, ""}
+	ComplexityLow  = Complexity{levelLow, "Password must contain:\n" +
+		"• At least 8 characters"}
+	ComplexityFair = Complexity{levelFair, "Password must contain:\n" +
+		"• At least 8 characters\n" +
+		"• Upper and lowercase letters\n" +
+		"• At least one number"}
+	ComplexityGood = Complexity{levelGood, "Password must contain:\n" +
+		"• At least 8 characters\n" +
+		"• Upper and lowercase letters\n" +
+		"• At least one number" +
+		"• Special characters (!@#$%^&* etc.)"}
+	ComplexityExcellent = Complexity{levelExcellent, "Password must contain:\n" +
+		"• At least 8 characters\n" +
+		"• Upper and lowercase letters\n" +
+		"• At least one number" +
+		"• Special characters (!@#$%^&* etc.)" +
+		"• No more than 2 identical characters in a row"}
+)
+
+func (cl Complexity) Validate(password string) error {
+	switch cl.level {
+	case levelNone:
+		return nil
+
+	case levelLow:
+		if len(password) < 8 {
+			return errors.New("minimum 8 characters required")
+		}
+		return nil
+
+	case levelFair:
+		if len(password) < 8 {
+			return errors.New("minimum 8 characters required")
+		}
+		var hasLower, hasUpper, hasNumber bool
+		for _, c := range password {
+			switch {
+			case unicode.IsLower(c):
+				hasLower = true
+			case unicode.IsUpper(c):
+				hasUpper = true
+			case unicode.IsNumber(c):
+				hasNumber = true
+			}
+		}
+		if !hasLower {
+			return errors.New("at least one lowercase letter required")
+		}
+		if !hasUpper {
+			return errors.New("at least one uppercase letter required")
+		}
+		if !hasNumber {
+			return errors.New("at least one number required")
+		}
+		return nil
+	case levelGood:
+		if len(password) < 10 {
+			return errors.New("minimum 10 characters required")
+		}
+		var hasLower, hasUpper, hasNumber, hasSpecial bool
+		for _, c := range password {
+			switch {
+			case unicode.IsLower(c):
+				hasLower = true
+			case unicode.IsUpper(c):
+				hasUpper = true
+			case unicode.IsNumber(c):
+				hasNumber = true
+			case !unicode.IsLetter(c) && !unicode.IsNumber(c):
+				hasSpecial = true
+			}
+		}
+		if !hasLower {
+			return errors.New("at least one lowercase letter required")
+		}
+		if !hasUpper {
+			return errors.New("at least one uppercase letter required")
+		}
+		if !hasNumber {
+			return errors.New("at least one number required")
+		}
+		if !hasSpecial {
+			return errors.New("at least one special character (!@#$ etc.) required")
+		}
+		return nil
+	case levelExcellent:
+		if len(password) < 10 {
+			return errors.New("minimum 10 characters required")
+		}
+		var hasLower, hasUpper, hasNumber, hasSpecial bool
+		var previousLetter rune
+		for _, c := range password {
+			if c == previousLetter {
+				return errors.New("password contains 2 identical characters in a row")
+			}
+			switch {
+			case unicode.IsLower(c):
+				hasLower = true
+			case unicode.IsUpper(c):
+				hasUpper = true
+			case unicode.IsNumber(c):
+				hasNumber = true
+			case !unicode.IsLetter(c) && !unicode.IsNumber(c):
+				hasSpecial = true
+			}
+			previousLetter = c
+		}
+		if !hasLower {
+			return errors.New("at least one lowercase letter required")
+		}
+		if !hasUpper {
+			return errors.New("at least one uppercase letter required")
+		}
+		if !hasNumber {
+			return errors.New("at least one number required")
+		}
+		if !hasSpecial {
+			return errors.New("at least one special character (!@#$ etc.) required")
+		}
+		return nil
+	default:
+		return errors.New("unknown password policy level")
+	}
+}
+
+func GetComplexity(level string) (Complexity, error) {
+	switch strings.ToLower(level) {
+	case levelNone.String(), "":
+		return ComplexityNone, nil
+	case levelLow.String():
+		return ComplexityLow, nil
+	case levelFair.String():
+		return ComplexityFair, nil
+	case levelGood.String():
+		return ComplexityGood, nil
+	case levelExcellent.String():
+		return ComplexityExcellent, nil
+	default:
+		return Complexity{}, fmt.Errorf("unknown password complexity level: %s", level)
+	}
+}
+
+func WithComplexityLevel(complexityLevel string) PasswordPolicyOption {
+	return func(pp *PasswordPolicy) error {
+		cl, err := GetComplexity(complexityLevel)
+		if err != nil {
+			return err
+		}
+		pp.complexity = cl
+		return nil
+	}
+}
+
+type LockoutSettings struct {
+	maxAttempts  uint64
+	lockDuration time.Duration
+}
+
+func WithLockoutSettings(maxAttempts uint64, lockDuration time.Duration) PasswordPolicyOption {
+	return func(pp *PasswordPolicy) error {
+		pp.lockout = &LockoutSettings{
+			maxAttempts:  maxAttempts,
+			lockDuration: lockDuration,
+		}
+		return nil
+	}
+}
+
+type RotationSettings struct {
+	passwordRotationInterval time.Duration
+	redirectURL              *string
+}
+
+func WithRotationSettings(rotationInterval time.Duration, redirectURL *string) PasswordPolicyOption {
+	return func(pp *PasswordPolicy) error {
+		pp.rotation = &RotationSettings{
+			passwordRotationInterval: rotationInterval,
+			redirectURL:              redirectURL,
+		}
+		return nil
+	}
+}
+
+type PasswordPolicy struct {
+	id string
+	// complexityLevel Sets password complexity requirements
+	// Possible values:
+	//   - None:      No restrictions. Password can be any length starting from 1 character.
+	//   - Low:       Minimum 8 characters.
+	//   - Fair:      (Default) Minimum 8 characters, at least:
+	//                • One uppercase letter
+	//                • One lowercase letter
+	//                • One digit
+	//   - Good:      Minimum 8 characters, at least:
+	//                • One uppercase letter
+	//                • One lowercase letter
+	//                • One digit
+	//                • One special character (!@#$%^&* etc.)
+	//   - Excellent: Minimum 8 characters, at least:
+	//                • One uppercase letter
+	//                • One lowercase letter
+	//                • One digit
+	//                • One special character (!@#$%^&* etc.)
+	//                • No more than 2 identical characters in a row
+	complexity Complexity
+	// lockout Settings that define restrictions and conditions for account lockout after failed login attempts.
+	lockout *LockoutSettings
+	// rotation Settings defines rule for periodic credential rotation.
+	rotation *RotationSettings
+}
+
+func (pp PasswordPolicy) IsPasswordLocked(p storage.Password) bool {
+	if pp.lockout != nil && p.LockedUntil != nil && p.LockedUntil.After(time.Now()) {
+		return true
+	}
+	return false
+}
+
+func (pp PasswordPolicy) IsMaxLoginAttemptsExeeded(attempts uint64) bool {
+	if pp.lockout != nil && pp.lockout.maxAttempts <= attempts {
+		return true
+	}
+	return false
+}
+
+func (pp PasswordPolicy) IsPasswordExpired(passwordCreatedAt time.Time) bool {
+	if pp.rotation == nil {
+		return false
+	}
+
+	passwordExpirationDate := passwordCreatedAt.Add(pp.rotation.passwordRotationInterval)
+
+	return passwordExpirationDate.Before(time.Now())
+}
+
+func NewPasswordPolicy(id string, options ...PasswordPolicyOption) (*PasswordPolicy, error) {
+	if id == "" {
+		return nil, fmt.Errorf("password policy id cannot be empty")
+	}
+	pp := &PasswordPolicy{
+		id:         id,
+		complexity: ComplexityFair,
+	}
+
+	for _, opt := range options {
+		if err := opt(pp); err != nil {
+			return nil, err
+		}
+	}
+
+	return pp, nil
+}
diff --git a/server/server.go b/server/server.go
index 6a04df85..50a311f8 100644
--- a/server/server.go
+++ b/server/server.go
@@ -104,6 +104,9 @@ type Config struct {
 	// Refresh token expiration settings
 	RefreshTokenPolicy *RefreshTokenPolicy
 
+	// Password policy settings
+	PasswordPolicy *PasswordPolicy
+
 	// If set, the server will use this connector to handle password grants
 	PasswordConnector string
 
@@ -197,6 +200,7 @@ type Server struct {
 	deviceRequestsValidFor time.Duration
 
 	refreshTokenPolicy *RefreshTokenPolicy
+	passwordPolicy     *PasswordPolicy
 
 	logger *slog.Logger
 
@@ -311,6 +315,7 @@ func newServer(ctx context.Context, c Config, rotationStrategy rotationStrategy)
 		authRequestsValidFor:   value(c.AuthRequestsValidFor, 24*time.Hour),
 		deviceRequestsValidFor: value(c.DeviceRequestsValidFor, 5*time.Minute),
 		refreshTokenPolicy:     c.RefreshTokenPolicy,
+		passwordPolicy:         c.PasswordPolicy,
 		skipApproval:           c.SkipApprovalScreen,
 		alwaysShowLogin:        c.AlwaysShowLoginScreen,
 		now:                    now,
@@ -488,6 +493,7 @@ func newServer(ctx context.Context, c Config, rotationStrategy rotationStrategy)
 		}
 		s.handleConnectorCallback(w, r)
 	})
+	handleFunc(passwordChangeURI, s.handlePasswordChange)
 	// For easier connector-specific web server configuration, e.g. for the
 	// "authproxy" connector.
 	handleFunc("/callback/{connector}", s.handleConnectorCallback)
@@ -555,8 +561,20 @@ func (db passwordDB) Login(ctx context.Context, s connector.Scopes, email, passw
 		return connector.Identity{}, false, err
 	}
 	if err := bcrypt.CompareHashAndPassword(p.Hash, []byte(password)); err != nil {
+		if err := db.s.UpdatePassword(ctx, email, func(p storage.Password) (storage.Password, error) {
+			p.IncorrectPasswordLoginAttempts += 1
+			return p, nil
+		}); err != nil {
+			return connector.Identity{}, false, err
+		}
 		return connector.Identity{}, false, nil
 	}
+	if err := db.s.UpdatePassword(ctx, email, func(p storage.Password) (storage.Password, error) {
+		p.IncorrectPasswordLoginAttempts = 0
+		return p, nil
+	}); err != nil {
+		return connector.Identity{}, true, err
+	}
 	return connector.Identity{
 		UserID:        p.UserID,
 		Username:      p.Username,
diff --git a/server/templates.go b/server/templates.go
index 46bca92e..5f5cb33b 100644
--- a/server/templates.go
+++ b/server/templates.go
@@ -1,6 +1,7 @@
 package server
 
 import (
+	"errors"
 	"fmt"
 	"html/template"
 	"io"
@@ -15,14 +16,15 @@ import (
 )
 
 const (
-	tmplApproval      = "approval.html"
-	tmplLogin         = "login.html"
-	tmplPassword      = "password.html"
-	tmplOOB           = "oob.html"
-	tmplError         = "error.html"
-	tmplDevice        = "device.html"
-	tmplDeviceSuccess = "device_success.html"
-	tmplTOTPVerify    = "totp_verify.html"
+	tmplApproval       = "approval.html"
+	tmplLogin          = "login.html"
+	tmplPassword       = "password.html"
+	tmplPasswordChange = "password_change.html"
+	tmplOOB            = "oob.html"
+	tmplError          = "error.html"
+	tmplDevice         = "device.html"
+	tmplDeviceSuccess  = "device_success.html"
+	tmplTOTPVerify     = "totp_verify.html"
 )
 
 var requiredTmpls = []string{
@@ -37,14 +39,15 @@ var requiredTmpls = []string{
 }
 
 type templates struct {
-	loginTmpl         *template.Template
-	approvalTmpl      *template.Template
-	passwordTmpl      *template.Template
-	oobTmpl           *template.Template
-	errorTmpl         *template.Template
-	deviceTmpl        *template.Template
-	deviceSuccessTmpl *template.Template
-	tmplTOTPVerify    *template.Template
+	loginTmpl          *template.Template
+	approvalTmpl       *template.Template
+	passwordTmpl       *template.Template
+	passwordChangeTmpl *template.Template
+	oobTmpl            *template.Template
+	errorTmpl          *template.Template
+	deviceTmpl         *template.Template
+	deviceSuccessTmpl  *template.Template
+	tmplTOTPVerify     *template.Template
 }
 
 type webConfig struct {
@@ -165,14 +168,15 @@ func loadTemplates(c webConfig, templatesDir string) (*templates, error) {
 		return nil, fmt.Errorf("missing template(s): %s", missingTmpls)
 	}
 	return &templates{
-		loginTmpl:         tmpls.Lookup(tmplLogin),
-		approvalTmpl:      tmpls.Lookup(tmplApproval),
-		passwordTmpl:      tmpls.Lookup(tmplPassword),
-		oobTmpl:           tmpls.Lookup(tmplOOB),
-		errorTmpl:         tmpls.Lookup(tmplError),
-		deviceTmpl:        tmpls.Lookup(tmplDevice),
-		deviceSuccessTmpl: tmpls.Lookup(tmplDeviceSuccess),
-		tmplTOTPVerify:    tmpls.Lookup(tmplTOTPVerify),
+		loginTmpl:          tmpls.Lookup(tmplLogin),
+		approvalTmpl:       tmpls.Lookup(tmplApproval),
+		passwordTmpl:       tmpls.Lookup(tmplPassword),
+		passwordChangeTmpl: tmpls.Lookup(tmplPasswordChange),
+		oobTmpl:            tmpls.Lookup(tmplOOB),
+		errorTmpl:          tmpls.Lookup(tmplError),
+		deviceTmpl:         tmpls.Lookup(tmplDevice),
+		deviceSuccessTmpl:  tmpls.Lookup(tmplDeviceSuccess),
+		tmplTOTPVerify:     tmpls.Lookup(tmplTOTPVerify),
 	}, nil
 }
 
@@ -325,6 +329,96 @@ func (t *templates) password(r *http.Request, w http.ResponseWriter, postURL, la
 	return renderTemplate(w, t.passwordTmpl, data)
 }
 
+var (
+	ErrReusedPassword                   = errors.New("cannot use one of previous passwords")
+	ErrCurrentPasswordInvalid           = errors.New("current password is invalid")
+	ErrPasswordTooWeak                  = errors.New("")
+	ErrOldAndNewPassAreEq               = errors.New("old and new passwords are equal")
+	ErrNewPasswordContainsForbiddenChar = errors.New("new password contains forbidden character")
+)
+
+type passwordChangeReason string
+
+const (
+	complexityPolicyReason passwordChangeReason = "complexity"
+	rotationPolicyReason   passwordChangeReason = "rotation"
+)
+
+type passwordChangeParams struct {
+	Username        string
+	NewPasswordHint string
+	IssuerURL       string
+	ChangeReason    passwordChangeReason
+
+	Err error
+}
+
+func (t *templates) passwordChange(r *http.Request, w http.ResponseWriter, params passwordChangeParams) error {
+	postURL, err := url.JoinPath(params.IssuerURL, passwordChangeURI)
+	if err != nil {
+		return err
+	}
+
+	data := struct {
+		PostURL      string
+		Username     string
+		ChangeReason struct {
+			WeakComplexity bool
+			Rotation       bool
+		}
+		Error struct {
+			Exists bool
+			List   struct {
+				OldAndNewPassAreEqual  bool
+				CurrentPasswordInvalid bool
+				PasswordTooWeak        struct {
+					Exists      bool
+					Description string
+				}
+				ReusedPassword      bool
+				PasswordTooWeakDesc string
+			}
+		}
+		PasswordPolicy struct {
+			ComplexityRequirements string
+		}
+		ReqPath string
+	}{
+		Username: params.Username,
+		PostURL:  postURL,
+		ReqPath:  r.URL.Path,
+	}
+
+	switch params.ChangeReason {
+	case complexityPolicyReason:
+		data.ChangeReason.WeakComplexity = true
+	case rotationPolicyReason:
+		data.ChangeReason.Rotation = true
+	}
+
+	data.PasswordPolicy.ComplexityRequirements = params.NewPasswordHint
+
+	if params.Err != nil {
+		data.Error.Exists = true
+
+		if errors.Is(params.Err, ErrCurrentPasswordInvalid) {
+			data.Error.List.CurrentPasswordInvalid = true
+		}
+		if errors.Is(params.Err, ErrPasswordTooWeak) {
+			data.Error.List.PasswordTooWeak.Exists = true
+			data.Error.List.PasswordTooWeak.Description = params.Err.Error()
+		}
+		if errors.Is(params.Err, ErrOldAndNewPassAreEq) {
+			data.Error.List.OldAndNewPassAreEqual = true
+		}
+		if errors.Is(params.Err, ErrReusedPassword) {
+			data.Error.List.ReusedPassword = true
+		}
+	}
+
+	return renderTemplate(w, t.passwordChangeTmpl, data)
+}
+
 func (t *templates) approval(r *http.Request, w http.ResponseWriter, authReqID, username, clientName string, scopes []string) error {
 	accesses := []string{}
 	for _, scope := range scopes {
diff --git a/storage/kubernetes/storage.go b/storage/kubernetes/storage.go
index 6ff52283..2d7744c1 100644
--- a/storage/kubernetes/storage.go
+++ b/storage/kubernetes/storage.go
@@ -384,10 +384,15 @@ func (cli *client) ListPasswords(ctx context.Context) (passwords []storage.Passw
 
 	for _, password := range passwordList.Passwords {
 		p := storage.Password{
-			Email:    password.Email,
-			Hash:     password.Hash,
-			Username: password.Username,
-			UserID:   password.UserID,
+			Email:                          password.Email,
+			Hash:                           password.Hash,
+			HashUpdatedAt:                  password.HashUpdatedAt,
+			PreviousHashes:                 password.PreviousHashes,
+			ComplexityLevel:                password.ComplexityLevel,
+			Username:                       password.Username,
+			UserID:                         password.UserID,
+			IncorrectPasswordLoginAttempts: password.IncorrectPasswordLoginAttempts,
+			LockedUntil:                    password.LockedUntil,
 		}
 		passwords = append(passwords, p)
 	}
diff --git a/storage/kubernetes/types.go b/storage/kubernetes/types.go
index c5acc42c..de87ad4e 100644
--- a/storage/kubernetes/types.go
+++ b/storage/kubernetes/types.go
@@ -442,10 +442,17 @@ type Password struct {
 	// This field is IMMUTABLE. Do not change.
 	Email string `json:"email,omitempty"`
 
-	Hash     []byte   `json:"hash,omitempty"`
-	Username string   `json:"username,omitempty"`
-	UserID   string   `json:"userID,omitempty"`
-	Groups   []string `json:"groups,omitempty"`
+	Hash            []byte    `json:"hash,omitempty"`
+	HashUpdatedAt   time.Time `json:"hashUpdatedAt"`
+	PreviousHashes  [][]byte  `json:"previousHashes,omitempty"`
+	ComplexityLevel string    `json:"complexityLevel,omitempty"`
+	Username        string    `json:"username,omitempty"`
+	UserID          string    `json:"userID,omitempty"`
+
+	IncorrectPasswordLoginAttempts uint64     `json:"incorrectPasswordLoginAttempts"`
+	LockedUntil                    *time.Time `json:"lockedUntil"`
+
+	Groups []string `json:"groups,omitempty"`
 }
 
 // PasswordList is a list of Passwords.
@@ -466,21 +473,31 @@ func (cli *client) fromStoragePassword(p storage.Password) Password {
 			Name:      cli.idToName(email),
 			Namespace: cli.namespace,
 		},
-		Email:    email,
-		Hash:     p.Hash,
-		Username: p.Username,
-		UserID:   p.UserID,
-		Groups:   p.Groups,
+		Email:                          email,
+		Hash:                           p.Hash,
+		HashUpdatedAt:                  p.HashUpdatedAt,
+		PreviousHashes:                 p.PreviousHashes,
+		ComplexityLevel:                p.ComplexityLevel,
+		Username:                       p.Username,
+		UserID:                         p.UserID,
+		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
+		LockedUntil:                    p.LockedUntil,
+		Groups:                         p.Groups,
 	}
 }
 
 func toStoragePassword(p Password) storage.Password {
 	return storage.Password{
-		Email:    p.Email,
-		Hash:     p.Hash,
-		Username: p.Username,
-		UserID:   p.UserID,
-		Groups:   p.Groups,
+		Email:                          p.Email,
+		Hash:                           p.Hash,
+		HashUpdatedAt:                  p.HashUpdatedAt,
+		PreviousHashes:                 p.PreviousHashes,
+		ComplexityLevel:                p.ComplexityLevel,
+		Username:                       p.Username,
+		UserID:                         p.UserID,
+		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
+		LockedUntil:                    p.LockedUntil,
+		Groups:                         p.Groups,
 	}
 }
 
diff --git a/storage/sql/crud.go b/storage/sql/crud.go
index 64961b5d..c2126108 100644
--- a/storage/sql/crud.go
+++ b/storage/sql/crud.go
@@ -631,9 +631,13 @@ func (c *conn) UpdatePassword(ctx context.Context, email string, updater func(p
 			update password
 			set
 				hash = $1, username = $2, user_id = $3, groups = $4
-			where email = $5;
+				incorrect_password_login_attempts = $4, locked_until = $5, hash_updated_at = $6,
+				previous_hashes = $7, complexity_level = $8
+			where email = $9;
 		`,
-			np.Hash, np.Username, np.UserID, encoder(p.Groups), p.Email,
+			np.Hash, np.Username, np.UserID, encoder(p.Groups),
+			np.IncorrectPasswordLoginAttempts, np.LockedUntil, np.HashUpdatedAt,
+			encoder(np.PreviousHashes), np.ComplexityLevel, p.Email,
 		)
 		if err != nil {
 			return fmt.Errorf("update password: %v", err)
@@ -649,7 +653,7 @@ func (c *conn) GetPassword(ctx context.Context, email string) (storage.Password,
 func getPassword(ctx context.Context, q querier, email string) (p storage.Password, err error) {
 	return scanPassword(q.QueryRow(`
 		select
-			email, hash, username, user_id, groups
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes, complexity_level
 		from password where email = $1;
 	`, strings.ToLower(email)))
 }
@@ -657,7 +661,7 @@ func getPassword(ctx context.Context, q querier, email string) (p storage.Passwo
 func (c *conn) ListPasswords(ctx context.Context) ([]storage.Password, error) {
 	rows, err := c.Query(`
 		select
-			email, hash, username, user_id, groups
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes, complexity_level
 		from password;
 	`)
 	if err != nil {
@@ -681,7 +685,9 @@ func (c *conn) ListPasswords(ctx context.Context) ([]storage.Password, error) {
 
 func scanPassword(s scanner) (p storage.Password, err error) {
 	err = s.Scan(
-		&p.Email, &p.Hash, &p.Username, &p.UserID, decoder(&p.Groups),
+		&p.Email, &p.Hash, &p.Username,
+		&p.UserID, decoder(&p.Groups), &p.IncorrectPasswordLoginAttempts, &p.LockedUntil,
+		&p.HashUpdatedAt, decoder(&p.PreviousHashes), &p.ComplexityLevel,
 	)
 	if err != nil {
 		if err == sql.ErrNoRows {
@@ -689,6 +695,7 @@ func scanPassword(s scanner) (p storage.Password, err error) {
 		}
 		return p, fmt.Errorf("select password: %v", err)
 	}
+
 	return p, nil
 }
 
diff --git a/storage/sql/migrate.go b/storage/sql/migrate.go
index 83e9c20d..b51d4c04 100644
--- a/storage/sql/migrate.go
+++ b/storage/sql/migrate.go
@@ -298,4 +298,18 @@ var migrations = []migration{
 				add column hmac_key bytea;`,
 		},
 	},
+	{
+		stmts: []string{
+			`alter table password
+				add column incorrect_password_login_attempts int default 0 not null`,
+			`alter table password
+				add column locked_until timestamptz default null`,
+			`alter table password
+				add column hash_updated_at timestamptz default current_timestamp`,
+			`alter table password
+				add column previous_hashes text default "" not null`,
+			`alter table password
+				add column complexity_level text default "none" not null`,
+		},
+	},
 }
diff --git a/storage/storage.go b/storage/storage.go
index 783ec7cc..540209c9 100644
--- a/storage/storage.go
+++ b/storage/storage.go
@@ -355,7 +355,10 @@ type Password struct {
 	Email string `json:"email"`
 
 	// Bcrypt encoded hash of the password. This package enforces a min cost value of 10
-	Hash []byte `json:"hash"`
+	Hash            []byte    `json:"hash"`
+	PreviousHashes  [][]byte  `json:"previousHashes"`
+	HashUpdatedAt   time.Time `json:"hashUpdatedAt"`
+	ComplexityLevel string    `json:"complexityLevel"`
 
 	// Bcrypt encoded hash of the password set in environment variable of this name.
 	HashFromEnv string `json:"hashFromEnv"`
@@ -366,6 +369,12 @@ type Password struct {
 	// Randomly generated user ID. This is NOT the primary ID of the Password object.
 	UserID string `json:"userID"`
 
+	// IncorrectPasswordLoginAttempts tracks the number of consecutive failed login attempts
+	IncorrectPasswordLoginAttempts uint64 `json:"incorrectPasswordLoginAttempts"`
+	// LockedUntil indicates timing when user will be able to login next time after lockout
+	// cuz of exceeding login attempts with password policy setting
+	LockedUntil *time.Time `json:"lockedUntil"`
+
 	// Groups assigned to the user
 	Groups []string `json:"groups"`
 }
diff --git a/web/templates/password_change.html b/web/templates/password_change.html
new file mode 100644
index 00000000..d4452f4c
--- /dev/null
+++ b/web/templates/password_change.html
@@ -0,0 +1,96 @@
+{{ template "header.html" . }}
+
+<div class="theme-panel">
+  <h2 class="theme-heading">Change Password</h2>
+  {{ if .ChangeReason.WeakComplexity }}
+    Initiator: password complexity policy
+  {{ else if .ChangeReason.Rotation }}
+    Initiator: password rotation policy
+  {{ end }}
+  <form method="post" action="{{ .PostURL }}">
+    <div class="theme-form-row">
+        <div class="theme-form-label">
+            <label for="username">Username</label>
+        </div>
+        <input type="text" id="username" name="username" 
+                value="{{ .Username }}" readonly
+                class="theme-form-input theme-form-input-readonly">
+    </div>
+
+    <div class="theme-form-row">
+      <div class="theme-form-label">
+        <label for="currentPassword">Current Password</label>
+      </div>
+      <input tabindex="1" required id="currentPassword" name="currentPassword" type="password" 
+             class="theme-form-input" placeholder="current password" {{ if .Error.Exists }} autofocus {{ end }}/>
+    </div>
+
+    <div class="theme-form-row">
+      <div class="theme-form-label">
+        <label for="newPassword">New Password</label>
+      </div>
+      <input tabindex="2" required id="newPassword" name="newPassword" type="password"
+             class="theme-form-input" placeholder="new password"/>
+      {{ if .PasswordPolicy }}
+        <pre class="theme-form-hint">{{ .PasswordPolicy.ComplexityRequirements }}</pre>
+      {{ end }}
+    </div>
+
+    <div class="theme-form-row">
+      <div class="theme-form-label">
+        <label for="confirmPassword">Confirm New Password</label>
+      </div>
+      <input tabindex="3" required id="confirmPassword" name="confirmPassword" type="password"
+             class="theme-form-input" placeholder="confirm new password"/>
+    </div>
+
+    {{ if .Error.Exists }}
+      <div id="password-error" class="dex-error-box">
+        {{ if .Error.List.CurrentPasswordInvalid }}
+          Current password is incorrect
+        {{ else if .Error.List.PasswordTooWeak.Exists }}
+          <pre class="theme-form-hint">Password doesn't meet requirements: {{ .Error.List.PasswordTooWeak.Description }}</pre>
+        {{ else if .Error.List.OldAndNewPassAreEqual }}
+          Current password and new password cannot be equal
+        {{ else if .Error.List.ReusedPassword }}
+          Cannot use one of previous passwords
+        {{ else }}
+          Failed to change password
+        {{ end }}
+      </div>
+    {{ end }}
+
+    <button tabindex="4" id="submit-change" type="submit" class="dex-btn theme-btn--primary">
+      Change Password
+    </button>
+  </form>
+</div>
+
+<script type="text/javascript">
+  document.querySelector('form').addEventListener('submit', function(e) {
+    const submitBtn = document.getElementById('submit-change');
+
+    const urlParams = new URLSearchParams(window.location.search);
+    
+    urlParams.forEach((value, key) => {
+        const hiddenInput = document.createElement('input');
+        hiddenInput.type = 'hidden';
+        hiddenInput.name = key;
+        hiddenInput.value = value;
+        this.appendChild(hiddenInput);
+    });
+  });
+
+  // Simple client-side validation
+  document.querySelector('form').addEventListener('submit', function(e) {
+    const newPass = document.getElementById('newPassword').value;
+    const confirmPass = document.getElementById('confirmPassword').value;
+    
+    if (newPass !== confirmPass) {
+      e.preventDefault();
+      alert('New passwords do not match');
+    }
+  });
+</script>
+
+{{ template "footer.html" . }}
\ No newline at end of file
diff --git a/web/themes/dark/styles.css b/web/themes/dark/styles.css
index edf30412..6965823a 100644
--- a/web/themes/dark/styles.css
+++ b/web/themes/dark/styles.css
@@ -120,3 +120,9 @@
 .dex-container {
   color: #c8d1d9;
 }
+
+.theme-form-input[readonly] {
+  background-color: #f8f9fa;
+  border-color: #ddd;
+  cursor: not-allowed;
+}
\ No newline at end of file
diff --git a/web/themes/light/styles.css b/web/themes/light/styles.css
index 2d920571..22bfeb3a 100644
--- a/web/themes/light/styles.css
+++ b/web/themes/light/styles.css
@@ -111,3 +111,9 @@
 .theme-link-back {
   margin-top: 4px;
 }
+
+.theme-form-input[readonly] {
+  background-color: #f8f9fa;
+  border-color: #ddd;
+  cursor: not-allowed;
+}
\ No newline at end of file
-- 
2.39.5 (Apple Git-154)

