diff --git a/cmd/dex/config.go b/cmd/dex/config.go
index 3ca92c6a..0c4f7f55 100644
--- a/cmd/dex/config.go
+++ b/cmd/dex/config.go
@@ -11,6 +11,8 @@ import (
 	"strings"
 	"time"
 
+	pkgtime "github.com/dexidp/dex/pkg/time"
+
 	"golang.org/x/crypto/bcrypt"
 
 	"github.com/dexidp/dex/pkg/featureflags"
@@ -527,7 +529,7 @@ func (p *PasswordPolicy) UnmarshalJSON(data []byte) error {
 
 	// Parse lockout duration
 	if aux.Lockout != nil {
-		duration, err := time.ParseDuration(aux.Lockout.DurationStr)
+		duration, err := pkgtime.ParseDuration(aux.Lockout.DurationStr)
 		if err != nil {
 			return fmt.Errorf("invalid lockout duration: %w", err)
 		}
@@ -543,7 +545,7 @@ func (p *PasswordPolicy) UnmarshalJSON(data []byte) error {
 
 	// Parse rotation interval
 	if aux.Rotation != nil {
-		interval, err := time.ParseDuration(aux.Rotation.IntervalStr)
+		interval, err := pkgtime.ParseDuration(aux.Rotation.IntervalStr)
 		if err != nil {
 			return fmt.Errorf("invalid rotation interval: %w", err)
 		}
diff --git a/examples/config-dev.yaml b/examples/config-dev.yaml
index 99a0914f..741419f0 100644
--- a/examples/config-dev.yaml
+++ b/examples/config-dev.yaml
@@ -77,8 +77,8 @@ telemetry:
 
 # Uncomment this block to enable the gRPC API. This values MUST be different
 # from the HTTP endpoints.
-# grpc:
-#   addr: 127.0.0.1:5557
+grpc:
+  addr: 127.0.0.1:5557
 #   tlsCert: examples/grpc-client/server.crt
 #   tlsKey: examples/grpc-client/server.key
 #   tlsClientCA: examples/grpc-client/ca.crt
@@ -155,14 +155,14 @@ connectors:
 # Let dex keep a list of passwords which can be used to login to dex.
 enablePasswordDB: true
 
-# passwordPolicy:
-#   id: hello-kitty
-#   complexityLevel: low
-#   lockout:
-#     maxAttempts: 3
-#     lockDuration: "1m"
-#   rotation:
-#     interval: "1s"
+passwordPolicy:
+  id: hello-kitty
+  complexityLevel: low
+  lockout:
+    maxAttempts: 3
+    lockDuration: "1d2h3s"
+  rotation:
+    interval: "1s"
 
 # A static list of passwords to login the end user. By identifying here, dex
 # won't look in its underlying storage for passwords.
diff --git a/pkg/time/parseduration.go b/pkg/time/parseduration.go
new file mode 100644
index 00000000..49280860
--- /dev/null
+++ b/pkg/time/parseduration.go
@@ -0,0 +1,225 @@
+// Based on time.ParseDuration from the Go standard library
+// Original source: https://cs.opensource.google/go/go/+/refs/tags/go1.23.0:src/time/format.go;l=1617
+// Modified to extend duration parsing with day units.
+// Now supports: ns, us, ms, s, m, h, d (days)
+// Example: "1d" = 24h, "2d12h" = 60h
+package config
+
+import (
+	"errors"
+	"time"
+)
+
+// These are borrowed from unicode/utf8 and strconv and replicate behavior in
+// that package, since we can't take a dependency on either.
+const (
+	lowerhex  = "0123456789abcdef"
+	runeSelf  = 0x80
+	runeError = '\uFFFD'
+)
+
+func quote(s string) string {
+	buf := make([]byte, 1, len(s)+2) // slice will be at least len(s) + quotes
+	buf[0] = '"'
+	for i, c := range s {
+		if c >= runeSelf || c < ' ' {
+			// This means you are asking us to parse a time.Duration or
+			// time.Location with unprintable or non-ASCII characters in it.
+			// We don't expect to hit this case very often. We could try to
+			// reproduce strconv.Quote's behavior with full fidelity but
+			// given how rarely we expect to hit these edge cases, speed and
+			// conciseness are better.
+			var width int
+			if c == runeError {
+				width = 1
+				if i+2 < len(s) && s[i:i+3] == string(runeError) {
+					width = 3
+				}
+			} else {
+				width = len(string(c))
+			}
+			for j := 0; j < width; j++ {
+				buf = append(buf, `\x`...)
+				buf = append(buf, lowerhex[s[i+j]>>4])
+				buf = append(buf, lowerhex[s[i+j]&0xF])
+			}
+		} else {
+			if c == '"' || c == '\\' {
+				buf = append(buf, '\\')
+			}
+			buf = append(buf, string(c)...)
+		}
+	}
+	buf = append(buf, '"')
+	return string(buf)
+}
+
+var errLeadingInt = errors.New("time: bad [0-9]*") // never printed
+
+// leadingInt consumes the leading [0-9]* from s.
+func leadingInt[bytes []byte | string](s bytes) (x uint64, rem bytes, err error) {
+	i := 0
+	for ; i < len(s); i++ {
+		c := s[i]
+		if c < '0' || c > '9' {
+			break
+		}
+		if x > 1<<63/10 {
+			// overflow
+			return 0, rem, errLeadingInt
+		}
+		x = x*10 + uint64(c) - '0'
+		if x > 1<<63 {
+			// overflow
+			return 0, rem, errLeadingInt
+		}
+	}
+	return x, s[i:], nil
+}
+
+// leadingFraction consumes the leading [0-9]* from s.
+// It is used only for fractions, so does not return an error on overflow,
+// it just stops accumulating precision.
+func leadingFraction(s string) (x uint64, scale float64, rem string) {
+	i := 0
+	scale = 1
+	overflow := false
+	for ; i < len(s); i++ {
+		c := s[i]
+		if c < '0' || c > '9' {
+			break
+		}
+		if overflow {
+			continue
+		}
+		if x > (1<<63-1)/10 {
+			// It's possible for overflow to give a positive number, so take care.
+			overflow = true
+			continue
+		}
+		y := x*10 + uint64(c) - '0'
+		if y > 1<<63 {
+			overflow = true
+			continue
+		}
+		x = y
+		scale *= 10
+	}
+	return x, scale, s[i:]
+}
+
+var unitMap = map[string]uint64{
+	"ns": uint64(time.Nanosecond),
+	"us": uint64(time.Microsecond),
+	"µs": uint64(time.Microsecond), // U+00B5 = micro symbol
+	"μs": uint64(time.Microsecond), // U+03BC = Greek letter mu
+	"ms": uint64(time.Millisecond),
+	"s":  uint64(time.Second),
+	"m":  uint64(time.Minute),
+	"h":  uint64(time.Hour),
+	"d":  uint64(time.Hour * 24),
+}
+
+// ParseDuration parses a duration string.
+// A duration string is a possibly signed sequence of
+// decimal numbers, each with optional fraction and a unit suffix,
+// such as "300ms", "-1.5h" or "2h45m".
+// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
+func ParseDuration(s string) (time.Duration, error) {
+	// [-+]?([0-9]*(\.[0-9]*)?[a-z]+)+
+	orig := s
+	var d uint64
+	neg := false
+
+	// Consume [-+]?
+	if s != "" {
+		c := s[0]
+		if c == '-' || c == '+' {
+			neg = c == '-'
+			s = s[1:]
+		}
+	}
+	// Special case: if all that is left is "0", this is zero.
+	if s == "0" {
+		return 0, nil
+	}
+	if s == "" {
+		return 0, errors.New("time: invalid duration " + quote(orig))
+	}
+	for s != "" {
+		var (
+			v, f  uint64      // integers before, after decimal point
+			scale float64 = 1 // value = v + f/scale
+		)
+
+		var err error
+
+		// The next character must be [0-9.]
+		if !(s[0] == '.' || '0' <= s[0] && s[0] <= '9') {
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+		// Consume [0-9]*
+		pl := len(s)
+		v, s, err = leadingInt(s)
+		if err != nil {
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+		pre := pl != len(s) // whether we consumed anything before a period
+
+		// Consume (\.[0-9]*)?
+		post := false
+		if s != "" && s[0] == '.' {
+			s = s[1:]
+			pl := len(s)
+			f, scale, s = leadingFraction(s)
+			post = pl != len(s)
+		}
+		if !pre && !post {
+			// no digits (e.g. ".s" or "-.s")
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+
+		// Consume unit.
+		i := 0
+		for ; i < len(s); i++ {
+			c := s[i]
+			if c == '.' || '0' <= c && c <= '9' {
+				break
+			}
+		}
+		if i == 0 {
+			return 0, errors.New("time: missing unit in duration " + quote(orig))
+		}
+		u := s[:i]
+		s = s[i:]
+		unit, ok := unitMap[u]
+		if !ok {
+			return 0, errors.New("time: unknown unit " + quote(u) + " in duration " + quote(orig))
+		}
+		if v > 1<<63/unit {
+			// overflow
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+		v *= unit
+		if f > 0 {
+			// float64 is needed to be nanosecond accurate for fractions of hours.
+			// v >= 0 && (f*unit/scale) <= 3.6e+12 (ns/h, h is the largest unit)
+			v += uint64(float64(f) * (float64(unit) / scale))
+			if v > 1<<63 {
+				// overflow
+				return 0, errors.New("time: invalid duration " + quote(orig))
+			}
+		}
+		d += v
+		if d > 1<<63 {
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+	}
+	if neg {
+		return -time.Duration(d), nil
+	}
+	if d > 1<<63-1 {
+		return 0, errors.New("time: invalid duration " + quote(orig))
+	}
+	return time.Duration(d), nil
+}
diff --git a/server/handlers.go b/server/handlers.go
index b8b4c005..b3289261 100644
--- a/server/handlers.go
+++ b/server/handlers.go
@@ -432,23 +432,15 @@ func (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {
 			return
 		}
 
-		if s.passwordPolicy != nil {
-			// TODO: move to password policy method
-			cl, err := GetComplexity(p.ComplexityLevel)
-			if err == nil {
-				if cl.level < s.passwordPolicy.complexity.level {
-					redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), complexityPolicyReason)
-					if err != nil {
-						s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
-						s.renderError(r, w, http.StatusInternalServerError, "Login error.")
-						return
-					}
-					http.Redirect(w, r, redirectURL, http.StatusSeeOther)
-					s.logger.InfoContext(r.Context(), "user was forced to change password due to password complexity policy settings", "user", username)
-				}
-			} else {
-				s.logger.ErrorContext(ctx, "wrong password complexity level", "err", err)
+		if s.passwordPolicy != nil && GetPasswordComplexity(password).level < s.passwordPolicy.complexity.level {
+			redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), complexityPolicyReason)
+			if err != nil {
+				s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
+				s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+				return
 			}
+			http.Redirect(w, r, redirectURL, http.StatusSeeOther)
+			s.logger.InfoContext(r.Context(), "user was forced to change password due to password complexity policy settings", "user", username)
 		}
 
 		if s.passwordPolicy != nil && s.passwordPolicy.IsPasswordExpired(p.HashUpdatedAt) {
diff --git a/server/passwordchangehandler.go b/server/passwordchangehandler.go
index 20d39398..3614bd18 100644
--- a/server/passwordchangehandler.go
+++ b/server/passwordchangehandler.go
@@ -156,9 +156,6 @@ func (s *Server) handlePasswordChange(w http.ResponseWriter, r *http.Request) {
 			}
 			p.HashUpdatedAt = time.Now()
 			p.Hash = hash
-			if s.passwordPolicy != nil {
-				p.ComplexityLevel = s.passwordPolicy.complexity.level.String()
-			}
 			return p, nil
 		}
 		if err := s.storage.UpdatePassword(ctx, username, updater); err != nil {
diff --git a/server/passwordpolicy.go b/server/passwordpolicy.go
index 3ecb4203..4720277b 100644
--- a/server/passwordpolicy.go
+++ b/server/passwordpolicy.go
@@ -73,106 +73,136 @@ func (cl Complexity) Validate(password string) error {
 	switch cl.level {
 	case levelNone:
 		return nil
-
 	case levelLow:
-		if len(password) < 8 {
-			return errors.New("minimum 8 characters required")
-		}
-		return nil
-
+		return validateComplexityLow(password)
 	case levelFair:
-		if len(password) < 8 {
-			return errors.New("minimum 8 characters required")
-		}
-		var hasLower, hasUpper, hasNumber bool
-		for _, c := range password {
-			switch {
-			case unicode.IsLower(c):
-				hasLower = true
-			case unicode.IsUpper(c):
-				hasUpper = true
-			case unicode.IsNumber(c):
-				hasNumber = true
-			}
-		}
-		if !hasLower {
-			return errors.New("at least one lowercase letter required")
-		}
-		if !hasUpper {
-			return errors.New("at least one uppercase letter required")
-		}
-		if !hasNumber {
-			return errors.New("at least one number required")
-		}
-		return nil
+		return validateComplexityFair(password)
 	case levelGood:
-		if len(password) < 8 {
-			return errors.New("minimum 8 characters required")
-		}
-		var hasLower, hasUpper, hasNumber, hasSpecial bool
-		for _, c := range password {
-			switch {
-			case unicode.IsLower(c):
-				hasLower = true
-			case unicode.IsUpper(c):
-				hasUpper = true
-			case unicode.IsNumber(c):
-				hasNumber = true
-			case !unicode.IsLetter(c) && !unicode.IsNumber(c):
-				hasSpecial = true
-			}
-		}
-		if !hasLower {
-			return errors.New("at least one lowercase letter required")
-		}
-		if !hasUpper {
-			return errors.New("at least one uppercase letter required")
-		}
-		if !hasNumber {
-			return errors.New("at least one number required")
-		}
-		if !hasSpecial {
-			return errors.New("at least one special character (!@#$ etc.) required")
-		}
-		return nil
+		return validateComplexityGood(password)
 	case levelExcellent:
-		if len(password) < 8 {
-			return errors.New("minimum 8 characters required")
-		}
-		var hasLower, hasUpper, hasNumber, hasSpecial bool
-		var previousLetter rune
-		for _, c := range password {
-			if c == previousLetter {
-				return errors.New("password contains 2 identical characters in a row")
-			}
-			switch {
-			case unicode.IsLower(c):
-				hasLower = true
-			case unicode.IsUpper(c):
-				hasUpper = true
-			case unicode.IsNumber(c):
-				hasNumber = true
-			case !unicode.IsLetter(c) && !unicode.IsNumber(c):
-				hasSpecial = true
-			}
-			previousLetter = c
-		}
-		if !hasLower {
-			return errors.New("at least one lowercase letter required")
+		return validateComplexityExcellent(password)
+	default:
+		return errors.New("unknown password policy level")
+	}
+}
+
+func GetPasswordComplexity(password string) Complexity {
+	if err := validateComplexityExcellent(password); err == nil {
+		return ComplexityExcellent
+	}
+	if err := validateComplexityGood(password); err == nil {
+		return ComplexityGood
+	}
+	if err := validateComplexityFair(password); err == nil {
+		return ComplexityFair
+	}
+	if err := validateComplexityLow(password); err == nil {
+		return ComplexityLow
+	}
+	return ComplexityNone
+}
+
+func validateComplexityExcellent(password string) error {
+	if len(password) < 8 {
+		return errors.New("minimum 8 characters required")
+	}
+	var hasLower, hasUpper, hasNumber, hasSpecial bool
+	var previousLetter rune
+	for _, c := range password {
+		if c == previousLetter {
+			return errors.New("password contains 2 identical characters in a row")
 		}
-		if !hasUpper {
-			return errors.New("at least one uppercase letter required")
+		switch {
+		case unicode.IsLower(c):
+			hasLower = true
+		case unicode.IsUpper(c):
+			hasUpper = true
+		case unicode.IsNumber(c):
+			hasNumber = true
+		case !unicode.IsLetter(c) && !unicode.IsNumber(c):
+			hasSpecial = true
 		}
-		if !hasNumber {
-			return errors.New("at least one number required")
+		previousLetter = c
+	}
+	if !hasLower {
+		return errors.New("at least one lowercase letter required")
+	}
+	if !hasUpper {
+		return errors.New("at least one uppercase letter required")
+	}
+	if !hasNumber {
+		return errors.New("at least one number required")
+	}
+	if !hasSpecial {
+		return errors.New("at least one special character (!@#$ etc.) required")
+	}
+	return nil
+}
+
+func validateComplexityGood(password string) error {
+	if len(password) < 8 {
+		return errors.New("minimum 8 characters required")
+	}
+	var hasLower, hasUpper, hasNumber, hasSpecial bool
+	for _, c := range password {
+		switch {
+		case unicode.IsLower(c):
+			hasLower = true
+		case unicode.IsUpper(c):
+			hasUpper = true
+		case unicode.IsNumber(c):
+			hasNumber = true
+		case !unicode.IsLetter(c) && !unicode.IsNumber(c):
+			hasSpecial = true
 		}
-		if !hasSpecial {
-			return errors.New("at least one special character (!@#$ etc.) required")
+	}
+	if !hasLower {
+		return errors.New("at least one lowercase letter required")
+	}
+	if !hasUpper {
+		return errors.New("at least one uppercase letter required")
+	}
+	if !hasNumber {
+		return errors.New("at least one number required")
+	}
+	if !hasSpecial {
+		return errors.New("at least one special character (!@#$ etc.) required")
+	}
+	return nil
+}
+
+func validateComplexityFair(password string) error {
+	if len(password) < 8 {
+		return errors.New("minimum 8 characters required")
+	}
+	var hasLower, hasUpper, hasNumber bool
+	for _, c := range password {
+		switch {
+		case unicode.IsLower(c):
+			hasLower = true
+		case unicode.IsUpper(c):
+			hasUpper = true
+		case unicode.IsNumber(c):
+			hasNumber = true
 		}
-		return nil
-	default:
-		return errors.New("unknown password policy level")
 	}
+	if !hasLower {
+		return errors.New("at least one lowercase letter required")
+	}
+	if !hasUpper {
+		return errors.New("at least one uppercase letter required")
+	}
+	if !hasNumber {
+		return errors.New("at least one number required")
+	}
+	return nil
+}
+
+func validateComplexityLow(password string) error {
+	if len(password) < 8 {
+		return errors.New("minimum 8 characters required")
+	}
+	return nil
 }
 
 func GetComplexity(level string) (Complexity, error) {
diff --git a/storage/kubernetes/storage.go b/storage/kubernetes/storage.go
index 2d7744c1..a26ccc4f 100644
--- a/storage/kubernetes/storage.go
+++ b/storage/kubernetes/storage.go
@@ -388,7 +388,6 @@ func (cli *client) ListPasswords(ctx context.Context) (passwords []storage.Passw
 			Hash:                           password.Hash,
 			HashUpdatedAt:                  password.HashUpdatedAt,
 			PreviousHashes:                 password.PreviousHashes,
-			ComplexityLevel:                password.ComplexityLevel,
 			Username:                       password.Username,
 			UserID:                         password.UserID,
 			IncorrectPasswordLoginAttempts: password.IncorrectPasswordLoginAttempts,
diff --git a/storage/kubernetes/types.go b/storage/kubernetes/types.go
index de87ad4e..7856996e 100644
--- a/storage/kubernetes/types.go
+++ b/storage/kubernetes/types.go
@@ -442,12 +442,11 @@ type Password struct {
 	// This field is IMMUTABLE. Do not change.
 	Email string `json:"email,omitempty"`
 
-	Hash            []byte    `json:"hash,omitempty"`
-	HashUpdatedAt   time.Time `json:"hashUpdatedAt"`
-	PreviousHashes  [][]byte  `json:"previousHashes,omitempty"`
-	ComplexityLevel string    `json:"complexityLevel,omitempty"`
-	Username        string    `json:"username,omitempty"`
-	UserID          string    `json:"userID,omitempty"`
+	Hash           []byte    `json:"hash,omitempty"`
+	HashUpdatedAt  time.Time `json:"hashUpdatedAt"`
+	PreviousHashes [][]byte  `json:"previousHashes,omitempty"`
+	Username       string    `json:"username,omitempty"`
+	UserID         string    `json:"userID,omitempty"`
 
 	IncorrectPasswordLoginAttempts uint64     `json:"incorrectPasswordLoginAttempts"`
 	LockedUntil                    *time.Time `json:"lockedUntil"`
@@ -477,7 +476,6 @@ func (cli *client) fromStoragePassword(p storage.Password) Password {
 		Hash:                           p.Hash,
 		HashUpdatedAt:                  p.HashUpdatedAt,
 		PreviousHashes:                 p.PreviousHashes,
-		ComplexityLevel:                p.ComplexityLevel,
 		Username:                       p.Username,
 		UserID:                         p.UserID,
 		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
@@ -492,7 +490,6 @@ func toStoragePassword(p Password) storage.Password {
 		Hash:                           p.Hash,
 		HashUpdatedAt:                  p.HashUpdatedAt,
 		PreviousHashes:                 p.PreviousHashes,
-		ComplexityLevel:                p.ComplexityLevel,
 		Username:                       p.Username,
 		UserID:                         p.UserID,
 		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
diff --git a/storage/sql/crud.go b/storage/sql/crud.go
index fed70841..ec06e2d4 100644
--- a/storage/sql/crud.go
+++ b/storage/sql/crud.go
@@ -632,12 +632,12 @@ func (c *conn) UpdatePassword(ctx context.Context, email string, updater func(p
 			set
 				hash = $1, username = $2, user_id = $3, groups = $4
 				incorrect_password_login_attempts = $5, locked_until = $6, hash_updated_at = $7,
-				previous_hashes = $8, complexity_level = $9
-			where email = $10;
+				previous_hashes = $8
+			where email = $9;
 		`,
 			np.Hash, np.Username, np.UserID, encoder(p.Groups),
 			np.IncorrectPasswordLoginAttempts, np.LockedUntil, np.HashUpdatedAt,
-			encoder(np.PreviousHashes), np.ComplexityLevel, p.Email,
+			encoder(np.PreviousHashes), p.Email,
 		)
 		if err != nil {
 			return fmt.Errorf("update password: %v", err)
@@ -653,7 +653,7 @@ func (c *conn) GetPassword(ctx context.Context, email string) (storage.Password,
 func getPassword(ctx context.Context, q querier, email string) (p storage.Password, err error) {
 	return scanPassword(q.QueryRow(`
 		select
-			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes, complexity_level
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes
 		from password where email = $1;
 	`, strings.ToLower(email)))
 }
@@ -661,7 +661,7 @@ func getPassword(ctx context.Context, q querier, email string) (p storage.Passwo
 func (c *conn) ListPasswords(ctx context.Context) ([]storage.Password, error) {
 	rows, err := c.Query(`
 		select
-			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes, complexity_level
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes
 		from password;
 	`)
 	if err != nil {
@@ -687,7 +687,7 @@ func scanPassword(s scanner) (p storage.Password, err error) {
 	err = s.Scan(
 		&p.Email, &p.Hash, &p.Username,
 		&p.UserID, decoder(&p.Groups), &p.IncorrectPasswordLoginAttempts, &p.LockedUntil,
-		&p.HashUpdatedAt, decoder(&p.PreviousHashes), &p.ComplexityLevel,
+		&p.HashUpdatedAt, decoder(&p.PreviousHashes),
 	)
 	if err != nil {
 		if err == sql.ErrNoRows {
diff --git a/storage/sql/migrate.go b/storage/sql/migrate.go
index b51d4c04..c2755c98 100644
--- a/storage/sql/migrate.go
+++ b/storage/sql/migrate.go
@@ -312,4 +312,10 @@ var migrations = []migration{
 				add column complexity_level text default "none" not null`,
 		},
 	},
+	{
+		stmts: []string{
+			`alter table password
+				drop column complexity_level`,
+		},
+	},
 }
diff --git a/storage/storage.go b/storage/storage.go
index 540209c9..5adce6f2 100644
--- a/storage/storage.go
+++ b/storage/storage.go
@@ -355,10 +355,9 @@ type Password struct {
 	Email string `json:"email"`
 
 	// Bcrypt encoded hash of the password. This package enforces a min cost value of 10
-	Hash            []byte    `json:"hash"`
-	PreviousHashes  [][]byte  `json:"previousHashes"`
-	HashUpdatedAt   time.Time `json:"hashUpdatedAt"`
-	ComplexityLevel string    `json:"complexityLevel"`
+	Hash           []byte    `json:"hash"`
+	PreviousHashes [][]byte  `json:"previousHashes"`
+	HashUpdatedAt  time.Time `json:"hashUpdatedAt"`
 
 	// Bcrypt encoded hash of the password set in environment variable of this name.
 	HashFromEnv string `json:"hashFromEnv"`
-- 
2.39.5 (Apple Git-154)

