diff --git a/connector/oidc/oidc.go b/connector/oidc/oidc.go
index e345dca0..01e6c2e3 100644
--- a/connector/oidc/oidc.go
+++ b/connector/oidc/oidc.go
@@ -3,9 +3,12 @@ package oidc

 import (
 	"context"
+	"crypto/tls"
+	"crypto/x509"
 	"encoding/json"
 	"errors"
 	"fmt"
+	"net"
 	"net/http"
 	"net/url"
 	"strings"
@@ -34,6 +37,10 @@ type Config struct {

 	Scopes []string `json:"scopes"` // defaults to "profile" and "email"

+	RootCAs []string `json:"rootCAs"`
+
+	InsecureSkipVerify bool `json:"insecureSkipVerify"`
+
 	// Override the value of email_verified to true in the returned claims
 	InsecureSkipEmailVerified bool `json:"insecureSkipEmailVerified"`

@@ -105,8 +112,37 @@ func knownBrokenAuthHeaderProvider(issuerURL string) bool {
 // Open returns a connector which can be used to login users through an upstream
 // OpenID Connect provider.
 func (c *Config) Open(id string, logger log.Logger) (conn connector.Connector, err error) {
+	pool, err := x509.SystemCertPool()
+	if err != nil {
+		return nil, err
+	}
+
+	tlsConfig := tls.Config{RootCAs: pool, InsecureSkipVerify: c.InsecureSkipVerify}
+	for _, rootCA := range c.RootCAs {
+		if !tlsConfig.RootCAs.AppendCertsFromPEM([]byte(rootCA)) {
+			return nil, fmt.Errorf("cannot add CA from PEM")
+		}
+	}
+
 	ctx, cancel := context.WithCancel(context.Background())

+	httpClient := &http.Client{
+		Transport: &http.Transport{
+			TLSClientConfig: &tlsConfig,
+			Proxy:           http.ProxyFromEnvironment,
+			DialContext: (&net.Dialer{
+				Timeout:   30 * time.Second,
+				KeepAlive: 30 * time.Second,
+				DualStack: true,
+			}).DialContext,
+			MaxIdleConns:          100,
+			IdleConnTimeout:       90 * time.Second,
+			TLSHandshakeTimeout:   10 * time.Second,
+			ExpectContinueTimeout: 1 * time.Second,
+		},
+	}
+	ctx = context.WithValue(ctx, oauth2.HTTPClient, httpClient)
+
 	provider, err := oidc.NewProvider(ctx, c.Issuer)
 	if err != nil {
 		cancel()
