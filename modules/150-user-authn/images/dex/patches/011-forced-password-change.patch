diff --git a/server/handlers.go b/server/handlers.go
index 42c90057..35d3b744 100644
--- a/server/handlers.go
+++ b/server/handlers.go
@@ -492,6 +492,35 @@ func (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {
 			return
 		}
 
+		if localConnector {
+			if !passwordFound {
+				p2, err := s.storage.GetPassword(ctx, username)
+				switch {
+				case err == nil:
+					p = p2
+					passwordFound = true
+				case err == storage.ErrNotFound:
+					// Password not found: skip forced reset check.
+				default:
+					s.logger.ErrorContext(r.Context(), "failed to get password", "err", err)
+					s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+					return
+				}
+			}
+
+			if passwordFound && p.RequireResetHashOnNextSuccLogin {
+				redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), forcedReason)
+				if err != nil {
+					s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
+					s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+					return
+				}
+				http.Redirect(w, r, redirectURL, http.StatusSeeOther)
+				s.logger.InfoContext(r.Context(), "user was forced to change password due to password object requirement", "user", username)
+				return
+			}
+		}
+
 		if localConnector && s.passwordPolicy != nil {
 			// Validate password complexity with configured password policy
 			if GetPasswordComplexity(password).level < s.passwordPolicy.complexity.level {
diff --git a/server/passwordchangehandler.go b/server/passwordchangehandler.go
index 040a33d6..f0a543dd 100644
--- a/server/passwordchangehandler.go
+++ b/server/passwordchangehandler.go
@@ -151,12 +151,15 @@ func (s *Server) handlePasswordChange(w http.ResponseWriter, r *http.Request) {
 		}
 
 		updater := func(p storage.Password) (storage.Password, error) {
-			p.PreviousHashes = append(p.PreviousHashes, p.Hash)
-			if len(p.PreviousHashes) > int(s.passwordPolicy.passwordHistoryLimit) {
-				p.PreviousHashes = p.PreviousHashes[1:]
+			if s.passwordPolicy != nil && s.passwordPolicy.passwordHistoryLimit > 0 {
+				p.PreviousHashes = append(p.PreviousHashes, p.Hash)
+				if len(p.PreviousHashes) > int(s.passwordPolicy.passwordHistoryLimit) {
+					p.PreviousHashes = p.PreviousHashes[1:]
+				}
 			}
 			p.HashUpdatedAt = time.Now()
 			p.Hash = hash
+			p.RequireResetHashOnNextSuccLogin = false
 			return p, nil
 		}
 		if err := s.storage.UpdatePassword(ctx, username, updater); err != nil {
diff --git a/server/templates.go b/server/templates.go
index 6539f0fb..1f9da468 100644
--- a/server/templates.go
+++ b/server/templates.go
@@ -342,6 +342,7 @@ type passwordChangeReason string
 const (
 	complexityPolicyReason passwordChangeReason = "complexity"
 	rotationPolicyReason   passwordChangeReason = "rotation"
+	forcedReason           passwordChangeReason = "forced"
 )
 
 type passwordChangeParams struct {
@@ -360,6 +361,7 @@ func (t *templates) passwordChange(r *http.Request, w http.ResponseWriter, param
 		ChangeReason struct {
 			WeakComplexity bool
 			Rotation       bool
+			Forced         bool
 		}
 		Error struct {
 			Exists bool
@@ -388,6 +390,8 @@ func (t *templates) passwordChange(r *http.Request, w http.ResponseWriter, param
 		data.ChangeReason.WeakComplexity = true
 	case rotationPolicyReason:
 		data.ChangeReason.Rotation = true
+	case forcedReason:
+		data.ChangeReason.Forced = true
 	}
 
 	data.PasswordPolicy.ComplexityRequirements = params.NewPasswordHint
diff --git a/storage/kubernetes/types.go b/storage/kubernetes/types.go
index 7856996e..8270b429 100644
--- a/storage/kubernetes/types.go
+++ b/storage/kubernetes/types.go
@@ -442,11 +442,12 @@ type Password struct {
 	// This field is IMMUTABLE. Do not change.
 	Email string `json:"email,omitempty"`
 
-	Hash           []byte    `json:"hash,omitempty"`
-	HashUpdatedAt  time.Time `json:"hashUpdatedAt"`
-	PreviousHashes [][]byte  `json:"previousHashes,omitempty"`
-	Username       string    `json:"username,omitempty"`
-	UserID         string    `json:"userID,omitempty"`
+	Hash                            []byte    `json:"hash,omitempty"`
+	HashUpdatedAt                   time.Time `json:"hashUpdatedAt"`
+	RequireResetHashOnNextSuccLogin bool      `json:"requireResetHashOnNextSuccLogin,omitempty"`
+	PreviousHashes                  [][]byte  `json:"previousHashes,omitempty"`
+	Username                        string    `json:"username,omitempty"`
+	UserID                          string    `json:"userID,omitempty"`
 
 	IncorrectPasswordLoginAttempts uint64     `json:"incorrectPasswordLoginAttempts"`
 	LockedUntil                    *time.Time `json:"lockedUntil"`
@@ -472,29 +473,31 @@ func (cli *client) fromStoragePassword(p storage.Password) Password {
 			Name:      cli.idToName(email),
 			Namespace: cli.namespace,
 		},
-		Email:                          email,
-		Hash:                           p.Hash,
-		HashUpdatedAt:                  p.HashUpdatedAt,
-		PreviousHashes:                 p.PreviousHashes,
-		Username:                       p.Username,
-		UserID:                         p.UserID,
-		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
-		LockedUntil:                    p.LockedUntil,
-		Groups:                         p.Groups,
+		Email:                           email,
+		Hash:                            p.Hash,
+		HashUpdatedAt:                   p.HashUpdatedAt,
+		RequireResetHashOnNextSuccLogin: p.RequireResetHashOnNextSuccLogin,
+		PreviousHashes:                  p.PreviousHashes,
+		Username:                        p.Username,
+		UserID:                          p.UserID,
+		IncorrectPasswordLoginAttempts:  p.IncorrectPasswordLoginAttempts,
+		LockedUntil:                     p.LockedUntil,
+		Groups:                          p.Groups,
 	}
 }
 
 func toStoragePassword(p Password) storage.Password {
 	return storage.Password{
-		Email:                          p.Email,
-		Hash:                           p.Hash,
-		HashUpdatedAt:                  p.HashUpdatedAt,
-		PreviousHashes:                 p.PreviousHashes,
-		Username:                       p.Username,
-		UserID:                         p.UserID,
-		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
-		LockedUntil:                    p.LockedUntil,
-		Groups:                         p.Groups,
+		Email:                           p.Email,
+		Hash:                            p.Hash,
+		HashUpdatedAt:                   p.HashUpdatedAt,
+		RequireResetHashOnNextSuccLogin: p.RequireResetHashOnNextSuccLogin,
+		PreviousHashes:                  p.PreviousHashes,
+		Username:                        p.Username,
+		UserID:                          p.UserID,
+		IncorrectPasswordLoginAttempts:  p.IncorrectPasswordLoginAttempts,
+		LockedUntil:                     p.LockedUntil,
+		Groups:                          p.Groups,
 	}
 }
 
diff --git a/storage/sql/crud.go b/storage/sql/crud.go
index 84ace050..b767bfdd 100644
--- a/storage/sql/crud.go
+++ b/storage/sql/crud.go
@@ -644,12 +644,12 @@ func (c *conn) UpdatePassword(ctx context.Context, email string, updater func(p
 			set
 				hash = $1, username = $2, user_id = $3, groups = $4,
 				incorrect_password_login_attempts = $5, locked_until = $6, hash_updated_at = $7,
-				previous_hashes = $8
-			where email = $9;
+				previous_hashes = $8, require_reset_hash_on_next_succ_login = $9
+			where email = $10;
 		`,
 			np.Hash, np.Username, np.UserID, encoder(p.Groups),
 			np.IncorrectPasswordLoginAttempts, np.LockedUntil, np.HashUpdatedAt,
-			encoder(np.PreviousHashes), p.Email,
+			encoder(np.PreviousHashes), np.RequireResetHashOnNextSuccLogin, p.Email,
 		)
 		if err != nil {
 			return fmt.Errorf("update password: %v", err)
@@ -665,7 +665,7 @@ func (c *conn) GetPassword(ctx context.Context, email string) (storage.Password,
 func getPassword(ctx context.Context, q querier, email string) (p storage.Password, err error) {
 	return scanPassword(q.QueryRow(`
 		select
-			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes, require_reset_hash_on_next_succ_login
 		from password where email = $1;
 	`, strings.ToLower(email)))
 }
@@ -673,7 +673,7 @@ func getPassword(ctx context.Context, q querier, email string) (p storage.Passwo
 func (c *conn) ListPasswords(ctx context.Context) ([]storage.Password, error) {
 	rows, err := c.Query(`
 		select
-			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes, require_reset_hash_on_next_succ_login
 		from password;
 	`)
 	if err != nil {
@@ -699,7 +699,7 @@ func scanPassword(s scanner) (p storage.Password, err error) {
 	err = s.Scan(
 		&p.Email, &p.Hash, &p.Username,
 		&p.UserID, decoder(&p.Groups), &p.IncorrectPasswordLoginAttempts, &p.LockedUntil,
-		&p.HashUpdatedAt, decoder(&p.PreviousHashes),
+		&p.HashUpdatedAt, decoder(&p.PreviousHashes), &p.RequireResetHashOnNextSuccLogin,
 	)
 	if err != nil {
 		if err == sql.ErrNoRows {
diff --git a/storage/sql/migrate.go b/storage/sql/migrate.go
index 5d8672bf..23788ecd 100644
--- a/storage/sql/migrate.go
+++ b/storage/sql/migrate.go
@@ -335,4 +335,10 @@ var migrations = []migration{
 				add column groups bytea`,
 		},
 	},
+	{
+		stmts: []string{
+			`alter table password
+				add column require_reset_hash_on_next_succ_login boolean default false`,
+		},
+	},
 }
diff --git a/storage/storage.go b/storage/storage.go
index 5adce6f2..c4fe7f26 100644
--- a/storage/storage.go
+++ b/storage/storage.go
@@ -359,6 +359,11 @@ type Password struct {
 	PreviousHashes [][]byte  `json:"previousHashes"`
 	HashUpdatedAt  time.Time `json:"hashUpdatedAt"`
 
+	// RequireResetHashOnNextSuccLogin forces a password change flow after a successful login.
+	// This flag may be set externally (e.g. by a controller) and must be reset to false
+	// after the user changes the password.
+	RequireResetHashOnNextSuccLogin bool `json:"requireResetHashOnNextSuccLogin"`
+
 	// Bcrypt encoded hash of the password set in environment variable of this name.
 	HashFromEnv string `json:"hashFromEnv"`
 
diff --git a/web/templates/password_change.html b/web/templates/password_change.html
index 1e945371..4d009fc2 100644
--- a/web/templates/password_change.html
+++ b/web/templates/password_change.html
@@ -6,6 +6,8 @@
     Initiator: password complexity policy
   {{ else if .ChangeReason.Rotation }}
     Initiator: password rotation policy
+  {{ else if .ChangeReason.Forced }}
+    Initiator: administrator
   {{ end }}
   <form method="post" action="{{ .ReqPath }}">
     <div class="theme-form-row">
