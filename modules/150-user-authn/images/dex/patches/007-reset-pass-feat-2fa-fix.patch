diff --git a/server/handlers.go b/server/handlers.go
index cafc099c..7e2d1810 100644
--- a/server/handlers.go
+++ b/server/handlers.go
@@ -444,30 +444,43 @@ func (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {
 			return
 		}
 
-		if localConnector && s.passwordPolicy != nil {
-			// Validate password complexity with configured password policy
-			if GetPasswordComplexity(password).level < s.passwordPolicy.complexity.level {
-				redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), complexityPolicyReason)
+		if localConnector {
+			if p.RequireResetHashOnNextSuccLogin {
+				redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), forcedReason)
 				if err != nil {
 					s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
 					s.renderError(r, w, http.StatusInternalServerError, "Login error.")
 					return
 				}
 				http.Redirect(w, r, redirectURL, http.StatusSeeOther)
-				s.logger.InfoContext(r.Context(), "user was forced to change password due to password complexity policy settings", "user", username)
+				s.logger.InfoContext(r.Context(), "user was forced to change password due to password object requirement", "user", username)
 			}
 
-			// Validate password expiry with configured password policy
-			if s.passwordPolicy.IsPasswordExpired(p.HashUpdatedAt) {
-				redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), rotationPolicyReason)
-				if err != nil {
-					s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
-					s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			if s.passwordPolicy != nil {
+				// Validate password complexity with configured password policy
+				if GetPasswordComplexity(password).level < s.passwordPolicy.complexity.level {
+					redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), complexityPolicyReason)
+					if err != nil {
+						s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
+						s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+						return
+					}
+					http.Redirect(w, r, redirectURL, http.StatusSeeOther)
+					s.logger.InfoContext(r.Context(), "user was forced to change password due to password complexity policy settings", "user", username)
+				}
+
+				// Validate password expiry with configured password policy
+				if s.passwordPolicy.IsPasswordExpired(p.HashUpdatedAt) {
+					redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), rotationPolicyReason)
+					if err != nil {
+						s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
+						s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+						return
+					}
+					http.Redirect(w, r, redirectURL, http.StatusSeeOther)
+					s.logger.InfoContext(r.Context(), "user was forced to change password due to password rotation policy settings", "user", username)
 					return
 				}
-				http.Redirect(w, r, redirectURL, http.StatusSeeOther)
-				s.logger.InfoContext(r.Context(), "user was forced to change password due to password rotation policy settings", "user", username)
-				return
 			}
 		}
 
@@ -697,6 +710,16 @@ func (s *Server) finalizeLogin(ctx context.Context, identity connector.Identity,
 		if len(identity.ConnectorData) > 0 {
 			old.ConnectorData = identity.ConnectorData
 		}
+		// handle case when 2fa setting was activated with already existed users
+		if old.TOTP == "" && s.totp.enabledForConnector(authReq.ConnectorID) {
+			generated, err := s.totp.generate(authReq.ConnectorID, identity.Email)
+			if err != nil {
+				s.logger.ErrorContext(ctx, "failed to generate totp for offline session", "err", err)
+				return old, err
+			}
+
+			old.TOTP = generated.String()
+		}
 		return old, nil
 	}); err != nil {
 		s.logger.ErrorContext(ctx, "failed to update offline session", "err", err)
diff --git a/server/passwordchangehandler.go b/server/passwordchangehandler.go
index 3614bd18..f23efe75 100644
--- a/server/passwordchangehandler.go
+++ b/server/passwordchangehandler.go
@@ -156,6 +156,7 @@ func (s *Server) handlePasswordChange(w http.ResponseWriter, r *http.Request) {
 			}
 			p.HashUpdatedAt = time.Now()
 			p.Hash = hash
+			p.RequireResetHashOnNextSuccLogin = false
 			return p, nil
 		}
 		if err := s.storage.UpdatePassword(ctx, username, updater); err != nil {
diff --git a/server/templates.go b/server/templates.go
index 6539f0fb..1f9da468 100644
--- a/server/templates.go
+++ b/server/templates.go
@@ -342,6 +342,7 @@ type passwordChangeReason string
 const (
 	complexityPolicyReason passwordChangeReason = "complexity"
 	rotationPolicyReason   passwordChangeReason = "rotation"
+	forcedReason           passwordChangeReason = "forced"
 )
 
 type passwordChangeParams struct {
@@ -360,6 +361,7 @@ func (t *templates) passwordChange(r *http.Request, w http.ResponseWriter, param
 		ChangeReason struct {
 			WeakComplexity bool
 			Rotation       bool
+			Forced         bool
 		}
 		Error struct {
 			Exists bool
@@ -388,6 +390,8 @@ func (t *templates) passwordChange(r *http.Request, w http.ResponseWriter, param
 		data.ChangeReason.WeakComplexity = true
 	case rotationPolicyReason:
 		data.ChangeReason.Rotation = true
+	case forcedReason:
+		data.ChangeReason.Forced = true
 	}
 
 	data.PasswordPolicy.ComplexityRequirements = params.NewPasswordHint
diff --git a/storage/kubernetes/types.go b/storage/kubernetes/types.go
index 7856996e..5a675d10 100644
--- a/storage/kubernetes/types.go
+++ b/storage/kubernetes/types.go
@@ -442,11 +442,12 @@ type Password struct {
 	// This field is IMMUTABLE. Do not change.
 	Email string `json:"email,omitempty"`
 
-	Hash           []byte    `json:"hash,omitempty"`
-	HashUpdatedAt  time.Time `json:"hashUpdatedAt"`
-	PreviousHashes [][]byte  `json:"previousHashes,omitempty"`
-	Username       string    `json:"username,omitempty"`
-	UserID         string    `json:"userID,omitempty"`
+	Hash                            []byte    `json:"hash,omitempty"`
+	HashUpdatedAt                   time.Time `json:"hashUpdatedAt"`
+	RequireResetHashOnNextSuccLogin bool      `json:"requireResetHashOnNextSuccLogin,omitempty"`
+	PreviousHashes                  [][]byte  `json:"previousHashes,omitempty"`
+	Username                        string    `json:"username,omitempty"`
+	UserID                          string    `json:"userID,omitempty"`
 
 	IncorrectPasswordLoginAttempts uint64     `json:"incorrectPasswordLoginAttempts"`
 	LockedUntil                    *time.Time `json:"lockedUntil"`
@@ -472,29 +473,31 @@ func (cli *client) fromStoragePassword(p storage.Password) Password {
 			Name:      cli.idToName(email),
 			Namespace: cli.namespace,
 		},
-		Email:                          email,
-		Hash:                           p.Hash,
-		HashUpdatedAt:                  p.HashUpdatedAt,
-		PreviousHashes:                 p.PreviousHashes,
-		Username:                       p.Username,
-		UserID:                         p.UserID,
-		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
-		LockedUntil:                    p.LockedUntil,
-		Groups:                         p.Groups,
+		Email:                           email,
+		Hash:                            p.Hash,
+		HashUpdatedAt:                   p.HashUpdatedAt,
+		RequireResetHashOnNextSuccLogin: p.RequireResetHashOnNextSuccLogin,
+		PreviousHashes:                  p.PreviousHashes,
+		Username:                        p.Username,
+		UserID:                          p.UserID,
+		IncorrectPasswordLoginAttempts:  p.IncorrectPasswordLoginAttempts,
+		LockedUntil:                     p.LockedUntil,
+		Groups:                          p.Groups,
 	}
 }
 
 func toStoragePassword(p Password) storage.Password {
 	return storage.Password{
-		Email:                          p.Email,
-		Hash:                           p.Hash,
-		HashUpdatedAt:                  p.HashUpdatedAt,
-		PreviousHashes:                 p.PreviousHashes,
-		Username:                       p.Username,
-		UserID:                         p.UserID,
-		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
-		LockedUntil:                    p.LockedUntil,
-		Groups:                         p.Groups,
+		Email:                           p.Email,
+		Hash:                            p.Hash,
+		HashUpdatedAt:                   p.HashUpdatedAt,
+		RequireResetHashOnNextSuccLogin: p.RequireResetHashOnNextSuccLogin,
+		PreviousHashes:                  p.PreviousHashes,
+		Username:                        p.Username,
+		UserID:                          p.UserID,
+		IncorrectPasswordLoginAttempts:  p.IncorrectPasswordLoginAttempts,
+		LockedUntil:                     p.LockedUntil,
+		Groups:                          p.Groups,
 	}
 }
 
diff --git a/storage/sql/crud.go b/storage/sql/crud.go
index 84ace050..b767bfdd 100644
--- a/storage/sql/crud.go
+++ b/storage/sql/crud.go
@@ -644,12 +644,12 @@ func (c *conn) UpdatePassword(ctx context.Context, email string, updater func(p
 			set
 				hash = $1, username = $2, user_id = $3, groups = $4,
 				incorrect_password_login_attempts = $5, locked_until = $6, hash_updated_at = $7,
-				previous_hashes = $8
-			where email = $9;
+				previous_hashes = $8, require_reset_hash_on_next_succ_login = $9
+			where email = $10;
 		`,
 			np.Hash, np.Username, np.UserID, encoder(p.Groups),
 			np.IncorrectPasswordLoginAttempts, np.LockedUntil, np.HashUpdatedAt,
-			encoder(np.PreviousHashes), p.Email,
+			encoder(np.PreviousHashes), np.RequireResetHashOnNextSuccLogin, p.Email,
 		)
 		if err != nil {
 			return fmt.Errorf("update password: %v", err)
@@ -665,7 +665,7 @@ func (c *conn) GetPassword(ctx context.Context, email string) (storage.Password,
 func getPassword(ctx context.Context, q querier, email string) (p storage.Password, err error) {
 	return scanPassword(q.QueryRow(`
 		select
-			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes, require_reset_hash_on_next_succ_login
 		from password where email = $1;
 	`, strings.ToLower(email)))
 }
@@ -673,7 +673,7 @@ func getPassword(ctx context.Context, q querier, email string) (p storage.Passwo
 func (c *conn) ListPasswords(ctx context.Context) ([]storage.Password, error) {
 	rows, err := c.Query(`
 		select
-			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes, require_reset_hash_on_next_succ_login
 		from password;
 	`)
 	if err != nil {
@@ -699,7 +699,7 @@ func scanPassword(s scanner) (p storage.Password, err error) {
 	err = s.Scan(
 		&p.Email, &p.Hash, &p.Username,
 		&p.UserID, decoder(&p.Groups), &p.IncorrectPasswordLoginAttempts, &p.LockedUntil,
-		&p.HashUpdatedAt, decoder(&p.PreviousHashes),
+		&p.HashUpdatedAt, decoder(&p.PreviousHashes), &p.RequireResetHashOnNextSuccLogin,
 	)
 	if err != nil {
 		if err == sql.ErrNoRows {
diff --git a/storage/sql/migrate.go b/storage/sql/migrate.go
index 5d8672bf..23788ecd 100644
--- a/storage/sql/migrate.go
+++ b/storage/sql/migrate.go
@@ -335,4 +335,10 @@ var migrations = []migration{
 				add column groups bytea`,
 		},
 	},
+	{
+		stmts: []string{
+			`alter table password
+				add column require_reset_hash_on_next_succ_login boolean default false`,
+		},
+	},
 }
diff --git a/storage/storage.go b/storage/storage.go
index 5adce6f2..f75771f6 100644
--- a/storage/storage.go
+++ b/storage/storage.go
@@ -355,9 +355,10 @@ type Password struct {
 	Email string `json:"email"`
 
 	// Bcrypt encoded hash of the password. This package enforces a min cost value of 10
-	Hash           []byte    `json:"hash"`
-	PreviousHashes [][]byte  `json:"previousHashes"`
-	HashUpdatedAt  time.Time `json:"hashUpdatedAt"`
+	Hash                            []byte    `json:"hash"`
+	PreviousHashes                  [][]byte  `json:"previousHashes"`
+	HashUpdatedAt                   time.Time `json:"hashUpdatedAt"`
+	RequireResetHashOnNextSuccLogin bool      `json:"requireResetHashOnNextSuccLogin"`
 
 	// Bcrypt encoded hash of the password set in environment variable of this name.
 	HashFromEnv string `json:"hashFromEnv"`
diff --git a/web/templates/password_change.html b/web/templates/password_change.html
index 1e945371..4d009fc2 100644
--- a/web/templates/password_change.html
+++ b/web/templates/password_change.html
@@ -6,6 +6,8 @@
     Initiator: password complexity policy
   {{ else if .ChangeReason.Rotation }}
     Initiator: password rotation policy
+  {{ else if .ChangeReason.Forced }}
+    Initiator: administrator
   {{ end }}
   <form method="post" action="{{ .ReqPath }}">
     <div class="theme-form-row">
