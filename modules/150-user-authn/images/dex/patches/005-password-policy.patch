diff --git a/cmd/dex/config.go b/cmd/dex/config.go
index be5441f9..0c4f7f55 100644
--- a/cmd/dex/config.go
+++ b/cmd/dex/config.go
@@ -9,6 +9,9 @@ import (
 	"net/netip"
 	"os"
 	"strings"
+	"time"
+
+	pkgtime "github.com/dexidp/dex/pkg/time"
 
 	"golang.org/x/crypto/bcrypt"
 
@@ -24,14 +27,15 @@ import (
 
 // Config is the config format for the main application.
 type Config struct {
-	Issuer    string    `json:"issuer"`
-	Storage   Storage   `json:"storage"`
-	Web       Web       `json:"web"`
-	Telemetry Telemetry `json:"telemetry"`
-	OAuth2    OAuth2    `json:"oauth2"`
-	GRPC      GRPC      `json:"grpc"`
-	Expiry    Expiry    `json:"expiry"`
-	Logger    Logger    `json:"logger"`
+	Issuer         string          `json:"issuer"`
+	Storage        Storage         `json:"storage"`
+	Web            Web             `json:"web"`
+	Telemetry      Telemetry       `json:"telemetry"`
+	OAuth2         OAuth2          `json:"oauth2"`
+	GRPC           GRPC            `json:"grpc"`
+	Expiry         Expiry          `json:"expiry"`
+	PasswordPolicy *PasswordPolicy `json:"passwordPolicy"`
+	Logger         Logger          `json:"logger"`
 
 	Frontend server.WebConfig `json:"frontend"`
 
@@ -486,3 +490,74 @@ type TOTP struct {
 	// Connectors is a list of connectors that will use TOTP.
 	Connectors []string `json:"connectors"`
 }
+
+// PasswordPolicy Defines security requirements for user passwords within the system.
+// This policy enforces password complexity rules, expiration intervals and rotation period.
+type PasswordPolicy struct {
+	ID              string  `json:"id"`
+	ComplexityLevel *string `json:"complexityLevel,omitempty"`
+	Lockout         *struct {
+		MaxAttempts  uint64        `json:"maxAttempts"`
+		LockDuration time.Duration `json:"lockDuration"`
+	} `json:"lockout,omitempty"`
+	Rotation *struct {
+		Interval    time.Duration `json:"interval"`
+		RedirectURL *string       `json:"redirectURL,omitempty"`
+	} `json:"rotation,omitempty"`
+	PasswordHistoryLimit uint64 `json:"passwordHistoryLimit"`
+}
+
+func (p *PasswordPolicy) UnmarshalJSON(data []byte) error {
+	type Alias PasswordPolicy
+	aux := &struct {
+		Lockout *struct {
+			MaxAttempts uint64 `json:"maxAttempts"`
+			DurationStr string `json:"lockDuration"`
+		} `json:"lockout,omitempty"`
+		Rotation *struct {
+			IntervalStr string  `json:"interval"`
+			RedirectURL *string `json:"redirectURL,omitempty"`
+		} `json:"rotation,omitempty"`
+		*Alias
+	}{
+		Alias: (*Alias)(p),
+	}
+
+	if err := json.Unmarshal(data, &aux); err != nil {
+		return err
+	}
+
+	// Parse lockout duration
+	if aux.Lockout != nil {
+		duration, err := pkgtime.ParseDuration(aux.Lockout.DurationStr)
+		if err != nil {
+			return fmt.Errorf("invalid lockout duration: %w", err)
+		}
+		if p.Lockout == nil {
+			p.Lockout = &struct {
+				MaxAttempts  uint64        `json:"maxAttempts"`
+				LockDuration time.Duration `json:"lockDuration"`
+			}{}
+		}
+		p.Lockout.MaxAttempts = aux.Lockout.MaxAttempts
+		p.Lockout.LockDuration = duration
+	}
+
+	// Parse rotation interval
+	if aux.Rotation != nil {
+		interval, err := pkgtime.ParseDuration(aux.Rotation.IntervalStr)
+		if err != nil {
+			return fmt.Errorf("invalid rotation interval: %w", err)
+		}
+		if p.Rotation == nil {
+			p.Rotation = &struct {
+				Interval    time.Duration `json:"interval"`
+				RedirectURL *string       `json:"redirectURL,omitempty"`
+			}{}
+		}
+		p.Rotation.Interval = interval
+		p.Rotation.RedirectURL = aux.Rotation.RedirectURL
+	}
+
+	return nil
+}
diff --git a/cmd/dex/serve.go b/cmd/dex/serve.go
index a29ca72e..4e5d3cfb 100644
--- a/cmd/dex/serve.go
+++ b/cmd/dex/serve.go
@@ -354,6 +354,32 @@ func runServe(options serveOptions) error {
 
 	serverConfig.RefreshTokenPolicy = refreshTokenPolicy
 
+	if c.PasswordPolicy != nil {
+		var opts []server.PasswordPolicyOption
+		if c.PasswordPolicy.ComplexityLevel != nil {
+			opts = append(opts, server.WithComplexityLevel(*c.PasswordPolicy.ComplexityLevel))
+		}
+		if c.PasswordPolicy.Lockout != nil {
+			opts = append(opts, server.WithLockoutSettings(
+				c.PasswordPolicy.Lockout.MaxAttempts, c.PasswordPolicy.Lockout.LockDuration,
+			))
+		}
+		if c.PasswordPolicy.Rotation != nil {
+			opts = append(opts, server.WithRotationSettings(
+				c.PasswordPolicy.Rotation.Interval, c.PasswordPolicy.Rotation.RedirectURL,
+			))
+		}
+
+		opts = append(opts, server.WithPasswordHistoryLimit(c.PasswordPolicy.PasswordHistoryLimit))
+
+		passwordPolicy, err := server.NewPasswordPolicy(c.PasswordPolicy.ID, opts...)
+		if err != nil {
+			return fmt.Errorf("invalid password policy config: %v", err)
+		}
+
+		serverConfig.PasswordPolicy = passwordPolicy
+	}
+
 	serverConfig.RealIPHeader = c.Web.ClientRemoteIP.Header
 	serverConfig.TrustedRealIPCIDRs, err = c.Web.ClientRemoteIP.ParseTrustedProxies()
 	if err != nil {
diff --git a/examples/config-dev.yaml b/examples/config-dev.yaml
index 147597a2..741419f0 100644
--- a/examples/config-dev.yaml
+++ b/examples/config-dev.yaml
@@ -77,8 +77,8 @@ telemetry:
 
 # Uncomment this block to enable the gRPC API. This values MUST be different
 # from the HTTP endpoints.
-# grpc:
-#   addr: 127.0.0.1:5557
+grpc:
+  addr: 127.0.0.1:5557
 #   tlsCert: examples/grpc-client/server.crt
 #   tlsKey: examples/grpc-client/server.key
 #   tlsClientCA: examples/grpc-client/ca.crt
@@ -155,6 +155,15 @@ connectors:
 # Let dex keep a list of passwords which can be used to login to dex.
 enablePasswordDB: true
 
+passwordPolicy:
+  id: hello-kitty
+  complexityLevel: low
+  lockout:
+    maxAttempts: 3
+    lockDuration: "1d2h3s"
+  rotation:
+    interval: "1s"
+
 # A static list of passwords to login the end user. By identifying here, dex
 # won't look in its underlying storage for passwords.
 #
diff --git a/pkg/time/parseduration.go b/pkg/time/parseduration.go
new file mode 100644
index 00000000..49280860
--- /dev/null
+++ b/pkg/time/parseduration.go
@@ -0,0 +1,225 @@
+// Based on time.ParseDuration from the Go standard library
+// Original source: https://cs.opensource.google/go/go/+/refs/tags/go1.23.0:src/time/format.go;l=1617
+// Modified to extend duration parsing with day units.
+// Now supports: ns, us, ms, s, m, h, d (days)
+// Example: "1d" = 24h, "2d12h" = 60h
+package config
+
+import (
+	"errors"
+	"time"
+)
+
+// These are borrowed from unicode/utf8 and strconv and replicate behavior in
+// that package, since we can't take a dependency on either.
+const (
+	lowerhex  = "0123456789abcdef"
+	runeSelf  = 0x80
+	runeError = '\uFFFD'
+)
+
+func quote(s string) string {
+	buf := make([]byte, 1, len(s)+2) // slice will be at least len(s) + quotes
+	buf[0] = '"'
+	for i, c := range s {
+		if c >= runeSelf || c < ' ' {
+			// This means you are asking us to parse a time.Duration or
+			// time.Location with unprintable or non-ASCII characters in it.
+			// We don't expect to hit this case very often. We could try to
+			// reproduce strconv.Quote's behavior with full fidelity but
+			// given how rarely we expect to hit these edge cases, speed and
+			// conciseness are better.
+			var width int
+			if c == runeError {
+				width = 1
+				if i+2 < len(s) && s[i:i+3] == string(runeError) {
+					width = 3
+				}
+			} else {
+				width = len(string(c))
+			}
+			for j := 0; j < width; j++ {
+				buf = append(buf, `\x`...)
+				buf = append(buf, lowerhex[s[i+j]>>4])
+				buf = append(buf, lowerhex[s[i+j]&0xF])
+			}
+		} else {
+			if c == '"' || c == '\\' {
+				buf = append(buf, '\\')
+			}
+			buf = append(buf, string(c)...)
+		}
+	}
+	buf = append(buf, '"')
+	return string(buf)
+}
+
+var errLeadingInt = errors.New("time: bad [0-9]*") // never printed
+
+// leadingInt consumes the leading [0-9]* from s.
+func leadingInt[bytes []byte | string](s bytes) (x uint64, rem bytes, err error) {
+	i := 0
+	for ; i < len(s); i++ {
+		c := s[i]
+		if c < '0' || c > '9' {
+			break
+		}
+		if x > 1<<63/10 {
+			// overflow
+			return 0, rem, errLeadingInt
+		}
+		x = x*10 + uint64(c) - '0'
+		if x > 1<<63 {
+			// overflow
+			return 0, rem, errLeadingInt
+		}
+	}
+	return x, s[i:], nil
+}
+
+// leadingFraction consumes the leading [0-9]* from s.
+// It is used only for fractions, so does not return an error on overflow,
+// it just stops accumulating precision.
+func leadingFraction(s string) (x uint64, scale float64, rem string) {
+	i := 0
+	scale = 1
+	overflow := false
+	for ; i < len(s); i++ {
+		c := s[i]
+		if c < '0' || c > '9' {
+			break
+		}
+		if overflow {
+			continue
+		}
+		if x > (1<<63-1)/10 {
+			// It's possible for overflow to give a positive number, so take care.
+			overflow = true
+			continue
+		}
+		y := x*10 + uint64(c) - '0'
+		if y > 1<<63 {
+			overflow = true
+			continue
+		}
+		x = y
+		scale *= 10
+	}
+	return x, scale, s[i:]
+}
+
+var unitMap = map[string]uint64{
+	"ns": uint64(time.Nanosecond),
+	"us": uint64(time.Microsecond),
+	"µs": uint64(time.Microsecond), // U+00B5 = micro symbol
+	"μs": uint64(time.Microsecond), // U+03BC = Greek letter mu
+	"ms": uint64(time.Millisecond),
+	"s":  uint64(time.Second),
+	"m":  uint64(time.Minute),
+	"h":  uint64(time.Hour),
+	"d":  uint64(time.Hour * 24),
+}
+
+// ParseDuration parses a duration string.
+// A duration string is a possibly signed sequence of
+// decimal numbers, each with optional fraction and a unit suffix,
+// such as "300ms", "-1.5h" or "2h45m".
+// Valid time units are "ns", "us" (or "µs"), "ms", "s", "m", "h".
+func ParseDuration(s string) (time.Duration, error) {
+	// [-+]?([0-9]*(\.[0-9]*)?[a-z]+)+
+	orig := s
+	var d uint64
+	neg := false
+
+	// Consume [-+]?
+	if s != "" {
+		c := s[0]
+		if c == '-' || c == '+' {
+			neg = c == '-'
+			s = s[1:]
+		}
+	}
+	// Special case: if all that is left is "0", this is zero.
+	if s == "0" {
+		return 0, nil
+	}
+	if s == "" {
+		return 0, errors.New("time: invalid duration " + quote(orig))
+	}
+	for s != "" {
+		var (
+			v, f  uint64      // integers before, after decimal point
+			scale float64 = 1 // value = v + f/scale
+		)
+
+		var err error
+
+		// The next character must be [0-9.]
+		if !(s[0] == '.' || '0' <= s[0] && s[0] <= '9') {
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+		// Consume [0-9]*
+		pl := len(s)
+		v, s, err = leadingInt(s)
+		if err != nil {
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+		pre := pl != len(s) // whether we consumed anything before a period
+
+		// Consume (\.[0-9]*)?
+		post := false
+		if s != "" && s[0] == '.' {
+			s = s[1:]
+			pl := len(s)
+			f, scale, s = leadingFraction(s)
+			post = pl != len(s)
+		}
+		if !pre && !post {
+			// no digits (e.g. ".s" or "-.s")
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+
+		// Consume unit.
+		i := 0
+		for ; i < len(s); i++ {
+			c := s[i]
+			if c == '.' || '0' <= c && c <= '9' {
+				break
+			}
+		}
+		if i == 0 {
+			return 0, errors.New("time: missing unit in duration " + quote(orig))
+		}
+		u := s[:i]
+		s = s[i:]
+		unit, ok := unitMap[u]
+		if !ok {
+			return 0, errors.New("time: unknown unit " + quote(u) + " in duration " + quote(orig))
+		}
+		if v > 1<<63/unit {
+			// overflow
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+		v *= unit
+		if f > 0 {
+			// float64 is needed to be nanosecond accurate for fractions of hours.
+			// v >= 0 && (f*unit/scale) <= 3.6e+12 (ns/h, h is the largest unit)
+			v += uint64(float64(f) * (float64(unit) / scale))
+			if v > 1<<63 {
+				// overflow
+				return 0, errors.New("time: invalid duration " + quote(orig))
+			}
+		}
+		d += v
+		if d > 1<<63 {
+			return 0, errors.New("time: invalid duration " + quote(orig))
+		}
+	}
+	if neg {
+		return -time.Duration(d), nil
+	}
+	if d > 1<<63-1 {
+		return 0, errors.New("time: invalid duration " + quote(orig))
+	}
+	return time.Duration(d), nil
+}
diff --git a/server/handlers.go b/server/handlers.go
index 17688448..5ba3cf8e 100644
--- a/server/handlers.go
+++ b/server/handlers.go
@@ -373,6 +373,39 @@ func (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {
 		password := r.FormValue("password")
 		scopes := parseScopes(authReq.Scopes)
 
+		var localConnector bool
+		_, ok := pwConn.(passwordDB)
+		if ok {
+			localConnector = true
+		}
+
+		var p storage.Password
+		var passwordFound bool
+		// Fetch local password in case of local connector for the further password policies validation
+		if localConnector && s.passwordPolicy != nil {
+			p, err = s.storage.GetPassword(ctx, username)
+			if err != nil {
+				if err != storage.ErrNotFound {
+					s.logger.ErrorContext(r.Context(), "failed to get password", "err", err)
+					s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+					return
+				}
+				// User not found - will be handled as invalid credentials by pwConn.Login
+			} else {
+				passwordFound = true
+				if s.passwordPolicy.IsPasswordLocked(p) {
+					s.logger.WarnContext(r.Context(),
+						"login attempt for locked account",
+						"username", username,
+						"locked_until", p.LockedUntil,
+					)
+					// TODO: maybe need to render error field in the login page (like incorrect pass error)
+					s.renderError(r, w, http.StatusTooManyRequests, "Account temporarily locked")
+					return
+				}
+			}
+		}
+
 		identity, ok, err := pwConn.Login(r.Context(), scopes, username, password)
 		if err != nil {
 			s.logger.ErrorContext(r.Context(), "failed to login user", "err", err)
@@ -380,12 +413,69 @@ func (s *Server) handlePasswordLogin(w http.ResponseWriter, r *http.Request) {
 			return
 		}
 		if !ok {
+			// Validate login incorrect attempts for local connector with configured password policy
+			// Only apply lockout logic for existing users (passwordFound == true)
+			if localConnector && s.passwordPolicy != nil && passwordFound && s.passwordPolicy.IsMaxLoginAttemptsExeeded(p.IncorrectPasswordLoginAttempts+1) {
+				lockedUntil := time.Now().Add(s.passwordPolicy.lockout.lockDuration)
+				updader := func(p storage.Password) (storage.Password, error) {
+					p.LockedUntil = &lockedUntil
+					p.IncorrectPasswordLoginAttempts = 0
+					return p, nil
+				}
+
+				// Update locked status in storage
+				if err := s.storage.UpdatePassword(ctx, username, updader); err != nil {
+					s.logger.ErrorContext(r.Context(),
+						"failed to lock account",
+						"username", username,
+						"error", err,
+					)
+				}
+
+				s.logger.WarnContext(r.Context(),
+					"account locked due to too many failed attempts",
+					"username", username,
+					"attempts", p.IncorrectPasswordLoginAttempts+1,
+					"locked_until", lockedUntil,
+				)
+				s.renderError(r, w, http.StatusTooManyRequests, "Account temporarily locked")
+				return
+			}
+
 			if err := s.templates.password(r, w, r.URL.String(), username, usernamePrompt(pwConn), true, backLink); err != nil {
 				s.logger.ErrorContext(r.Context(), "server template error", "err", err)
 			}
 			s.logger.ErrorContext(r.Context(), "failed login attempt: Invalid credentials.", "user", username)
 			return
 		}
+
+		if localConnector && s.passwordPolicy != nil {
+			// Validate password complexity with configured password policy
+			if GetPasswordComplexity(password).level < s.passwordPolicy.complexity.level {
+				redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), complexityPolicyReason)
+				if err != nil {
+					s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
+					s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+					return
+				}
+				http.Redirect(w, r, redirectURL, http.StatusSeeOther)
+				s.logger.InfoContext(r.Context(), "user was forced to change password due to password complexity policy settings", "user", username)
+			}
+
+			// Validate password expiry with configured password policy
+			if s.passwordPolicy.IsPasswordExpired(p.HashUpdatedAt) {
+				redirectURL, err := buildPasswordChangeURI(s.issuerURL.String(), username, r.URL.String(), rotationPolicyReason)
+				if err != nil {
+					s.logger.ErrorContext(r.Context(), "cannot build password change redirect URL", "err", err)
+					s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+					return
+				}
+				http.Redirect(w, r, redirectURL, http.StatusSeeOther)
+				s.logger.InfoContext(r.Context(), "user was forced to change password due to password rotation policy settings", "user", username)
+				return
+			}
+		}
+
 		redirectURL, canSkipApproval, err := s.finalizeLogin(r.Context(), identity, authReq, conn.Connector)
 		if err != nil {
 			s.logger.ErrorContext(r.Context(), "failed to finalize login", "err", err)
diff --git a/server/handlers_test.go b/server/handlers_test.go
index 114712ba..00d7f2d8 100644
--- a/server/handlers_test.go
+++ b/server/handlers_test.go
@@ -555,6 +555,61 @@ func TestHandlePasswordLoginWithSkipApproval(t *testing.T) {
 	}
 }
 
+func TestHandlePasswordLoginWithPasswordPolicyNonExistingUser(t *testing.T) {
+	ctx := t.Context()
+
+	connID := "local"
+	authReqID := "test"
+	expiry := time.Now().Add(100 * time.Second)
+	resTypes := []string{responseTypeCode}
+
+	// Create a password policy
+	passwordPolicy, err := NewPasswordPolicy("test-policy", WithComplexityLevel("low"))
+	require.NoError(t, err)
+
+	httpServer, s := newTestServer(t, func(c *Config) {
+		c.SkipApprovalScreen = true
+		c.Now = time.Now
+		c.PasswordPolicy = passwordPolicy
+	})
+	defer httpServer.Close()
+
+	// Create a local connector
+	sc := storage.Connector{
+		ID:              connID,
+		Type:            "local",
+		Name:            "Local",
+		ResourceVersion: "1",
+	}
+	if err := s.storage.CreateConnector(ctx, sc); err != nil {
+		t.Fatalf("create connector: %v", err)
+	}
+	if _, err := s.OpenConnector(sc); err != nil {
+		t.Fatalf("open connector: %v", err)
+	}
+
+	authReq := storage.AuthRequest{
+		ID:                  authReqID,
+		ConnectorID:         connID,
+		RedirectURI:         "cb",
+		Expiry:              expiry,
+		ResponseTypes:       resTypes,
+		ForceApprovalPrompt: false,
+	}
+	if err := s.storage.CreateAuthRequest(ctx, authReq); err != nil {
+		t.Fatalf("failed to create AuthRequest: %v", err)
+	}
+
+	rr := httptest.NewRecorder()
+
+	// Login with non-existing user - should NOT return 500
+	path := fmt.Sprintf("/auth/%s/login?state=%s&back=&login=nonexistent@example.com&password=somepassword", connID, authReqID)
+	s.handlePasswordLogin(rr, httptest.NewRequest("POST", path, nil))
+
+	// Should return 401 (invalid credentials form), not 500
+	require.Equal(t, http.StatusUnauthorized, rr.Code, "expected 401 for non-existing user, got %d", rr.Code)
+}
+
 func TestHandleConnectorCallbackWithSkipApproval(t *testing.T) {
 	ctx := t.Context()
 
diff --git a/server/passwordchangehandler.go b/server/passwordchangehandler.go
new file mode 100644
index 00000000..3614bd18
--- /dev/null
+++ b/server/passwordchangehandler.go
@@ -0,0 +1,173 @@
+package server
+
+import (
+	"errors"
+	"fmt"
+	"net/http"
+	"net/url"
+	"strings"
+	"time"
+
+	"github.com/dexidp/dex/storage"
+	"golang.org/x/crypto/bcrypt"
+)
+
+const passwordChangeURI = "/password/change"
+
+func buildPasswordChangeURI(issuerUrl, username, backURI string, changeReason passwordChangeReason) (string, error) {
+	retUrl, err := url.JoinPath(issuerUrl, passwordChangeURI)
+	if err != nil {
+		return "", err
+	}
+
+	return fmt.Sprintf(
+		"%s?username=%s&back=%s&changeReason=%s",
+		retUrl, url.QueryEscape(username), url.QueryEscape(backURI), changeReason,
+	), nil
+}
+
+func (s *Server) handlePasswordChange(w http.ResponseWriter, r *http.Request) {
+	ctx := r.Context()
+	err := r.ParseForm()
+	if err != nil {
+		s.logger.ErrorContext(ctx, "form parse error", "error", err)
+		s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+		return
+	}
+
+	username := r.Form.Get("username")
+	currentPassword := r.Form.Get("currentPassword")
+	newPassword := r.Form.Get("newPassword")
+	changeReason := r.Form.Get("changeReason")
+	backURL := r.Form.Get("back")
+	if backURL == "" {
+		backURL = s.issuerURL.String()
+	}
+
+	var passwordHint string
+	if s.passwordPolicy != nil {
+		passwordHint = s.passwordPolicy.complexity.UserPrompt()
+	}
+
+	switch r.Method {
+	case http.MethodGet:
+		if err := s.templates.passwordChange(r, w, passwordChangeParams{
+			Username:        username,
+			NewPasswordHint: passwordHint,
+			ChangeReason:    passwordChangeReason(changeReason),
+			IssuerURL:       s.issuerURL.String(),
+		}); err != nil {
+			s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+		}
+		return
+	case http.MethodPost:
+		if currentPassword == newPassword {
+			if err := s.templates.passwordChange(r, w, passwordChangeParams{
+				Username:        username,
+				NewPasswordHint: passwordHint,
+				IssuerURL:       s.issuerURL.String(),
+				ChangeReason:    passwordChangeReason(changeReason),
+				Err:             ErrOldAndNewPassAreEq,
+			}); err != nil {
+				s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+			}
+			return
+		}
+
+		if strings.Contains(newPassword, " ") {
+			if err := s.templates.passwordChange(r, w, passwordChangeParams{
+				Username:        username,
+				NewPasswordHint: passwordHint,
+				IssuerURL:       s.issuerURL.String(),
+				ChangeReason:    passwordChangeReason(changeReason),
+				Err:             ErrNewPasswordContainsForbiddenChar,
+			}); err != nil {
+				s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+			}
+		}
+
+		if s.passwordPolicy != nil {
+			if err := s.passwordPolicy.complexity.Validate(newPassword); err != nil {
+				if err := s.templates.passwordChange(r, w, passwordChangeParams{
+					Username:        username,
+					NewPasswordHint: passwordHint,
+					IssuerURL:       s.issuerURL.String(),
+					ChangeReason:    passwordChangeReason(changeReason),
+					Err:             errors.Join(ErrPasswordTooWeak, err),
+				}); err != nil {
+					s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+				}
+				return
+			}
+		}
+
+		p, err := s.storage.GetPassword(ctx, username)
+		if err != nil {
+			s.logger.ErrorContext(r.Context(), "failed to get password", "username", username, "err", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		if err := checkCost(p.Hash); err != nil {
+			s.logger.ErrorContext(r.Context(), "checkCost failed", "username", username, "err", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		if err := bcrypt.CompareHashAndPassword(p.Hash, []byte(currentPassword)); err != nil {
+			if err := s.templates.passwordChange(r, w, passwordChangeParams{
+				Username:        username,
+				NewPasswordHint: passwordHint,
+				IssuerURL:       s.issuerURL.String(),
+				ChangeReason:    passwordChangeReason(changeReason),
+				Err:             ErrCurrentPasswordInvalid,
+			}); err != nil {
+				s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+			}
+			return
+		}
+
+		hash, err := bcrypt.GenerateFromPassword([]byte(newPassword), 10)
+		if err != nil {
+			s.logger.ErrorContext(ctx, "bcrypt.GenerateFromPassword", "username", username, "error", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		for _, el := range p.PreviousHashes {
+			if err := bcrypt.CompareHashAndPassword(el, []byte(newPassword)); err == nil {
+				if err := s.templates.passwordChange(r, w, passwordChangeParams{
+					Username:        username,
+					NewPasswordHint: passwordHint,
+					IssuerURL:       s.issuerURL.String(),
+					ChangeReason:    passwordChangeReason(changeReason),
+					Err:             ErrReusedPassword,
+				}); err != nil {
+					s.logger.ErrorContext(r.Context(), "server template error", "err", err)
+				}
+				return
+			}
+		}
+
+		updater := func(p storage.Password) (storage.Password, error) {
+			p.PreviousHashes = append(p.PreviousHashes, p.Hash)
+			if len(p.PreviousHashes) > int(s.passwordPolicy.passwordHistoryLimit) {
+				p.PreviousHashes = p.PreviousHashes[1:]
+			}
+			p.HashUpdatedAt = time.Now()
+			p.Hash = hash
+			return p, nil
+		}
+		if err := s.storage.UpdatePassword(ctx, username, updater); err != nil {
+			s.logger.ErrorContext(r.Context(), "failed to update password", "username", username, "err", err)
+			s.renderError(r, w, http.StatusInternalServerError, "Login error.")
+			return
+		}
+
+		s.logger.InfoContext(r.Context(), "password changed successfully", "username", username)
+
+		http.Redirect(w, r, backURL, http.StatusSeeOther)
+	default:
+		s.renderError(r, w, http.StatusBadRequest, "Method not supported")
+	}
+}
diff --git a/server/passwordpolicy.go b/server/passwordpolicy.go
new file mode 100644
index 00000000..ea87beb5
--- /dev/null
+++ b/server/passwordpolicy.go
@@ -0,0 +1,352 @@
+package server
+
+import (
+	"errors"
+	"fmt"
+	"strings"
+	"time"
+	"unicode"
+
+	"github.com/dexidp/dex/storage"
+)
+
+type PasswordPolicyOption func(*PasswordPolicy) error
+
+type complexityLevel int
+
+const (
+	levelNone complexityLevel = iota
+	levelLow
+	levelFair
+	levelGood
+	levelExcellent
+)
+
+func (cl complexityLevel) String() string {
+	switch cl {
+	case levelNone:
+		return "none"
+	case levelLow:
+		return "low"
+	case levelFair:
+		return "fair"
+	case levelGood:
+		return "good"
+	case levelExcellent:
+		return "excellent"
+	default:
+		return "unknown"
+	}
+}
+
+type Complexity struct {
+	level      complexityLevel
+	userPrompt string
+}
+
+func (cl Complexity) UserPrompt() string {
+	return cl.userPrompt
+}
+
+var (
+	ComplexityNone = Complexity{levelNone, ""}
+	ComplexityLow  = Complexity{levelLow, "Password must contain:\n" +
+		"• At least 8 characters"}
+	ComplexityFair = Complexity{levelFair, "Password must contain:\n" +
+		"• At least 8 characters\n" +
+		"• Upper and lowercase letters\n" +
+		"• At least one number"}
+	ComplexityGood = Complexity{levelGood, "Password must contain:\n" +
+		"• At least 8 characters\n" +
+		"• Upper and lowercase letters\n" +
+		"• At least one number\n" +
+		"• Special characters (!@#$%^&* etc.)"}
+	ComplexityExcellent = Complexity{levelExcellent, "Password must contain:\n" +
+		"• At least 8 characters\n" +
+		"• Upper and lowercase letters\n" +
+		"• At least one number\n" +
+		"• Special characters (!@#$%^&* etc.)\n" +
+		"• No more than 2 identical characters in a row"}
+)
+
+func (cl Complexity) Validate(password string) error {
+	switch cl.level {
+	case levelNone:
+		return nil
+	case levelLow:
+		return validateComplexityLow(password)
+	case levelFair:
+		return validateComplexityFair(password)
+	case levelGood:
+		return validateComplexityGood(password)
+	case levelExcellent:
+		return validateComplexityExcellent(password)
+	default:
+		return errors.New("unknown password policy level")
+	}
+}
+
+func GetPasswordComplexity(password string) Complexity {
+	if err := validateComplexityExcellent(password); err == nil {
+		return ComplexityExcellent
+	}
+	if err := validateComplexityGood(password); err == nil {
+		return ComplexityGood
+	}
+	if err := validateComplexityFair(password); err == nil {
+		return ComplexityFair
+	}
+	if err := validateComplexityLow(password); err == nil {
+		return ComplexityLow
+	}
+	return ComplexityNone
+}
+
+func validateComplexityExcellent(password string) error {
+	if len(password) < 8 {
+		return errors.New("minimum 8 characters required")
+	}
+	var hasLower, hasUpper, hasNumber, hasSpecial bool
+	var previousLetter rune
+	runLen := 0
+
+	for _, c := range password {
+		if c == previousLetter {
+			runLen++
+		} else {
+			runLen = 1
+			previousLetter = c
+		}
+		if runLen >= 3 {
+			return errors.New("password contains 3 or more identical characters in a row")
+		}
+
+		switch {
+		case unicode.IsLower(c):
+			hasLower = true
+		case unicode.IsUpper(c):
+			hasUpper = true
+		case unicode.IsNumber(c):
+			hasNumber = true
+		case !unicode.IsLetter(c) && !unicode.IsNumber(c):
+			hasSpecial = true
+		}
+	}
+	if !hasLower {
+		return errors.New("at least one lowercase letter required")
+	}
+	if !hasUpper {
+		return errors.New("at least one uppercase letter required")
+	}
+	if !hasNumber {
+		return errors.New("at least one number required")
+	}
+	if !hasSpecial {
+		return errors.New("at least one special character (!@#$ etc.) required")
+	}
+	return nil
+}
+
+func validateComplexityGood(password string) error {
+	if len(password) < 8 {
+		return errors.New("minimum 8 characters required")
+	}
+	var hasLower, hasUpper, hasNumber, hasSpecial bool
+	for _, c := range password {
+		switch {
+		case unicode.IsLower(c):
+			hasLower = true
+		case unicode.IsUpper(c):
+			hasUpper = true
+		case unicode.IsNumber(c):
+			hasNumber = true
+		case !unicode.IsLetter(c) && !unicode.IsNumber(c):
+			hasSpecial = true
+		}
+	}
+	if !hasLower {
+		return errors.New("at least one lowercase letter required")
+	}
+	if !hasUpper {
+		return errors.New("at least one uppercase letter required")
+	}
+	if !hasNumber {
+		return errors.New("at least one number required")
+	}
+	if !hasSpecial {
+		return errors.New("at least one special character (!@#$ etc.) required")
+	}
+	return nil
+}
+
+func validateComplexityFair(password string) error {
+	if len(password) < 8 {
+		return errors.New("minimum 8 characters required")
+	}
+	var hasLower, hasUpper, hasNumber bool
+	for _, c := range password {
+		switch {
+		case unicode.IsLower(c):
+			hasLower = true
+		case unicode.IsUpper(c):
+			hasUpper = true
+		case unicode.IsNumber(c):
+			hasNumber = true
+		}
+	}
+	if !hasLower {
+		return errors.New("at least one lowercase letter required")
+	}
+	if !hasUpper {
+		return errors.New("at least one uppercase letter required")
+	}
+	if !hasNumber {
+		return errors.New("at least one number required")
+	}
+	return nil
+}
+
+func validateComplexityLow(password string) error {
+	if len(password) < 8 {
+		return errors.New("minimum 8 characters required")
+	}
+	return nil
+}
+
+func GetComplexity(level string) (Complexity, error) {
+	switch strings.ToLower(level) {
+	case levelNone.String(), "":
+		return ComplexityNone, nil
+	case levelLow.String():
+		return ComplexityLow, nil
+	case levelFair.String():
+		return ComplexityFair, nil
+	case levelGood.String():
+		return ComplexityGood, nil
+	case levelExcellent.String():
+		return ComplexityExcellent, nil
+	default:
+		return Complexity{}, fmt.Errorf("unknown password complexity level: %s", level)
+	}
+}
+
+func WithComplexityLevel(complexityLevel string) PasswordPolicyOption {
+	return func(pp *PasswordPolicy) error {
+		cl, err := GetComplexity(complexityLevel)
+		if err != nil {
+			return err
+		}
+		pp.complexity = cl
+		return nil
+	}
+}
+
+type LockoutSettings struct {
+	maxAttempts  uint64
+	lockDuration time.Duration
+}
+
+func WithLockoutSettings(maxAttempts uint64, lockDuration time.Duration) PasswordPolicyOption {
+	return func(pp *PasswordPolicy) error {
+		pp.lockout = &LockoutSettings{
+			maxAttempts:  maxAttempts,
+			lockDuration: lockDuration,
+		}
+		return nil
+	}
+}
+
+type RotationSettings struct {
+	passwordRotationInterval time.Duration
+	redirectURL              *string
+}
+
+func WithRotationSettings(rotationInterval time.Duration, redirectURL *string) PasswordPolicyOption {
+	return func(pp *PasswordPolicy) error {
+		pp.rotation = &RotationSettings{
+			passwordRotationInterval: rotationInterval,
+			redirectURL:              redirectURL,
+		}
+		return nil
+	}
+}
+
+func WithPasswordHistoryLimit(passwordHistoryLimit uint64) PasswordPolicyOption {
+	return func(pp *PasswordPolicy) error {
+		pp.passwordHistoryLimit = passwordHistoryLimit
+		return nil
+	}
+}
+
+type PasswordPolicy struct {
+	id string
+	// complexityLevel Sets password complexity requirements
+	// Possible values:
+	//   - None:      No restrictions. Password can be any length starting from 1 character.
+	//   - Low:       Minimum 8 characters.
+	//   - Fair:      (Default) Minimum 8 characters, at least:
+	//                • One uppercase letter
+	//                • One lowercase letter
+	//                • One digit
+	//   - Good:      Minimum 8 characters, at least:
+	//                • One uppercase letter
+	//                • One lowercase letter
+	//                • One digit
+	//                • One special character (!@#$%^&* etc.)
+	//   - Excellent: Minimum 8 characters, at least:
+	//                • One uppercase letter
+	//                • One lowercase letter
+	//                • One digit
+	//                • One special character (!@#$%^&* etc.)
+	//                • No more than 2 identical characters in a row
+	complexity Complexity
+	// passwordHistoryLimit Sets count of stored passwords.
+	// Prevents user from reuse old passwords.
+	passwordHistoryLimit uint64
+	// lockout Settings that define restrictions and conditions for account lockout after failed login attempts.
+	lockout *LockoutSettings
+	// rotation Settings defines rule for periodic credential rotation.
+	rotation *RotationSettings
+}
+
+func (pp PasswordPolicy) IsPasswordLocked(p storage.Password) bool {
+	if pp.lockout != nil && p.LockedUntil != nil && p.LockedUntil.After(time.Now()) {
+		return true
+	}
+	return false
+}
+
+func (pp PasswordPolicy) IsMaxLoginAttemptsExeeded(attempts uint64) bool {
+	if pp.lockout != nil && pp.lockout.maxAttempts <= attempts {
+		return true
+	}
+	return false
+}
+
+func (pp PasswordPolicy) IsPasswordExpired(passwordUpdatedAt time.Time) bool {
+	if pp.rotation == nil {
+		return false
+	}
+
+	passwordExpirationDate := passwordUpdatedAt.Add(pp.rotation.passwordRotationInterval)
+
+	return passwordExpirationDate.Before(time.Now())
+}
+
+func NewPasswordPolicy(id string, options ...PasswordPolicyOption) (*PasswordPolicy, error) {
+	if id == "" {
+		return nil, fmt.Errorf("password policy id cannot be empty")
+	}
+	pp := &PasswordPolicy{
+		id:         id,
+		complexity: ComplexityFair,
+	}
+
+	for _, opt := range options {
+		if err := opt(pp); err != nil {
+			return nil, err
+		}
+	}
+
+	return pp, nil
+}
diff --git a/server/server.go b/server/server.go
index 97450af1..d463fd50 100644
--- a/server/server.go
+++ b/server/server.go
@@ -104,6 +104,9 @@ type Config struct {
 	// Refresh token expiration settings
 	RefreshTokenPolicy *RefreshTokenPolicy
 
+	// Password policy settings
+	PasswordPolicy *PasswordPolicy
+
 	// If set, the server will use this connector to handle password grants
 	PasswordConnector string
 
@@ -201,6 +204,7 @@ type Server struct {
 	deviceRequestsValidFor time.Duration
 
 	refreshTokenPolicy *RefreshTokenPolicy
+	passwordPolicy     *PasswordPolicy
 
 	logger *slog.Logger
 
@@ -315,6 +319,7 @@ func newServer(ctx context.Context, c Config, rotationStrategy rotationStrategy)
 		authRequestsValidFor:   value(c.AuthRequestsValidFor, 24*time.Hour),
 		deviceRequestsValidFor: value(c.DeviceRequestsValidFor, 5*time.Minute),
 		refreshTokenPolicy:     c.RefreshTokenPolicy,
+		passwordPolicy:         c.PasswordPolicy,
 		skipApproval:           c.SkipApprovalScreen,
 		alwaysShowLogin:        c.AlwaysShowLoginScreen,
 		now:                    now,
@@ -502,6 +507,7 @@ func newServer(ctx context.Context, c Config, rotationStrategy rotationStrategy)
 		}
 		s.handleConnectorCallback(w, r)
 	})
+	handleFunc(passwordChangeURI, s.handlePasswordChange)
 	// For easier connector-specific web server configuration, e.g. for the
 	// "authproxy" connector.
 	handleFunc("/callback/{connector}", s.handleConnectorCallback)
@@ -569,8 +575,20 @@ func (db passwordDB) Login(ctx context.Context, s connector.Scopes, email, passw
 		return connector.Identity{}, false, err
 	}
 	if err := bcrypt.CompareHashAndPassword(p.Hash, []byte(password)); err != nil {
+		if err := db.s.UpdatePassword(ctx, email, func(p storage.Password) (storage.Password, error) {
+			p.IncorrectPasswordLoginAttempts += 1
+			return p, nil
+		}); err != nil {
+			return connector.Identity{}, false, err
+		}
 		return connector.Identity{}, false, nil
 	}
+	if err := db.s.UpdatePassword(ctx, email, func(p storage.Password) (storage.Password, error) {
+		p.IncorrectPasswordLoginAttempts = 0
+		return p, nil
+	}); err != nil {
+		return connector.Identity{}, true, err
+	}
 	return connector.Identity{
 		UserID:        p.UserID,
 		Username:      p.Username,
diff --git a/server/templates.go b/server/templates.go
index 46bca92e..6539f0fb 100644
--- a/server/templates.go
+++ b/server/templates.go
@@ -1,6 +1,7 @@
 package server
 
 import (
+	"errors"
 	"fmt"
 	"html/template"
 	"io"
@@ -15,14 +16,15 @@ import (
 )
 
 const (
-	tmplApproval      = "approval.html"
-	tmplLogin         = "login.html"
-	tmplPassword      = "password.html"
-	tmplOOB           = "oob.html"
-	tmplError         = "error.html"
-	tmplDevice        = "device.html"
-	tmplDeviceSuccess = "device_success.html"
-	tmplTOTPVerify    = "totp_verify.html"
+	tmplApproval       = "approval.html"
+	tmplLogin          = "login.html"
+	tmplPassword       = "password.html"
+	tmplPasswordChange = "password_change.html"
+	tmplOOB            = "oob.html"
+	tmplError          = "error.html"
+	tmplDevice         = "device.html"
+	tmplDeviceSuccess  = "device_success.html"
+	tmplTOTPVerify     = "totp_verify.html"
 )
 
 var requiredTmpls = []string{
@@ -37,14 +39,15 @@ var requiredTmpls = []string{
 }
 
 type templates struct {
-	loginTmpl         *template.Template
-	approvalTmpl      *template.Template
-	passwordTmpl      *template.Template
-	oobTmpl           *template.Template
-	errorTmpl         *template.Template
-	deviceTmpl        *template.Template
-	deviceSuccessTmpl *template.Template
-	tmplTOTPVerify    *template.Template
+	loginTmpl          *template.Template
+	approvalTmpl       *template.Template
+	passwordTmpl       *template.Template
+	passwordChangeTmpl *template.Template
+	oobTmpl            *template.Template
+	errorTmpl          *template.Template
+	deviceTmpl         *template.Template
+	deviceSuccessTmpl  *template.Template
+	tmplTOTPVerify     *template.Template
 }
 
 type webConfig struct {
@@ -165,14 +168,15 @@ func loadTemplates(c webConfig, templatesDir string) (*templates, error) {
 		return nil, fmt.Errorf("missing template(s): %s", missingTmpls)
 	}
 	return &templates{
-		loginTmpl:         tmpls.Lookup(tmplLogin),
-		approvalTmpl:      tmpls.Lookup(tmplApproval),
-		passwordTmpl:      tmpls.Lookup(tmplPassword),
-		oobTmpl:           tmpls.Lookup(tmplOOB),
-		errorTmpl:         tmpls.Lookup(tmplError),
-		deviceTmpl:        tmpls.Lookup(tmplDevice),
-		deviceSuccessTmpl: tmpls.Lookup(tmplDeviceSuccess),
-		tmplTOTPVerify:    tmpls.Lookup(tmplTOTPVerify),
+		loginTmpl:          tmpls.Lookup(tmplLogin),
+		approvalTmpl:       tmpls.Lookup(tmplApproval),
+		passwordTmpl:       tmpls.Lookup(tmplPassword),
+		passwordChangeTmpl: tmpls.Lookup(tmplPasswordChange),
+		oobTmpl:            tmpls.Lookup(tmplOOB),
+		errorTmpl:          tmpls.Lookup(tmplError),
+		deviceTmpl:         tmpls.Lookup(tmplDevice),
+		deviceSuccessTmpl:  tmpls.Lookup(tmplDeviceSuccess),
+		tmplTOTPVerify:     tmpls.Lookup(tmplTOTPVerify),
 	}, nil
 }
 
@@ -325,6 +329,90 @@ func (t *templates) password(r *http.Request, w http.ResponseWriter, postURL, la
 	return renderTemplate(w, t.passwordTmpl, data)
 }
 
+var (
+	ErrReusedPassword                   = errors.New("cannot use one of previous passwords")
+	ErrCurrentPasswordInvalid           = errors.New("current password is invalid")
+	ErrPasswordTooWeak                  = errors.New("")
+	ErrOldAndNewPassAreEq               = errors.New("old and new passwords are equal")
+	ErrNewPasswordContainsForbiddenChar = errors.New("new password contains forbidden character")
+)
+
+type passwordChangeReason string
+
+const (
+	complexityPolicyReason passwordChangeReason = "complexity"
+	rotationPolicyReason   passwordChangeReason = "rotation"
+)
+
+type passwordChangeParams struct {
+	Username        string
+	NewPasswordHint string
+	IssuerURL       string
+	ChangeReason    passwordChangeReason
+
+	Err error
+}
+
+func (t *templates) passwordChange(r *http.Request, w http.ResponseWriter, params passwordChangeParams) error {
+	data := struct {
+		PostURL      string
+		Username     string
+		ChangeReason struct {
+			WeakComplexity bool
+			Rotation       bool
+		}
+		Error struct {
+			Exists bool
+			List   struct {
+				OldAndNewPassAreEqual  bool
+				CurrentPasswordInvalid bool
+				PasswordTooWeak        struct {
+					Exists      bool
+					Description string
+				}
+				ReusedPassword      bool
+				PasswordTooWeakDesc string
+			}
+		}
+		PasswordPolicy struct {
+			ComplexityRequirements string
+		}
+		ReqPath string
+	}{
+		Username: params.Username,
+		ReqPath:  r.URL.String(),
+	}
+
+	switch params.ChangeReason {
+	case complexityPolicyReason:
+		data.ChangeReason.WeakComplexity = true
+	case rotationPolicyReason:
+		data.ChangeReason.Rotation = true
+	}
+
+	data.PasswordPolicy.ComplexityRequirements = params.NewPasswordHint
+
+	if params.Err != nil {
+		data.Error.Exists = true
+
+		if errors.Is(params.Err, ErrCurrentPasswordInvalid) {
+			data.Error.List.CurrentPasswordInvalid = true
+		}
+		if errors.Is(params.Err, ErrPasswordTooWeak) {
+			data.Error.List.PasswordTooWeak.Exists = true
+			data.Error.List.PasswordTooWeak.Description = params.Err.Error()
+		}
+		if errors.Is(params.Err, ErrOldAndNewPassAreEq) {
+			data.Error.List.OldAndNewPassAreEqual = true
+		}
+		if errors.Is(params.Err, ErrReusedPassword) {
+			data.Error.List.ReusedPassword = true
+		}
+	}
+
+	return renderTemplate(w, t.passwordChangeTmpl, data)
+}
+
 func (t *templates) approval(r *http.Request, w http.ResponseWriter, authReqID, username, clientName string, scopes []string) error {
 	accesses := []string{}
 	for _, scope := range scopes {
diff --git a/storage/kubernetes/storage.go b/storage/kubernetes/storage.go
index eae5b7a6..0508321b 100644
--- a/storage/kubernetes/storage.go
+++ b/storage/kubernetes/storage.go
@@ -384,10 +384,14 @@ func (cli *client) ListPasswords(ctx context.Context) (passwords []storage.Passw
 
 	for _, password := range passwordList.Passwords {
 		p := storage.Password{
-			Email:    password.Email,
-			Hash:     password.Hash,
-			Username: password.Username,
-			UserID:   password.UserID,
+			Email:                          password.Email,
+			Hash:                           password.Hash,
+			HashUpdatedAt:                  password.HashUpdatedAt,
+			PreviousHashes:                 password.PreviousHashes,
+			Username:                       password.Username,
+			UserID:                         password.UserID,
+			IncorrectPasswordLoginAttempts: password.IncorrectPasswordLoginAttempts,
+			LockedUntil:                    password.LockedUntil,
 		}
 		passwords = append(passwords, p)
 	}
diff --git a/storage/kubernetes/types.go b/storage/kubernetes/types.go
index c5acc42c..7856996e 100644
--- a/storage/kubernetes/types.go
+++ b/storage/kubernetes/types.go
@@ -442,10 +442,16 @@ type Password struct {
 	// This field is IMMUTABLE. Do not change.
 	Email string `json:"email,omitempty"`
 
-	Hash     []byte   `json:"hash,omitempty"`
-	Username string   `json:"username,omitempty"`
-	UserID   string   `json:"userID,omitempty"`
-	Groups   []string `json:"groups,omitempty"`
+	Hash           []byte    `json:"hash,omitempty"`
+	HashUpdatedAt  time.Time `json:"hashUpdatedAt"`
+	PreviousHashes [][]byte  `json:"previousHashes,omitempty"`
+	Username       string    `json:"username,omitempty"`
+	UserID         string    `json:"userID,omitempty"`
+
+	IncorrectPasswordLoginAttempts uint64     `json:"incorrectPasswordLoginAttempts"`
+	LockedUntil                    *time.Time `json:"lockedUntil"`
+
+	Groups []string `json:"groups,omitempty"`
 }
 
 // PasswordList is a list of Passwords.
@@ -466,21 +472,29 @@ func (cli *client) fromStoragePassword(p storage.Password) Password {
 			Name:      cli.idToName(email),
 			Namespace: cli.namespace,
 		},
-		Email:    email,
-		Hash:     p.Hash,
-		Username: p.Username,
-		UserID:   p.UserID,
-		Groups:   p.Groups,
+		Email:                          email,
+		Hash:                           p.Hash,
+		HashUpdatedAt:                  p.HashUpdatedAt,
+		PreviousHashes:                 p.PreviousHashes,
+		Username:                       p.Username,
+		UserID:                         p.UserID,
+		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
+		LockedUntil:                    p.LockedUntil,
+		Groups:                         p.Groups,
 	}
 }
 
 func toStoragePassword(p Password) storage.Password {
 	return storage.Password{
-		Email:    p.Email,
-		Hash:     p.Hash,
-		Username: p.Username,
-		UserID:   p.UserID,
-		Groups:   p.Groups,
+		Email:                          p.Email,
+		Hash:                           p.Hash,
+		HashUpdatedAt:                  p.HashUpdatedAt,
+		PreviousHashes:                 p.PreviousHashes,
+		Username:                       p.Username,
+		UserID:                         p.UserID,
+		IncorrectPasswordLoginAttempts: p.IncorrectPasswordLoginAttempts,
+		LockedUntil:                    p.LockedUntil,
+		Groups:                         p.Groups,
 	}
 }
 
diff --git a/storage/sql/crud.go b/storage/sql/crud.go
index 64961b5d..84ace050 100644
--- a/storage/sql/crud.go
+++ b/storage/sql/crud.go
@@ -4,6 +4,7 @@ import (
 	"context"
 	"database/sql"
 	"database/sql/driver"
+	"encoding/base64"
 	"encoding/json"
 	"errors"
 	"fmt"
@@ -64,12 +65,23 @@ func (j jsonDecoder) Scan(dest interface{}) error {
 	if dest == nil {
 		return errors.New("nil value")
 	}
-	b, ok := dest.([]byte)
-	if !ok {
-		return fmt.Errorf("expected []byte got %T", dest)
-	}
-	if err := json.Unmarshal(b, &j.i); err != nil {
-		return fmt.Errorf("unmarshal: %v", err)
+
+	switch b := dest.(type) {
+	case []byte:
+		if err := json.Unmarshal(b, &j.i); err != nil {
+			return fmt.Errorf("unmarshal: %v", err)
+		}
+	case string:
+		bb, err := base64.StdEncoding.DecodeString(b)
+		if err != nil {
+			return fmt.Errorf("decodeString: %v", err)
+		}
+
+		if err := json.Unmarshal(bb, &j.i); err != nil {
+			return fmt.Errorf("unmarshal: %v", err)
+		}
+	default:
+		return fmt.Errorf("expected []byte or string got %T", dest)
 	}
 	return nil
 }
@@ -630,10 +642,14 @@ func (c *conn) UpdatePassword(ctx context.Context, email string, updater func(p
 		_, err = tx.Exec(`
 			update password
 			set
-				hash = $1, username = $2, user_id = $3, groups = $4
-			where email = $5;
+				hash = $1, username = $2, user_id = $3, groups = $4,
+				incorrect_password_login_attempts = $5, locked_until = $6, hash_updated_at = $7,
+				previous_hashes = $8
+			where email = $9;
 		`,
-			np.Hash, np.Username, np.UserID, encoder(p.Groups), p.Email,
+			np.Hash, np.Username, np.UserID, encoder(p.Groups),
+			np.IncorrectPasswordLoginAttempts, np.LockedUntil, np.HashUpdatedAt,
+			encoder(np.PreviousHashes), p.Email,
 		)
 		if err != nil {
 			return fmt.Errorf("update password: %v", err)
@@ -649,7 +665,7 @@ func (c *conn) GetPassword(ctx context.Context, email string) (storage.Password,
 func getPassword(ctx context.Context, q querier, email string) (p storage.Password, err error) {
 	return scanPassword(q.QueryRow(`
 		select
-			email, hash, username, user_id, groups
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes
 		from password where email = $1;
 	`, strings.ToLower(email)))
 }
@@ -657,7 +673,7 @@ func getPassword(ctx context.Context, q querier, email string) (p storage.Passwo
 func (c *conn) ListPasswords(ctx context.Context) ([]storage.Password, error) {
 	rows, err := c.Query(`
 		select
-			email, hash, username, user_id, groups
+			email, hash, username, user_id, groups, incorrect_password_login_attempts, locked_until, hash_updated_at, previous_hashes
 		from password;
 	`)
 	if err != nil {
@@ -681,7 +697,9 @@ func (c *conn) ListPasswords(ctx context.Context) ([]storage.Password, error) {
 
 func scanPassword(s scanner) (p storage.Password, err error) {
 	err = s.Scan(
-		&p.Email, &p.Hash, &p.Username, &p.UserID, decoder(&p.Groups),
+		&p.Email, &p.Hash, &p.Username,
+		&p.UserID, decoder(&p.Groups), &p.IncorrectPasswordLoginAttempts, &p.LockedUntil,
+		&p.HashUpdatedAt, decoder(&p.PreviousHashes),
 	)
 	if err != nil {
 		if err == sql.ErrNoRows {
@@ -689,6 +707,7 @@ func scanPassword(s scanner) (p storage.Password, err error) {
 		}
 		return p, fmt.Errorf("select password: %v", err)
 	}
+
 	return p, nil
 }
 
diff --git a/storage/sql/migrate.go b/storage/sql/migrate.go
index 83e9c20d..5d8672bf 100644
--- a/storage/sql/migrate.go
+++ b/storage/sql/migrate.go
@@ -225,6 +225,14 @@ var migrations = []migration{
 			alter table offline_session
 				add column connector_data bytea;
 			`,
+			`
+			alter table offline_session
+				add column totp text;
+			`,
+			`
+			alter table offline_session
+				add column totp_confirmed boolean;
+			`,
 		},
 	},
 	{
@@ -296,6 +304,35 @@ var migrations = []migration{
 			`
 			alter table auth_request
 				add column hmac_key bytea;`,
+			`alter table auth_request
+				add column totp_validated boolean;`,
+		},
+	},
+	{
+		stmts: []string{
+			`alter table password
+				add column incorrect_password_login_attempts int default 0 not null`,
+			`alter table password
+				add column locked_until timestamptz default null`,
+			`alter table password
+				add column hash_updated_at timestamptz default current_timestamp`,
+			`-- DEFAULT 'W10=' - base64 encoded []
+			alter table password
+				add column previous_hashes text default "W10=" not null`,
+			`alter table password
+				add column complexity_level text default "none" not null`,
+		},
+	},
+	{
+		stmts: []string{
+			`alter table password
+				drop column complexity_level`,
+		},
+	},
+	{
+		stmts: []string{
+			`alter table password
+				add column groups bytea`,
 		},
 	},
 }
diff --git a/storage/storage.go b/storage/storage.go
index 783ec7cc..5adce6f2 100644
--- a/storage/storage.go
+++ b/storage/storage.go
@@ -355,7 +355,9 @@ type Password struct {
 	Email string `json:"email"`
 
 	// Bcrypt encoded hash of the password. This package enforces a min cost value of 10
-	Hash []byte `json:"hash"`
+	Hash           []byte    `json:"hash"`
+	PreviousHashes [][]byte  `json:"previousHashes"`
+	HashUpdatedAt  time.Time `json:"hashUpdatedAt"`
 
 	// Bcrypt encoded hash of the password set in environment variable of this name.
 	HashFromEnv string `json:"hashFromEnv"`
@@ -366,6 +368,12 @@ type Password struct {
 	// Randomly generated user ID. This is NOT the primary ID of the Password object.
 	UserID string `json:"userID"`
 
+	// IncorrectPasswordLoginAttempts tracks the number of consecutive failed login attempts
+	IncorrectPasswordLoginAttempts uint64 `json:"incorrectPasswordLoginAttempts"`
+	// LockedUntil indicates timing when user will be able to login next time after lockout
+	// cuz of exceeding login attempts with password policy setting
+	LockedUntil *time.Time `json:"lockedUntil"`
+
 	// Groups assigned to the user
 	Groups []string `json:"groups"`
 }
diff --git a/web/templates/password_change.html b/web/templates/password_change.html
new file mode 100644
index 00000000..1e945371
--- /dev/null
+++ b/web/templates/password_change.html
@@ -0,0 +1,96 @@
+{{ template "header.html" . }}
+
+<div class="theme-panel">
+  <h2 class="theme-heading">Change Password</h2>
+  {{ if .ChangeReason.WeakComplexity }}
+    Initiator: password complexity policy
+  {{ else if .ChangeReason.Rotation }}
+    Initiator: password rotation policy
+  {{ end }}
+  <form method="post" action="{{ .ReqPath }}">
+    <div class="theme-form-row">
+        <div class="theme-form-label">
+            <label for="username">Username</label>
+        </div>
+        <input type="text" id="username" name="username"
+                value="{{ .Username }}" readonly
+                class="theme-form-input theme-form-input-readonly">
+    </div>
+
+    <div class="theme-form-row">
+      <div class="theme-form-label">
+        <label for="currentPassword">Current Password</label>
+      </div>
+      <input tabindex="1" required id="currentPassword" name="currentPassword" type="password"
+             class="theme-form-input" placeholder="current password" {{ if .Error.Exists }} autofocus {{ end }}/>
+    </div>
+
+    <div class="theme-form-row">
+      <div class="theme-form-label">
+        <label for="newPassword">New Password</label>
+      </div>
+      <input tabindex="2" required id="newPassword" name="newPassword" type="password"
+             class="theme-form-input" placeholder="new password"/>
+      {{ if .PasswordPolicy }}
+        <pre class="theme-form-hint">{{ .PasswordPolicy.ComplexityRequirements }}</pre>
+      {{ end }}
+    </div>
+
+    <div class="theme-form-row">
+      <div class="theme-form-label">
+        <label for="confirmPassword">Confirm New Password</label>
+      </div>
+      <input tabindex="3" required id="confirmPassword" name="confirmPassword" type="password"
+             class="theme-form-input" placeholder="confirm new password"/>
+    </div>
+
+    {{ if .Error.Exists }}
+      <div id="password-error" class="dex-error-box">
+        {{ if .Error.List.CurrentPasswordInvalid }}
+          Current password is incorrect
+        {{ else if .Error.List.PasswordTooWeak.Exists }}
+          <pre class="theme-form-hint">Password doesn't meet requirements: {{ .Error.List.PasswordTooWeak.Description }}</pre>
+        {{ else if .Error.List.OldAndNewPassAreEqual }}
+          Current password and new password cannot be equal
+        {{ else if .Error.List.ReusedPassword }}
+          Cannot use one of previous passwords
+        {{ else }}
+          Failed to change password
+        {{ end }}
+      </div>
+    {{ end }}
+
+    <button tabindex="4" id="submit-change" type="submit" class="dex-btn theme-btn--primary">
+      Change Password
+    </button>
+  </form>
+</div>
+
+<script type="text/javascript">
+  document.querySelector('form').addEventListener('submit', function(e) {
+    const submitBtn = document.getElementById('submit-change');
+
+    const urlParams = new URLSearchParams(window.location.search);
+
+    urlParams.forEach((value, key) => {
+        const hiddenInput = document.createElement('input');
+        hiddenInput.type = 'hidden';
+        hiddenInput.name = key;
+        hiddenInput.value = value;
+        this.appendChild(hiddenInput);
+    });
+  });
+
+  // Simple client-side validation
+  document.querySelector('form').addEventListener('submit', function(e) {
+    const newPass = document.getElementById('newPassword').value;
+    const confirmPass = document.getElementById('confirmPassword').value;
+
+    if (newPass !== confirmPass) {
+      e.preventDefault();
+      alert('New passwords do not match');
+    }
+  });
+</script>
+
+{{ template "footer.html" . }}
\ No newline at end of file
diff --git a/web/themes/dark/styles.css b/web/themes/dark/styles.css
index edf30412..28f76280 100644
--- a/web/themes/dark/styles.css
+++ b/web/themes/dark/styles.css
@@ -120,3 +120,9 @@
 .dex-container {
   color: #c8d1d9;
 }
+
+.theme-form-input[readonly] {
+  background-color: #f8f9fa;
+  border-color: #ddd;
+  cursor: not-allowed;
+}
diff --git a/web/themes/light/styles.css b/web/themes/light/styles.css
index 2d920571..ae4552e3 100644
--- a/web/themes/light/styles.css
+++ b/web/themes/light/styles.css
@@ -111,3 +111,9 @@
 .theme-link-back {
   margin-top: 4px;
 }
+
+.theme-form-input[readonly] {
+  background-color: #f8f9fa;
+  border-color: #ddd;
+  cursor: not-allowed;
+}
