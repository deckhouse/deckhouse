#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  cat << EOF
    configVersion: v1
    afterHelm: 10
    kubernetes:
    - name: ngs
      group: main
      keepFullObjectsInMemory: false
      queue: /modules/$(module::name::kebab_case)/update_ngs_statuses
      executeHookOnEvent: ["Added", "Modified"]
      waitForSynchronization: false
      apiVersion: deckhouse.io/v1alpha1
      kind: NodeGroup
      jqFilter: |
        {
          "name": .metadata.name,
          "nodeType": .spec.nodeType,
          "minPerZone": (.spec.cloudInstances.minPerZone // null),
          "maxPerZone": (.spec.cloudInstances.maxPerZone // null),
          "zonesNum": (if (.spec.cloudInstances|has("zones")) then .spec.cloudInstances.zones | length else null end),
          "error": .status.error
        }
    - name: cloud_provider_secrets
      group: main
      keepFullObjectsInMemory: false
      queue: /modules/$(module::name::kebab_case)/update_ngs_statuses
      waitForSynchronization: false
      apiVersion: v1
      kind: Secret
      namespace:
        nameSelector:
          matchNames: [kube-system]
      nameSelector:
        matchNames: [d8-node-manager-cloud-provider]
      jqFilter: |
        {"zonesNum": (try(.data.zones | @base64d | fromjson) // [] | length)}
    - name: configuration_checksums_secret
      group: main
      keepFullObjectsInMemory: false
      queue: /modules/$(module::name::kebab_case)/update_ngs_statuses
      waitForSynchronization: false
      apiVersion: v1
      kind: Secret
      namespace:
        nameSelector:
          matchNames: [d8-cloud-instance-manager]
      nameSelector:
        matchNames: [configuration-checksums]
      jqFilter: (.data // {}) | [to_entries[] | (.value |= (. | @base64d))] | from_entries
    - name: mds
      group: main
      keepFullObjectsInMemory: true
      queue: /modules/$(module::name::kebab_case)/update_ngs_statuses
      executeHookOnEvent: ["Added", "Modified"]
      waitForSynchronization: false
      apiVersion: machine.sapcloud.io/v1alpha1
      kind: MachineDeployment
      namespace:
        nameSelector:
          matchNames: [d8-cloud-instance-manager]
      jqFilter: '{"nodeGroup": .metadata.labels."node-group", "replicas": .spec.replicas}'
    - name: instances
      group: main
      keepFullObjectsInMemory: false
      queue: /modules/$(module::name::kebab_case)/update_ngs_statuses
      executeHookOnEvent: ["Added", "Modified"]
      waitForSynchronization: false
      apiVersion: machine.sapcloud.io/v1alpha1
      kind: Machine
      namespace:
        nameSelector:
          matchNames: [d8-cloud-instance-manager]
      jqFilter: '{"nodeGroup": .spec.nodeTemplate.metadata.labels."node.deckhouse.io/group"}'
    - name: nodes
      group: main
      keepFullObjectsInMemory: false
      queue: /modules/$(module::name::kebab_case)/update_ngs_statuses
      waitForSynchronization: false
      apiVersion: v1
      kind: Node
      labelSelector:
        matchExpressions:
        - key: "node.deckhouse.io/group"
          operator: Exists
      jqFilter: |
        {
          "name": .metadata.name,
          "cloudInstanceGroup": .metadata.labels."node.deckhouse.io/group",
          "isReady": ([.status.conditions[] | select(.type == "Ready")][-1].status == "True"),
          "configurationChecksum": .metadata.annotations."node.deckhouse.io/configuration-checksum"
        }
EOF
}

# $1 — ng name
# $2 — ng error message or empty string
# $3 — latest machine failure or empty string
function _set_ng_condition_summary() {
  error_message=$(echo "$2" "$3" | xargs)
  ready="True"
  if [ ! -z "$error_message" ]; then
      ready="False"
  fi
  patch="$(jq -ns --arg ready "$ready" --arg error_message "$error_message" '
{
  "conditionSummary": {
    "ready": $ready,
    "errorMessage": $error_message
  }
}')"
    kubernetes::status::merge_patch "" "deckhouse.io/v1alpha1" "nodegroups" "${1}" "${patch}"
}

function __main__() {
  default_zones_num="0"
  if context::has snapshots.cloud_provider_secrets.0; then
    default_zones_num="$(context::jq -r '.snapshots.cloud_provider_secrets[0].filterResult.zonesNum')"
  fi

  for i in $(context::jq -r '.snapshots.ngs | keys[]'); do
    ng_name="$(context::get snapshots.ngs."$i".filterResult.name)"
    ng_error=$(context::jq -r --argjson i "$i" '.snapshots.ngs[$i].filterResult |.error // ""')

    last_machine_failures="$(context::jq -r --arg ng_name "${ng_name}" '([.snapshots.mds[] | select(.filterResult.nodeGroup == $ng_name)] | reduce .[] as $md ([]; . += $md.object.status.failedMachines)) // []')"
    latest_machine_failure="$(jq -nr --argjson last_machine_failures "${last_machine_failures}" '($last_machine_failures | sort_by(.lastOperation.lastUpdateTime | fromdate) | .[-1].lastOperation.description) // ""')"
    all_md_replicas="$(context::jq -r --arg ng_name "${ng_name}" '[.snapshots.mds[] | select(.filterResult.nodeGroup == $ng_name) | .filterResult.replicas] | add // 0')"
    instances_num="$(context::jq -r --arg ng_name "${ng_name}" '[.snapshots.instances[] | select(.filterResult.nodeGroup == $ng_name)] | length')"
    nodes_num="$(context::jq -r --arg ng_name "${ng_name}" '[.snapshots.nodes[] | select(.filterResult.cloudInstanceGroup == $ng_name)] | length')"
    ready_nodes_num="$(context::jq -r --arg ng_name "${ng_name}" '[.snapshots.nodes[] | select(.filterResult.cloudInstanceGroup == $ng_name and .filterResult.isReady)] | length')"

    ng_checksum="$(context::jq --arg ng_name "$ng_name" -r '.snapshots.configuration_checksums_secret[0].filterResult[$ng_name]')"
    uptodate_nodes_count="$(context::jq --arg ng_checksum "$ng_checksum" '[.snapshots.nodes[].filterResult | select(.configurationChecksum == $ng_checksum)] | length')"

    # shellcheck disable=SC2016
    status_patch="$(context::jq -c \
      --argjson i "$i" \
      --argjson default_zones_num "$default_zones_num" \
      --argjson all_md_replicas "$all_md_replicas" \
      --argjson instances_num "$instances_num" \
      --argjson nodes_num "$nodes_num" \
      --argjson ready_nodes_num "$ready_nodes_num" \
      --argjson uptodate_nodes_count "$uptodate_nodes_count" \
      --argjson last_machine_failures "$last_machine_failures" \
      '.snapshots.ngs[$i].filterResult |
        if .nodeType == "Cloud" then
        {
          "min": (.minPerZone * (.zonesNum // $default_zones_num)),
          "max": (.maxPerZone * (.zonesNum // $default_zones_num)),
          "desired": ([$all_md_replicas, (.minPerZone * (.zonesNum // $default_zones_num))] | max),
          "instances": $instances_num,
          "lastMachineFailures": $last_machine_failures
        }
        else {} end |
        .nodes = $nodes_num |
        .ready = $ready_nodes_num |
        .upToDate = $uptodate_nodes_count
    ')"

    kubernetes::status::merge_patch "" "deckhouse.io/v1alpha1" "nodegroups" "${ng_name}" "${status_patch}"

    _set_ng_condition_summary "${ng_name}" "${ng_error}" "${latest_machine_failure}"
  done
}

hook::run "$@"
