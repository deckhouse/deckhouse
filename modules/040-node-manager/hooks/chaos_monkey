#!/bin/bash

source /deckhouse/shell_lib.sh

function __config__() {
  cat << EOF
    configVersion: v1
    kubernetes:
    - name: ngs
      group: monkey
      queue: /modules/$(module::name::kebab_case)
      waitForSynchronization: false
      executeHookOnEvent: []
      executeHookOnSynchronization: false
      apiVersion: deckhouse.io/v1alpha1
      kind: NodeGroup
      jqFilter: |
        {
          "isReadyForChaos": (if .spec.nodeType == "Cloud" then .status.desired > 1 and .status.desired == .status.ready else .status.nodes > 1 and .status.nodes == .status.ready end),
          "spec": (.spec | .spec.chaos = (.spec.chaos // {}) | .spec.chaos.mode = (.spec.chaos.mode // "Disabled")) ,
          "name": .metadata.name
        }
    - name: nodes
      group: monkey
      queue: /modules/$(module::name::kebab_case)
      waitForSynchronization: false
      executeHookOnEvent: []
      executeHookOnSynchronization: false
      apiVersion: v1
      kind: Node
      labelSelector:
        matchExpressions:
        - key: node.deckhouse.io/group
          operator: Exists
      jqFilter: |
        {
          "nodeGroup": (.metadata.labels."node.deckhouse.io/group" // null),
          "name": .metadata.name
        }
    - name: machines
      group: monkey
      queue: /modules/$(module::name::kebab_case)
      waitForSynchronization: false
      executeHookOnEvent: []
      executeHookOnSynchronization: false
      apiVersion: machine.sapcloud.io/v1alpha1
      kind: Machine
      jqFilter: |
        {
          "isMonkeyVictim": (.metadata.labels | has("node.deckhouse.io/chaos-monkey-victim")),
          "node": .metadata.labels.node,
          "name": .metadata.name
        }
    schedule:
    - name: monkey
      group: monkey
      queue: /modules/$(module::name::kebab_case)/chaos_monkey
      crontab: "* * * * *"
EOF
}

function __on_group::monkey() {
  # for testing environment
  if [ -n "${RANDOM_SEED-}" ]; then
    RANDOM="${RANDOM_SEED}"
    tmp=$(mktemp)
    echo $RANDOM_SEED > $tmp
    export SHUF_RANDOM_SOURCE="--random-source=$tmp"
  else
    export SHUF_RANDOM_SOURCE=""
  fi

  ng_names="$(context::jq -r '.snapshots.ngs[] | select(.filterResult.spec.chaos.mode != "Disabled" and .filterResult.isReadyForChaos) | .object.metadata.name')"
  for ng_name in $ng_names ; do
    # If there are nodes in deleting state then do nothing
    if context::jq -e '[.snapshots.machines[] | select(.filterResult.isMonkeyVictim)] | any'; then
      continue
    fi

    ng_spec="$(context::jq -r --arg ng_name "$ng_name" '.snapshots.ngs[] | select(.filterResult.name == $ng_name) | .filterResult.spec')"
    ng_chaos_mode=$(jq -r '.chaos.mode' <<< "$ng_spec")
    ng_chaos_period_seconds=$(jq -r '.chaos.period // "6h"' <<< "$ng_spec" | deckhouse-controller helper unit convert --mode duration)

    run=$(( RANDOM % (ng_chaos_period_seconds / 60) ))
    if [[ "$run" == "0" ]]; then
      victim_node="$(context::jq -r --arg ng_name "${ng_name}" '.snapshots.nodes[] | select(.filterResult.nodeGroup == $ng_name) | .filterResult.name' | shuf -n 1 $SHUF_RANDOM_SOURCE)"
      victim_machine="$(context::jq -r --arg node "${victim_node}" '.snapshots.machines[] | select(.filterResult.node == $node) | .filterResult.name' | shuf -n 1 $SHUF_RANDOM_SOURCE)"
      if [[ "$ng_chaos_mode" == "DrainAndDelete" ]] ; then
        kubernetes::patch_jq "d8-cloud-instance-manager" "machine/$victim_machine" '.metadata.labels."node.deckhouse.io/chaos-monkey-victim" = ""'
        kubernetes::delete_if_exists "d8-cloud-instance-manager" "machine/$victim_machine"
      fi
    fi
  done
}

hook::run "$@"
