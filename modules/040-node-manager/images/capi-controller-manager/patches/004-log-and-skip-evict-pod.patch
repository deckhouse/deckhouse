Subject: [PATCH] ++
---
Index: internal/controllers/machine/machine_controller.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/controllers/machine/machine_controller.go b/internal/controllers/machine/machine_controller.go
--- a/internal/controllers/machine/machine_controller.go	(revision c37851897736ecd5bfcf29791b9ccfef1220e503)
+++ b/internal/controllers/machine/machine_controller.go	(date 1757268279863)
@@ -817,6 +817,8 @@
 	log := ctrl.LoggerFrom(ctx, "Node", klog.KRef("", nodeName))
 	ctx = ctrl.LoggerInto(ctx, log)

+	log.V(3).Info("Starting drain node")
+
 	remoteClient, err := r.ClusterCache.GetClient(ctx, util.ObjectKey(cluster))
 	if err != nil {
 		return ctrl.Result{}, errors.Wrapf(err, "failed to drain Node %s", nodeName)
@@ -836,6 +838,7 @@
 		Client:             r.Client,
 		RemoteClient:       remoteClient,
 		GracePeriodSeconds: -1,
+		Logger:             log,
 	}

 	if noderefutil.IsNodeUnreachable(node) {
@@ -861,11 +864,15 @@
 		log.V(3).Info("Node is unreachable, draining will use 1s GracePeriodSeconds and will ignore all Pods that have a deletionTimestamp > 1s old")
 	}

+	log.V(3).Info("Starting cordon node")
+
 	if err := drainer.CordonNode(ctx, node); err != nil {
 		// Machine will be re-reconciled after a cordon failure.
 		return ctrl.Result{}, errors.Wrapf(err, "failed to cordon Node %s", node.Name)
 	}

+	log.V(3).Info("Getting pod to eviction")
+
 	podDeleteList, err := drainer.GetPodsForEviction(ctx, cluster, machine, nodeName)
 	if err != nil {
 		return ctrl.Result{}, err
Index: internal/controllers/machine/drain/filters.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/controllers/machine/drain/filters.go b/internal/controllers/machine/drain/filters.go
--- a/internal/controllers/machine/drain/filters.go	(revision c37851897736ecd5bfcf29791b9ccfef1220e503)
+++ b/internal/controllers/machine/drain/filters.go	(date 1757268855731)
@@ -202,6 +202,8 @@
 }

 func (d *Helper) daemonSetFilter(ctx context.Context, pod *corev1.Pod) PodDeleteStatus {
+	log := d.Logger.WithValues("namespace", pod.Namespace, "podName", pod.Name)
+	d.Logger.V(4).Info("Checking if daemonset pod")
 	// Note that we return false in cases where the pod is DaemonSet managed,
 	// regardless of flags.
 	//
@@ -209,24 +211,33 @@
 	// management resource - including DaemonSet - is not found).
 	// Such pods will be deleted.
 	controllerRef := metav1.GetControllerOf(pod)
+	if controllerRef == nil {
+		log.V(4).Info("Pod does not have a controller reference")
+	} else {
+		log.V(4).Info("Pod has a controller reference", "controllerRef", controllerRef.String())
+	}
+
 	if controllerRef == nil || controllerRef.Kind != appsv1.SchemeGroupVersion.WithKind("DaemonSet").Kind {
+		log.V(4).Info("Pod does not have a DaemonSet controller. Should delete")
 		return MakePodDeleteStatusOkay()
 	}
 	// Any finished pod can be removed.
 	if pod.Status.Phase == corev1.PodSucceeded || pod.Status.Phase == corev1.PodFailed {
+		log.V(4).Info("Pod already terminated. Should delete")
 		return MakePodDeleteStatusOkay()
 	}

 	if err := d.RemoteClient.Get(ctx, client.ObjectKey{Namespace: pod.Namespace, Name: controllerRef.Name}, &appsv1.DaemonSet{}); err != nil {
 		// remove orphaned pods with a warning
 		if apierrors.IsNotFound(err) {
+			log.V(4).Info("Not found daemonset for Pod. Should delete")
 			return MakePodDeleteStatusWithWarning(clusterv1.MachineDrainRuleDrainBehaviorDrain, daemonSetOrphanedWarning)
 		}

+		log.V(4).Info("Error getting daemonset for Pod", "err", err.Error())
 		return MakePodDeleteStatusWithError(err.Error())
 	}

-	log := ctrl.LoggerFrom(ctx, "Pod", klog.KObj(pod))
 	log.V(4).Info("Skip evicting DaemonSet Pod")
 	return MakePodDeleteStatusWithWarning(clusterv1.MachineDrainRuleDrainBehaviorSkip, daemonSetWarning)
 }
Index: internal/controllers/machine/drain/drain.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/controllers/machine/drain/drain.go b/internal/controllers/machine/drain/drain.go
--- a/internal/controllers/machine/drain/drain.go	(revision c37851897736ecd5bfcf29791b9ccfef1220e503)
+++ b/internal/controllers/machine/drain/drain.go	(date 1757268279580)
@@ -20,6 +20,7 @@
 import (
 	"context"
 	"fmt"
+	"github.com/go-logr/logr"
 	"maps"
 	"math"
 	"slices"
@@ -61,6 +62,8 @@
 	// DeletionTimeStamp > N seconds. This can be used e.g. when a Node is unreachable
 	// and the Pods won't drain because of that.
 	SkipWaitForDeleteTimeoutSeconds int
+
+	Logger logr.Logger
 }

 // CordonNode cordons a Node.
