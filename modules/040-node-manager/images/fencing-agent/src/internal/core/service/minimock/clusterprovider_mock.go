// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package minimock

//go:generate minimock -i fencing-agent/internal/core/service.ClusterProvider -o clusterprovider_mock.go -n ClusterProviderMock -p minimock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClusterProviderMock implements mm_service.ClusterProvider
type ClusterProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcIsAvailable          func(ctx context.Context) (b1 bool)
	funcIsAvailableOrigin    string
	inspectFuncIsAvailable   func(ctx context.Context)
	afterIsAvailableCounter  uint64
	beforeIsAvailableCounter uint64
	IsAvailableMock          mClusterProviderMockIsAvailable

	funcIsMaintenanceMode          func(ctx context.Context) (b1 bool, err error)
	funcIsMaintenanceModeOrigin    string
	inspectFuncIsMaintenanceMode   func(ctx context.Context)
	afterIsMaintenanceModeCounter  uint64
	beforeIsMaintenanceModeCounter uint64
	IsMaintenanceModeMock          mClusterProviderMockIsMaintenanceMode

	funcRemoveNodeLabel          func(ctx context.Context, key string) (err error)
	funcRemoveNodeLabelOrigin    string
	inspectFuncRemoveNodeLabel   func(ctx context.Context, key string)
	afterRemoveNodeLabelCounter  uint64
	beforeRemoveNodeLabelCounter uint64
	RemoveNodeLabelMock          mClusterProviderMockRemoveNodeLabel

	funcSetNodeLabel          func(ctx context.Context, key string, value string) (err error)
	funcSetNodeLabelOrigin    string
	inspectFuncSetNodeLabel   func(ctx context.Context, key string, value string)
	afterSetNodeLabelCounter  uint64
	beforeSetNodeLabelCounter uint64
	SetNodeLabelMock          mClusterProviderMockSetNodeLabel
}

// NewClusterProviderMock returns a mock for mm_service.ClusterProvider
func NewClusterProviderMock(t minimock.Tester) *ClusterProviderMock {
	m := &ClusterProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsAvailableMock = mClusterProviderMockIsAvailable{mock: m}
	m.IsAvailableMock.callArgs = []*ClusterProviderMockIsAvailableParams{}

	m.IsMaintenanceModeMock = mClusterProviderMockIsMaintenanceMode{mock: m}
	m.IsMaintenanceModeMock.callArgs = []*ClusterProviderMockIsMaintenanceModeParams{}

	m.RemoveNodeLabelMock = mClusterProviderMockRemoveNodeLabel{mock: m}
	m.RemoveNodeLabelMock.callArgs = []*ClusterProviderMockRemoveNodeLabelParams{}

	m.SetNodeLabelMock = mClusterProviderMockSetNodeLabel{mock: m}
	m.SetNodeLabelMock.callArgs = []*ClusterProviderMockSetNodeLabelParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClusterProviderMockIsAvailable struct {
	optional           bool
	mock               *ClusterProviderMock
	defaultExpectation *ClusterProviderMockIsAvailableExpectation
	expectations       []*ClusterProviderMockIsAvailableExpectation

	callArgs []*ClusterProviderMockIsAvailableParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClusterProviderMockIsAvailableExpectation specifies expectation struct of the ClusterProvider.IsAvailable
type ClusterProviderMockIsAvailableExpectation struct {
	mock               *ClusterProviderMock
	params             *ClusterProviderMockIsAvailableParams
	paramPtrs          *ClusterProviderMockIsAvailableParamPtrs
	expectationOrigins ClusterProviderMockIsAvailableExpectationOrigins
	results            *ClusterProviderMockIsAvailableResults
	returnOrigin       string
	Counter            uint64
}

// ClusterProviderMockIsAvailableParams contains parameters of the ClusterProvider.IsAvailable
type ClusterProviderMockIsAvailableParams struct {
	ctx context.Context
}

// ClusterProviderMockIsAvailableParamPtrs contains pointers to parameters of the ClusterProvider.IsAvailable
type ClusterProviderMockIsAvailableParamPtrs struct {
	ctx *context.Context
}

// ClusterProviderMockIsAvailableResults contains results of the ClusterProvider.IsAvailable
type ClusterProviderMockIsAvailableResults struct {
	b1 bool
}

// ClusterProviderMockIsAvailableOrigins contains origins of expectations of the ClusterProvider.IsAvailable
type ClusterProviderMockIsAvailableExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsAvailable *mClusterProviderMockIsAvailable) Optional() *mClusterProviderMockIsAvailable {
	mmIsAvailable.optional = true
	return mmIsAvailable
}

// Expect sets up expected params for ClusterProvider.IsAvailable
func (mmIsAvailable *mClusterProviderMockIsAvailable) Expect(ctx context.Context) *mClusterProviderMockIsAvailable {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("ClusterProviderMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &ClusterProviderMockIsAvailableExpectation{}
	}

	if mmIsAvailable.defaultExpectation.paramPtrs != nil {
		mmIsAvailable.mock.t.Fatalf("ClusterProviderMock.IsAvailable mock is already set by ExpectParams functions")
	}

	mmIsAvailable.defaultExpectation.params = &ClusterProviderMockIsAvailableParams{ctx}
	mmIsAvailable.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsAvailable.expectations {
		if minimock.Equal(e.params, mmIsAvailable.defaultExpectation.params) {
			mmIsAvailable.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsAvailable.defaultExpectation.params)
		}
	}

	return mmIsAvailable
}

// ExpectCtxParam1 sets up expected param ctx for ClusterProvider.IsAvailable
func (mmIsAvailable *mClusterProviderMockIsAvailable) ExpectCtxParam1(ctx context.Context) *mClusterProviderMockIsAvailable {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("ClusterProviderMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &ClusterProviderMockIsAvailableExpectation{}
	}

	if mmIsAvailable.defaultExpectation.params != nil {
		mmIsAvailable.mock.t.Fatalf("ClusterProviderMock.IsAvailable mock is already set by Expect")
	}

	if mmIsAvailable.defaultExpectation.paramPtrs == nil {
		mmIsAvailable.defaultExpectation.paramPtrs = &ClusterProviderMockIsAvailableParamPtrs{}
	}
	mmIsAvailable.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsAvailable.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsAvailable
}

// Inspect accepts an inspector function that has same arguments as the ClusterProvider.IsAvailable
func (mmIsAvailable *mClusterProviderMockIsAvailable) Inspect(f func(ctx context.Context)) *mClusterProviderMockIsAvailable {
	if mmIsAvailable.mock.inspectFuncIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("Inspect function is already set for ClusterProviderMock.IsAvailable")
	}

	mmIsAvailable.mock.inspectFuncIsAvailable = f

	return mmIsAvailable
}

// Return sets up results that will be returned by ClusterProvider.IsAvailable
func (mmIsAvailable *mClusterProviderMockIsAvailable) Return(b1 bool) *ClusterProviderMock {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("ClusterProviderMock.IsAvailable mock is already set by Set")
	}

	if mmIsAvailable.defaultExpectation == nil {
		mmIsAvailable.defaultExpectation = &ClusterProviderMockIsAvailableExpectation{mock: mmIsAvailable.mock}
	}
	mmIsAvailable.defaultExpectation.results = &ClusterProviderMockIsAvailableResults{b1}
	mmIsAvailable.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsAvailable.mock
}

// Set uses given function f to mock the ClusterProvider.IsAvailable method
func (mmIsAvailable *mClusterProviderMockIsAvailable) Set(f func(ctx context.Context) (b1 bool)) *ClusterProviderMock {
	if mmIsAvailable.defaultExpectation != nil {
		mmIsAvailable.mock.t.Fatalf("Default expectation is already set for the ClusterProvider.IsAvailable method")
	}

	if len(mmIsAvailable.expectations) > 0 {
		mmIsAvailable.mock.t.Fatalf("Some expectations are already set for the ClusterProvider.IsAvailable method")
	}

	mmIsAvailable.mock.funcIsAvailable = f
	mmIsAvailable.mock.funcIsAvailableOrigin = minimock.CallerInfo(1)
	return mmIsAvailable.mock
}

// When sets expectation for the ClusterProvider.IsAvailable which will trigger the result defined by the following
// Then helper
func (mmIsAvailable *mClusterProviderMockIsAvailable) When(ctx context.Context) *ClusterProviderMockIsAvailableExpectation {
	if mmIsAvailable.mock.funcIsAvailable != nil {
		mmIsAvailable.mock.t.Fatalf("ClusterProviderMock.IsAvailable mock is already set by Set")
	}

	expectation := &ClusterProviderMockIsAvailableExpectation{
		mock:               mmIsAvailable.mock,
		params:             &ClusterProviderMockIsAvailableParams{ctx},
		expectationOrigins: ClusterProviderMockIsAvailableExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsAvailable.expectations = append(mmIsAvailable.expectations, expectation)
	return expectation
}

// Then sets up ClusterProvider.IsAvailable return parameters for the expectation previously defined by the When method
func (e *ClusterProviderMockIsAvailableExpectation) Then(b1 bool) *ClusterProviderMock {
	e.results = &ClusterProviderMockIsAvailableResults{b1}
	return e.mock
}

// Times sets number of times ClusterProvider.IsAvailable should be invoked
func (mmIsAvailable *mClusterProviderMockIsAvailable) Times(n uint64) *mClusterProviderMockIsAvailable {
	if n == 0 {
		mmIsAvailable.mock.t.Fatalf("Times of ClusterProviderMock.IsAvailable mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsAvailable.expectedInvocations, n)
	mmIsAvailable.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsAvailable
}

func (mmIsAvailable *mClusterProviderMockIsAvailable) invocationsDone() bool {
	if len(mmIsAvailable.expectations) == 0 && mmIsAvailable.defaultExpectation == nil && mmIsAvailable.mock.funcIsAvailable == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsAvailable.mock.afterIsAvailableCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsAvailable.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsAvailable implements mm_service.ClusterProvider
func (mmIsAvailable *ClusterProviderMock) IsAvailable(ctx context.Context) (b1 bool) {
	mm_atomic.AddUint64(&mmIsAvailable.beforeIsAvailableCounter, 1)
	defer mm_atomic.AddUint64(&mmIsAvailable.afterIsAvailableCounter, 1)

	mmIsAvailable.t.Helper()

	if mmIsAvailable.inspectFuncIsAvailable != nil {
		mmIsAvailable.inspectFuncIsAvailable(ctx)
	}

	mm_params := ClusterProviderMockIsAvailableParams{ctx}

	// Record call args
	mmIsAvailable.IsAvailableMock.mutex.Lock()
	mmIsAvailable.IsAvailableMock.callArgs = append(mmIsAvailable.IsAvailableMock.callArgs, &mm_params)
	mmIsAvailable.IsAvailableMock.mutex.Unlock()

	for _, e := range mmIsAvailable.IsAvailableMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsAvailable.IsAvailableMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsAvailable.IsAvailableMock.defaultExpectation.Counter, 1)
		mm_want := mmIsAvailable.IsAvailableMock.defaultExpectation.params
		mm_want_ptrs := mmIsAvailable.IsAvailableMock.defaultExpectation.paramPtrs

		mm_got := ClusterProviderMockIsAvailableParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsAvailable.t.Errorf("ClusterProviderMock.IsAvailable got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsAvailable.IsAvailableMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsAvailable.t.Errorf("ClusterProviderMock.IsAvailable got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsAvailable.IsAvailableMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsAvailable.IsAvailableMock.defaultExpectation.results
		if mm_results == nil {
			mmIsAvailable.t.Fatal("No results are set for the ClusterProviderMock.IsAvailable")
		}
		return (*mm_results).b1
	}
	if mmIsAvailable.funcIsAvailable != nil {
		return mmIsAvailable.funcIsAvailable(ctx)
	}
	mmIsAvailable.t.Fatalf("Unexpected call to ClusterProviderMock.IsAvailable. %v", ctx)
	return
}

// IsAvailableAfterCounter returns a count of finished ClusterProviderMock.IsAvailable invocations
func (mmIsAvailable *ClusterProviderMock) IsAvailableAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAvailable.afterIsAvailableCounter)
}

// IsAvailableBeforeCounter returns a count of ClusterProviderMock.IsAvailable invocations
func (mmIsAvailable *ClusterProviderMock) IsAvailableBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAvailable.beforeIsAvailableCounter)
}

// Calls returns a list of arguments used in each call to ClusterProviderMock.IsAvailable.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsAvailable *mClusterProviderMockIsAvailable) Calls() []*ClusterProviderMockIsAvailableParams {
	mmIsAvailable.mutex.RLock()

	argCopy := make([]*ClusterProviderMockIsAvailableParams, len(mmIsAvailable.callArgs))
	copy(argCopy, mmIsAvailable.callArgs)

	mmIsAvailable.mutex.RUnlock()

	return argCopy
}

// MinimockIsAvailableDone returns true if the count of the IsAvailable invocations corresponds
// the number of defined expectations
func (m *ClusterProviderMock) MinimockIsAvailableDone() bool {
	if m.IsAvailableMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsAvailableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsAvailableMock.invocationsDone()
}

// MinimockIsAvailableInspect logs each unmet expectation
func (m *ClusterProviderMock) MinimockIsAvailableInspect() {
	for _, e := range m.IsAvailableMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClusterProviderMock.IsAvailable at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsAvailableCounter := mm_atomic.LoadUint64(&m.afterIsAvailableCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsAvailableMock.defaultExpectation != nil && afterIsAvailableCounter < 1 {
		if m.IsAvailableMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClusterProviderMock.IsAvailable at\n%s", m.IsAvailableMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClusterProviderMock.IsAvailable at\n%s with params: %#v", m.IsAvailableMock.defaultExpectation.expectationOrigins.origin, *m.IsAvailableMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAvailable != nil && afterIsAvailableCounter < 1 {
		m.t.Errorf("Expected call to ClusterProviderMock.IsAvailable at\n%s", m.funcIsAvailableOrigin)
	}

	if !m.IsAvailableMock.invocationsDone() && afterIsAvailableCounter > 0 {
		m.t.Errorf("Expected %d calls to ClusterProviderMock.IsAvailable at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsAvailableMock.expectedInvocations), m.IsAvailableMock.expectedInvocationsOrigin, afterIsAvailableCounter)
	}
}

type mClusterProviderMockIsMaintenanceMode struct {
	optional           bool
	mock               *ClusterProviderMock
	defaultExpectation *ClusterProviderMockIsMaintenanceModeExpectation
	expectations       []*ClusterProviderMockIsMaintenanceModeExpectation

	callArgs []*ClusterProviderMockIsMaintenanceModeParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClusterProviderMockIsMaintenanceModeExpectation specifies expectation struct of the ClusterProvider.IsMaintenanceMode
type ClusterProviderMockIsMaintenanceModeExpectation struct {
	mock               *ClusterProviderMock
	params             *ClusterProviderMockIsMaintenanceModeParams
	paramPtrs          *ClusterProviderMockIsMaintenanceModeParamPtrs
	expectationOrigins ClusterProviderMockIsMaintenanceModeExpectationOrigins
	results            *ClusterProviderMockIsMaintenanceModeResults
	returnOrigin       string
	Counter            uint64
}

// ClusterProviderMockIsMaintenanceModeParams contains parameters of the ClusterProvider.IsMaintenanceMode
type ClusterProviderMockIsMaintenanceModeParams struct {
	ctx context.Context
}

// ClusterProviderMockIsMaintenanceModeParamPtrs contains pointers to parameters of the ClusterProvider.IsMaintenanceMode
type ClusterProviderMockIsMaintenanceModeParamPtrs struct {
	ctx *context.Context
}

// ClusterProviderMockIsMaintenanceModeResults contains results of the ClusterProvider.IsMaintenanceMode
type ClusterProviderMockIsMaintenanceModeResults struct {
	b1  bool
	err error
}

// ClusterProviderMockIsMaintenanceModeOrigins contains origins of expectations of the ClusterProvider.IsMaintenanceMode
type ClusterProviderMockIsMaintenanceModeExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) Optional() *mClusterProviderMockIsMaintenanceMode {
	mmIsMaintenanceMode.optional = true
	return mmIsMaintenanceMode
}

// Expect sets up expected params for ClusterProvider.IsMaintenanceMode
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) Expect(ctx context.Context) *mClusterProviderMockIsMaintenanceMode {
	if mmIsMaintenanceMode.mock.funcIsMaintenanceMode != nil {
		mmIsMaintenanceMode.mock.t.Fatalf("ClusterProviderMock.IsMaintenanceMode mock is already set by Set")
	}

	if mmIsMaintenanceMode.defaultExpectation == nil {
		mmIsMaintenanceMode.defaultExpectation = &ClusterProviderMockIsMaintenanceModeExpectation{}
	}

	if mmIsMaintenanceMode.defaultExpectation.paramPtrs != nil {
		mmIsMaintenanceMode.mock.t.Fatalf("ClusterProviderMock.IsMaintenanceMode mock is already set by ExpectParams functions")
	}

	mmIsMaintenanceMode.defaultExpectation.params = &ClusterProviderMockIsMaintenanceModeParams{ctx}
	mmIsMaintenanceMode.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsMaintenanceMode.expectations {
		if minimock.Equal(e.params, mmIsMaintenanceMode.defaultExpectation.params) {
			mmIsMaintenanceMode.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsMaintenanceMode.defaultExpectation.params)
		}
	}

	return mmIsMaintenanceMode
}

// ExpectCtxParam1 sets up expected param ctx for ClusterProvider.IsMaintenanceMode
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) ExpectCtxParam1(ctx context.Context) *mClusterProviderMockIsMaintenanceMode {
	if mmIsMaintenanceMode.mock.funcIsMaintenanceMode != nil {
		mmIsMaintenanceMode.mock.t.Fatalf("ClusterProviderMock.IsMaintenanceMode mock is already set by Set")
	}

	if mmIsMaintenanceMode.defaultExpectation == nil {
		mmIsMaintenanceMode.defaultExpectation = &ClusterProviderMockIsMaintenanceModeExpectation{}
	}

	if mmIsMaintenanceMode.defaultExpectation.params != nil {
		mmIsMaintenanceMode.mock.t.Fatalf("ClusterProviderMock.IsMaintenanceMode mock is already set by Expect")
	}

	if mmIsMaintenanceMode.defaultExpectation.paramPtrs == nil {
		mmIsMaintenanceMode.defaultExpectation.paramPtrs = &ClusterProviderMockIsMaintenanceModeParamPtrs{}
	}
	mmIsMaintenanceMode.defaultExpectation.paramPtrs.ctx = &ctx
	mmIsMaintenanceMode.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmIsMaintenanceMode
}

// Inspect accepts an inspector function that has same arguments as the ClusterProvider.IsMaintenanceMode
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) Inspect(f func(ctx context.Context)) *mClusterProviderMockIsMaintenanceMode {
	if mmIsMaintenanceMode.mock.inspectFuncIsMaintenanceMode != nil {
		mmIsMaintenanceMode.mock.t.Fatalf("Inspect function is already set for ClusterProviderMock.IsMaintenanceMode")
	}

	mmIsMaintenanceMode.mock.inspectFuncIsMaintenanceMode = f

	return mmIsMaintenanceMode
}

// Return sets up results that will be returned by ClusterProvider.IsMaintenanceMode
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) Return(b1 bool, err error) *ClusterProviderMock {
	if mmIsMaintenanceMode.mock.funcIsMaintenanceMode != nil {
		mmIsMaintenanceMode.mock.t.Fatalf("ClusterProviderMock.IsMaintenanceMode mock is already set by Set")
	}

	if mmIsMaintenanceMode.defaultExpectation == nil {
		mmIsMaintenanceMode.defaultExpectation = &ClusterProviderMockIsMaintenanceModeExpectation{mock: mmIsMaintenanceMode.mock}
	}
	mmIsMaintenanceMode.defaultExpectation.results = &ClusterProviderMockIsMaintenanceModeResults{b1, err}
	mmIsMaintenanceMode.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsMaintenanceMode.mock
}

// Set uses given function f to mock the ClusterProvider.IsMaintenanceMode method
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) Set(f func(ctx context.Context) (b1 bool, err error)) *ClusterProviderMock {
	if mmIsMaintenanceMode.defaultExpectation != nil {
		mmIsMaintenanceMode.mock.t.Fatalf("Default expectation is already set for the ClusterProvider.IsMaintenanceMode method")
	}

	if len(mmIsMaintenanceMode.expectations) > 0 {
		mmIsMaintenanceMode.mock.t.Fatalf("Some expectations are already set for the ClusterProvider.IsMaintenanceMode method")
	}

	mmIsMaintenanceMode.mock.funcIsMaintenanceMode = f
	mmIsMaintenanceMode.mock.funcIsMaintenanceModeOrigin = minimock.CallerInfo(1)
	return mmIsMaintenanceMode.mock
}

// When sets expectation for the ClusterProvider.IsMaintenanceMode which will trigger the result defined by the following
// Then helper
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) When(ctx context.Context) *ClusterProviderMockIsMaintenanceModeExpectation {
	if mmIsMaintenanceMode.mock.funcIsMaintenanceMode != nil {
		mmIsMaintenanceMode.mock.t.Fatalf("ClusterProviderMock.IsMaintenanceMode mock is already set by Set")
	}

	expectation := &ClusterProviderMockIsMaintenanceModeExpectation{
		mock:               mmIsMaintenanceMode.mock,
		params:             &ClusterProviderMockIsMaintenanceModeParams{ctx},
		expectationOrigins: ClusterProviderMockIsMaintenanceModeExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsMaintenanceMode.expectations = append(mmIsMaintenanceMode.expectations, expectation)
	return expectation
}

// Then sets up ClusterProvider.IsMaintenanceMode return parameters for the expectation previously defined by the When method
func (e *ClusterProviderMockIsMaintenanceModeExpectation) Then(b1 bool, err error) *ClusterProviderMock {
	e.results = &ClusterProviderMockIsMaintenanceModeResults{b1, err}
	return e.mock
}

// Times sets number of times ClusterProvider.IsMaintenanceMode should be invoked
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) Times(n uint64) *mClusterProviderMockIsMaintenanceMode {
	if n == 0 {
		mmIsMaintenanceMode.mock.t.Fatalf("Times of ClusterProviderMock.IsMaintenanceMode mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsMaintenanceMode.expectedInvocations, n)
	mmIsMaintenanceMode.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsMaintenanceMode
}

func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) invocationsDone() bool {
	if len(mmIsMaintenanceMode.expectations) == 0 && mmIsMaintenanceMode.defaultExpectation == nil && mmIsMaintenanceMode.mock.funcIsMaintenanceMode == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsMaintenanceMode.mock.afterIsMaintenanceModeCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsMaintenanceMode.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsMaintenanceMode implements mm_service.ClusterProvider
func (mmIsMaintenanceMode *ClusterProviderMock) IsMaintenanceMode(ctx context.Context) (b1 bool, err error) {
	mm_atomic.AddUint64(&mmIsMaintenanceMode.beforeIsMaintenanceModeCounter, 1)
	defer mm_atomic.AddUint64(&mmIsMaintenanceMode.afterIsMaintenanceModeCounter, 1)

	mmIsMaintenanceMode.t.Helper()

	if mmIsMaintenanceMode.inspectFuncIsMaintenanceMode != nil {
		mmIsMaintenanceMode.inspectFuncIsMaintenanceMode(ctx)
	}

	mm_params := ClusterProviderMockIsMaintenanceModeParams{ctx}

	// Record call args
	mmIsMaintenanceMode.IsMaintenanceModeMock.mutex.Lock()
	mmIsMaintenanceMode.IsMaintenanceModeMock.callArgs = append(mmIsMaintenanceMode.IsMaintenanceModeMock.callArgs, &mm_params)
	mmIsMaintenanceMode.IsMaintenanceModeMock.mutex.Unlock()

	for _, e := range mmIsMaintenanceMode.IsMaintenanceModeMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1, e.results.err
		}
	}

	if mmIsMaintenanceMode.IsMaintenanceModeMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsMaintenanceMode.IsMaintenanceModeMock.defaultExpectation.Counter, 1)
		mm_want := mmIsMaintenanceMode.IsMaintenanceModeMock.defaultExpectation.params
		mm_want_ptrs := mmIsMaintenanceMode.IsMaintenanceModeMock.defaultExpectation.paramPtrs

		mm_got := ClusterProviderMockIsMaintenanceModeParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmIsMaintenanceMode.t.Errorf("ClusterProviderMock.IsMaintenanceMode got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsMaintenanceMode.IsMaintenanceModeMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsMaintenanceMode.t.Errorf("ClusterProviderMock.IsMaintenanceMode got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsMaintenanceMode.IsMaintenanceModeMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsMaintenanceMode.IsMaintenanceModeMock.defaultExpectation.results
		if mm_results == nil {
			mmIsMaintenanceMode.t.Fatal("No results are set for the ClusterProviderMock.IsMaintenanceMode")
		}
		return (*mm_results).b1, (*mm_results).err
	}
	if mmIsMaintenanceMode.funcIsMaintenanceMode != nil {
		return mmIsMaintenanceMode.funcIsMaintenanceMode(ctx)
	}
	mmIsMaintenanceMode.t.Fatalf("Unexpected call to ClusterProviderMock.IsMaintenanceMode. %v", ctx)
	return
}

// IsMaintenanceModeAfterCounter returns a count of finished ClusterProviderMock.IsMaintenanceMode invocations
func (mmIsMaintenanceMode *ClusterProviderMock) IsMaintenanceModeAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsMaintenanceMode.afterIsMaintenanceModeCounter)
}

// IsMaintenanceModeBeforeCounter returns a count of ClusterProviderMock.IsMaintenanceMode invocations
func (mmIsMaintenanceMode *ClusterProviderMock) IsMaintenanceModeBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsMaintenanceMode.beforeIsMaintenanceModeCounter)
}

// Calls returns a list of arguments used in each call to ClusterProviderMock.IsMaintenanceMode.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsMaintenanceMode *mClusterProviderMockIsMaintenanceMode) Calls() []*ClusterProviderMockIsMaintenanceModeParams {
	mmIsMaintenanceMode.mutex.RLock()

	argCopy := make([]*ClusterProviderMockIsMaintenanceModeParams, len(mmIsMaintenanceMode.callArgs))
	copy(argCopy, mmIsMaintenanceMode.callArgs)

	mmIsMaintenanceMode.mutex.RUnlock()

	return argCopy
}

// MinimockIsMaintenanceModeDone returns true if the count of the IsMaintenanceMode invocations corresponds
// the number of defined expectations
func (m *ClusterProviderMock) MinimockIsMaintenanceModeDone() bool {
	if m.IsMaintenanceModeMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsMaintenanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsMaintenanceModeMock.invocationsDone()
}

// MinimockIsMaintenanceModeInspect logs each unmet expectation
func (m *ClusterProviderMock) MinimockIsMaintenanceModeInspect() {
	for _, e := range m.IsMaintenanceModeMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClusterProviderMock.IsMaintenanceMode at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsMaintenanceModeCounter := mm_atomic.LoadUint64(&m.afterIsMaintenanceModeCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsMaintenanceModeMock.defaultExpectation != nil && afterIsMaintenanceModeCounter < 1 {
		if m.IsMaintenanceModeMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClusterProviderMock.IsMaintenanceMode at\n%s", m.IsMaintenanceModeMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClusterProviderMock.IsMaintenanceMode at\n%s with params: %#v", m.IsMaintenanceModeMock.defaultExpectation.expectationOrigins.origin, *m.IsMaintenanceModeMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsMaintenanceMode != nil && afterIsMaintenanceModeCounter < 1 {
		m.t.Errorf("Expected call to ClusterProviderMock.IsMaintenanceMode at\n%s", m.funcIsMaintenanceModeOrigin)
	}

	if !m.IsMaintenanceModeMock.invocationsDone() && afterIsMaintenanceModeCounter > 0 {
		m.t.Errorf("Expected %d calls to ClusterProviderMock.IsMaintenanceMode at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsMaintenanceModeMock.expectedInvocations), m.IsMaintenanceModeMock.expectedInvocationsOrigin, afterIsMaintenanceModeCounter)
	}
}

type mClusterProviderMockRemoveNodeLabel struct {
	optional           bool
	mock               *ClusterProviderMock
	defaultExpectation *ClusterProviderMockRemoveNodeLabelExpectation
	expectations       []*ClusterProviderMockRemoveNodeLabelExpectation

	callArgs []*ClusterProviderMockRemoveNodeLabelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClusterProviderMockRemoveNodeLabelExpectation specifies expectation struct of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelExpectation struct {
	mock               *ClusterProviderMock
	params             *ClusterProviderMockRemoveNodeLabelParams
	paramPtrs          *ClusterProviderMockRemoveNodeLabelParamPtrs
	expectationOrigins ClusterProviderMockRemoveNodeLabelExpectationOrigins
	results            *ClusterProviderMockRemoveNodeLabelResults
	returnOrigin       string
	Counter            uint64
}

// ClusterProviderMockRemoveNodeLabelParams contains parameters of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelParams struct {
	ctx context.Context
	key string
}

// ClusterProviderMockRemoveNodeLabelParamPtrs contains pointers to parameters of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelParamPtrs struct {
	ctx *context.Context
	key *string
}

// ClusterProviderMockRemoveNodeLabelResults contains results of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelResults struct {
	err error
}

// ClusterProviderMockRemoveNodeLabelOrigins contains origins of expectations of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Optional() *mClusterProviderMockRemoveNodeLabel {
	mmRemoveNodeLabel.optional = true
	return mmRemoveNodeLabel
}

// Expect sets up expected params for ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Expect(ctx context.Context, key string) *mClusterProviderMockRemoveNodeLabel {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	if mmRemoveNodeLabel.defaultExpectation == nil {
		mmRemoveNodeLabel.defaultExpectation = &ClusterProviderMockRemoveNodeLabelExpectation{}
	}

	if mmRemoveNodeLabel.defaultExpectation.paramPtrs != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by ExpectParams functions")
	}

	mmRemoveNodeLabel.defaultExpectation.params = &ClusterProviderMockRemoveNodeLabelParams{ctx, key}
	mmRemoveNodeLabel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveNodeLabel.expectations {
		if minimock.Equal(e.params, mmRemoveNodeLabel.defaultExpectation.params) {
			mmRemoveNodeLabel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveNodeLabel.defaultExpectation.params)
		}
	}

	return mmRemoveNodeLabel
}

// ExpectCtxParam1 sets up expected param ctx for ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) ExpectCtxParam1(ctx context.Context) *mClusterProviderMockRemoveNodeLabel {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	if mmRemoveNodeLabel.defaultExpectation == nil {
		mmRemoveNodeLabel.defaultExpectation = &ClusterProviderMockRemoveNodeLabelExpectation{}
	}

	if mmRemoveNodeLabel.defaultExpectation.params != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Expect")
	}

	if mmRemoveNodeLabel.defaultExpectation.paramPtrs == nil {
		mmRemoveNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockRemoveNodeLabelParamPtrs{}
	}
	mmRemoveNodeLabel.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveNodeLabel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveNodeLabel
}

// ExpectKeyParam2 sets up expected param key for ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) ExpectKeyParam2(key string) *mClusterProviderMockRemoveNodeLabel {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	if mmRemoveNodeLabel.defaultExpectation == nil {
		mmRemoveNodeLabel.defaultExpectation = &ClusterProviderMockRemoveNodeLabelExpectation{}
	}

	if mmRemoveNodeLabel.defaultExpectation.params != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Expect")
	}

	if mmRemoveNodeLabel.defaultExpectation.paramPtrs == nil {
		mmRemoveNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockRemoveNodeLabelParamPtrs{}
	}
	mmRemoveNodeLabel.defaultExpectation.paramPtrs.key = &key
	mmRemoveNodeLabel.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmRemoveNodeLabel
}

// Inspect accepts an inspector function that has same arguments as the ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Inspect(f func(ctx context.Context, key string)) *mClusterProviderMockRemoveNodeLabel {
	if mmRemoveNodeLabel.mock.inspectFuncRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("Inspect function is already set for ClusterProviderMock.RemoveNodeLabel")
	}

	mmRemoveNodeLabel.mock.inspectFuncRemoveNodeLabel = f

	return mmRemoveNodeLabel
}

// Return sets up results that will be returned by ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Return(err error) *ClusterProviderMock {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	if mmRemoveNodeLabel.defaultExpectation == nil {
		mmRemoveNodeLabel.defaultExpectation = &ClusterProviderMockRemoveNodeLabelExpectation{mock: mmRemoveNodeLabel.mock}
	}
	mmRemoveNodeLabel.defaultExpectation.results = &ClusterProviderMockRemoveNodeLabelResults{err}
	mmRemoveNodeLabel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveNodeLabel.mock
}

// Set uses given function f to mock the ClusterProvider.RemoveNodeLabel method
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Set(f func(ctx context.Context, key string) (err error)) *ClusterProviderMock {
	if mmRemoveNodeLabel.defaultExpectation != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("Default expectation is already set for the ClusterProvider.RemoveNodeLabel method")
	}

	if len(mmRemoveNodeLabel.expectations) > 0 {
		mmRemoveNodeLabel.mock.t.Fatalf("Some expectations are already set for the ClusterProvider.RemoveNodeLabel method")
	}

	mmRemoveNodeLabel.mock.funcRemoveNodeLabel = f
	mmRemoveNodeLabel.mock.funcRemoveNodeLabelOrigin = minimock.CallerInfo(1)
	return mmRemoveNodeLabel.mock
}

// When sets expectation for the ClusterProvider.RemoveNodeLabel which will trigger the result defined by the following
// Then helper
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) When(ctx context.Context, key string) *ClusterProviderMockRemoveNodeLabelExpectation {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	expectation := &ClusterProviderMockRemoveNodeLabelExpectation{
		mock:               mmRemoveNodeLabel.mock,
		params:             &ClusterProviderMockRemoveNodeLabelParams{ctx, key},
		expectationOrigins: ClusterProviderMockRemoveNodeLabelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveNodeLabel.expectations = append(mmRemoveNodeLabel.expectations, expectation)
	return expectation
}

// Then sets up ClusterProvider.RemoveNodeLabel return parameters for the expectation previously defined by the When method
func (e *ClusterProviderMockRemoveNodeLabelExpectation) Then(err error) *ClusterProviderMock {
	e.results = &ClusterProviderMockRemoveNodeLabelResults{err}
	return e.mock
}

// Times sets number of times ClusterProvider.RemoveNodeLabel should be invoked
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Times(n uint64) *mClusterProviderMockRemoveNodeLabel {
	if n == 0 {
		mmRemoveNodeLabel.mock.t.Fatalf("Times of ClusterProviderMock.RemoveNodeLabel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveNodeLabel.expectedInvocations, n)
	mmRemoveNodeLabel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveNodeLabel
}

func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) invocationsDone() bool {
	if len(mmRemoveNodeLabel.expectations) == 0 && mmRemoveNodeLabel.defaultExpectation == nil && mmRemoveNodeLabel.mock.funcRemoveNodeLabel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveNodeLabel.mock.afterRemoveNodeLabelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveNodeLabel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveNodeLabel implements mm_service.ClusterProvider
func (mmRemoveNodeLabel *ClusterProviderMock) RemoveNodeLabel(ctx context.Context, key string) (err error) {
	mm_atomic.AddUint64(&mmRemoveNodeLabel.beforeRemoveNodeLabelCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveNodeLabel.afterRemoveNodeLabelCounter, 1)

	mmRemoveNodeLabel.t.Helper()

	if mmRemoveNodeLabel.inspectFuncRemoveNodeLabel != nil {
		mmRemoveNodeLabel.inspectFuncRemoveNodeLabel(ctx, key)
	}

	mm_params := ClusterProviderMockRemoveNodeLabelParams{ctx, key}

	// Record call args
	mmRemoveNodeLabel.RemoveNodeLabelMock.mutex.Lock()
	mmRemoveNodeLabel.RemoveNodeLabelMock.callArgs = append(mmRemoveNodeLabel.RemoveNodeLabelMock.callArgs, &mm_params)
	mmRemoveNodeLabel.RemoveNodeLabelMock.mutex.Unlock()

	for _, e := range mmRemoveNodeLabel.RemoveNodeLabelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.paramPtrs

		mm_got := ClusterProviderMockRemoveNodeLabelParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveNodeLabel.t.Errorf("ClusterProviderMock.RemoveNodeLabel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmRemoveNodeLabel.t.Errorf("ClusterProviderMock.RemoveNodeLabel got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveNodeLabel.t.Errorf("ClusterProviderMock.RemoveNodeLabel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveNodeLabel.t.Fatal("No results are set for the ClusterProviderMock.RemoveNodeLabel")
		}
		return (*mm_results).err
	}
	if mmRemoveNodeLabel.funcRemoveNodeLabel != nil {
		return mmRemoveNodeLabel.funcRemoveNodeLabel(ctx, key)
	}
	mmRemoveNodeLabel.t.Fatalf("Unexpected call to ClusterProviderMock.RemoveNodeLabel. %v %v", ctx, key)
	return
}

// RemoveNodeLabelAfterCounter returns a count of finished ClusterProviderMock.RemoveNodeLabel invocations
func (mmRemoveNodeLabel *ClusterProviderMock) RemoveNodeLabelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveNodeLabel.afterRemoveNodeLabelCounter)
}

// RemoveNodeLabelBeforeCounter returns a count of ClusterProviderMock.RemoveNodeLabel invocations
func (mmRemoveNodeLabel *ClusterProviderMock) RemoveNodeLabelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveNodeLabel.beforeRemoveNodeLabelCounter)
}

// Calls returns a list of arguments used in each call to ClusterProviderMock.RemoveNodeLabel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Calls() []*ClusterProviderMockRemoveNodeLabelParams {
	mmRemoveNodeLabel.mutex.RLock()

	argCopy := make([]*ClusterProviderMockRemoveNodeLabelParams, len(mmRemoveNodeLabel.callArgs))
	copy(argCopy, mmRemoveNodeLabel.callArgs)

	mmRemoveNodeLabel.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveNodeLabelDone returns true if the count of the RemoveNodeLabel invocations corresponds
// the number of defined expectations
func (m *ClusterProviderMock) MinimockRemoveNodeLabelDone() bool {
	if m.RemoveNodeLabelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveNodeLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveNodeLabelMock.invocationsDone()
}

// MinimockRemoveNodeLabelInspect logs each unmet expectation
func (m *ClusterProviderMock) MinimockRemoveNodeLabelInspect() {
	for _, e := range m.RemoveNodeLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClusterProviderMock.RemoveNodeLabel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveNodeLabelCounter := mm_atomic.LoadUint64(&m.afterRemoveNodeLabelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveNodeLabelMock.defaultExpectation != nil && afterRemoveNodeLabelCounter < 1 {
		if m.RemoveNodeLabelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClusterProviderMock.RemoveNodeLabel at\n%s", m.RemoveNodeLabelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClusterProviderMock.RemoveNodeLabel at\n%s with params: %#v", m.RemoveNodeLabelMock.defaultExpectation.expectationOrigins.origin, *m.RemoveNodeLabelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveNodeLabel != nil && afterRemoveNodeLabelCounter < 1 {
		m.t.Errorf("Expected call to ClusterProviderMock.RemoveNodeLabel at\n%s", m.funcRemoveNodeLabelOrigin)
	}

	if !m.RemoveNodeLabelMock.invocationsDone() && afterRemoveNodeLabelCounter > 0 {
		m.t.Errorf("Expected %d calls to ClusterProviderMock.RemoveNodeLabel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveNodeLabelMock.expectedInvocations), m.RemoveNodeLabelMock.expectedInvocationsOrigin, afterRemoveNodeLabelCounter)
	}
}

type mClusterProviderMockSetNodeLabel struct {
	optional           bool
	mock               *ClusterProviderMock
	defaultExpectation *ClusterProviderMockSetNodeLabelExpectation
	expectations       []*ClusterProviderMockSetNodeLabelExpectation

	callArgs []*ClusterProviderMockSetNodeLabelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClusterProviderMockSetNodeLabelExpectation specifies expectation struct of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelExpectation struct {
	mock               *ClusterProviderMock
	params             *ClusterProviderMockSetNodeLabelParams
	paramPtrs          *ClusterProviderMockSetNodeLabelParamPtrs
	expectationOrigins ClusterProviderMockSetNodeLabelExpectationOrigins
	results            *ClusterProviderMockSetNodeLabelResults
	returnOrigin       string
	Counter            uint64
}

// ClusterProviderMockSetNodeLabelParams contains parameters of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelParams struct {
	ctx   context.Context
	key   string
	value string
}

// ClusterProviderMockSetNodeLabelParamPtrs contains pointers to parameters of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *string
}

// ClusterProviderMockSetNodeLabelResults contains results of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelResults struct {
	err error
}

// ClusterProviderMockSetNodeLabelOrigins contains origins of expectations of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Optional() *mClusterProviderMockSetNodeLabel {
	mmSetNodeLabel.optional = true
	return mmSetNodeLabel
}

// Expect sets up expected params for ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Expect(ctx context.Context, key string, value string) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{}
	}

	if mmSetNodeLabel.defaultExpectation.paramPtrs != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by ExpectParams functions")
	}

	mmSetNodeLabel.defaultExpectation.params = &ClusterProviderMockSetNodeLabelParams{ctx, key, value}
	mmSetNodeLabel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetNodeLabel.expectations {
		if minimock.Equal(e.params, mmSetNodeLabel.defaultExpectation.params) {
			mmSetNodeLabel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetNodeLabel.defaultExpectation.params)
		}
	}

	return mmSetNodeLabel
}

// ExpectCtxParam1 sets up expected param ctx for ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) ExpectCtxParam1(ctx context.Context) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{}
	}

	if mmSetNodeLabel.defaultExpectation.params != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Expect")
	}

	if mmSetNodeLabel.defaultExpectation.paramPtrs == nil {
		mmSetNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockSetNodeLabelParamPtrs{}
	}
	mmSetNodeLabel.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetNodeLabel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetNodeLabel
}

// ExpectKeyParam2 sets up expected param key for ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) ExpectKeyParam2(key string) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{}
	}

	if mmSetNodeLabel.defaultExpectation.params != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Expect")
	}

	if mmSetNodeLabel.defaultExpectation.paramPtrs == nil {
		mmSetNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockSetNodeLabelParamPtrs{}
	}
	mmSetNodeLabel.defaultExpectation.paramPtrs.key = &key
	mmSetNodeLabel.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSetNodeLabel
}

// ExpectValueParam3 sets up expected param value for ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) ExpectValueParam3(value string) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{}
	}

	if mmSetNodeLabel.defaultExpectation.params != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Expect")
	}

	if mmSetNodeLabel.defaultExpectation.paramPtrs == nil {
		mmSetNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockSetNodeLabelParamPtrs{}
	}
	mmSetNodeLabel.defaultExpectation.paramPtrs.value = &value
	mmSetNodeLabel.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSetNodeLabel
}

// Inspect accepts an inspector function that has same arguments as the ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Inspect(f func(ctx context.Context, key string, value string)) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.inspectFuncSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("Inspect function is already set for ClusterProviderMock.SetNodeLabel")
	}

	mmSetNodeLabel.mock.inspectFuncSetNodeLabel = f

	return mmSetNodeLabel
}

// Return sets up results that will be returned by ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Return(err error) *ClusterProviderMock {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{mock: mmSetNodeLabel.mock}
	}
	mmSetNodeLabel.defaultExpectation.results = &ClusterProviderMockSetNodeLabelResults{err}
	mmSetNodeLabel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetNodeLabel.mock
}

// Set uses given function f to mock the ClusterProvider.SetNodeLabel method
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Set(f func(ctx context.Context, key string, value string) (err error)) *ClusterProviderMock {
	if mmSetNodeLabel.defaultExpectation != nil {
		mmSetNodeLabel.mock.t.Fatalf("Default expectation is already set for the ClusterProvider.SetNodeLabel method")
	}

	if len(mmSetNodeLabel.expectations) > 0 {
		mmSetNodeLabel.mock.t.Fatalf("Some expectations are already set for the ClusterProvider.SetNodeLabel method")
	}

	mmSetNodeLabel.mock.funcSetNodeLabel = f
	mmSetNodeLabel.mock.funcSetNodeLabelOrigin = minimock.CallerInfo(1)
	return mmSetNodeLabel.mock
}

// When sets expectation for the ClusterProvider.SetNodeLabel which will trigger the result defined by the following
// Then helper
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) When(ctx context.Context, key string, value string) *ClusterProviderMockSetNodeLabelExpectation {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	expectation := &ClusterProviderMockSetNodeLabelExpectation{
		mock:               mmSetNodeLabel.mock,
		params:             &ClusterProviderMockSetNodeLabelParams{ctx, key, value},
		expectationOrigins: ClusterProviderMockSetNodeLabelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetNodeLabel.expectations = append(mmSetNodeLabel.expectations, expectation)
	return expectation
}

// Then sets up ClusterProvider.SetNodeLabel return parameters for the expectation previously defined by the When method
func (e *ClusterProviderMockSetNodeLabelExpectation) Then(err error) *ClusterProviderMock {
	e.results = &ClusterProviderMockSetNodeLabelResults{err}
	return e.mock
}

// Times sets number of times ClusterProvider.SetNodeLabel should be invoked
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Times(n uint64) *mClusterProviderMockSetNodeLabel {
	if n == 0 {
		mmSetNodeLabel.mock.t.Fatalf("Times of ClusterProviderMock.SetNodeLabel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetNodeLabel.expectedInvocations, n)
	mmSetNodeLabel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetNodeLabel
}

func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) invocationsDone() bool {
	if len(mmSetNodeLabel.expectations) == 0 && mmSetNodeLabel.defaultExpectation == nil && mmSetNodeLabel.mock.funcSetNodeLabel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetNodeLabel.mock.afterSetNodeLabelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetNodeLabel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetNodeLabel implements mm_service.ClusterProvider
func (mmSetNodeLabel *ClusterProviderMock) SetNodeLabel(ctx context.Context, key string, value string) (err error) {
	mm_atomic.AddUint64(&mmSetNodeLabel.beforeSetNodeLabelCounter, 1)
	defer mm_atomic.AddUint64(&mmSetNodeLabel.afterSetNodeLabelCounter, 1)

	mmSetNodeLabel.t.Helper()

	if mmSetNodeLabel.inspectFuncSetNodeLabel != nil {
		mmSetNodeLabel.inspectFuncSetNodeLabel(ctx, key, value)
	}

	mm_params := ClusterProviderMockSetNodeLabelParams{ctx, key, value}

	// Record call args
	mmSetNodeLabel.SetNodeLabelMock.mutex.Lock()
	mmSetNodeLabel.SetNodeLabelMock.callArgs = append(mmSetNodeLabel.SetNodeLabelMock.callArgs, &mm_params)
	mmSetNodeLabel.SetNodeLabelMock.mutex.Unlock()

	for _, e := range mmSetNodeLabel.SetNodeLabelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetNodeLabel.SetNodeLabelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.Counter, 1)
		mm_want := mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.params
		mm_want_ptrs := mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.paramPtrs

		mm_got := ClusterProviderMockSetNodeLabelParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetNodeLabel.t.Errorf("ClusterProviderMock.SetNodeLabel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSetNodeLabel.t.Errorf("ClusterProviderMock.SetNodeLabel got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetNodeLabel.t.Errorf("ClusterProviderMock.SetNodeLabel got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetNodeLabel.t.Errorf("ClusterProviderMock.SetNodeLabel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.results
		if mm_results == nil {
			mmSetNodeLabel.t.Fatal("No results are set for the ClusterProviderMock.SetNodeLabel")
		}
		return (*mm_results).err
	}
	if mmSetNodeLabel.funcSetNodeLabel != nil {
		return mmSetNodeLabel.funcSetNodeLabel(ctx, key, value)
	}
	mmSetNodeLabel.t.Fatalf("Unexpected call to ClusterProviderMock.SetNodeLabel. %v %v %v", ctx, key, value)
	return
}

// SetNodeLabelAfterCounter returns a count of finished ClusterProviderMock.SetNodeLabel invocations
func (mmSetNodeLabel *ClusterProviderMock) SetNodeLabelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNodeLabel.afterSetNodeLabelCounter)
}

// SetNodeLabelBeforeCounter returns a count of ClusterProviderMock.SetNodeLabel invocations
func (mmSetNodeLabel *ClusterProviderMock) SetNodeLabelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNodeLabel.beforeSetNodeLabelCounter)
}

// Calls returns a list of arguments used in each call to ClusterProviderMock.SetNodeLabel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Calls() []*ClusterProviderMockSetNodeLabelParams {
	mmSetNodeLabel.mutex.RLock()

	argCopy := make([]*ClusterProviderMockSetNodeLabelParams, len(mmSetNodeLabel.callArgs))
	copy(argCopy, mmSetNodeLabel.callArgs)

	mmSetNodeLabel.mutex.RUnlock()

	return argCopy
}

// MinimockSetNodeLabelDone returns true if the count of the SetNodeLabel invocations corresponds
// the number of defined expectations
func (m *ClusterProviderMock) MinimockSetNodeLabelDone() bool {
	if m.SetNodeLabelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetNodeLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetNodeLabelMock.invocationsDone()
}

// MinimockSetNodeLabelInspect logs each unmet expectation
func (m *ClusterProviderMock) MinimockSetNodeLabelInspect() {
	for _, e := range m.SetNodeLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClusterProviderMock.SetNodeLabel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetNodeLabelCounter := mm_atomic.LoadUint64(&m.afterSetNodeLabelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetNodeLabelMock.defaultExpectation != nil && afterSetNodeLabelCounter < 1 {
		if m.SetNodeLabelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClusterProviderMock.SetNodeLabel at\n%s", m.SetNodeLabelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClusterProviderMock.SetNodeLabel at\n%s with params: %#v", m.SetNodeLabelMock.defaultExpectation.expectationOrigins.origin, *m.SetNodeLabelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetNodeLabel != nil && afterSetNodeLabelCounter < 1 {
		m.t.Errorf("Expected call to ClusterProviderMock.SetNodeLabel at\n%s", m.funcSetNodeLabelOrigin)
	}

	if !m.SetNodeLabelMock.invocationsDone() && afterSetNodeLabelCounter > 0 {
		m.t.Errorf("Expected %d calls to ClusterProviderMock.SetNodeLabel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetNodeLabelMock.expectedInvocations), m.SetNodeLabelMock.expectedInvocationsOrigin, afterSetNodeLabelCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClusterProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockIsAvailableInspect()

			m.MinimockIsMaintenanceModeInspect()

			m.MinimockRemoveNodeLabelInspect()

			m.MinimockSetNodeLabelInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClusterProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClusterProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsAvailableDone() &&
		m.MinimockIsMaintenanceModeDone() &&
		m.MinimockRemoveNodeLabelDone() &&
		m.MinimockSetNodeLabelDone()
}
