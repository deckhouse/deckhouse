// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package minimock

//go:generate minimock -i fencing-agent/internal/core/service.MemberlistProvider -o membelist_mock.go -n MemberlistProviderMock -p minimock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// MemberlistProviderMock implements mm_service.MemberlistProvider
type MemberlistProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcIsAlone          func() (b1 bool)
	funcIsAloneOrigin    string
	inspectFuncIsAlone   func()
	afterIsAloneCounter  uint64
	beforeIsAloneCounter uint64
	IsAloneMock          mMemberlistProviderMockIsAlone

	funcNumOtherMembers          func() (i1 int)
	funcNumOtherMembersOrigin    string
	inspectFuncNumOtherMembers   func()
	afterNumOtherMembersCounter  uint64
	beforeNumOtherMembersCounter uint64
	NumOtherMembersMock          mMemberlistProviderMockNumOtherMembers
}

// NewMemberlistProviderMock returns a mock for mm_service.MemberlistProvider
func NewMemberlistProviderMock(t minimock.Tester) *MemberlistProviderMock {
	m := &MemberlistProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsAloneMock = mMemberlistProviderMockIsAlone{mock: m}

	m.NumOtherMembersMock = mMemberlistProviderMockNumOtherMembers{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMemberlistProviderMockIsAlone struct {
	optional           bool
	mock               *MemberlistProviderMock
	defaultExpectation *MemberlistProviderMockIsAloneExpectation
	expectations       []*MemberlistProviderMockIsAloneExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MemberlistProviderMockIsAloneExpectation specifies expectation struct of the MemberlistProvider.IsAlone
type MemberlistProviderMockIsAloneExpectation struct {
	mock *MemberlistProviderMock

	results      *MemberlistProviderMockIsAloneResults
	returnOrigin string
	Counter      uint64
}

// MemberlistProviderMockIsAloneResults contains results of the MemberlistProvider.IsAlone
type MemberlistProviderMockIsAloneResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsAlone *mMemberlistProviderMockIsAlone) Optional() *mMemberlistProviderMockIsAlone {
	mmIsAlone.optional = true
	return mmIsAlone
}

// Expect sets up expected params for MemberlistProvider.IsAlone
func (mmIsAlone *mMemberlistProviderMockIsAlone) Expect() *mMemberlistProviderMockIsAlone {
	if mmIsAlone.mock.funcIsAlone != nil {
		mmIsAlone.mock.t.Fatalf("MemberlistProviderMock.IsAlone mock is already set by Set")
	}

	if mmIsAlone.defaultExpectation == nil {
		mmIsAlone.defaultExpectation = &MemberlistProviderMockIsAloneExpectation{}
	}

	return mmIsAlone
}

// Inspect accepts an inspector function that has same arguments as the MemberlistProvider.IsAlone
func (mmIsAlone *mMemberlistProviderMockIsAlone) Inspect(f func()) *mMemberlistProviderMockIsAlone {
	if mmIsAlone.mock.inspectFuncIsAlone != nil {
		mmIsAlone.mock.t.Fatalf("Inspect function is already set for MemberlistProviderMock.IsAlone")
	}

	mmIsAlone.mock.inspectFuncIsAlone = f

	return mmIsAlone
}

// Return sets up results that will be returned by MemberlistProvider.IsAlone
func (mmIsAlone *mMemberlistProviderMockIsAlone) Return(b1 bool) *MemberlistProviderMock {
	if mmIsAlone.mock.funcIsAlone != nil {
		mmIsAlone.mock.t.Fatalf("MemberlistProviderMock.IsAlone mock is already set by Set")
	}

	if mmIsAlone.defaultExpectation == nil {
		mmIsAlone.defaultExpectation = &MemberlistProviderMockIsAloneExpectation{mock: mmIsAlone.mock}
	}
	mmIsAlone.defaultExpectation.results = &MemberlistProviderMockIsAloneResults{b1}
	mmIsAlone.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsAlone.mock
}

// Set uses given function f to mock the MemberlistProvider.IsAlone method
func (mmIsAlone *mMemberlistProviderMockIsAlone) Set(f func() (b1 bool)) *MemberlistProviderMock {
	if mmIsAlone.defaultExpectation != nil {
		mmIsAlone.mock.t.Fatalf("Default expectation is already set for the MemberlistProvider.IsAlone method")
	}

	if len(mmIsAlone.expectations) > 0 {
		mmIsAlone.mock.t.Fatalf("Some expectations are already set for the MemberlistProvider.IsAlone method")
	}

	mmIsAlone.mock.funcIsAlone = f
	mmIsAlone.mock.funcIsAloneOrigin = minimock.CallerInfo(1)
	return mmIsAlone.mock
}

// Times sets number of times MemberlistProvider.IsAlone should be invoked
func (mmIsAlone *mMemberlistProviderMockIsAlone) Times(n uint64) *mMemberlistProviderMockIsAlone {
	if n == 0 {
		mmIsAlone.mock.t.Fatalf("Times of MemberlistProviderMock.IsAlone mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsAlone.expectedInvocations, n)
	mmIsAlone.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsAlone
}

func (mmIsAlone *mMemberlistProviderMockIsAlone) invocationsDone() bool {
	if len(mmIsAlone.expectations) == 0 && mmIsAlone.defaultExpectation == nil && mmIsAlone.mock.funcIsAlone == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsAlone.mock.afterIsAloneCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsAlone.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsAlone implements mm_service.MemberlistProvider
func (mmIsAlone *MemberlistProviderMock) IsAlone() (b1 bool) {
	mm_atomic.AddUint64(&mmIsAlone.beforeIsAloneCounter, 1)
	defer mm_atomic.AddUint64(&mmIsAlone.afterIsAloneCounter, 1)

	mmIsAlone.t.Helper()

	if mmIsAlone.inspectFuncIsAlone != nil {
		mmIsAlone.inspectFuncIsAlone()
	}

	if mmIsAlone.IsAloneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsAlone.IsAloneMock.defaultExpectation.Counter, 1)

		mm_results := mmIsAlone.IsAloneMock.defaultExpectation.results
		if mm_results == nil {
			mmIsAlone.t.Fatal("No results are set for the MemberlistProviderMock.IsAlone")
		}
		return (*mm_results).b1
	}
	if mmIsAlone.funcIsAlone != nil {
		return mmIsAlone.funcIsAlone()
	}
	mmIsAlone.t.Fatalf("Unexpected call to MemberlistProviderMock.IsAlone.")
	return
}

// IsAloneAfterCounter returns a count of finished MemberlistProviderMock.IsAlone invocations
func (mmIsAlone *MemberlistProviderMock) IsAloneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAlone.afterIsAloneCounter)
}

// IsAloneBeforeCounter returns a count of MemberlistProviderMock.IsAlone invocations
func (mmIsAlone *MemberlistProviderMock) IsAloneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAlone.beforeIsAloneCounter)
}

// MinimockIsAloneDone returns true if the count of the IsAlone invocations corresponds
// the number of defined expectations
func (m *MemberlistProviderMock) MinimockIsAloneDone() bool {
	if m.IsAloneMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsAloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsAloneMock.invocationsDone()
}

// MinimockIsAloneInspect logs each unmet expectation
func (m *MemberlistProviderMock) MinimockIsAloneInspect() {
	for _, e := range m.IsAloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberlistProviderMock.IsAlone")
		}
	}

	afterIsAloneCounter := mm_atomic.LoadUint64(&m.afterIsAloneCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsAloneMock.defaultExpectation != nil && afterIsAloneCounter < 1 {
		m.t.Errorf("Expected call to MemberlistProviderMock.IsAlone at\n%s", m.IsAloneMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAlone != nil && afterIsAloneCounter < 1 {
		m.t.Errorf("Expected call to MemberlistProviderMock.IsAlone at\n%s", m.funcIsAloneOrigin)
	}

	if !m.IsAloneMock.invocationsDone() && afterIsAloneCounter > 0 {
		m.t.Errorf("Expected %d calls to MemberlistProviderMock.IsAlone at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsAloneMock.expectedInvocations), m.IsAloneMock.expectedInvocationsOrigin, afterIsAloneCounter)
	}
}

type mMemberlistProviderMockNumOtherMembers struct {
	optional           bool
	mock               *MemberlistProviderMock
	defaultExpectation *MemberlistProviderMockNumOtherMembersExpectation
	expectations       []*MemberlistProviderMockNumOtherMembersExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MemberlistProviderMockNumOtherMembersExpectation specifies expectation struct of the MemberlistProvider.NumOtherMembers
type MemberlistProviderMockNumOtherMembersExpectation struct {
	mock *MemberlistProviderMock

	results      *MemberlistProviderMockNumOtherMembersResults
	returnOrigin string
	Counter      uint64
}

// MemberlistProviderMockNumOtherMembersResults contains results of the MemberlistProvider.NumOtherMembers
type MemberlistProviderMockNumOtherMembersResults struct {
	i1 int
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNumOtherMembers *mMemberlistProviderMockNumOtherMembers) Optional() *mMemberlistProviderMockNumOtherMembers {
	mmNumOtherMembers.optional = true
	return mmNumOtherMembers
}

// Expect sets up expected params for MemberlistProvider.NumOtherMembers
func (mmNumOtherMembers *mMemberlistProviderMockNumOtherMembers) Expect() *mMemberlistProviderMockNumOtherMembers {
	if mmNumOtherMembers.mock.funcNumOtherMembers != nil {
		mmNumOtherMembers.mock.t.Fatalf("MemberlistProviderMock.NumOtherMembers mock is already set by Set")
	}

	if mmNumOtherMembers.defaultExpectation == nil {
		mmNumOtherMembers.defaultExpectation = &MemberlistProviderMockNumOtherMembersExpectation{}
	}

	return mmNumOtherMembers
}

// Inspect accepts an inspector function that has same arguments as the MemberlistProvider.NumOtherMembers
func (mmNumOtherMembers *mMemberlistProviderMockNumOtherMembers) Inspect(f func()) *mMemberlistProviderMockNumOtherMembers {
	if mmNumOtherMembers.mock.inspectFuncNumOtherMembers != nil {
		mmNumOtherMembers.mock.t.Fatalf("Inspect function is already set for MemberlistProviderMock.NumOtherMembers")
	}

	mmNumOtherMembers.mock.inspectFuncNumOtherMembers = f

	return mmNumOtherMembers
}

// Return sets up results that will be returned by MemberlistProvider.NumOtherMembers
func (mmNumOtherMembers *mMemberlistProviderMockNumOtherMembers) Return(i1 int) *MemberlistProviderMock {
	if mmNumOtherMembers.mock.funcNumOtherMembers != nil {
		mmNumOtherMembers.mock.t.Fatalf("MemberlistProviderMock.NumOtherMembers mock is already set by Set")
	}

	if mmNumOtherMembers.defaultExpectation == nil {
		mmNumOtherMembers.defaultExpectation = &MemberlistProviderMockNumOtherMembersExpectation{mock: mmNumOtherMembers.mock}
	}
	mmNumOtherMembers.defaultExpectation.results = &MemberlistProviderMockNumOtherMembersResults{i1}
	mmNumOtherMembers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNumOtherMembers.mock
}

// Set uses given function f to mock the MemberlistProvider.NumOtherMembers method
func (mmNumOtherMembers *mMemberlistProviderMockNumOtherMembers) Set(f func() (i1 int)) *MemberlistProviderMock {
	if mmNumOtherMembers.defaultExpectation != nil {
		mmNumOtherMembers.mock.t.Fatalf("Default expectation is already set for the MemberlistProvider.NumOtherMembers method")
	}

	if len(mmNumOtherMembers.expectations) > 0 {
		mmNumOtherMembers.mock.t.Fatalf("Some expectations are already set for the MemberlistProvider.NumOtherMembers method")
	}

	mmNumOtherMembers.mock.funcNumOtherMembers = f
	mmNumOtherMembers.mock.funcNumOtherMembersOrigin = minimock.CallerInfo(1)
	return mmNumOtherMembers.mock
}

// Times sets number of times MemberlistProvider.NumOtherMembers should be invoked
func (mmNumOtherMembers *mMemberlistProviderMockNumOtherMembers) Times(n uint64) *mMemberlistProviderMockNumOtherMembers {
	if n == 0 {
		mmNumOtherMembers.mock.t.Fatalf("Times of MemberlistProviderMock.NumOtherMembers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNumOtherMembers.expectedInvocations, n)
	mmNumOtherMembers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNumOtherMembers
}

func (mmNumOtherMembers *mMemberlistProviderMockNumOtherMembers) invocationsDone() bool {
	if len(mmNumOtherMembers.expectations) == 0 && mmNumOtherMembers.defaultExpectation == nil && mmNumOtherMembers.mock.funcNumOtherMembers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNumOtherMembers.mock.afterNumOtherMembersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNumOtherMembers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NumOtherMembers implements mm_service.MemberlistProvider
func (mmNumOtherMembers *MemberlistProviderMock) NumOtherMembers() (i1 int) {
	mm_atomic.AddUint64(&mmNumOtherMembers.beforeNumOtherMembersCounter, 1)
	defer mm_atomic.AddUint64(&mmNumOtherMembers.afterNumOtherMembersCounter, 1)

	mmNumOtherMembers.t.Helper()

	if mmNumOtherMembers.inspectFuncNumOtherMembers != nil {
		mmNumOtherMembers.inspectFuncNumOtherMembers()
	}

	if mmNumOtherMembers.NumOtherMembersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNumOtherMembers.NumOtherMembersMock.defaultExpectation.Counter, 1)

		mm_results := mmNumOtherMembers.NumOtherMembersMock.defaultExpectation.results
		if mm_results == nil {
			mmNumOtherMembers.t.Fatal("No results are set for the MemberlistProviderMock.NumOtherMembers")
		}
		return (*mm_results).i1
	}
	if mmNumOtherMembers.funcNumOtherMembers != nil {
		return mmNumOtherMembers.funcNumOtherMembers()
	}
	mmNumOtherMembers.t.Fatalf("Unexpected call to MemberlistProviderMock.NumOtherMembers.")
	return
}

// NumOtherMembersAfterCounter returns a count of finished MemberlistProviderMock.NumOtherMembers invocations
func (mmNumOtherMembers *MemberlistProviderMock) NumOtherMembersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNumOtherMembers.afterNumOtherMembersCounter)
}

// NumOtherMembersBeforeCounter returns a count of MemberlistProviderMock.NumOtherMembers invocations
func (mmNumOtherMembers *MemberlistProviderMock) NumOtherMembersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNumOtherMembers.beforeNumOtherMembersCounter)
}

// MinimockNumOtherMembersDone returns true if the count of the NumOtherMembers invocations corresponds
// the number of defined expectations
func (m *MemberlistProviderMock) MinimockNumOtherMembersDone() bool {
	if m.NumOtherMembersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NumOtherMembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NumOtherMembersMock.invocationsDone()
}

// MinimockNumOtherMembersInspect logs each unmet expectation
func (m *MemberlistProviderMock) MinimockNumOtherMembersInspect() {
	for _, e := range m.NumOtherMembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberlistProviderMock.NumOtherMembers")
		}
	}

	afterNumOtherMembersCounter := mm_atomic.LoadUint64(&m.afterNumOtherMembersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NumOtherMembersMock.defaultExpectation != nil && afterNumOtherMembersCounter < 1 {
		m.t.Errorf("Expected call to MemberlistProviderMock.NumOtherMembers at\n%s", m.NumOtherMembersMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNumOtherMembers != nil && afterNumOtherMembersCounter < 1 {
		m.t.Errorf("Expected call to MemberlistProviderMock.NumOtherMembers at\n%s", m.funcNumOtherMembersOrigin)
	}

	if !m.NumOtherMembersMock.invocationsDone() && afterNumOtherMembersCounter > 0 {
		m.t.Errorf("Expected %d calls to MemberlistProviderMock.NumOtherMembers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NumOtherMembersMock.expectedInvocations), m.NumOtherMembersMock.expectedInvocationsOrigin, afterNumOtherMembersCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MemberlistProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockIsAloneInspect()

			m.MinimockNumOtherMembersInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MemberlistProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MemberlistProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsAloneDone() &&
		m.MinimockNumOtherMembersDone()
}
