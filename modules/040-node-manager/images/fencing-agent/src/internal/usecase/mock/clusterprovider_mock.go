// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// ClusterProviderMock implements mm_usecase.ClusterProvider
type ClusterProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcRemoveNodeLabel          func(ctx context.Context, key string) (err error)
	funcRemoveNodeLabelOrigin    string
	inspectFuncRemoveNodeLabel   func(ctx context.Context, key string)
	afterRemoveNodeLabelCounter  uint64
	beforeRemoveNodeLabelCounter uint64
	RemoveNodeLabelMock          mClusterProviderMockRemoveNodeLabel

	funcSetNodeLabel          func(ctx context.Context, key string, value string) (err error)
	funcSetNodeLabelOrigin    string
	inspectFuncSetNodeLabel   func(ctx context.Context, key string, value string)
	afterSetNodeLabelCounter  uint64
	beforeSetNodeLabelCounter uint64
	SetNodeLabelMock          mClusterProviderMockSetNodeLabel
}

// NewClusterProviderMock returns a mock for mm_usecase.ClusterProvider
func NewClusterProviderMock(t minimock.Tester) *ClusterProviderMock {
	m := &ClusterProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.RemoveNodeLabelMock = mClusterProviderMockRemoveNodeLabel{mock: m}
	m.RemoveNodeLabelMock.callArgs = []*ClusterProviderMockRemoveNodeLabelParams{}

	m.SetNodeLabelMock = mClusterProviderMockSetNodeLabel{mock: m}
	m.SetNodeLabelMock.callArgs = []*ClusterProviderMockSetNodeLabelParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClusterProviderMockRemoveNodeLabel struct {
	optional           bool
	mock               *ClusterProviderMock
	defaultExpectation *ClusterProviderMockRemoveNodeLabelExpectation
	expectations       []*ClusterProviderMockRemoveNodeLabelExpectation

	callArgs []*ClusterProviderMockRemoveNodeLabelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClusterProviderMockRemoveNodeLabelExpectation specifies expectation struct of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelExpectation struct {
	mock               *ClusterProviderMock
	params             *ClusterProviderMockRemoveNodeLabelParams
	paramPtrs          *ClusterProviderMockRemoveNodeLabelParamPtrs
	expectationOrigins ClusterProviderMockRemoveNodeLabelExpectationOrigins
	results            *ClusterProviderMockRemoveNodeLabelResults
	returnOrigin       string
	Counter            uint64
}

// ClusterProviderMockRemoveNodeLabelParams contains parameters of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelParams struct {
	ctx context.Context
	key string
}

// ClusterProviderMockRemoveNodeLabelParamPtrs contains pointers to parameters of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelParamPtrs struct {
	ctx *context.Context
	key *string
}

// ClusterProviderMockRemoveNodeLabelResults contains results of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelResults struct {
	err error
}

// ClusterProviderMockRemoveNodeLabelOrigins contains origins of expectations of the ClusterProvider.RemoveNodeLabel
type ClusterProviderMockRemoveNodeLabelExpectationOrigins struct {
	origin    string
	originCtx string
	originKey string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Optional() *mClusterProviderMockRemoveNodeLabel {
	mmRemoveNodeLabel.optional = true
	return mmRemoveNodeLabel
}

// Expect sets up expected params for ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Expect(ctx context.Context, key string) *mClusterProviderMockRemoveNodeLabel {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	if mmRemoveNodeLabel.defaultExpectation == nil {
		mmRemoveNodeLabel.defaultExpectation = &ClusterProviderMockRemoveNodeLabelExpectation{}
	}

	if mmRemoveNodeLabel.defaultExpectation.paramPtrs != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by ExpectParams functions")
	}

	mmRemoveNodeLabel.defaultExpectation.params = &ClusterProviderMockRemoveNodeLabelParams{ctx, key}
	mmRemoveNodeLabel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmRemoveNodeLabel.expectations {
		if minimock.Equal(e.params, mmRemoveNodeLabel.defaultExpectation.params) {
			mmRemoveNodeLabel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmRemoveNodeLabel.defaultExpectation.params)
		}
	}

	return mmRemoveNodeLabel
}

// ExpectCtxParam1 sets up expected param ctx for ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) ExpectCtxParam1(ctx context.Context) *mClusterProviderMockRemoveNodeLabel {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	if mmRemoveNodeLabel.defaultExpectation == nil {
		mmRemoveNodeLabel.defaultExpectation = &ClusterProviderMockRemoveNodeLabelExpectation{}
	}

	if mmRemoveNodeLabel.defaultExpectation.params != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Expect")
	}

	if mmRemoveNodeLabel.defaultExpectation.paramPtrs == nil {
		mmRemoveNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockRemoveNodeLabelParamPtrs{}
	}
	mmRemoveNodeLabel.defaultExpectation.paramPtrs.ctx = &ctx
	mmRemoveNodeLabel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmRemoveNodeLabel
}

// ExpectKeyParam2 sets up expected param key for ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) ExpectKeyParam2(key string) *mClusterProviderMockRemoveNodeLabel {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	if mmRemoveNodeLabel.defaultExpectation == nil {
		mmRemoveNodeLabel.defaultExpectation = &ClusterProviderMockRemoveNodeLabelExpectation{}
	}

	if mmRemoveNodeLabel.defaultExpectation.params != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Expect")
	}

	if mmRemoveNodeLabel.defaultExpectation.paramPtrs == nil {
		mmRemoveNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockRemoveNodeLabelParamPtrs{}
	}
	mmRemoveNodeLabel.defaultExpectation.paramPtrs.key = &key
	mmRemoveNodeLabel.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmRemoveNodeLabel
}

// Inspect accepts an inspector function that has same arguments as the ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Inspect(f func(ctx context.Context, key string)) *mClusterProviderMockRemoveNodeLabel {
	if mmRemoveNodeLabel.mock.inspectFuncRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("Inspect function is already set for ClusterProviderMock.RemoveNodeLabel")
	}

	mmRemoveNodeLabel.mock.inspectFuncRemoveNodeLabel = f

	return mmRemoveNodeLabel
}

// Return sets up results that will be returned by ClusterProvider.RemoveNodeLabel
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Return(err error) *ClusterProviderMock {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	if mmRemoveNodeLabel.defaultExpectation == nil {
		mmRemoveNodeLabel.defaultExpectation = &ClusterProviderMockRemoveNodeLabelExpectation{mock: mmRemoveNodeLabel.mock}
	}
	mmRemoveNodeLabel.defaultExpectation.results = &ClusterProviderMockRemoveNodeLabelResults{err}
	mmRemoveNodeLabel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmRemoveNodeLabel.mock
}

// Set uses given function f to mock the ClusterProvider.RemoveNodeLabel method
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Set(f func(ctx context.Context, key string) (err error)) *ClusterProviderMock {
	if mmRemoveNodeLabel.defaultExpectation != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("Default expectation is already set for the ClusterProvider.RemoveNodeLabel method")
	}

	if len(mmRemoveNodeLabel.expectations) > 0 {
		mmRemoveNodeLabel.mock.t.Fatalf("Some expectations are already set for the ClusterProvider.RemoveNodeLabel method")
	}

	mmRemoveNodeLabel.mock.funcRemoveNodeLabel = f
	mmRemoveNodeLabel.mock.funcRemoveNodeLabelOrigin = minimock.CallerInfo(1)
	return mmRemoveNodeLabel.mock
}

// When sets expectation for the ClusterProvider.RemoveNodeLabel which will trigger the result defined by the following
// Then helper
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) When(ctx context.Context, key string) *ClusterProviderMockRemoveNodeLabelExpectation {
	if mmRemoveNodeLabel.mock.funcRemoveNodeLabel != nil {
		mmRemoveNodeLabel.mock.t.Fatalf("ClusterProviderMock.RemoveNodeLabel mock is already set by Set")
	}

	expectation := &ClusterProviderMockRemoveNodeLabelExpectation{
		mock:               mmRemoveNodeLabel.mock,
		params:             &ClusterProviderMockRemoveNodeLabelParams{ctx, key},
		expectationOrigins: ClusterProviderMockRemoveNodeLabelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmRemoveNodeLabel.expectations = append(mmRemoveNodeLabel.expectations, expectation)
	return expectation
}

// Then sets up ClusterProvider.RemoveNodeLabel return parameters for the expectation previously defined by the When method
func (e *ClusterProviderMockRemoveNodeLabelExpectation) Then(err error) *ClusterProviderMock {
	e.results = &ClusterProviderMockRemoveNodeLabelResults{err}
	return e.mock
}

// Times sets number of times ClusterProvider.RemoveNodeLabel should be invoked
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Times(n uint64) *mClusterProviderMockRemoveNodeLabel {
	if n == 0 {
		mmRemoveNodeLabel.mock.t.Fatalf("Times of ClusterProviderMock.RemoveNodeLabel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmRemoveNodeLabel.expectedInvocations, n)
	mmRemoveNodeLabel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmRemoveNodeLabel
}

func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) invocationsDone() bool {
	if len(mmRemoveNodeLabel.expectations) == 0 && mmRemoveNodeLabel.defaultExpectation == nil && mmRemoveNodeLabel.mock.funcRemoveNodeLabel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmRemoveNodeLabel.mock.afterRemoveNodeLabelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmRemoveNodeLabel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// RemoveNodeLabel implements mm_usecase.ClusterProvider
func (mmRemoveNodeLabel *ClusterProviderMock) RemoveNodeLabel(ctx context.Context, key string) (err error) {
	mm_atomic.AddUint64(&mmRemoveNodeLabel.beforeRemoveNodeLabelCounter, 1)
	defer mm_atomic.AddUint64(&mmRemoveNodeLabel.afterRemoveNodeLabelCounter, 1)

	mmRemoveNodeLabel.t.Helper()

	if mmRemoveNodeLabel.inspectFuncRemoveNodeLabel != nil {
		mmRemoveNodeLabel.inspectFuncRemoveNodeLabel(ctx, key)
	}

	mm_params := ClusterProviderMockRemoveNodeLabelParams{ctx, key}

	// Record call args
	mmRemoveNodeLabel.RemoveNodeLabelMock.mutex.Lock()
	mmRemoveNodeLabel.RemoveNodeLabelMock.callArgs = append(mmRemoveNodeLabel.RemoveNodeLabelMock.callArgs, &mm_params)
	mmRemoveNodeLabel.RemoveNodeLabelMock.mutex.Unlock()

	for _, e := range mmRemoveNodeLabel.RemoveNodeLabelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.Counter, 1)
		mm_want := mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.params
		mm_want_ptrs := mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.paramPtrs

		mm_got := ClusterProviderMockRemoveNodeLabelParams{ctx, key}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmRemoveNodeLabel.t.Errorf("ClusterProviderMock.RemoveNodeLabel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmRemoveNodeLabel.t.Errorf("ClusterProviderMock.RemoveNodeLabel got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmRemoveNodeLabel.t.Errorf("ClusterProviderMock.RemoveNodeLabel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmRemoveNodeLabel.RemoveNodeLabelMock.defaultExpectation.results
		if mm_results == nil {
			mmRemoveNodeLabel.t.Fatal("No results are set for the ClusterProviderMock.RemoveNodeLabel")
		}
		return (*mm_results).err
	}
	if mmRemoveNodeLabel.funcRemoveNodeLabel != nil {
		return mmRemoveNodeLabel.funcRemoveNodeLabel(ctx, key)
	}
	mmRemoveNodeLabel.t.Fatalf("Unexpected call to ClusterProviderMock.RemoveNodeLabel. %v %v", ctx, key)
	return
}

// RemoveNodeLabelAfterCounter returns a count of finished ClusterProviderMock.RemoveNodeLabel invocations
func (mmRemoveNodeLabel *ClusterProviderMock) RemoveNodeLabelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveNodeLabel.afterRemoveNodeLabelCounter)
}

// RemoveNodeLabelBeforeCounter returns a count of ClusterProviderMock.RemoveNodeLabel invocations
func (mmRemoveNodeLabel *ClusterProviderMock) RemoveNodeLabelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmRemoveNodeLabel.beforeRemoveNodeLabelCounter)
}

// Calls returns a list of arguments used in each call to ClusterProviderMock.RemoveNodeLabel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmRemoveNodeLabel *mClusterProviderMockRemoveNodeLabel) Calls() []*ClusterProviderMockRemoveNodeLabelParams {
	mmRemoveNodeLabel.mutex.RLock()

	argCopy := make([]*ClusterProviderMockRemoveNodeLabelParams, len(mmRemoveNodeLabel.callArgs))
	copy(argCopy, mmRemoveNodeLabel.callArgs)

	mmRemoveNodeLabel.mutex.RUnlock()

	return argCopy
}

// MinimockRemoveNodeLabelDone returns true if the count of the RemoveNodeLabel invocations corresponds
// the number of defined expectations
func (m *ClusterProviderMock) MinimockRemoveNodeLabelDone() bool {
	if m.RemoveNodeLabelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.RemoveNodeLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.RemoveNodeLabelMock.invocationsDone()
}

// MinimockRemoveNodeLabelInspect logs each unmet expectation
func (m *ClusterProviderMock) MinimockRemoveNodeLabelInspect() {
	for _, e := range m.RemoveNodeLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClusterProviderMock.RemoveNodeLabel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterRemoveNodeLabelCounter := mm_atomic.LoadUint64(&m.afterRemoveNodeLabelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.RemoveNodeLabelMock.defaultExpectation != nil && afterRemoveNodeLabelCounter < 1 {
		if m.RemoveNodeLabelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClusterProviderMock.RemoveNodeLabel at\n%s", m.RemoveNodeLabelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClusterProviderMock.RemoveNodeLabel at\n%s with params: %#v", m.RemoveNodeLabelMock.defaultExpectation.expectationOrigins.origin, *m.RemoveNodeLabelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcRemoveNodeLabel != nil && afterRemoveNodeLabelCounter < 1 {
		m.t.Errorf("Expected call to ClusterProviderMock.RemoveNodeLabel at\n%s", m.funcRemoveNodeLabelOrigin)
	}

	if !m.RemoveNodeLabelMock.invocationsDone() && afterRemoveNodeLabelCounter > 0 {
		m.t.Errorf("Expected %d calls to ClusterProviderMock.RemoveNodeLabel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.RemoveNodeLabelMock.expectedInvocations), m.RemoveNodeLabelMock.expectedInvocationsOrigin, afterRemoveNodeLabelCounter)
	}
}

type mClusterProviderMockSetNodeLabel struct {
	optional           bool
	mock               *ClusterProviderMock
	defaultExpectation *ClusterProviderMockSetNodeLabelExpectation
	expectations       []*ClusterProviderMockSetNodeLabelExpectation

	callArgs []*ClusterProviderMockSetNodeLabelParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClusterProviderMockSetNodeLabelExpectation specifies expectation struct of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelExpectation struct {
	mock               *ClusterProviderMock
	params             *ClusterProviderMockSetNodeLabelParams
	paramPtrs          *ClusterProviderMockSetNodeLabelParamPtrs
	expectationOrigins ClusterProviderMockSetNodeLabelExpectationOrigins
	results            *ClusterProviderMockSetNodeLabelResults
	returnOrigin       string
	Counter            uint64
}

// ClusterProviderMockSetNodeLabelParams contains parameters of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelParams struct {
	ctx   context.Context
	key   string
	value string
}

// ClusterProviderMockSetNodeLabelParamPtrs contains pointers to parameters of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelParamPtrs struct {
	ctx   *context.Context
	key   *string
	value *string
}

// ClusterProviderMockSetNodeLabelResults contains results of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelResults struct {
	err error
}

// ClusterProviderMockSetNodeLabelOrigins contains origins of expectations of the ClusterProvider.SetNodeLabel
type ClusterProviderMockSetNodeLabelExpectationOrigins struct {
	origin      string
	originCtx   string
	originKey   string
	originValue string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Optional() *mClusterProviderMockSetNodeLabel {
	mmSetNodeLabel.optional = true
	return mmSetNodeLabel
}

// Expect sets up expected params for ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Expect(ctx context.Context, key string, value string) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{}
	}

	if mmSetNodeLabel.defaultExpectation.paramPtrs != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by ExpectParams functions")
	}

	mmSetNodeLabel.defaultExpectation.params = &ClusterProviderMockSetNodeLabelParams{ctx, key, value}
	mmSetNodeLabel.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmSetNodeLabel.expectations {
		if minimock.Equal(e.params, mmSetNodeLabel.defaultExpectation.params) {
			mmSetNodeLabel.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmSetNodeLabel.defaultExpectation.params)
		}
	}

	return mmSetNodeLabel
}

// ExpectCtxParam1 sets up expected param ctx for ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) ExpectCtxParam1(ctx context.Context) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{}
	}

	if mmSetNodeLabel.defaultExpectation.params != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Expect")
	}

	if mmSetNodeLabel.defaultExpectation.paramPtrs == nil {
		mmSetNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockSetNodeLabelParamPtrs{}
	}
	mmSetNodeLabel.defaultExpectation.paramPtrs.ctx = &ctx
	mmSetNodeLabel.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmSetNodeLabel
}

// ExpectKeyParam2 sets up expected param key for ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) ExpectKeyParam2(key string) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{}
	}

	if mmSetNodeLabel.defaultExpectation.params != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Expect")
	}

	if mmSetNodeLabel.defaultExpectation.paramPtrs == nil {
		mmSetNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockSetNodeLabelParamPtrs{}
	}
	mmSetNodeLabel.defaultExpectation.paramPtrs.key = &key
	mmSetNodeLabel.defaultExpectation.expectationOrigins.originKey = minimock.CallerInfo(1)

	return mmSetNodeLabel
}

// ExpectValueParam3 sets up expected param value for ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) ExpectValueParam3(value string) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{}
	}

	if mmSetNodeLabel.defaultExpectation.params != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Expect")
	}

	if mmSetNodeLabel.defaultExpectation.paramPtrs == nil {
		mmSetNodeLabel.defaultExpectation.paramPtrs = &ClusterProviderMockSetNodeLabelParamPtrs{}
	}
	mmSetNodeLabel.defaultExpectation.paramPtrs.value = &value
	mmSetNodeLabel.defaultExpectation.expectationOrigins.originValue = minimock.CallerInfo(1)

	return mmSetNodeLabel
}

// Inspect accepts an inspector function that has same arguments as the ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Inspect(f func(ctx context.Context, key string, value string)) *mClusterProviderMockSetNodeLabel {
	if mmSetNodeLabel.mock.inspectFuncSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("Inspect function is already set for ClusterProviderMock.SetNodeLabel")
	}

	mmSetNodeLabel.mock.inspectFuncSetNodeLabel = f

	return mmSetNodeLabel
}

// Return sets up results that will be returned by ClusterProvider.SetNodeLabel
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Return(err error) *ClusterProviderMock {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	if mmSetNodeLabel.defaultExpectation == nil {
		mmSetNodeLabel.defaultExpectation = &ClusterProviderMockSetNodeLabelExpectation{mock: mmSetNodeLabel.mock}
	}
	mmSetNodeLabel.defaultExpectation.results = &ClusterProviderMockSetNodeLabelResults{err}
	mmSetNodeLabel.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmSetNodeLabel.mock
}

// Set uses given function f to mock the ClusterProvider.SetNodeLabel method
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Set(f func(ctx context.Context, key string, value string) (err error)) *ClusterProviderMock {
	if mmSetNodeLabel.defaultExpectation != nil {
		mmSetNodeLabel.mock.t.Fatalf("Default expectation is already set for the ClusterProvider.SetNodeLabel method")
	}

	if len(mmSetNodeLabel.expectations) > 0 {
		mmSetNodeLabel.mock.t.Fatalf("Some expectations are already set for the ClusterProvider.SetNodeLabel method")
	}

	mmSetNodeLabel.mock.funcSetNodeLabel = f
	mmSetNodeLabel.mock.funcSetNodeLabelOrigin = minimock.CallerInfo(1)
	return mmSetNodeLabel.mock
}

// When sets expectation for the ClusterProvider.SetNodeLabel which will trigger the result defined by the following
// Then helper
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) When(ctx context.Context, key string, value string) *ClusterProviderMockSetNodeLabelExpectation {
	if mmSetNodeLabel.mock.funcSetNodeLabel != nil {
		mmSetNodeLabel.mock.t.Fatalf("ClusterProviderMock.SetNodeLabel mock is already set by Set")
	}

	expectation := &ClusterProviderMockSetNodeLabelExpectation{
		mock:               mmSetNodeLabel.mock,
		params:             &ClusterProviderMockSetNodeLabelParams{ctx, key, value},
		expectationOrigins: ClusterProviderMockSetNodeLabelExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmSetNodeLabel.expectations = append(mmSetNodeLabel.expectations, expectation)
	return expectation
}

// Then sets up ClusterProvider.SetNodeLabel return parameters for the expectation previously defined by the When method
func (e *ClusterProviderMockSetNodeLabelExpectation) Then(err error) *ClusterProviderMock {
	e.results = &ClusterProviderMockSetNodeLabelResults{err}
	return e.mock
}

// Times sets number of times ClusterProvider.SetNodeLabel should be invoked
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Times(n uint64) *mClusterProviderMockSetNodeLabel {
	if n == 0 {
		mmSetNodeLabel.mock.t.Fatalf("Times of ClusterProviderMock.SetNodeLabel mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmSetNodeLabel.expectedInvocations, n)
	mmSetNodeLabel.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmSetNodeLabel
}

func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) invocationsDone() bool {
	if len(mmSetNodeLabel.expectations) == 0 && mmSetNodeLabel.defaultExpectation == nil && mmSetNodeLabel.mock.funcSetNodeLabel == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmSetNodeLabel.mock.afterSetNodeLabelCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmSetNodeLabel.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// SetNodeLabel implements mm_usecase.ClusterProvider
func (mmSetNodeLabel *ClusterProviderMock) SetNodeLabel(ctx context.Context, key string, value string) (err error) {
	mm_atomic.AddUint64(&mmSetNodeLabel.beforeSetNodeLabelCounter, 1)
	defer mm_atomic.AddUint64(&mmSetNodeLabel.afterSetNodeLabelCounter, 1)

	mmSetNodeLabel.t.Helper()

	if mmSetNodeLabel.inspectFuncSetNodeLabel != nil {
		mmSetNodeLabel.inspectFuncSetNodeLabel(ctx, key, value)
	}

	mm_params := ClusterProviderMockSetNodeLabelParams{ctx, key, value}

	// Record call args
	mmSetNodeLabel.SetNodeLabelMock.mutex.Lock()
	mmSetNodeLabel.SetNodeLabelMock.callArgs = append(mmSetNodeLabel.SetNodeLabelMock.callArgs, &mm_params)
	mmSetNodeLabel.SetNodeLabelMock.mutex.Unlock()

	for _, e := range mmSetNodeLabel.SetNodeLabelMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.err
		}
	}

	if mmSetNodeLabel.SetNodeLabelMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.Counter, 1)
		mm_want := mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.params
		mm_want_ptrs := mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.paramPtrs

		mm_got := ClusterProviderMockSetNodeLabelParams{ctx, key, value}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmSetNodeLabel.t.Errorf("ClusterProviderMock.SetNodeLabel got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.key != nil && !minimock.Equal(*mm_want_ptrs.key, mm_got.key) {
				mmSetNodeLabel.t.Errorf("ClusterProviderMock.SetNodeLabel got unexpected parameter key, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.expectationOrigins.originKey, *mm_want_ptrs.key, mm_got.key, minimock.Diff(*mm_want_ptrs.key, mm_got.key))
			}

			if mm_want_ptrs.value != nil && !minimock.Equal(*mm_want_ptrs.value, mm_got.value) {
				mmSetNodeLabel.t.Errorf("ClusterProviderMock.SetNodeLabel got unexpected parameter value, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.expectationOrigins.originValue, *mm_want_ptrs.value, mm_got.value, minimock.Diff(*mm_want_ptrs.value, mm_got.value))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmSetNodeLabel.t.Errorf("ClusterProviderMock.SetNodeLabel got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmSetNodeLabel.SetNodeLabelMock.defaultExpectation.results
		if mm_results == nil {
			mmSetNodeLabel.t.Fatal("No results are set for the ClusterProviderMock.SetNodeLabel")
		}
		return (*mm_results).err
	}
	if mmSetNodeLabel.funcSetNodeLabel != nil {
		return mmSetNodeLabel.funcSetNodeLabel(ctx, key, value)
	}
	mmSetNodeLabel.t.Fatalf("Unexpected call to ClusterProviderMock.SetNodeLabel. %v %v %v", ctx, key, value)
	return
}

// SetNodeLabelAfterCounter returns a count of finished ClusterProviderMock.SetNodeLabel invocations
func (mmSetNodeLabel *ClusterProviderMock) SetNodeLabelAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNodeLabel.afterSetNodeLabelCounter)
}

// SetNodeLabelBeforeCounter returns a count of ClusterProviderMock.SetNodeLabel invocations
func (mmSetNodeLabel *ClusterProviderMock) SetNodeLabelBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmSetNodeLabel.beforeSetNodeLabelCounter)
}

// Calls returns a list of arguments used in each call to ClusterProviderMock.SetNodeLabel.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmSetNodeLabel *mClusterProviderMockSetNodeLabel) Calls() []*ClusterProviderMockSetNodeLabelParams {
	mmSetNodeLabel.mutex.RLock()

	argCopy := make([]*ClusterProviderMockSetNodeLabelParams, len(mmSetNodeLabel.callArgs))
	copy(argCopy, mmSetNodeLabel.callArgs)

	mmSetNodeLabel.mutex.RUnlock()

	return argCopy
}

// MinimockSetNodeLabelDone returns true if the count of the SetNodeLabel invocations corresponds
// the number of defined expectations
func (m *ClusterProviderMock) MinimockSetNodeLabelDone() bool {
	if m.SetNodeLabelMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.SetNodeLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.SetNodeLabelMock.invocationsDone()
}

// MinimockSetNodeLabelInspect logs each unmet expectation
func (m *ClusterProviderMock) MinimockSetNodeLabelInspect() {
	for _, e := range m.SetNodeLabelMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClusterProviderMock.SetNodeLabel at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterSetNodeLabelCounter := mm_atomic.LoadUint64(&m.afterSetNodeLabelCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.SetNodeLabelMock.defaultExpectation != nil && afterSetNodeLabelCounter < 1 {
		if m.SetNodeLabelMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClusterProviderMock.SetNodeLabel at\n%s", m.SetNodeLabelMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClusterProviderMock.SetNodeLabel at\n%s with params: %#v", m.SetNodeLabelMock.defaultExpectation.expectationOrigins.origin, *m.SetNodeLabelMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcSetNodeLabel != nil && afterSetNodeLabelCounter < 1 {
		m.t.Errorf("Expected call to ClusterProviderMock.SetNodeLabel at\n%s", m.funcSetNodeLabelOrigin)
	}

	if !m.SetNodeLabelMock.invocationsDone() && afterSetNodeLabelCounter > 0 {
		m.t.Errorf("Expected %d calls to ClusterProviderMock.SetNodeLabel at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.SetNodeLabelMock.expectedInvocations), m.SetNodeLabelMock.expectedInvocationsOrigin, afterSetNodeLabelCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClusterProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockRemoveNodeLabelInspect()

			m.MinimockSetNodeLabelInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClusterProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClusterProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockRemoveNodeLabelDone() &&
		m.MinimockSetNodeLabelDone()
}
