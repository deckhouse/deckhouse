// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// MemberlistProviderMock implements mm_usecase.MemberlistProvider
type MemberlistProviderMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcIsAlone          func() (b1 bool)
	funcIsAloneOrigin    string
	inspectFuncIsAlone   func()
	afterIsAloneCounter  uint64
	beforeIsAloneCounter uint64
	IsAloneMock          mMemberlistProviderMockIsAlone

	funcNumMembers          func() (i1 int)
	funcNumMembersOrigin    string
	inspectFuncNumMembers   func()
	afterNumMembersCounter  uint64
	beforeNumMembersCounter uint64
	NumMembersMock          mMemberlistProviderMockNumMembers
}

// NewMemberlistProviderMock returns a mock for mm_usecase.MemberlistProvider
func NewMemberlistProviderMock(t minimock.Tester) *MemberlistProviderMock {
	m := &MemberlistProviderMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.IsAloneMock = mMemberlistProviderMockIsAlone{mock: m}

	m.NumMembersMock = mMemberlistProviderMockNumMembers{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mMemberlistProviderMockIsAlone struct {
	optional           bool
	mock               *MemberlistProviderMock
	defaultExpectation *MemberlistProviderMockIsAloneExpectation
	expectations       []*MemberlistProviderMockIsAloneExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MemberlistProviderMockIsAloneExpectation specifies expectation struct of the MemberlistProvider.IsAlone
type MemberlistProviderMockIsAloneExpectation struct {
	mock *MemberlistProviderMock

	results      *MemberlistProviderMockIsAloneResults
	returnOrigin string
	Counter      uint64
}

// MemberlistProviderMockIsAloneResults contains results of the MemberlistProvider.IsAlone
type MemberlistProviderMockIsAloneResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsAlone *mMemberlistProviderMockIsAlone) Optional() *mMemberlistProviderMockIsAlone {
	mmIsAlone.optional = true
	return mmIsAlone
}

// Expect sets up expected params for MemberlistProvider.IsAlone
func (mmIsAlone *mMemberlistProviderMockIsAlone) Expect() *mMemberlistProviderMockIsAlone {
	if mmIsAlone.mock.funcIsAlone != nil {
		mmIsAlone.mock.t.Fatalf("MemberlistProviderMock.IsAlone mock is already set by Set")
	}

	if mmIsAlone.defaultExpectation == nil {
		mmIsAlone.defaultExpectation = &MemberlistProviderMockIsAloneExpectation{}
	}

	return mmIsAlone
}

// Inspect accepts an inspector function that has same arguments as the MemberlistProvider.IsAlone
func (mmIsAlone *mMemberlistProviderMockIsAlone) Inspect(f func()) *mMemberlistProviderMockIsAlone {
	if mmIsAlone.mock.inspectFuncIsAlone != nil {
		mmIsAlone.mock.t.Fatalf("Inspect function is already set for MemberlistProviderMock.IsAlone")
	}

	mmIsAlone.mock.inspectFuncIsAlone = f

	return mmIsAlone
}

// Return sets up results that will be returned by MemberlistProvider.IsAlone
func (mmIsAlone *mMemberlistProviderMockIsAlone) Return(b1 bool) *MemberlistProviderMock {
	if mmIsAlone.mock.funcIsAlone != nil {
		mmIsAlone.mock.t.Fatalf("MemberlistProviderMock.IsAlone mock is already set by Set")
	}

	if mmIsAlone.defaultExpectation == nil {
		mmIsAlone.defaultExpectation = &MemberlistProviderMockIsAloneExpectation{mock: mmIsAlone.mock}
	}
	mmIsAlone.defaultExpectation.results = &MemberlistProviderMockIsAloneResults{b1}
	mmIsAlone.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsAlone.mock
}

// Set uses given function f to mock the MemberlistProvider.IsAlone method
func (mmIsAlone *mMemberlistProviderMockIsAlone) Set(f func() (b1 bool)) *MemberlistProviderMock {
	if mmIsAlone.defaultExpectation != nil {
		mmIsAlone.mock.t.Fatalf("Default expectation is already set for the MemberlistProvider.IsAlone method")
	}

	if len(mmIsAlone.expectations) > 0 {
		mmIsAlone.mock.t.Fatalf("Some expectations are already set for the MemberlistProvider.IsAlone method")
	}

	mmIsAlone.mock.funcIsAlone = f
	mmIsAlone.mock.funcIsAloneOrigin = minimock.CallerInfo(1)
	return mmIsAlone.mock
}

// Times sets number of times MemberlistProvider.IsAlone should be invoked
func (mmIsAlone *mMemberlistProviderMockIsAlone) Times(n uint64) *mMemberlistProviderMockIsAlone {
	if n == 0 {
		mmIsAlone.mock.t.Fatalf("Times of MemberlistProviderMock.IsAlone mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsAlone.expectedInvocations, n)
	mmIsAlone.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsAlone
}

func (mmIsAlone *mMemberlistProviderMockIsAlone) invocationsDone() bool {
	if len(mmIsAlone.expectations) == 0 && mmIsAlone.defaultExpectation == nil && mmIsAlone.mock.funcIsAlone == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsAlone.mock.afterIsAloneCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsAlone.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsAlone implements mm_usecase.MemberlistProvider
func (mmIsAlone *MemberlistProviderMock) IsAlone() (b1 bool) {
	mm_atomic.AddUint64(&mmIsAlone.beforeIsAloneCounter, 1)
	defer mm_atomic.AddUint64(&mmIsAlone.afterIsAloneCounter, 1)

	mmIsAlone.t.Helper()

	if mmIsAlone.inspectFuncIsAlone != nil {
		mmIsAlone.inspectFuncIsAlone()
	}

	if mmIsAlone.IsAloneMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsAlone.IsAloneMock.defaultExpectation.Counter, 1)

		mm_results := mmIsAlone.IsAloneMock.defaultExpectation.results
		if mm_results == nil {
			mmIsAlone.t.Fatal("No results are set for the MemberlistProviderMock.IsAlone")
		}
		return (*mm_results).b1
	}
	if mmIsAlone.funcIsAlone != nil {
		return mmIsAlone.funcIsAlone()
	}
	mmIsAlone.t.Fatalf("Unexpected call to MemberlistProviderMock.IsAlone.")
	return
}

// IsAloneAfterCounter returns a count of finished MemberlistProviderMock.IsAlone invocations
func (mmIsAlone *MemberlistProviderMock) IsAloneAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAlone.afterIsAloneCounter)
}

// IsAloneBeforeCounter returns a count of MemberlistProviderMock.IsAlone invocations
func (mmIsAlone *MemberlistProviderMock) IsAloneBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsAlone.beforeIsAloneCounter)
}

// MinimockIsAloneDone returns true if the count of the IsAlone invocations corresponds
// the number of defined expectations
func (m *MemberlistProviderMock) MinimockIsAloneDone() bool {
	if m.IsAloneMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsAloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsAloneMock.invocationsDone()
}

// MinimockIsAloneInspect logs each unmet expectation
func (m *MemberlistProviderMock) MinimockIsAloneInspect() {
	for _, e := range m.IsAloneMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberlistProviderMock.IsAlone")
		}
	}

	afterIsAloneCounter := mm_atomic.LoadUint64(&m.afterIsAloneCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsAloneMock.defaultExpectation != nil && afterIsAloneCounter < 1 {
		m.t.Errorf("Expected call to MemberlistProviderMock.IsAlone at\n%s", m.IsAloneMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsAlone != nil && afterIsAloneCounter < 1 {
		m.t.Errorf("Expected call to MemberlistProviderMock.IsAlone at\n%s", m.funcIsAloneOrigin)
	}

	if !m.IsAloneMock.invocationsDone() && afterIsAloneCounter > 0 {
		m.t.Errorf("Expected %d calls to MemberlistProviderMock.IsAlone at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsAloneMock.expectedInvocations), m.IsAloneMock.expectedInvocationsOrigin, afterIsAloneCounter)
	}
}

type mMemberlistProviderMockNumMembers struct {
	optional           bool
	mock               *MemberlistProviderMock
	defaultExpectation *MemberlistProviderMockNumMembersExpectation
	expectations       []*MemberlistProviderMockNumMembersExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// MemberlistProviderMockNumMembersExpectation specifies expectation struct of the MemberlistProvider.NumMembers
type MemberlistProviderMockNumMembersExpectation struct {
	mock *MemberlistProviderMock

	results      *MemberlistProviderMockNumMembersResults
	returnOrigin string
	Counter      uint64
}

// MemberlistProviderMockNumMembersResults contains results of the MemberlistProvider.NumMembers
type MemberlistProviderMockNumMembersResults struct {
	i1 int
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmNumMembers *mMemberlistProviderMockNumMembers) Optional() *mMemberlistProviderMockNumMembers {
	mmNumMembers.optional = true
	return mmNumMembers
}

// Expect sets up expected params for MemberlistProvider.NumMembers
func (mmNumMembers *mMemberlistProviderMockNumMembers) Expect() *mMemberlistProviderMockNumMembers {
	if mmNumMembers.mock.funcNumMembers != nil {
		mmNumMembers.mock.t.Fatalf("MemberlistProviderMock.NumMembers mock is already set by Set")
	}

	if mmNumMembers.defaultExpectation == nil {
		mmNumMembers.defaultExpectation = &MemberlistProviderMockNumMembersExpectation{}
	}

	return mmNumMembers
}

// Inspect accepts an inspector function that has same arguments as the MemberlistProvider.NumMembers
func (mmNumMembers *mMemberlistProviderMockNumMembers) Inspect(f func()) *mMemberlistProviderMockNumMembers {
	if mmNumMembers.mock.inspectFuncNumMembers != nil {
		mmNumMembers.mock.t.Fatalf("Inspect function is already set for MemberlistProviderMock.NumMembers")
	}

	mmNumMembers.mock.inspectFuncNumMembers = f

	return mmNumMembers
}

// Return sets up results that will be returned by MemberlistProvider.NumMembers
func (mmNumMembers *mMemberlistProviderMockNumMembers) Return(i1 int) *MemberlistProviderMock {
	if mmNumMembers.mock.funcNumMembers != nil {
		mmNumMembers.mock.t.Fatalf("MemberlistProviderMock.NumMembers mock is already set by Set")
	}

	if mmNumMembers.defaultExpectation == nil {
		mmNumMembers.defaultExpectation = &MemberlistProviderMockNumMembersExpectation{mock: mmNumMembers.mock}
	}
	mmNumMembers.defaultExpectation.results = &MemberlistProviderMockNumMembersResults{i1}
	mmNumMembers.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmNumMembers.mock
}

// Set uses given function f to mock the MemberlistProvider.NumMembers method
func (mmNumMembers *mMemberlistProviderMockNumMembers) Set(f func() (i1 int)) *MemberlistProviderMock {
	if mmNumMembers.defaultExpectation != nil {
		mmNumMembers.mock.t.Fatalf("Default expectation is already set for the MemberlistProvider.NumMembers method")
	}

	if len(mmNumMembers.expectations) > 0 {
		mmNumMembers.mock.t.Fatalf("Some expectations are already set for the MemberlistProvider.NumMembers method")
	}

	mmNumMembers.mock.funcNumMembers = f
	mmNumMembers.mock.funcNumMembersOrigin = minimock.CallerInfo(1)
	return mmNumMembers.mock
}

// Times sets number of times MemberlistProvider.NumMembers should be invoked
func (mmNumMembers *mMemberlistProviderMockNumMembers) Times(n uint64) *mMemberlistProviderMockNumMembers {
	if n == 0 {
		mmNumMembers.mock.t.Fatalf("Times of MemberlistProviderMock.NumMembers mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmNumMembers.expectedInvocations, n)
	mmNumMembers.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmNumMembers
}

func (mmNumMembers *mMemberlistProviderMockNumMembers) invocationsDone() bool {
	if len(mmNumMembers.expectations) == 0 && mmNumMembers.defaultExpectation == nil && mmNumMembers.mock.funcNumMembers == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmNumMembers.mock.afterNumMembersCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmNumMembers.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// NumMembers implements mm_usecase.MemberlistProvider
func (mmNumMembers *MemberlistProviderMock) NumMembers() (i1 int) {
	mm_atomic.AddUint64(&mmNumMembers.beforeNumMembersCounter, 1)
	defer mm_atomic.AddUint64(&mmNumMembers.afterNumMembersCounter, 1)

	mmNumMembers.t.Helper()

	if mmNumMembers.inspectFuncNumMembers != nil {
		mmNumMembers.inspectFuncNumMembers()
	}

	if mmNumMembers.NumMembersMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmNumMembers.NumMembersMock.defaultExpectation.Counter, 1)

		mm_results := mmNumMembers.NumMembersMock.defaultExpectation.results
		if mm_results == nil {
			mmNumMembers.t.Fatal("No results are set for the MemberlistProviderMock.NumMembers")
		}
		return (*mm_results).i1
	}
	if mmNumMembers.funcNumMembers != nil {
		return mmNumMembers.funcNumMembers()
	}
	mmNumMembers.t.Fatalf("Unexpected call to MemberlistProviderMock.NumMembers.")
	return
}

// NumMembersAfterCounter returns a count of finished MemberlistProviderMock.NumMembers invocations
func (mmNumMembers *MemberlistProviderMock) NumMembersAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNumMembers.afterNumMembersCounter)
}

// NumMembersBeforeCounter returns a count of MemberlistProviderMock.NumMembers invocations
func (mmNumMembers *MemberlistProviderMock) NumMembersBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmNumMembers.beforeNumMembersCounter)
}

// MinimockNumMembersDone returns true if the count of the NumMembers invocations corresponds
// the number of defined expectations
func (m *MemberlistProviderMock) MinimockNumMembersDone() bool {
	if m.NumMembersMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NumMembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NumMembersMock.invocationsDone()
}

// MinimockNumMembersInspect logs each unmet expectation
func (m *MemberlistProviderMock) MinimockNumMembersInspect() {
	for _, e := range m.NumMembersMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to MemberlistProviderMock.NumMembers")
		}
	}

	afterNumMembersCounter := mm_atomic.LoadUint64(&m.afterNumMembersCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NumMembersMock.defaultExpectation != nil && afterNumMembersCounter < 1 {
		m.t.Errorf("Expected call to MemberlistProviderMock.NumMembers at\n%s", m.NumMembersMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcNumMembers != nil && afterNumMembersCounter < 1 {
		m.t.Errorf("Expected call to MemberlistProviderMock.NumMembers at\n%s", m.funcNumMembersOrigin)
	}

	if !m.NumMembersMock.invocationsDone() && afterNumMembersCounter > 0 {
		m.t.Errorf("Expected %d calls to MemberlistProviderMock.NumMembers at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NumMembersMock.expectedInvocations), m.NumMembersMock.expectedInvocationsOrigin, afterNumMembersCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *MemberlistProviderMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockIsAloneInspect()

			m.MinimockNumMembersInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *MemberlistProviderMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *MemberlistProviderMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockIsAloneDone() &&
		m.MinimockNumMembersDone()
}
