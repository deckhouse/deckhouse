// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package mock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
)

// WatchDogMock implements mm_usecase.WatchDog
type WatchDogMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcFeed          func() (err error)
	funcFeedOrigin    string
	inspectFuncFeed   func()
	afterFeedCounter  uint64
	beforeFeedCounter uint64
	FeedMock          mWatchDogMockFeed

	funcIsArmed          func() (b1 bool)
	funcIsArmedOrigin    string
	inspectFuncIsArmed   func()
	afterIsArmedCounter  uint64
	beforeIsArmedCounter uint64
	IsArmedMock          mWatchDogMockIsArmed

	funcStart          func() (err error)
	funcStartOrigin    string
	inspectFuncStart   func()
	afterStartCounter  uint64
	beforeStartCounter uint64
	StartMock          mWatchDogMockStart

	funcStop          func() (err error)
	funcStopOrigin    string
	inspectFuncStop   func()
	afterStopCounter  uint64
	beforeStopCounter uint64
	StopMock          mWatchDogMockStop
}

// NewWatchDogMock returns a mock for mm_usecase.WatchDog
func NewWatchDogMock(t minimock.Tester) *WatchDogMock {
	m := &WatchDogMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.FeedMock = mWatchDogMockFeed{mock: m}

	m.IsArmedMock = mWatchDogMockIsArmed{mock: m}

	m.StartMock = mWatchDogMockStart{mock: m}

	m.StopMock = mWatchDogMockStop{mock: m}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mWatchDogMockFeed struct {
	optional           bool
	mock               *WatchDogMock
	defaultExpectation *WatchDogMockFeedExpectation
	expectations       []*WatchDogMockFeedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WatchDogMockFeedExpectation specifies expectation struct of the WatchDog.Feed
type WatchDogMockFeedExpectation struct {
	mock *WatchDogMock

	results      *WatchDogMockFeedResults
	returnOrigin string
	Counter      uint64
}

// WatchDogMockFeedResults contains results of the WatchDog.Feed
type WatchDogMockFeedResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmFeed *mWatchDogMockFeed) Optional() *mWatchDogMockFeed {
	mmFeed.optional = true
	return mmFeed
}

// Expect sets up expected params for WatchDog.Feed
func (mmFeed *mWatchDogMockFeed) Expect() *mWatchDogMockFeed {
	if mmFeed.mock.funcFeed != nil {
		mmFeed.mock.t.Fatalf("WatchDogMock.Feed mock is already set by Set")
	}

	if mmFeed.defaultExpectation == nil {
		mmFeed.defaultExpectation = &WatchDogMockFeedExpectation{}
	}

	return mmFeed
}

// Inspect accepts an inspector function that has same arguments as the WatchDog.Feed
func (mmFeed *mWatchDogMockFeed) Inspect(f func()) *mWatchDogMockFeed {
	if mmFeed.mock.inspectFuncFeed != nil {
		mmFeed.mock.t.Fatalf("Inspect function is already set for WatchDogMock.Feed")
	}

	mmFeed.mock.inspectFuncFeed = f

	return mmFeed
}

// Return sets up results that will be returned by WatchDog.Feed
func (mmFeed *mWatchDogMockFeed) Return(err error) *WatchDogMock {
	if mmFeed.mock.funcFeed != nil {
		mmFeed.mock.t.Fatalf("WatchDogMock.Feed mock is already set by Set")
	}

	if mmFeed.defaultExpectation == nil {
		mmFeed.defaultExpectation = &WatchDogMockFeedExpectation{mock: mmFeed.mock}
	}
	mmFeed.defaultExpectation.results = &WatchDogMockFeedResults{err}
	mmFeed.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmFeed.mock
}

// Set uses given function f to mock the WatchDog.Feed method
func (mmFeed *mWatchDogMockFeed) Set(f func() (err error)) *WatchDogMock {
	if mmFeed.defaultExpectation != nil {
		mmFeed.mock.t.Fatalf("Default expectation is already set for the WatchDog.Feed method")
	}

	if len(mmFeed.expectations) > 0 {
		mmFeed.mock.t.Fatalf("Some expectations are already set for the WatchDog.Feed method")
	}

	mmFeed.mock.funcFeed = f
	mmFeed.mock.funcFeedOrigin = minimock.CallerInfo(1)
	return mmFeed.mock
}

// Times sets number of times WatchDog.Feed should be invoked
func (mmFeed *mWatchDogMockFeed) Times(n uint64) *mWatchDogMockFeed {
	if n == 0 {
		mmFeed.mock.t.Fatalf("Times of WatchDogMock.Feed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmFeed.expectedInvocations, n)
	mmFeed.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmFeed
}

func (mmFeed *mWatchDogMockFeed) invocationsDone() bool {
	if len(mmFeed.expectations) == 0 && mmFeed.defaultExpectation == nil && mmFeed.mock.funcFeed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmFeed.mock.afterFeedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmFeed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Feed implements mm_usecase.WatchDog
func (mmFeed *WatchDogMock) Feed() (err error) {
	mm_atomic.AddUint64(&mmFeed.beforeFeedCounter, 1)
	defer mm_atomic.AddUint64(&mmFeed.afterFeedCounter, 1)

	mmFeed.t.Helper()

	if mmFeed.inspectFuncFeed != nil {
		mmFeed.inspectFuncFeed()
	}

	if mmFeed.FeedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmFeed.FeedMock.defaultExpectation.Counter, 1)

		mm_results := mmFeed.FeedMock.defaultExpectation.results
		if mm_results == nil {
			mmFeed.t.Fatal("No results are set for the WatchDogMock.Feed")
		}
		return (*mm_results).err
	}
	if mmFeed.funcFeed != nil {
		return mmFeed.funcFeed()
	}
	mmFeed.t.Fatalf("Unexpected call to WatchDogMock.Feed.")
	return
}

// FeedAfterCounter returns a count of finished WatchDogMock.Feed invocations
func (mmFeed *WatchDogMock) FeedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFeed.afterFeedCounter)
}

// FeedBeforeCounter returns a count of WatchDogMock.Feed invocations
func (mmFeed *WatchDogMock) FeedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmFeed.beforeFeedCounter)
}

// MinimockFeedDone returns true if the count of the Feed invocations corresponds
// the number of defined expectations
func (m *WatchDogMock) MinimockFeedDone() bool {
	if m.FeedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.FeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.FeedMock.invocationsDone()
}

// MinimockFeedInspect logs each unmet expectation
func (m *WatchDogMock) MinimockFeedInspect() {
	for _, e := range m.FeedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WatchDogMock.Feed")
		}
	}

	afterFeedCounter := mm_atomic.LoadUint64(&m.afterFeedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.FeedMock.defaultExpectation != nil && afterFeedCounter < 1 {
		m.t.Errorf("Expected call to WatchDogMock.Feed at\n%s", m.FeedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcFeed != nil && afterFeedCounter < 1 {
		m.t.Errorf("Expected call to WatchDogMock.Feed at\n%s", m.funcFeedOrigin)
	}

	if !m.FeedMock.invocationsDone() && afterFeedCounter > 0 {
		m.t.Errorf("Expected %d calls to WatchDogMock.Feed at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.FeedMock.expectedInvocations), m.FeedMock.expectedInvocationsOrigin, afterFeedCounter)
	}
}

type mWatchDogMockIsArmed struct {
	optional           bool
	mock               *WatchDogMock
	defaultExpectation *WatchDogMockIsArmedExpectation
	expectations       []*WatchDogMockIsArmedExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WatchDogMockIsArmedExpectation specifies expectation struct of the WatchDog.IsArmed
type WatchDogMockIsArmedExpectation struct {
	mock *WatchDogMock

	results      *WatchDogMockIsArmedResults
	returnOrigin string
	Counter      uint64
}

// WatchDogMockIsArmedResults contains results of the WatchDog.IsArmed
type WatchDogMockIsArmedResults struct {
	b1 bool
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsArmed *mWatchDogMockIsArmed) Optional() *mWatchDogMockIsArmed {
	mmIsArmed.optional = true
	return mmIsArmed
}

// Expect sets up expected params for WatchDog.IsArmed
func (mmIsArmed *mWatchDogMockIsArmed) Expect() *mWatchDogMockIsArmed {
	if mmIsArmed.mock.funcIsArmed != nil {
		mmIsArmed.mock.t.Fatalf("WatchDogMock.IsArmed mock is already set by Set")
	}

	if mmIsArmed.defaultExpectation == nil {
		mmIsArmed.defaultExpectation = &WatchDogMockIsArmedExpectation{}
	}

	return mmIsArmed
}

// Inspect accepts an inspector function that has same arguments as the WatchDog.IsArmed
func (mmIsArmed *mWatchDogMockIsArmed) Inspect(f func()) *mWatchDogMockIsArmed {
	if mmIsArmed.mock.inspectFuncIsArmed != nil {
		mmIsArmed.mock.t.Fatalf("Inspect function is already set for WatchDogMock.IsArmed")
	}

	mmIsArmed.mock.inspectFuncIsArmed = f

	return mmIsArmed
}

// Return sets up results that will be returned by WatchDog.IsArmed
func (mmIsArmed *mWatchDogMockIsArmed) Return(b1 bool) *WatchDogMock {
	if mmIsArmed.mock.funcIsArmed != nil {
		mmIsArmed.mock.t.Fatalf("WatchDogMock.IsArmed mock is already set by Set")
	}

	if mmIsArmed.defaultExpectation == nil {
		mmIsArmed.defaultExpectation = &WatchDogMockIsArmedExpectation{mock: mmIsArmed.mock}
	}
	mmIsArmed.defaultExpectation.results = &WatchDogMockIsArmedResults{b1}
	mmIsArmed.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsArmed.mock
}

// Set uses given function f to mock the WatchDog.IsArmed method
func (mmIsArmed *mWatchDogMockIsArmed) Set(f func() (b1 bool)) *WatchDogMock {
	if mmIsArmed.defaultExpectation != nil {
		mmIsArmed.mock.t.Fatalf("Default expectation is already set for the WatchDog.IsArmed method")
	}

	if len(mmIsArmed.expectations) > 0 {
		mmIsArmed.mock.t.Fatalf("Some expectations are already set for the WatchDog.IsArmed method")
	}

	mmIsArmed.mock.funcIsArmed = f
	mmIsArmed.mock.funcIsArmedOrigin = minimock.CallerInfo(1)
	return mmIsArmed.mock
}

// Times sets number of times WatchDog.IsArmed should be invoked
func (mmIsArmed *mWatchDogMockIsArmed) Times(n uint64) *mWatchDogMockIsArmed {
	if n == 0 {
		mmIsArmed.mock.t.Fatalf("Times of WatchDogMock.IsArmed mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsArmed.expectedInvocations, n)
	mmIsArmed.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsArmed
}

func (mmIsArmed *mWatchDogMockIsArmed) invocationsDone() bool {
	if len(mmIsArmed.expectations) == 0 && mmIsArmed.defaultExpectation == nil && mmIsArmed.mock.funcIsArmed == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsArmed.mock.afterIsArmedCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsArmed.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsArmed implements mm_usecase.WatchDog
func (mmIsArmed *WatchDogMock) IsArmed() (b1 bool) {
	mm_atomic.AddUint64(&mmIsArmed.beforeIsArmedCounter, 1)
	defer mm_atomic.AddUint64(&mmIsArmed.afterIsArmedCounter, 1)

	mmIsArmed.t.Helper()

	if mmIsArmed.inspectFuncIsArmed != nil {
		mmIsArmed.inspectFuncIsArmed()
	}

	if mmIsArmed.IsArmedMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsArmed.IsArmedMock.defaultExpectation.Counter, 1)

		mm_results := mmIsArmed.IsArmedMock.defaultExpectation.results
		if mm_results == nil {
			mmIsArmed.t.Fatal("No results are set for the WatchDogMock.IsArmed")
		}
		return (*mm_results).b1
	}
	if mmIsArmed.funcIsArmed != nil {
		return mmIsArmed.funcIsArmed()
	}
	mmIsArmed.t.Fatalf("Unexpected call to WatchDogMock.IsArmed.")
	return
}

// IsArmedAfterCounter returns a count of finished WatchDogMock.IsArmed invocations
func (mmIsArmed *WatchDogMock) IsArmedAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsArmed.afterIsArmedCounter)
}

// IsArmedBeforeCounter returns a count of WatchDogMock.IsArmed invocations
func (mmIsArmed *WatchDogMock) IsArmedBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsArmed.beforeIsArmedCounter)
}

// MinimockIsArmedDone returns true if the count of the IsArmed invocations corresponds
// the number of defined expectations
func (m *WatchDogMock) MinimockIsArmedDone() bool {
	if m.IsArmedMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsArmedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsArmedMock.invocationsDone()
}

// MinimockIsArmedInspect logs each unmet expectation
func (m *WatchDogMock) MinimockIsArmedInspect() {
	for _, e := range m.IsArmedMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WatchDogMock.IsArmed")
		}
	}

	afterIsArmedCounter := mm_atomic.LoadUint64(&m.afterIsArmedCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsArmedMock.defaultExpectation != nil && afterIsArmedCounter < 1 {
		m.t.Errorf("Expected call to WatchDogMock.IsArmed at\n%s", m.IsArmedMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsArmed != nil && afterIsArmedCounter < 1 {
		m.t.Errorf("Expected call to WatchDogMock.IsArmed at\n%s", m.funcIsArmedOrigin)
	}

	if !m.IsArmedMock.invocationsDone() && afterIsArmedCounter > 0 {
		m.t.Errorf("Expected %d calls to WatchDogMock.IsArmed at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsArmedMock.expectedInvocations), m.IsArmedMock.expectedInvocationsOrigin, afterIsArmedCounter)
	}
}

type mWatchDogMockStart struct {
	optional           bool
	mock               *WatchDogMock
	defaultExpectation *WatchDogMockStartExpectation
	expectations       []*WatchDogMockStartExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WatchDogMockStartExpectation specifies expectation struct of the WatchDog.Start
type WatchDogMockStartExpectation struct {
	mock *WatchDogMock

	results      *WatchDogMockStartResults
	returnOrigin string
	Counter      uint64
}

// WatchDogMockStartResults contains results of the WatchDog.Start
type WatchDogMockStartResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStart *mWatchDogMockStart) Optional() *mWatchDogMockStart {
	mmStart.optional = true
	return mmStart
}

// Expect sets up expected params for WatchDog.Start
func (mmStart *mWatchDogMockStart) Expect() *mWatchDogMockStart {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("WatchDogMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &WatchDogMockStartExpectation{}
	}

	return mmStart
}

// Inspect accepts an inspector function that has same arguments as the WatchDog.Start
func (mmStart *mWatchDogMockStart) Inspect(f func()) *mWatchDogMockStart {
	if mmStart.mock.inspectFuncStart != nil {
		mmStart.mock.t.Fatalf("Inspect function is already set for WatchDogMock.Start")
	}

	mmStart.mock.inspectFuncStart = f

	return mmStart
}

// Return sets up results that will be returned by WatchDog.Start
func (mmStart *mWatchDogMockStart) Return(err error) *WatchDogMock {
	if mmStart.mock.funcStart != nil {
		mmStart.mock.t.Fatalf("WatchDogMock.Start mock is already set by Set")
	}

	if mmStart.defaultExpectation == nil {
		mmStart.defaultExpectation = &WatchDogMockStartExpectation{mock: mmStart.mock}
	}
	mmStart.defaultExpectation.results = &WatchDogMockStartResults{err}
	mmStart.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStart.mock
}

// Set uses given function f to mock the WatchDog.Start method
func (mmStart *mWatchDogMockStart) Set(f func() (err error)) *WatchDogMock {
	if mmStart.defaultExpectation != nil {
		mmStart.mock.t.Fatalf("Default expectation is already set for the WatchDog.Start method")
	}

	if len(mmStart.expectations) > 0 {
		mmStart.mock.t.Fatalf("Some expectations are already set for the WatchDog.Start method")
	}

	mmStart.mock.funcStart = f
	mmStart.mock.funcStartOrigin = minimock.CallerInfo(1)
	return mmStart.mock
}

// Times sets number of times WatchDog.Start should be invoked
func (mmStart *mWatchDogMockStart) Times(n uint64) *mWatchDogMockStart {
	if n == 0 {
		mmStart.mock.t.Fatalf("Times of WatchDogMock.Start mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStart.expectedInvocations, n)
	mmStart.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStart
}

func (mmStart *mWatchDogMockStart) invocationsDone() bool {
	if len(mmStart.expectations) == 0 && mmStart.defaultExpectation == nil && mmStart.mock.funcStart == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStart.mock.afterStartCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStart.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Start implements mm_usecase.WatchDog
func (mmStart *WatchDogMock) Start() (err error) {
	mm_atomic.AddUint64(&mmStart.beforeStartCounter, 1)
	defer mm_atomic.AddUint64(&mmStart.afterStartCounter, 1)

	mmStart.t.Helper()

	if mmStart.inspectFuncStart != nil {
		mmStart.inspectFuncStart()
	}

	if mmStart.StartMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStart.StartMock.defaultExpectation.Counter, 1)

		mm_results := mmStart.StartMock.defaultExpectation.results
		if mm_results == nil {
			mmStart.t.Fatal("No results are set for the WatchDogMock.Start")
		}
		return (*mm_results).err
	}
	if mmStart.funcStart != nil {
		return mmStart.funcStart()
	}
	mmStart.t.Fatalf("Unexpected call to WatchDogMock.Start.")
	return
}

// StartAfterCounter returns a count of finished WatchDogMock.Start invocations
func (mmStart *WatchDogMock) StartAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.afterStartCounter)
}

// StartBeforeCounter returns a count of WatchDogMock.Start invocations
func (mmStart *WatchDogMock) StartBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStart.beforeStartCounter)
}

// MinimockStartDone returns true if the count of the Start invocations corresponds
// the number of defined expectations
func (m *WatchDogMock) MinimockStartDone() bool {
	if m.StartMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StartMock.invocationsDone()
}

// MinimockStartInspect logs each unmet expectation
func (m *WatchDogMock) MinimockStartInspect() {
	for _, e := range m.StartMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WatchDogMock.Start")
		}
	}

	afterStartCounter := mm_atomic.LoadUint64(&m.afterStartCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StartMock.defaultExpectation != nil && afterStartCounter < 1 {
		m.t.Errorf("Expected call to WatchDogMock.Start at\n%s", m.StartMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStart != nil && afterStartCounter < 1 {
		m.t.Errorf("Expected call to WatchDogMock.Start at\n%s", m.funcStartOrigin)
	}

	if !m.StartMock.invocationsDone() && afterStartCounter > 0 {
		m.t.Errorf("Expected %d calls to WatchDogMock.Start at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StartMock.expectedInvocations), m.StartMock.expectedInvocationsOrigin, afterStartCounter)
	}
}

type mWatchDogMockStop struct {
	optional           bool
	mock               *WatchDogMock
	defaultExpectation *WatchDogMockStopExpectation
	expectations       []*WatchDogMockStopExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// WatchDogMockStopExpectation specifies expectation struct of the WatchDog.Stop
type WatchDogMockStopExpectation struct {
	mock *WatchDogMock

	results      *WatchDogMockStopResults
	returnOrigin string
	Counter      uint64
}

// WatchDogMockStopResults contains results of the WatchDog.Stop
type WatchDogMockStopResults struct {
	err error
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmStop *mWatchDogMockStop) Optional() *mWatchDogMockStop {
	mmStop.optional = true
	return mmStop
}

// Expect sets up expected params for WatchDog.Stop
func (mmStop *mWatchDogMockStop) Expect() *mWatchDogMockStop {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("WatchDogMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &WatchDogMockStopExpectation{}
	}

	return mmStop
}

// Inspect accepts an inspector function that has same arguments as the WatchDog.Stop
func (mmStop *mWatchDogMockStop) Inspect(f func()) *mWatchDogMockStop {
	if mmStop.mock.inspectFuncStop != nil {
		mmStop.mock.t.Fatalf("Inspect function is already set for WatchDogMock.Stop")
	}

	mmStop.mock.inspectFuncStop = f

	return mmStop
}

// Return sets up results that will be returned by WatchDog.Stop
func (mmStop *mWatchDogMockStop) Return(err error) *WatchDogMock {
	if mmStop.mock.funcStop != nil {
		mmStop.mock.t.Fatalf("WatchDogMock.Stop mock is already set by Set")
	}

	if mmStop.defaultExpectation == nil {
		mmStop.defaultExpectation = &WatchDogMockStopExpectation{mock: mmStop.mock}
	}
	mmStop.defaultExpectation.results = &WatchDogMockStopResults{err}
	mmStop.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmStop.mock
}

// Set uses given function f to mock the WatchDog.Stop method
func (mmStop *mWatchDogMockStop) Set(f func() (err error)) *WatchDogMock {
	if mmStop.defaultExpectation != nil {
		mmStop.mock.t.Fatalf("Default expectation is already set for the WatchDog.Stop method")
	}

	if len(mmStop.expectations) > 0 {
		mmStop.mock.t.Fatalf("Some expectations are already set for the WatchDog.Stop method")
	}

	mmStop.mock.funcStop = f
	mmStop.mock.funcStopOrigin = minimock.CallerInfo(1)
	return mmStop.mock
}

// Times sets number of times WatchDog.Stop should be invoked
func (mmStop *mWatchDogMockStop) Times(n uint64) *mWatchDogMockStop {
	if n == 0 {
		mmStop.mock.t.Fatalf("Times of WatchDogMock.Stop mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmStop.expectedInvocations, n)
	mmStop.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmStop
}

func (mmStop *mWatchDogMockStop) invocationsDone() bool {
	if len(mmStop.expectations) == 0 && mmStop.defaultExpectation == nil && mmStop.mock.funcStop == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmStop.mock.afterStopCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmStop.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Stop implements mm_usecase.WatchDog
func (mmStop *WatchDogMock) Stop() (err error) {
	mm_atomic.AddUint64(&mmStop.beforeStopCounter, 1)
	defer mm_atomic.AddUint64(&mmStop.afterStopCounter, 1)

	mmStop.t.Helper()

	if mmStop.inspectFuncStop != nil {
		mmStop.inspectFuncStop()
	}

	if mmStop.StopMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmStop.StopMock.defaultExpectation.Counter, 1)

		mm_results := mmStop.StopMock.defaultExpectation.results
		if mm_results == nil {
			mmStop.t.Fatal("No results are set for the WatchDogMock.Stop")
		}
		return (*mm_results).err
	}
	if mmStop.funcStop != nil {
		return mmStop.funcStop()
	}
	mmStop.t.Fatalf("Unexpected call to WatchDogMock.Stop.")
	return
}

// StopAfterCounter returns a count of finished WatchDogMock.Stop invocations
func (mmStop *WatchDogMock) StopAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.afterStopCounter)
}

// StopBeforeCounter returns a count of WatchDogMock.Stop invocations
func (mmStop *WatchDogMock) StopBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmStop.beforeStopCounter)
}

// MinimockStopDone returns true if the count of the Stop invocations corresponds
// the number of defined expectations
func (m *WatchDogMock) MinimockStopDone() bool {
	if m.StopMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.StopMock.invocationsDone()
}

// MinimockStopInspect logs each unmet expectation
func (m *WatchDogMock) MinimockStopInspect() {
	for _, e := range m.StopMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to WatchDogMock.Stop")
		}
	}

	afterStopCounter := mm_atomic.LoadUint64(&m.afterStopCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.StopMock.defaultExpectation != nil && afterStopCounter < 1 {
		m.t.Errorf("Expected call to WatchDogMock.Stop at\n%s", m.StopMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcStop != nil && afterStopCounter < 1 {
		m.t.Errorf("Expected call to WatchDogMock.Stop at\n%s", m.funcStopOrigin)
	}

	if !m.StopMock.invocationsDone() && afterStopCounter > 0 {
		m.t.Errorf("Expected %d calls to WatchDogMock.Stop at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.StopMock.expectedInvocations), m.StopMock.expectedInvocationsOrigin, afterStopCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *WatchDogMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockFeedInspect()

			m.MinimockIsArmedInspect()

			m.MinimockStartInspect()

			m.MinimockStopInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *WatchDogMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *WatchDogMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockFeedDone() &&
		m.MinimockIsArmedDone() &&
		m.MinimockStartDone() &&
		m.MinimockStopDone()
}
