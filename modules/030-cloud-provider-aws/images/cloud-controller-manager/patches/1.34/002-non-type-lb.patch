diff --git a/pkg/providers/v1/aws.go b/pkg/providers/v1/aws.go
index e1070ee..8fda582 100644
--- a/pkg/providers/v1/aws.go
+++ b/pkg/providers/v1/aws.go
@@ -278,6 +278,13 @@ var backendProtocolMapping = map[string]string{
 	"tcp":   "ssl",
 }
 
+var backendProtocolToAwsEnumMapping = map[string]string{
+	"tcp":   string(elbv2types.ProtocolEnumTcp),
+	"tls":   string(elbv2types.ProtocolEnumTls),
+	"http":  string(elbv2types.ProtocolEnumHttp),
+	"https": string(elbv2types.ProtocolEnumHttps),
+}
+
 // MaxReadThenCreateRetries sets the maximum number of attempts we will make when
 // we read to see if something exists and then try to create it if we didn't find it.
 // This can fail once in a consistent system if done in parallel
@@ -2173,7 +2180,7 @@ func (c *Cloud) EnsureLoadBalancer(ctx context.Context, clusterName string, apiS
 			continue
 		}
 
-		if isNLB(annotations) {
+		if isNLB(annotations) || isNone(annotations) {
 			portMapping := nlbPortMapping{
 				FrontendPort:     int32(port.Port),
 				FrontendProtocol: elbv2types.ProtocolEnum(port.Protocol),
@@ -2185,6 +2192,12 @@ func (c *Cloud) EnsureLoadBalancer(ctx context.Context, clusterName string, apiS
 				return nil, err
 			}
 
+			if isNone(annotations) {
+				portMapping.HealthCheckConfig.Protocol = elbv2types.ProtocolEnumHttp
+				portMapping.HealthCheckConfig.Port = "10256" // ProxyHealthzPort
+				portMapping.HealthCheckConfig.Path = "/healthz"
+			}
+
 			certificateARN := annotations[ServiceAnnotationLoadBalancerCertificate]
 			if port.Protocol != v1.ProtocolUDP && certificateARN != "" && (sslPorts == nil || sslPorts.numbers.Has(port.Port) || sslPorts.names.Has(port.Name)) {
 				portMapping.FrontendProtocol = elbv2types.ProtocolEnumTls
@@ -2196,6 +2209,19 @@ func (c *Cloud) EnsureLoadBalancer(ctx context.Context, clusterName string, apiS
 				}
 			}
 
+			if isNone(annotations) {
+				instanceProtocol := annotations[ServiceAnnotationLoadBalancerBEProtocol]
+				if instanceProtocol == "" {
+					portMapping.TrafficProtocol = elbv2types.ProtocolEnumTcp
+				} else {
+					protocol := backendProtocolToAwsEnumMapping[instanceProtocol]
+					if protocol == "" {
+						return nil, fmt.Errorf("invalid backend protocol %s", ServiceAnnotationLoadBalancerBEProtocol)
+					}
+					portMapping.TrafficProtocol = elbv2types.ProtocolEnum(protocol)
+				}
+			}
+
 			v2Mappings = append(v2Mappings, portMapping)
 		} else {
 			listener, err := buildListener(port, annotations, sslPorts)
@@ -2229,6 +2255,58 @@ func (c *Cloud) EnsureLoadBalancer(ctx context.Context, clusterName string, apiS
 		internalELB = true
 	}
 
+	if isNone(annotations) {
+		if path, healthCheckNodePort := servicehelpers.GetServiceHealthCheckPathPort(apiService); path != "" {
+			for i := range v2Mappings {
+				v2Mappings[i].HealthCheckConfig.Port = strconv.Itoa(int(healthCheckNodePort))
+				v2Mappings[i].HealthCheckConfig.Path = path
+				v2Mappings[i].HealthCheckConfig.Protocol = elbv2types.ProtocolEnumHttp
+			}
+		}
+		loadBalancerName := c.GetLoadBalancerName(ctx, clusterName, apiService)
+		serviceName := types.NamespacedName{Namespace: apiService.Namespace, Name: apiService.Name}
+
+		instanceIDs := []string{}
+		for id := range instances {
+			instanceIDs = append(instanceIDs, string(id))
+		}
+		// Get additional tags set by the user
+		tags := getKeyValuePropertiesFromAnnotation(annotations, ServiceAnnotationLoadBalancerAdditionalTags)
+		// Add default tags
+		tags[TagNameKubernetesService] = serviceName.String()
+		tags = c.tagging.buildTags(ResourceLifecycleOwned, tags)
+
+		for i, mapping := range v2Mappings {
+			tgNameWithSuffix := generateTgName(loadBalancerName, strconv.Itoa(i))
+			existingTg, err := c.describeTargetGroup(ctx, tgNameWithSuffix)
+			if err != nil {
+				return nil, err
+			}
+
+			_, err = c.ensureTargetGroup(
+				ctx,
+				existingTg,
+				serviceName,
+				mapping,
+				instanceIDs,
+				c.vpcID,
+				tags,
+				tgNameWithSuffix,
+			)
+			if err != nil {
+				return nil, err
+			}
+		}
+
+		return &v1.LoadBalancerStatus{Ingress: []v1.LoadBalancerIngress{
+			{
+				IP:       "0.0.0.0",
+				Hostname: "none",
+			},
+		},
+		}, nil
+	}
+
 	if isNLB(annotations) {
 		// Find the subnets that the ELB will live in
 		discoveredSubnetIDs, err := c.getLoadBalancerSubnets(ctx, apiService, internalELB)
@@ -2572,6 +2650,34 @@ func (c *Cloud) GetLoadBalancer(ctx context.Context, clusterName string, service
 		return nil, false, nil
 	}
 	loadBalancerName := c.GetLoadBalancerName(ctx, clusterName, service)
+	if isNone(service.Annotations) {
+		tgCount := 0
+		portCount := len(service.Spec.Ports)
+		for i := range service.Spec.Ports {
+			tgNameWithSuffix := generateTgName(loadBalancerName, strconv.Itoa(i))
+			tg, err := c.describeTargetGroup(ctx, tgNameWithSuffix)
+			if err != nil {
+				return nil, false, err
+			}
+
+			if tg != nil {
+				tgCount++
+			}
+		}
+		if tgCount == 0 {
+			return nil, false, nil
+		} else if tgCount < portCount {
+			return nil, true, nil
+		} else {
+			return &v1.LoadBalancerStatus{Ingress: []v1.LoadBalancerIngress{
+				{
+					IP:       "0.0.0.0",
+					Hostname: "none",
+				},
+			},
+			}, true, nil
+		}
+	}
 
 	if isNLB(service.Annotations) {
 		lb, err := c.describeLoadBalancerv2(ctx, loadBalancerName)
@@ -2978,6 +3084,27 @@ func (c *Cloud) EnsureLoadBalancerDeleted(ctx context.Context, clusterName strin
 	}
 	loadBalancerName := c.GetLoadBalancerName(ctx, clusterName, service)
 
+	if isNone(service.Annotations) {
+		for i := range service.Spec.Ports {
+			tgNameWithSuffix := generateTgName(loadBalancerName, strconv.Itoa(i))
+			tg, err := c.describeTargetGroup(ctx, tgNameWithSuffix)
+			if err != nil {
+				return err
+			}
+			if tg == nil {
+				klog.Info("Target group already deleted: ", loadBalancerName)
+				continue
+			}
+
+			_, err = c.elbv2.DeleteTargetGroup(ctx, &elbv2.DeleteTargetGroupInput{TargetGroupArn: tg.TargetGroupArn})
+			if err != nil {
+				return err
+			}
+		}
+
+		return nil
+	}
+
 	if isNLB(service.Annotations) {
 		lb, err := c.describeLoadBalancerv2(ctx, loadBalancerName)
 		if err != nil {
@@ -3096,6 +3223,10 @@ func (c *Cloud) UpdateLoadBalancer(ctx context.Context, clusterName string, serv
 		return err
 	}
 	loadBalancerName := c.GetLoadBalancerName(ctx, clusterName, service)
+	if isNone(service.Annotations) {
+		_, err = c.EnsureLoadBalancer(ctx, clusterName, service, nodes)
+		return err
+	}
 	if isNLB(service.Annotations) {
 		lb, err := c.describeLoadBalancerv2(ctx, loadBalancerName)
 		if err != nil {
@@ -3442,3 +3573,7 @@ func getRegionFromMetadata(ctx context.Context, cfg config.CloudConfig, metadata
 
 	return cfg.GetRegion(ctx, metadata)
 }
+
+func generateTgName(prefix, suffix string) string {
+	return prefix[0:32-1-len(suffix)] + "-" + suffix
+}
diff --git a/pkg/providers/v1/aws_loadbalancer.go b/pkg/providers/v1/aws_loadbalancer.go
index ca95a3a..ebee2da 100644
--- a/pkg/providers/v1/aws_loadbalancer.go
+++ b/pkg/providers/v1/aws_loadbalancer.go
@@ -94,6 +94,13 @@ func isLBExternal(annotations map[string]string) bool {
 	return false
 }
 
+func isNone(annotations map[string]string) bool {
+	if annotations[ServiceAnnotationLoadBalancerType] == "none" {
+		return true
+	}
+	return false
+}
+
 type healthCheckConfig struct {
 	Port               string
 	Path               string
@@ -144,6 +151,21 @@ func getKeyValuePropertiesFromAnnotation(annotations map[string]string, annotati
 	return additionalTags
 }
 
+func (c *Cloud) describeTargetGroup(ctx context.Context, tgName string) (*elbv2types.TargetGroup, error) {
+	response, err := c.elbv2.DescribeTargetGroups(ctx, &elbv2.DescribeTargetGroupsInput{})
+	if err != nil {
+		return nil, fmt.Errorf("error describing target groups: %q", err)
+	}
+
+	for _, tg := range response.TargetGroups {
+		if aws.ToString(tg.TargetGroupName) == tgName {
+			return &tg, nil
+		}
+	}
+
+	return nil, nil
+}
+
 // ensureLoadBalancerv2 ensures a v2 load balancer is created
 func (c *Cloud) ensureLoadBalancerv2(ctx context.Context, namespacedName types.NamespacedName, loadBalancerName string, mappings []nlbPortMapping, instanceIDs, discoveredSubnetIDs []string, internalELB bool, annotations map[string]string) (*elbv2types.LoadBalancer, error) {
 	loadBalancer, err := c.describeLoadBalancerv2(ctx, loadBalancerName)
@@ -583,12 +605,15 @@ func (c *Cloud) deleteListenerV2(ctx context.Context, listener *elbv2types.Liste
 }
 
 // ensureTargetGroup creates a target group with a set of instances.
-func (c *Cloud) ensureTargetGroup(ctx context.Context, targetGroup *elbv2types.TargetGroup, serviceName types.NamespacedName, mapping nlbPortMapping, instances []string, vpcID string, tags map[string]string) (*elbv2types.TargetGroup, error) {
+func (c *Cloud) ensureTargetGroup(ctx context.Context, targetGroup *elbv2types.TargetGroup, serviceName types.NamespacedName, mapping nlbPortMapping, instances []string, vpcID string, tags map[string]string, tgName ...string) (*elbv2types.TargetGroup, error) {
 	dirty := false
 	expectedTargets := c.computeTargetGroupExpectedTargets(instances, mapping.TrafficPort)
 	if targetGroup == nil {
 		targetType := elbv2types.TargetTypeEnumInstance
 		name := c.buildTargetGroupName(serviceName, mapping.FrontendPort, mapping.TrafficPort, mapping.TrafficProtocol, targetType, mapping)
+		if len(tgName) > 0 {
+			name = tgName[0]
+		}
 		klog.Infof("Creating load balancer target group for %v with name: %s", serviceName, name)
 		input := &elbv2.CreateTargetGroupInput{
 			VpcId:                      aws.String(vpcID),
@@ -633,6 +658,22 @@ func (c *Cloud) ensureTargetGroup(ctx context.Context, targetGroup *elbv2types.T
 		return &tg, nil
 	}
 
+	// handle protocol change
+	{
+		if targetGroup.Protocol != mapping.TrafficProtocol {
+			_, err := c.elbv2.DeleteTargetGroup(ctx, &elbv2.DeleteTargetGroupInput{TargetGroupArn: targetGroup.TargetGroupArn})
+			if err != nil {
+				return nil, err
+			}
+
+			var targetGroupName string
+			if len(tgName) > 0 {
+				targetGroupName = tgName[0]
+			}
+			return c.ensureTargetGroup(ctx, nil, serviceName, mapping, instances, vpcID, tags, targetGroupName)
+		}
+	}
+
 	// handle instances in service
 	{
 		tgARN := aws.ToString(targetGroup.TargetGroupArn)
