<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Upmeter</title>

    <!--
      Start the server with the following command (read README.md for more details):
      go run ./cmd/upmeter/ start --origins=1 --db-path=./db-emu-server.db.sqlite

      Start the agent emulator with the following command
      go run ./cmd/upmeter/ agent --emulation --db-path=./db-emu-agent.sqlite --log-level="debug"

      Open this page
    -->

    <style>
      div.up {
        background: hsl(130, 83%, 35%);
        background: linear-gradient(
          0,
          hsla(130, 55%, 45%, 100%) 0,
          hsla(130, 50%, 55%, 60%) 6px,
          hsla(130, 44%, 65%, 50%) 12px,
          hsla(130, 44%, 65%, 100%) 100%
        );
      }

      div.down {
        background: hsl(340, 83%, 35%);
        background: linear-gradient(
          0,
          hsl(340, 74%, 25%) 0%,
          hsl(340, 83%, 45%) 5%,
          hsl(340, 83%, 45%) 95%,
          hsl(340, 74%, 35%) 100%
        );
      }

      div.unknown {
        background: hsl(278, 83%, 35%);
        background: linear-gradient(
          0,
          hsl(278, 74%, 25%) 0%,
          hsl(278, 83%, 45%) 5%,
          hsl(278, 83%, 45%) 95%,
          hsl(278, 74%, 35%) 100%
        );
      }

      div.nodata,
      div.muted {
        background: hsl(0, 0%, 82%);
        background: linear-gradient(
          0,
          hsl(0, 0%, 88%) 0%,
          hsl(0, 0%, 94%) 5px,
          hsl(0, 0%, 94%) 95%,
          hsl(0, 0%, 88%) 100%
        );
      }

      body {
        margin: 0;
        padding: 0;
      }

      body > header,
      body > main {
        padding: 1rem;
      }

      #chart > * {
        margin-block-end: 0.4rem;
      }

      div.probe {
        display: flex;
        flex-direction: row;
        vertical-align: top;
        padding: 0;
        margin: 0;
        font-size: small;
      }

      div.probe > div {
        margin-block-end: 0rem;
      }

      div.title {
        flex-grow: 0;
        width: 20rem;
        font-size: larger;
      }

      div.availability {
        font-size: large;
        flex-grow: 0;
        width: 5rem;
        font-family: monospace;
      }

      div.title,
      div.availability {
        padding-top: 0em;
      }

      div.range {
        flex-grow: 1;
        display: inline-flex;
        flex-direction: row;
        vertical-align: top;
        gap: 0.4rem;
      }

      div.slotsingle {
        display: block;
        width: 1.5rem;
        height: 1.5rem;
        border-radius: 20%;
        border: 0.1rem solid;
        box-sizing: border-box;
        margin: 0;
        color: #ffffff;
        font-family: monospace;
        font-size: 100%;
        line-height: 100%;
        text-align: center;
        align-content: center;
        flex-direction: column;
      }

      div.slot {
        flex-grow: 1;
        flex-direction: column;
        width: 3em;
        height: 3em;
        border: 10% solid;
        min-width: 4px;
        display: flex;
        outline-offset: -1px;
      }
    </style>

    <script type="module">
      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

      // The data
      const GPs = await fetch("/api/probe").then((d) => d.json());
      console.log(GPs);

      var h = d3.scaleLinear().domain([0, 1]).range([0, 24]);
      const ordering = ["down", "nodata", "muted", "unknown", "up"];

      const chartElement = d3.select("#chart");

      function formatPercentage(d) {
        const sum = d.up + d.down;
        if (!sum) return "No data";
        const ratio = d.up / (d.up + d.down);
        if (ratio == 1) return "100%";
        return (ratio * 100).toFixed(2) + "%";
      }

      function show(data) {
        const gp = chartElement
          .selectAll("div.probe") // , (gp) => gp.group + "/" + gp.probe)
          .data(data)
          .join("div") // , (gp) => gp.group + "/" + gp.probe)
          .attr("class", "probe");

        // Probe title
        gp.selectAll("div.title")
          // .data((gp) => [gp.group + "/" + gp.probe])
          .data((gp) => [gp.probe])
          .join("div")
          .attr("class", "title")
          .text((d) => d);

        // Availability for the range
        gp.selectAll("div.availability")
          .data((gp) => gp.statuses.slice(-1))
          .join("div")
          .attr("class", "availability")
          .style("text-align", "right")
          .style("margin", "auto 1ex")
          .text(formatPercentage);

        // Slot range
        const range = gp
          .selectAll("div.range")
          .data((gp) => [gp])
          .join("div")
          .attr("class", "range");

        // Slot
        const slot = range
          .selectAll("div")
          .data((gp) => gp.statuses.slice(0, -1))
          .join("div")
          .attr("class", "slotsingle")
          .style("background", (d) => getColor(d).background)
          // .style( "height", (d) => `${d.measured / d.total * 100}%` )
          .style("border-color", (d) => getColor(d).border)
          // .style("line-height", "100%")
          .text((d) => {
            if (!Number.isFinite(d.availability)) return ""; // NaN == no data
            if (d.total === 0) return ""; // No data here
            const av = d.availability * 100;
            if (av === 100) return "";
            if (av < 1) return "";
            if (av > 99) return av.toFixed(2).substring(2);
            return av.toFixed(0);
          });

        // Colored bar (green/violet/red/grey)
        /*
           slot
             .selectAll("div")
             .data((d, i) => ordering.map((k) => [d[k]]))
             .join("div")
             .style("height", (d) => `${h(d)}px`)
             .attr("class", (d, i) => ordering[i]);
             */
      }

      // /api/status/range?from=1723221800&to=1723245800&step=300&group=control-plane&probe=apiserver

      async function getData() {
        // controls that should become parameters
        const API_MINUTE = 60;
        const API_HOUR = 3600;

        const step = API_MINUTE * 10; // ←←←←←←← CHANGE THIS
        const range = API_HOUR * 6; // ←←←←←←← CHANGE THIS

        const now = Math.round(new Date().valueOf() / 1000); // 'now' in seconds
        const to = now - (now % (5 * API_MINUTE));  // 'now' floored by 5 min
        const from = to - range;

        const url = (gp) =>
          `/api/status/range?from=${from}&to=${to}&step=${step}&group=${gp.group}&probe=${gp.probe}`;
        const fetchGP = (gp) => fetch(url(gp)).then((d) => d.json());
        const gpStatuses = await Promise.all(GPs.map(fetchGP));

        const data = GPs.map((gp, i) => {
          const groupStatuses = gpStatuses[i].statuses;
          if (!groupStatuses[gp.group]) {
            return null;
          }
          if (!groupStatuses[gp.group][gp.probe]) {
            return null;
          }
          gp.statuses = groupStatuses[gp.group][gp.probe]
            // .slice(0, -1)
            .map((d) => {
              // Calculate relative availability. Convert from time units to fractions of 1.
              let slotDuration = d.slot_size;
              if (slotDuration == 0) {
                const start = new Date(d.start).valueOf();
                const end = new Date(d.end).valueOf();
                slotDuration = 1e6 * (end - start);
              }

              const total = d.up + d.down + d.unknown + d.nodata;
              const measured = d.up + d.down;
              const availability = d.up / measured;

              return {
                up: d.up / slotDuration,
                down: d.down / slotDuration,
                unknown: d.unknown / slotDuration,
                muted: d.muted / slotDuration,
                nodata: d.nodata / slotDuration,
                total,
                measured,
                availability,
              };
            });

          return gp;
        }).filter((d) => d);

        return data;
      }

      function getColor(d) {
        /*
        function perc2color(perc) {
          var r, g, b = 0;
          if(perc < 50) {
            r = 255;
            g = Math.round(5.1 * perc);
            }
            else {
              g = 130; // 255
              r = Math.round(510 - 5.10 * perc);
              }
              var h = r * 0x10000 + g * 0x100 + b * 0x1;
              return '#' + ('000000' + h.toString(16)).slice(-6);
              }

              return perc2color(availability*100)
              */

        if (!Number.isFinite(d.availability)) {
          return { background: "#f6f6f6", border: "#eee" };
        }

        const colors = [
          // { background: "#bbddaa88", border: "#bbddaa44" },
          // { background: "#aaddaa88", border: "#aaddaa44" },
          { background: "#aaddcc88", border: "#aaddcc44" },
          // { background: "#aaddbb88", border: "#aaddbb44" },
          { background: "#759138aa", border: "#509E5922" },
          { background: "#A1C71Dbb", border: "#75913822" },
          // { background:  "#FFFD00", border: "ffffff33" },
          // { background:  "#FAD405", border: "ffffff33" },
          { background: "#F4AF0Bcc", border: "#EF8C1022" },
          { background: "#EF8C10dd", border: "#EA6D1522" },
          { background: "#EA6D15ee", border: "#E5501A22" },
          { background: "#E5501Aff", border: "#DF372022" },
          { background: "#DF3720ff", border: "#DA252922" },
          { background: "#DA2529ff", border: "#00000022" },
        ];

        if (d.availability === 1) return colors[0];
        const ci = Math.round((1 - d.availability) * (colors.length - 2)) + 1;
        return colors[ci];

        const hue = 130 * d.availability + 20;
        const fullness = (d.measured / d.total) * 100;
        // return `oklch(70.73% 0.1429 ${hue} / ${fullness}%)`;
        return `oklch(60% 0.1429 ${hue} / ${fullness}%)`;
      }

      show(await getData());

      setInterval(async () => {
        show(await getData());
        console.log("Updated");
      }, 5000);
    </script>
  </head>
  <body>
    <header>
      <h1>Deckhouse Kubernetes Platform Subsystem Availability</h1>
    </header>
    <main>
      <div id="chart"></div>
    </main>
  </body>
</html>
