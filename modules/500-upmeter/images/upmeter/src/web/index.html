<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Upmeter</title>

    <!--
      Start the server with the following command (read README.md for more details):
      go run ./cmd/upmeter/ start --origins=1 --db-path=./db-emu-server.db.sqlite

      Start the agent emulator with the following command
      go run ./cmd/upmeter/ agent --emulation --db-path=./db-emu-agent.sqlite --log-level="debug"

      Open this page
    -->

    <style>
      body {
        margin: 0;
        padding: 0;
      }

      body > header,
      body > main {
        padding: 1rem;
      }

      div.up {
        background: hsl(130, 83%, 35%);
        background: linear-gradient(
          0,
          hsla(130, 55%, 45%, 100%) 0,
          hsla(130, 50%, 55%, 60%) 6px,
          hsla(130, 44%, 65%, 50%) 12px,
          hsla(130, 44%, 65%, 100%) 100%
        );
      }

      div.down {
        background: hsl(340, 83%, 35%);
        background: linear-gradient(
          0,
          hsl(340, 74%, 25%) 0%,
          hsl(340, 83%, 45%) 5%,
          hsl(340, 83%, 45%) 95%,
          hsl(340, 74%, 35%) 100%
        );
      }

      div.unknown {
        background: hsl(278, 83%, 35%);
        background: linear-gradient(
          0,
          hsl(278, 74%, 25%) 0%,
          hsl(278, 83%, 45%) 5%,
          hsl(278, 83%, 45%) 95%,
          hsl(278, 74%, 35%) 100%
        );
      }

      div.nodata,
      div.muted {
        background: hsl(0, 0%, 82%);
        background: linear-gradient(
          0,
          hsl(0, 0%, 88%) 0%,
          hsl(0, 0%, 94%) 5px,
          hsl(0, 0%, 94%) 95%,
          hsl(0, 0%, 88%) 100%
        );
      }

      #chart > * {
        margin-block-end: 0.5rem;
      }

      div.probe {
        display: flex;
        flex-direction: row;
        vertical-align: top;
        padding: 0;
        margin: 0;
        font-size: small;
      }

      div.probe > div {
        margin-block-end: 0rem;
      }

      div.title {
        flex-grow: 0;
        width: 20rem;
        font-size: larger;
      }

      div.availability {
        font-size: large;
        flex-grow: 0;
        width: 5rem;
      }

      div.title,
      div.availability {
        padding-top: 0em;
      }

      div.range {
        flex-grow: 1;
        display: inline-flex;
        flex-direction: row;
        vertical-align: top;
        gap: 0.5em;
      }

      div.slot {
        flex-grow: 1;
        flex-direction: column;
        width: 2em;
        height: 2em;
        border: 0.5px solid #000000cc;
        min-width: 4px;
        display: flex;
        outline-offset: -1px;
      }

      div.slotsingle {
        display: block;
        width: 2em;
        height: 2em;
        border-radius: 5px;
        box-sizing: border-box;
        margin: 0;
      }
    </style>

    <script type="module">
      import * as d3 from "https://cdn.jsdelivr.net/npm/d3@7/+esm";

      // The data
      const GPs = await fetch("/api/probe").then((d) => d.json());
      console.log(GPs);

      var h = d3.scaleLinear().domain([0, 1]).range([0, 24]);
      const ordering = ["down", "nodata", "muted", "unknown", "up"];

      const chartElement = d3.select("#chart");

      function formatPercentage(d) {
        const sum = d.up + d.down;
        if (!sum) return "No data";
        const ratio = d.up / (d.up + d.down);
        if (ratio == 1) return "100%";
        return (ratio * 100).toFixed(2) + "%";
      }

      function show(data) {
        const gp = chartElement
          .selectAll("div.probe") // , (gp) => gp.group + "/" + gp.probe)
          .data(data)
          .join("div") // , (gp) => gp.group + "/" + gp.probe)
          .attr("class", "probe");

        // Probe title
        gp.selectAll("div.title")
          // .data((gp) => [gp.group + "/" + gp.probe])
          .data((gp) => [gp.probe])
          .join("div")
          .attr("class", "title")
          .text((d) => d);

        // Availability for the range
        gp.selectAll("div.availability")
          .data((gp) => gp.statuses.slice(-1))
          .join("div")
          .attr("class", "availability")
          .style("text-align", "right")
          .style("margin", "auto 1ex")
          .text(formatPercentage);

        // Slot range
        const range = gp
          .selectAll("div.range")
          .data((gp) => [gp])
          .join("div")
          .attr("class", "range");

        function getColor(d) {
          const total = d.up + d.down + d.unknown + d.nodata;
          const measured = d.up + d.down;
          const availability = d.up / measured;

          /*
          function perc2color(perc) {
            var r, g, b = 0;
            if(perc < 50) {
              r = 255;
              g = Math.round(5.1 * perc);
              }
              else {
                g = 130; // 255
                r = Math.round(510 - 5.10 * perc);
                }
                var h = r * 0x10000 + g * 0x100 + b * 0x1;
                return '#' + ('000000' + h.toString(16)).slice(-6);
                }

                return perc2color(availability*100)
                */

          if (!Number.isFinite(availability))
            return { background: "#DDDDDD", border: "#000000cc" };
          const colors = [
            { background: "#508E59cc", border: "#000000cc" },
            { background: "#55B138cc", border: "#000000cc" },
            { background: "#91D71Dcc", border: "#000000cc" },
            // { background:  "#FFFD00", border: "000000cc" },
            // { background:  "#FAD405", border: "000000cc" },
            { background: "#F4AF0Bcc", border: "#000000cc" },
            { background: "#EF8C10cc", border: "#000000cc" },
            { background: "#EA6D15cc", border: "#ffffffcc" },
            { background: "#E5501Aff", border: "#ffffffcc" },
            { background: "#DF3720ff", border: "#ffffffcc" },
            { background: "#DA2529ff", border: "#ffffffcc" },
          ].reverse();

          const ci = Math.round(availability * (colors.length - 1));
          return colors[ci];

          const hue = 130 * availability + 20;
          const fullness = (measured / total) * 100;
          // return `oklch(70.73% 0.1429 ${hue} / ${fullness}%)`;
          return `oklch(60% 0.1429 ${hue} / ${fullness}%)`;
        }

        // Slot
        const slot = range
          .selectAll("div")
          .data((gp) => gp.statuses.slice(0, -1))
          .join("div")
          .attr("class", "slotsingle")
          .style("background", (d) => getColor(d).background)
          // .style( "height", (d) => `${(d.up + d.down) / (d.up + d.down + d.nodata + d.unknown) * 100}%` )
          .style("border-color", (d) => getColor(d).border);

        // Colored bar (green/violet/red/grey)
        /*
           slot
             .selectAll("div")
             .data((d, i) => ordering.map((k) => [d[k]]))
             .join("div")
             .style("height", (d) => `${h(d)}px`)
             .attr("class", (d, i) => ordering[i]);
             */
      }

      // /api/status/range?from=1723221800&to=1723245800&step=300&group=control-plane&probe=apiserver

      async function getData() {
        // controls that should become parameters
        const API_MINUTE = 60;
        const API_HOUR = 3600;

        const step = API_MINUTE * 5; // ←←←←←←← CHANGE THIS
        const range = API_HOUR * 2; // ←←←←←←← CHANGE THIS

        const to = Math.round(new Date().valueOf() / 1000); // 'now' in seconds
        const from = to - range;

        const url = (gp) =>
          `/api/status/range?from=${from}&to=${to}&step=${step}&group=${gp.group}&probe=${gp.probe}`;
        const fetchGP = (gp) => fetch(url(gp)).then((d) => d.json());
        const gpStatuses = await Promise.all(GPs.map(fetchGP));

        const data = GPs.map((gp, i) => {
          const groupStatuses = gpStatuses[i].statuses;
          if (!groupStatuses[gp.group]) {
            return null;
          }
          if (!groupStatuses[gp.group][gp.probe]) {
            return null;
          }
          gp.statuses = groupStatuses[gp.group][gp.probe]
            // .slice(0, -1)
            .map((d) => {
              // Calculate relative availability. Convert from time units to fractions of 1.
              let slotDuration = d.slot_size;
              if (slotDuration == 0) {
                const start = new Date(d.start).valueOf();
                const end = new Date(d.end).valueOf();
                slotDuration = 1e6 * (end - start);
              }
              return {
                up: d.up / slotDuration,
                down: d.down / slotDuration,
                unknown: d.unknown / slotDuration,
                muted: d.muted / slotDuration,
                nodata: d.nodata / slotDuration,
              };
            });

          return gp;
        }).filter((d) => d);

        return data;
      }

      show(await getData());

      setInterval(async () => {
        show(await getData());
        console.log("Updated");
      }, 5000);
    </script>
  </head>
  <body>
    <header>
      <h1>Deckhouse Kubernetes Platform Subsystem Availability</h1>
    </header>
    <main>
      <div id="chart"></div>
    </main>
  </body>
</html>
