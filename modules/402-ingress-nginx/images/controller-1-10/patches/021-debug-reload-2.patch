diff --git a/pkg/apis/ingress/types_equals.go b/pkg/apis/ingress/types_equals.go
index eeed9a06e..15a131c1f 100644
--- a/pkg/apis/ingress/types_equals.go
+++ b/pkg/apis/ingress/types_equals.go
@@ -17,49 +17,60 @@ limitations under the License.
 package ingress
 
 import (
+	"fmt"
+
 	"k8s.io/ingress-nginx/pkg/util/sets"
 )
 
 // Equal tests for equality between two Configuration types
 func (c1 *Configuration) Equal(c2 *Configuration) bool {
 	if c1 == c2 {
+		fmt.Println("CONFIG: c1=c2")
 		return true
 	}
 	if c1 == nil || c2 == nil {
+		fmt.Println("CONFIG: c1 or c2 is nil")
 		return false
 	}
 
 	if !c1.DefaultSSLCertificate.Equal(c2.DefaultSSLCertificate) {
+		fmt.Println("CONFIG: default ssl certs aren't equal")
 		return false
 	}
 
 	match := compareBackends(c1.Backends, c2.Backends)
 	if !match {
+		fmt.Println("CONFIG: backends don't match")
 		return false
 	}
 
 	if len(c1.Servers) != len(c2.Servers) {
+		fmt.Println("CONFIG: servers lengts don't match")
 		return false
 	}
 
 	// Servers are sorted
 	for idx, c1s := range c1.Servers {
 		if !c1s.Equal(c2.Servers[idx]) {
+			fmt.Printf("CONFIG: server %s doesn't match %s\n", c1s.Hostname, c2.Servers[idx].Hostname)
 			return false
 		}
 	}
 
 	match = compareL4Service(c1.TCPEndpoints, c2.TCPEndpoints)
 	if !match {
+		fmt.Printf("CONFIG: l4 tcp endpoints don't match")
 		return false
 	}
 
 	match = compareL4Service(c1.UDPEndpoints, c2.UDPEndpoints)
 	if !match {
+		fmt.Printf("CONFIG: l4 udp endpoints don't match")
 		return false
 	}
 
 	if len(c1.PassthroughBackends) != len(c2.PassthroughBackends) {
+		fmt.Printf("CONFIG: passthrough backends don't match")
 		return false
 	}
 
@@ -72,10 +83,13 @@ func (c1 *Configuration) Equal(c2 *Configuration) bool {
 			}
 		}
 		if !found {
+			fmt.Printf("CONFIG: passthrough backends don't match 2")
 			return false
 		}
 	}
 
+	fmt.Printf("CONFIG: BackendConfigChecksums match %b\n", c1.BackendConfigChecksum == c2.BackendConfigChecksum)
+
 	return c1.BackendConfigChecksum == c2.BackendConfigChecksum
 }
 
@@ -269,19 +283,24 @@ func (s1 *Server) Equal(s2 *Server) bool {
 		return true
 	}
 	if s1 == nil || s2 == nil {
+		fmt.Println("CONFIG SERVER: nil")
 		return false
 	}
 	if s1.Hostname != s2.Hostname {
+		fmt.Println("CONFIG SERVER: hostame")
 		return false
 	}
 	if s1.SSLPassthrough != s2.SSLPassthrough {
+		fmt.Println("CONFIG SERVER: ssl passtrough")
 		return false
 	}
 	if !s1.SSLCert.Equal(s2.SSLCert) {
+		fmt.Println("CONFIG SERVER: ssl cert")
 		return false
 	}
 
 	if len(s1.Aliases) != len(s2.Aliases) {
+		fmt.Println("CONFIG SERVER: len aliases")
 		return false
 	}
 
@@ -294,39 +313,49 @@ func (s1 *Server) Equal(s2 *Server) bool {
 			}
 		}
 		if !found {
+		fmt.Println("CONFIG SERVER: aliases")
 			return false
 		}
 	}
 
 	if s1.RedirectFromToWWW != s2.RedirectFromToWWW {
+		fmt.Println("CONFIG SERVER: redirect from to www")
 		return false
 	}
 	if !(&s1.CertificateAuth).Equal(&s2.CertificateAuth) {
+		fmt.Println("CONFIG SERVER: auth cert")
 		return false
 	}
 	if s1.ServerSnippet != s2.ServerSnippet {
+		fmt.Println("CONFIG SERVER: serv snippet")
 		return false
 	}
 	if s1.SSLCiphers != s2.SSLCiphers {
+		fmt.Println("CONFIG SERVER: ssl cipher")
 		return false
 	}
 	if s1.SSLPreferServerCiphers != s2.SSLPreferServerCiphers {
+		fmt.Println("CONFIG SERVER: prefer ssl cipher")
 		return false
 	}
 	if s1.AuthTLSError != s2.AuthTLSError {
+		fmt.Println("CONFIG SERVER: auth tls error")
 		return false
 	}
 	if !(&s1.ProxySSL).Equal(&s2.ProxySSL) {
+		fmt.Println("CONFIG SERVER: proxy ssl")
 		return false
 	}
 
 	if len(s1.Locations) != len(s2.Locations) {
+		fmt.Println("CONFIG SERVER: len locations")
 		return false
 	}
 
 	// Location are sorted
 	for idx, s1l := range s1.Locations {
 		if !s1l.Equal(s2.Locations[idx]) {
+			fmt.Printf("CONFIG SERVER: location %s doesn't match location %s\n", s1l.Path, s2.Locations[idx].Path)
 			return false
 		}
 	}
