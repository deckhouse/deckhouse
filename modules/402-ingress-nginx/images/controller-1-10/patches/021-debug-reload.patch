diff --git a/pkg/apis/ingress/types_equals.go b/pkg/apis/ingress/types_equals.go
index eeed9a06e..b1961d06b 100644
--- a/pkg/apis/ingress/types_equals.go
+++ b/pkg/apis/ingress/types_equals.go
@@ -17,49 +17,60 @@ limitations under the License.
 package ingress
 
 import (
+	"fmt"
+
 	"k8s.io/ingress-nginx/pkg/util/sets"
 )
 
 // Equal tests for equality between two Configuration types
 func (c1 *Configuration) Equal(c2 *Configuration) bool {
 	if c1 == c2 {
+		fmt.Println("CONFIG: c1=c2")
 		return true
 	}
 	if c1 == nil || c2 == nil {
+		fmt.Println("CONFIG: c1 or c2 is nil")
 		return false
 	}
 
 	if !c1.DefaultSSLCertificate.Equal(c2.DefaultSSLCertificate) {
+		fmt.Println("CONFIG: default ssl certs aren't equal")
 		return false
 	}
 
 	match := compareBackends(c1.Backends, c2.Backends)
 	if !match {
+		fmt.Println("CONFIG: backends don't match")
 		return false
 	}
 
 	if len(c1.Servers) != len(c2.Servers) {
+		fmt.Println("CONFIG: servers lengts don't match")
 		return false
 	}
 
 	// Servers are sorted
 	for idx, c1s := range c1.Servers {
 		if !c1s.Equal(c2.Servers[idx]) {
+			fmt.Printf("CONFIG: server %s doesn't match %s\n", c1s.Hostname, c2.Servers[idx].Hostname)
 			return false
 		}
 	}
 
 	match = compareL4Service(c1.TCPEndpoints, c2.TCPEndpoints)
 	if !match {
+		fmt.Printf("CONFIG: l4 tcp endpoints don't match")
 		return false
 	}
 
 	match = compareL4Service(c1.UDPEndpoints, c2.UDPEndpoints)
 	if !match {
+		fmt.Printf("CONFIG: l4 udp endpoints don't match")
 		return false
 	}
 
 	if len(c1.PassthroughBackends) != len(c2.PassthroughBackends) {
+		fmt.Printf("CONFIG: passthrough backends don't match")
 		return false
 	}
 
@@ -72,10 +83,13 @@ func (c1 *Configuration) Equal(c2 *Configuration) bool {
 			}
 		}
 		if !found {
+			fmt.Printf("CONFIG: passthrough backends don't match 2")
 			return false
 		}
 	}
 
+	fmt.Printf("CONFIG: BackendConfigChecksums match %b\n", c1.BackendConfigChecksum == c2.BackendConfigChecksum)
+
 	return c1.BackendConfigChecksum == c2.BackendConfigChecksum
 }
 
