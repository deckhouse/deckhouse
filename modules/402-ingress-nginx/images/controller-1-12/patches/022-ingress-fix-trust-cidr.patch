diff --git a/internal/ingress/controller/nginx.go b/internal/ingress/controller/nginx.go
index a5275144c..58998ad75 100644
--- a/internal/ingress/controller/nginx.go
+++ b/internal/ingress/controller/nginx.go
@@ -1111,6 +1111,7 @@ func (n *NGINXController) createLuaConfig(cfg *ngx_config.Configuration) error {
 		HSTSMaxAge:              cfg.HSTSMaxAge,
 		HSTSIncludeSubdomains:   cfg.HSTSIncludeSubdomains,
 		HSTSPreload:             cfg.HSTSPreload,
+		ProxyRealIPCIDR:         cfg.ProxyRealIPCIDR,
 	}
 	jsonCfg, err := json.Marshal(luaconfigs)
 	if err != nil {
diff --git a/internal/ingress/controller/template/template.go b/internal/ingress/controller/template/template.go
index fd4e3b1c2..08a6ec715 100644
--- a/internal/ingress/controller/template/template.go
+++ b/internal/ingress/controller/template/template.go
@@ -221,6 +221,7 @@ type LuaConfig struct {
 	HSTSMaxAge              string         `json:"hsts_max_age"`
 	HSTSIncludeSubdomains   bool           `json:"hsts_include_subdomains"`
 	HSTSPreload             bool           `json:"hsts_preload"`
+	ProxyRealIPCIDR         []string       `json:"proxy-real-ip-cidr"`
 }
 
 type LuaListenPorts struct {
diff --git a/rootfs/etc/nginx/lua/lua_ingress.lua b/rootfs/etc/nginx/lua/lua_ingress.lua
index a513928cf..c9d4cb5dd 100644
--- a/rootfs/etc/nginx/lua/lua_ingress.lua
+++ b/rootfs/etc/nginx/lua/lua_ingress.lua
@@ -62,6 +62,61 @@ local function randomseed()
   math.randomseed(seed)
 end
 
+local function ipv4_to_long(ip)
+  if not ip then
+    return nil
+  end
+
+  local o1, o2, o3, o4 = ip:match("^(%d+)%.(%d+)%.(%d+)%.(%d+)$")
+  o1, o2, o3, o4 = tonumber(o1), tonumber(o2), tonumber(o3), tonumber(o4)
+  if not o1 or not o2 or not o3 or not o4 then
+    return nil
+  end
+  if o1 > 255 or o2 > 255 or o3 > 255 or o4 > 255 then
+    return nil
+  end
+
+  return (((o1 * 256) + o2) * 256 + o3) * 256 + o4
+end
+
+local function parse_cidr(cidr)
+  if not cidr then
+    return nil
+  end
+
+  local ip, mask = cidr:match("^([^/]+)/(%d+)$")
+  if not ip or not mask then
+    return nil
+  end
+
+  mask = tonumber(mask)
+  if not mask or mask < 0 or mask > 32 then
+    return nil
+  end
+
+  local ipnum = ipv4_to_long(ip)
+  if not ipnum then
+    return nil
+  end
+
+  local host_bits = 32 - mask
+  local size = 1
+  if host_bits > 0 then
+    size = 2 ^ host_bits
+  end
+
+  local network_start
+  if host_bits == 0 then
+    network_start = ipnum
+  else
+    network_start = ipnum - (ipnum % size)
+  end
+
+  local network_end = network_start + size - 1
+
+  return network_start, network_end
+end
+
 local function redirect_to_https(location_config)
   if location_config.force_no_ssl_redirect then
     return false
@@ -103,9 +158,55 @@ function _M.init_worker()
 end
 
 function _M.set_config(new_config)
+  new_config.proxy_real_ip_cidr = new_config["proxy-real-ip-cidr"]
+
+  local trusted = {}
+  if new_config.proxy_real_ip_cidr then
+    for _, cidr in ipairs(new_config.proxy_real_ip_cidr) do
+      local start_ip, end_ip = parse_cidr(cidr)
+      if start_ip and end_ip then
+        trusted[#trusted + 1] = { start = start_ip, ["end"] = end_ip }
+      else
+        ngx.log(ngx.WARN, string_format("ignoring invalid proxy-real-ip-cidr entry: %s", tostring(cidr)))
+      end
+    end
+  end
+
+  new_config._trusted_cidrs = trusted
   config = new_config
 end
 
+local function trusted_forward_headers()
+  if not config.use_forwarded_headers then
+    return false
+  end
+
+  local cidrs = config.proxy_real_ip_cidr
+  if not cidrs or #cidrs == 0 then
+    return false
+  end
+
+  local trusted = config._trusted_cidrs
+  if not trusted or #trusted == 0 then
+    return false
+  end
+
+  local proxy_ip = ngx.var.realip_remote_addr or ngx.var.remote_addr
+  local ipnum = ipv4_to_long(proxy_ip)
+  if not ipnum then
+    return false
+  end
+
+  for i = 1, #trusted do
+    local entry = trusted[i]
+    if ipnum >= entry.start and ipnum <= entry["end"] then
+      return true
+    end
+  end
+
+  return false
+end
+
 -- rewrite gets called in every location context.
 -- This is where we do variable assignments to be used in subsequent
 -- phases or redirection
@@ -123,7 +224,7 @@ function _M.rewrite()
 
   ngx.var.best_http_host = ngx.var.http_host or ngx.var.host
 
-  if config.use_forwarded_headers then
+  if trusted_forward_headers() then
     -- trust http_x_forwarded_proto headers correctly indicate ssl offloading
     if ngx.var.http_x_forwarded_proto then
       ngx.var.pass_access_scheme = ngx.var.http_x_forwarded_proto
