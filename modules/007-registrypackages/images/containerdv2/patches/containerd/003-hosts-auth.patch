Subject: [PATCH] hosts auth
---
Index: cmd/ctr/commands/resolver.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/ctr/commands/resolver.go b/cmd/ctr/commands/resolver.go
--- a/cmd/ctr/commands/resolver.go	(revision 4b87d7d28ac7f4c29f8259b90504bfceb1bdad61)
+++ b/cmd/ctr/commands/resolver.go	(revision 668381d7a6807b01b485ec1f521aa25c1e1045bc)
@@ -28,12 +28,13 @@
 	"strings"
 
 	"github.com/containerd/console"
+	"github.com/urfave/cli/v2"
+
 	"github.com/containerd/containerd/v2/core/remotes"
 	"github.com/containerd/containerd/v2/core/remotes/docker"
 	"github.com/containerd/containerd/v2/core/remotes/docker/config"
 	"github.com/containerd/containerd/v2/core/transfer/registry"
 	"github.com/containerd/containerd/v2/pkg/httpdbg"
-	"github.com/urfave/cli/v2"
 )
 
 // PushTracker returns a new InMemoryTracker which tracks the ref status
@@ -82,10 +83,12 @@
 	}
 
 	hostOptions := config.HostOptions{}
-	hostOptions.Credentials = func(host string) (string, string, error) {
-		// If host doesn't match...
-		// Only one host
-		return username, secret, nil
+	if username != "" && secret != "" {
+		hostOptions.Credentials = func(host string) (string, string, error) {
+			// If host doesn't match...
+			// Only one host
+			return username, secret, nil
+		}
 	}
 	if cliContext.Bool("plain-http") {
 		hostOptions.DefaultScheme = "http"
Index: core/remotes/docker/config/hosts.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/remotes/docker/config/hosts.go b/core/remotes/docker/config/hosts.go
--- a/core/remotes/docker/config/hosts.go	(revision 4b87d7d28ac7f4c29f8259b90504bfceb1bdad61)
+++ b/core/remotes/docker/config/hosts.go	(revision 668381d7a6807b01b485ec1f521aa25c1e1045bc)
@@ -20,6 +20,7 @@
 import (
 	"context"
 	"crypto/tls"
+	"encoding/base64"
 	"fmt"
 	"net"
 	"net/http"
@@ -59,9 +60,19 @@
 
 	rewrites []hostPathRewrite
 
+	auth authConfig
+
 	// TODO: Add credential configuration (domain alias, username)
 }
 
+// authConfig holds authentication-related parameters for interacting with a registry.
+type authConfig struct {
+	userName      string
+	password      string
+	auth          string
+	identityToken string
+}
+
 // HostPathRewrite is used to confirure rewrite paths in the mirror hosts
 type hostPathRewrite struct {
 	regexp      *regexp.Regexp
@@ -166,19 +177,23 @@
 			}
 		}
 
-		authOpts := []docker.AuthorizerOpt{docker.WithAuthClient(client)}
-		if options.Credentials != nil {
-			authOpts = append(authOpts, docker.WithAuthCreds(options.Credentials))
-		}
-		authOpts = append(authOpts, options.AuthorizerOpts...)
-		authorizer := docker.NewDockerAuthorizer(authOpts...)
-
 		rhosts := make([]docker.RegistryHost, len(hosts))
 		for i, host := range hosts {
 			// Allow setting for each host as well
 			explicitTLSFromHost := host.caCerts != nil || host.clientPairs != nil || host.skipVerify != nil
 			explicitTLS := tlsConfigured || explicitTLSFromHost
 
+			authOpts := []docker.AuthorizerOpt{docker.WithAuthClient(client)}
+			if options.Credentials != nil {
+				authOpts = append(authOpts, docker.WithAuthCreds(options.Credentials))
+			} else {
+				hostAuth := host.auth // copy to local variable from loop variable
+				authOpts = append(authOpts, docker.WithAuthCreds(func(s string) (string, string, error) {
+					return parseAuth(&hostAuth)
+				}))
+			}
+			authOpts = append(authOpts, options.AuthorizerOpts...)
+
 			if explicitTLSFromHost || host.dialTimeout != nil || len(host.header) != 0 {
 				c := *client
 				if explicitTLSFromHost || host.dialTimeout != nil {
@@ -217,7 +232,7 @@
 				rhosts[i].Authorizer = docker.NewDockerAuthorizer(append(authOpts, docker.WithAuthClient(&c))...)
 			} else {
 				rhosts[i].Client = client
-				rhosts[i].Authorizer = authorizer
+				rhosts[i].Authorizer = docker.NewDockerAuthorizer(authOpts...)
 			}
 
 			// When TLS has been configured for the operation or host and
@@ -398,6 +413,19 @@
 		Replacement string `toml:"replace"`
 	} `toml:"rewrite"`
 
+	Auth struct {
+		// Username is the username to login the registry.
+		Username string `toml:"username" json:"username"`
+		// Password is the password to login the registry.
+		Password string `toml:"password" json:"password"`
+		// Auth is a base64 encoded string from the concatenation of the username,
+		// a colon, and the password.
+		Auth string `toml:"auth" json:"auth"`
+		// IdentityToken is used to authenticate the user and get
+		// an access token for the registry.
+		IdentityToken string `toml:"identitytoken" json:"identitytoken"`
+	} `toml:"auth"`
+
 	// TODO: Credentials: helper? name? username? alternate domain? token?
 }
 
@@ -583,6 +611,13 @@
 		}
 	}
 
+	result.auth = authConfig{
+		userName:      config.Auth.Username,
+		password:      config.Auth.Password,
+		auth:          config.Auth.Auth,
+		identityToken: config.Auth.IdentityToken,
+	}
+
 	return result, nil
 }
 
@@ -687,3 +722,31 @@
 	}
 	return hosts, nil
 }
+
+// parseAuth parses AuthConfig and returns username and password/secret required by containerd.
+func parseAuth(auth *authConfig) (string, string, error) {
+	if auth == nil {
+		return "", "", nil
+	}
+	if auth.userName != "" {
+		return auth.userName, auth.password, nil
+	}
+	if auth.identityToken != "" {
+		return "", auth.identityToken, nil
+	}
+	if auth.auth != "" {
+		decLen := base64.StdEncoding.DecodedLen(len(auth.auth))
+		decoded := make([]byte, decLen)
+		_, err := base64.StdEncoding.Decode(decoded, []byte(auth.auth))
+		if err != nil {
+			return "", "", err
+		}
+		user, passwd, ok := strings.Cut(string(decoded), ":")
+		if !ok {
+			return "", "", fmt.Errorf("invalid decoded auth: %q", decoded)
+		}
+		return user, strings.Trim(passwd, "\x00"), nil
+	}
+
+	return "", "", nil
+}
Index: internal/cri/server/images/image_pull.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/cri/server/images/image_pull.go b/internal/cri/server/images/image_pull.go
--- a/internal/cri/server/images/image_pull.go	(revision 4b87d7d28ac7f4c29f8259b90504bfceb1bdad61)
+++ b/internal/cri/server/images/image_pull.go	(revision 668381d7a6807b01b485ec1f521aa25c1e1045bc)
@@ -101,16 +101,12 @@
 func (c *GRPCCRIImageService) PullImage(ctx context.Context, r *runtime.PullImageRequest) (_ *runtime.PullImageResponse, err error) {
 
 	imageRef := r.GetImage().GetImage()
-
-	credentials := func(host string) (string, string, error) {
-		hostauth := r.GetAuth()
-		if hostauth == nil {
-			config := c.config.Registry.Configs[host]
-			if config.Auth != nil {
-				hostauth = toRuntimeAuthConfig(*config.Auth)
-			}
-		}
-		return ParseAuth(hostauth, host)
+	hostauth := r.GetAuth()
+	var credentials func(host string) (string, string, error)
+	if hostauth != nil {
+		credentials = func(host string) (string, string, error) {
+			return ParseAuth(hostauth, host)
+		}
 	}
 
 	ref, err := c.CRIImageService.PullImage(ctx, imageRef, credentials, r.SandboxConfig, r.GetImage().GetRuntimeHandler())
