Subject: [PATCH] hosts auth
---
Index: cmd/ctr/commands/resolver.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/cmd/ctr/commands/resolver.go b/cmd/ctr/commands/resolver.go
--- a/cmd/ctr/commands/resolver.go	(revision f5bc380d2c2dcb9662f1e1a874a0e7f6f1a19fd4)
+++ b/cmd/ctr/commands/resolver.go	(revision a272b0317438f44a0f469ff49c6c2669e4879c98)
@@ -28,12 +28,13 @@
 	"strings"

 	"github.com/containerd/console"
+	"github.com/urfave/cli/v2"
+
 	"github.com/containerd/containerd/v2/core/remotes"
 	"github.com/containerd/containerd/v2/core/remotes/docker"
 	"github.com/containerd/containerd/v2/core/remotes/docker/config"
 	"github.com/containerd/containerd/v2/core/transfer/registry"
 	"github.com/containerd/containerd/v2/pkg/httpdbg"
-	"github.com/urfave/cli/v2"
 )

 // PushTracker returns a new InMemoryTracker which tracks the ref status
@@ -82,10 +83,12 @@
 	}

 	hostOptions := config.HostOptions{}
-	hostOptions.Credentials = func(host string) (string, string, error) {
-		// If host doesn't match...
-		// Only one host
-		return username, secret, nil
+	if username != "" && secret != "" {
+		hostOptions.Credentials = func(host string) (string, string, error) {
+			// If host doesn't match...
+			// Only one host
+			return username, secret, nil
+		}
 	}
 	if cliContext.Bool("plain-http") {
 		hostOptions.DefaultScheme = "http"
Index: core/remotes/docker/config/hosts.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/remotes/docker/config/hosts.go b/core/remotes/docker/config/hosts.go
--- a/core/remotes/docker/config/hosts.go	(revision f5bc380d2c2dcb9662f1e1a874a0e7f6f1a19fd4)
+++ b/core/remotes/docker/config/hosts.go	(revision a272b0317438f44a0f469ff49c6c2669e4879c98)
@@ -20,6 +20,7 @@
 import (
 	"context"
 	"crypto/tls"
+	"encoding/base64"
 	"fmt"
 	"net"
 	"net/http"
@@ -59,9 +60,19 @@

 	rewrites []hostPathRewrite

+	auth authConfig
+
 	// TODO: Add credential configuration (domain alias, username)
 }

+// authConfig holds authentication-related parameters for interacting with a registry.
+type authConfig struct {
+	userName      string
+	password      string
+	auth          string
+	identityToken string
+}
+
 // HostPathRewrite is used to confirure rewrite paths in the mirror hosts
 type hostPathRewrite struct {
 	regexp      *regexp.Regexp
@@ -166,19 +177,23 @@
 			}
 		}

-		authOpts := []docker.AuthorizerOpt{docker.WithAuthClient(client)}
-		if options.Credentials != nil {
-			authOpts = append(authOpts, docker.WithAuthCreds(options.Credentials))
-		}
-		authOpts = append(authOpts, options.AuthorizerOpts...)
-		authorizer := docker.NewDockerAuthorizer(authOpts...)
-
 		rhosts := make([]docker.RegistryHost, len(hosts))
 		for i, host := range hosts {
 			// Allow setting for each host as well
 			explicitTLSFromHost := host.caCerts != nil || host.clientPairs != nil || host.skipVerify != nil
 			explicitTLS := tlsConfigured || explicitTLSFromHost

+			authOpts := []docker.AuthorizerOpt{docker.WithAuthClient(client)}
+			if options.Credentials != nil {
+				authOpts = append(authOpts, docker.WithAuthCreds(options.Credentials))
+			} else {
+				hostAuth := host.auth // copy to local variable from loop variable
+				authOpts = append(authOpts, docker.WithAuthCreds(func(s string) (string, string, error) {
+					return parseAuth(&hostAuth)
+				}))
+			}
+			authOpts = append(authOpts, options.AuthorizerOpts...)
+
 			if explicitTLSFromHost || host.dialTimeout != nil || len(host.header) != 0 {
 				c := *client
 				if explicitTLSFromHost || host.dialTimeout != nil {
@@ -217,7 +232,7 @@
 				rhosts[i].Authorizer = docker.NewDockerAuthorizer(append(authOpts, docker.WithAuthClient(&c))...)
 			} else {
 				rhosts[i].Client = client
-				rhosts[i].Authorizer = authorizer
+				rhosts[i].Authorizer = docker.NewDockerAuthorizer(authOpts...)
 			}

 			// When TLS has been configured for the operation or host and
@@ -398,6 +413,19 @@
 		Replacement string `toml:"replace"`
 	} `toml:"rewrite"`

+	Auth struct {
+		// Username is the username to login the registry.
+		Username string `toml:"username" json:"username"`
+		// Password is the password to login the registry.
+		Password string `toml:"password" json:"password"`
+		// Auth is a base64 encoded string from the concatenation of the username,
+		// a colon, and the password.
+		Auth string `toml:"auth" json:"auth"`
+		// IdentityToken is used to authenticate the user and get
+		// an access token for the registry.
+		IdentityToken string `toml:"identitytoken" json:"identitytoken"`
+	} `toml:"auth"`
+
 	// TODO: Credentials: helper? name? username? alternate domain? token?
 }

@@ -583,6 +611,13 @@
 		}
 	}

+	result.auth = authConfig{
+		userName:      config.Auth.Username,
+		password:      config.Auth.Password,
+		auth:          config.Auth.Auth,
+		identityToken: config.Auth.IdentityToken,
+	}
+
 	return result, nil
 }

@@ -687,3 +722,31 @@
 	}
 	return hosts, nil
 }
+
+// parseAuth parses AuthConfig and returns username and password/secret required by containerd.
+func parseAuth(auth *authConfig) (string, string, error) {
+	if auth == nil {
+		return "", "", nil
+	}
+	if auth.userName != "" {
+		return auth.userName, auth.password, nil
+	}
+	if auth.identityToken != "" {
+		return "", auth.identityToken, nil
+	}
+	if auth.auth != "" {
+		decLen := base64.StdEncoding.DecodedLen(len(auth.auth))
+		decoded := make([]byte, decLen)
+		_, err := base64.StdEncoding.Decode(decoded, []byte(auth.auth))
+		if err != nil {
+			return "", "", err
+		}
+		user, passwd, ok := strings.Cut(string(decoded), ":")
+		if !ok {
+			return "", "", fmt.Errorf("invalid decoded auth: %q", decoded)
+		}
+		return user, strings.Trim(passwd, "\x00"), nil
+	}
+
+	return "", "", nil
+}
Index: core/remotes/docker/config/hosts_test.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/core/remotes/docker/config/hosts_test.go b/core/remotes/docker/config/hosts_test.go
--- a/core/remotes/docker/config/hosts_test.go	(revision f5bc380d2c2dcb9662f1e1a874a0e7f6f1a19fd4)
+++ b/core/remotes/docker/config/hosts_test.go	(revision a272b0317438f44a0f469ff49c6c2669e4879c98)
@@ -300,6 +300,70 @@
 	}
 }

+func TestParseHostFileWithAuth(t *testing.T) {
+	const testtoml = `
+server = "https://test-default.registry"
+[auth]
+username = "user"
+password = "password"
+
+[host."https://mirror.registry"]
+  capabilities = ["pull"]
+  [host."https://mirror.registry".auth]
+    username = "user2"
+    password = "password2"
+
+[host."https://mirror-bak.registry/us"]
+  capabilities = ["pull"]
+  [host."https://mirror-bak.registry/us".auth]
+    username = "user3"
+    password = "password3"
+`
+	expected := []hostConfig{
+		{
+			scheme:       "https",
+			host:         "mirror.registry",
+			path:         "/v2",
+			capabilities: docker.HostCapabilityPull,
+			auth:         authConfig{userName: "user2", password: "password2"},
+		},
+		{
+			scheme:       "https",
+			host:         "mirror-bak.registry",
+			path:         "/us/v2",
+			capabilities: docker.HostCapabilityPull,
+			auth:         authConfig{userName: "user3", password: "password3"},
+		},
+		{
+			scheme:       "https",
+			host:         "test-default.registry",
+			path:         "/v2",
+			capabilities: allCaps,
+			auth:         authConfig{userName: "user", password: "password"},
+		},
+	}
+	hosts, err := parseHostsFile("", []byte(testtoml))
+	if err != nil {
+		t.Fatal(err)
+	}
+
+	defer func() {
+		if t.Failed() {
+			t.Log("HostConfigs...\nActual:\n" + printHostConfig(hosts) + "Expected:\n" + printHostConfig(expected))
+		}
+	}()
+
+	if len(hosts) != len(expected) {
+		t.Fatalf("Unexpected number of hosts %d, expected %d", len(hosts), len(expected))
+	}
+
+	for i := range hosts {
+		if !compareHostConfig(hosts[i], expected[i]) {
+			t.Fatalf("Mismatch at host %d", i)
+		}
+	}
+}
+
 func TestLoadCertFiles(t *testing.T) {
 	dir := t.TempDir()

@@ -656,6 +720,20 @@
 			return false
 		}
 	}
+
+	if j.auth.userName != k.auth.userName {
+		return false
+	}
+	if j.auth.password != k.auth.password {
+		return false
+	}
+	if j.auth.auth != k.auth.auth {
+		return false
+	}
+	if j.auth.identityToken != k.auth.identityToken {
+		return false
+	}
+
 	return true
 }

@@ -680,6 +758,7 @@
 		if hc[i].rewrites != nil {
 			fmt.Fprintf(b, "\t\trewrites: %#v\n", hc[i].rewrites)
 		}
+		fmt.Fprintf(b, "\t\tauth: %#v\n", hc[i].auth)
 		fmt.Fprintf(b, "\n")
 	}
 	return b.String()
Index: internal/cri/server/images/image_pull.go
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/internal/cri/server/images/image_pull.go b/internal/cri/server/images/image_pull.go
--- a/internal/cri/server/images/image_pull.go	(revision f5bc380d2c2dcb9662f1e1a874a0e7f6f1a19fd4)
+++ b/internal/cri/server/images/image_pull.go	(revision a272b0317438f44a0f469ff49c6c2669e4879c98)
@@ -101,16 +101,12 @@
 func (c *GRPCCRIImageService) PullImage(ctx context.Context, r *runtime.PullImageRequest) (_ *runtime.PullImageResponse, err error) {

 	imageRef := r.GetImage().GetImage()
-
-	credentials := func(host string) (string, string, error) {
-		hostauth := r.GetAuth()
-		if hostauth == nil {
-			config := c.config.Registry.Configs[host]
-			if config.Auth != nil {
-				hostauth = toRuntimeAuthConfig(*config.Auth)
-			}
-		}
-		return ParseAuth(hostauth, host)
+	hostauth := r.GetAuth()
+	var credentials func(host string) (string, string, error)
+	if hostauth != nil {
+		credentials = func(host string) (string, string, error) {
+			return ParseAuth(hostauth, host)
+		}
 	}

 	ref, err := c.CRIImageService.PullImage(ctx, imageRef, credentials, r.SandboxConfig, r.GetImage().GetRuntimeHandler())
