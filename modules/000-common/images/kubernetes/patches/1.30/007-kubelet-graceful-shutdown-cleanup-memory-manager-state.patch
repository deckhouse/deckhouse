diff --git a/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go b/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
index 6bbe5e5eb0e..44bd8c70d43 100644
--- a/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
+++ b/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
@@ -23,6 +23,7 @@ package nodeshutdown
 import (
 	"context"
 	"fmt"
+	"os"
 	"path/filepath"
 	"sort"
 	"sync"
@@ -337,6 +338,11 @@ func (m *managerImpl) start() (chan struct{}, error) {
 					m.conditionChecker.PauseMonitor()
 				}
 
+				// Clean up memory manager state before shutdown
+				if isShuttingDown {
+					m.cleanupMemoryManagerState()
+				}
+
 				m.nodeShuttingDownMutex.Lock()
 				m.nodeShuttingDownNow = isShuttingDown
 				m.nodeShuttingDownMutex.Unlock()
@@ -485,6 +491,23 @@ func (m *managerImpl) periodRequested() time.Duration {
 	return time.Duration(sum) * time.Second
 }
 
+// cleanupMemoryManagerState ensures that the memory manager starts with a clean state after reboot.
+func (m *managerImpl) cleanupMemoryManagerState() {
+	memoryManagerStatePath := "/var/lib/kubelet/memory_manager_state"
+
+	if _, err := os.Stat(memoryManagerStatePath); os.IsNotExist(err) {
+		m.logger.V(1).Info("Memory manager state file does not exist, skipping removal", "path", memoryManagerStatePath)
+		return
+	}
+
+	if err := os.Remove(memoryManagerStatePath); err != nil {
+		m.logger.Error(err, "Failed to remove memory manager state file", "path", memoryManagerStatePath)
+		return
+	}
+
+	m.logger.Info("Successfully removed memory manager state file before shutdown", "path", memoryManagerStatePath)
+}
+
 func migrateConfig(shutdownGracePeriodRequested, shutdownGracePeriodCriticalPods time.Duration) []kubeletconfig.ShutdownGracePeriodByPodPriority {
 	if shutdownGracePeriodRequested == 0 {
 		return nil
