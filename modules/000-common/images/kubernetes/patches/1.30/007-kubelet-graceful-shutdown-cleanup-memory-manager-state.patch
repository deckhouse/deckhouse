diff --git a/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go b/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
index 8469cecdc0e..cf3968d19ab 100644
--- a/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
+++ b/pkg/kubelet/nodeshutdown/nodeshutdown_manager_linux.go
@@ -22,6 +22,7 @@ package nodeshutdown
 
 import (
 	"fmt"
+	"os"
 	"path/filepath"
 	"sort"
 	"sync"
@@ -277,6 +278,11 @@ func (m *managerImpl) start() (chan struct{}, error) {
 					m.recorder.Event(m.nodeRef, v1.EventTypeNormal, kubeletevents.NodeShutdown, "Shutdown manager detected shutdown cancellation")
 				}
 
+				// Clean up memory manager state before shutdown
+				if isShuttingDown {
+					m.cleanupMemoryManagerState()
+				}
+
 				m.nodeShuttingDownMutex.Lock()
 				m.nodeShuttingDownNow = isShuttingDown
 				m.nodeShuttingDownMutex.Unlock()
@@ -425,6 +431,23 @@ func (m *managerImpl) periodRequested() time.Duration {
 	return time.Duration(sum) * time.Second
 }
 
+// cleanupMemoryManagerState ensures that the memory manager starts with a clean state after reboot.
+func (m *managerImpl) cleanupMemoryManagerState() {
+	memoryManagerStatePath := "/var/lib/kubelet/memory_manager_state"
+
+	if _, err := os.Stat(memoryManagerStatePath); os.IsNotExist(err) {
+		m.logger.V(1).Info("Memory manager state file does not exist, skipping removal", "path", memoryManagerStatePath)
+		return
+	}
+
+	if err := os.Remove(memoryManagerStatePath); err != nil {
+		m.logger.Error(err, "Failed to remove memory manager state file", "path", memoryManagerStatePath)
+		return
+	}
+
+	m.logger.Info("Successfully removed memory manager state file before shutdown", "path", memoryManagerStatePath)
+}
+
 func migrateConfig(shutdownGracePeriodRequested, shutdownGracePeriodCriticalPods time.Duration) []kubeletconfig.ShutdownGracePeriodByPodPriority {
 	if shutdownGracePeriodRequested == 0 {
 		return nil
