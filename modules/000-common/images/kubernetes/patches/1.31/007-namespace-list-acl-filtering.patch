diff --git a/pkg/registry/core/namespace/storage/accessible_fetcher.go b/pkg/registry/core/namespace/storage/accessible_fetcher.go
new file mode 100644
index 00000000000..ca18c1d9566
--- /dev/null
+++ b/pkg/registry/core/namespace/storage/accessible_fetcher.go
@@ -0,0 +1,206 @@
+/*
+Copyright 2025 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package storage
+
+import (
+	"context"
+	"encoding/json"
+	"fmt"
+	"io"
+	"net/http"
+	"strings"
+	"time"
+
+	restclient "k8s.io/client-go/rest"
+	"k8s.io/client-go/transport"
+	"k8s.io/klog/v2"
+)
+
+const (
+	// accessibleNamespacesAPIPath is the path to the accessiblenamespaces API
+	// provided by permission-browser-apiserver (Deckhouse extension).
+	accessibleNamespacesAPIPath = "/apis/authorization.deckhouse.io/v1alpha1/accessiblenamespaces"
+
+	// DefaultHTTPTimeout is the default timeout for HTTP requests.
+	DefaultHTTPTimeout = 10 * time.Second
+)
+
+// AccessibleNamespaceResponse represents a single accessible namespace from the API response.
+type AccessibleNamespaceResponse struct {
+	Metadata struct {
+		Name string `json:"name"`
+	} `json:"metadata"`
+}
+
+// AccessibleNamespaceListResponse represents the list response from the accessible namespaces API.
+type AccessibleNamespaceListResponse struct {
+	Items []AccessibleNamespaceResponse `json:"items"`
+}
+
+// LoopbackAccessibleNamespaceFetcher implements AccessibleNamespaceFetcher by calling
+// the permission-browser-apiserver's accessiblenamespaces API through kube-apiserver's
+// loopback connection. This ensures proper authentication via loopback client credentials
+// while using impersonation to act as the target user.
+//
+// Deckhouse-specific: used for ACL-based namespace filtering.
+type LoopbackAccessibleNamespaceFetcher struct {
+	// baseURL is the base URL for API requests (typically https://127.0.0.1:6443)
+	baseURL string
+
+	// roundTripper is the authenticated transport from loopback config
+	roundTripper http.RoundTripper
+
+	// timeout for HTTP requests
+	timeout time.Duration
+}
+
+// NewLoopbackAccessibleNamespaceFetcher creates a new fetcher that uses the kube-apiserver's
+// loopback client configuration to call the accessiblenamespaces API with impersonation.
+//
+// This is the recommended way to create the fetcher as it:
+// - Uses proper authentication via loopback client certificates
+// - Supports impersonation to act as the target user
+// - Routes through kube-apiserver's aggregator to reach the extension apiserver
+func NewLoopbackAccessibleNamespaceFetcher(loopbackConfig *restclient.Config) (*LoopbackAccessibleNamespaceFetcher, error) {
+	if loopbackConfig == nil {
+		return nil, fmt.Errorf("loopback config is required")
+	}
+
+	// Create a copy of the config to avoid modifying the original
+	cfg := restclient.CopyConfig(loopbackConfig)
+
+	// Create the transport from config (includes TLS, auth, etc.)
+	transportConfig, err := cfg.TransportConfig()
+	if err != nil {
+		return nil, fmt.Errorf("failed to get transport config: %w", err)
+	}
+
+	rt, err := transport.New(transportConfig)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create transport: %w", err)
+	}
+
+	// Normalize the base URL
+	baseURL := strings.TrimRight(cfg.Host, "/")
+
+	return &LoopbackAccessibleNamespaceFetcher{
+		baseURL:      baseURL,
+		roundTripper: rt,
+		timeout:      DefaultHTTPTimeout,
+	}, nil
+}
+
+// FetchAccessibleNamespaces fetches the list of accessible namespace names for the user
+// by calling the accessiblenamespaces API with impersonation headers.
+func (f *LoopbackAccessibleNamespaceFetcher) FetchAccessibleNamespaces(ctx context.Context, username string, groups []string, extra map[string][]string) ([]string, error) {
+	url := f.baseURL + accessibleNamespacesAPIPath
+
+	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
+	if err != nil {
+		return nil, fmt.Errorf("failed to create request: %w", err)
+	}
+
+	// Set impersonation headers - the loopback client is authenticated,
+	// so kube-apiserver will honor these headers for impersonation.
+	req.Header.Set("Impersonate-User", username)
+	for _, group := range groups {
+		req.Header.Add("Impersonate-Group", group)
+	}
+	for key, values := range extra {
+		for _, value := range values {
+			req.Header.Add("Impersonate-Extra-"+key, value)
+		}
+	}
+
+	klog.V(4).Infof("Fetching accessible namespaces for user %s via loopback at %s", username, url)
+
+	client := &http.Client{
+		Transport: f.roundTripper,
+		Timeout:   f.timeout,
+	}
+
+	resp, err := client.Do(req)
+	if err != nil {
+		return nil, fmt.Errorf("failed to fetch accessible namespaces: %w", err)
+	}
+	defer resp.Body.Close()
+
+	if resp.StatusCode != http.StatusOK {
+		body, _ := io.ReadAll(resp.Body)
+		return nil, fmt.Errorf("unexpected status code %d: %s", resp.StatusCode, string(body))
+	}
+
+	var listResponse AccessibleNamespaceListResponse
+	if err := json.NewDecoder(resp.Body).Decode(&listResponse); err != nil {
+		return nil, fmt.Errorf("failed to decode response: %w", err)
+	}
+
+	names := make([]string, len(listResponse.Items))
+	for i, item := range listResponse.Items {
+		names[i] = item.Metadata.Name
+	}
+
+	klog.V(4).Infof("User %s has access to %d namespaces", username, len(names))
+
+	return names, nil
+}
+
+// IsNamespaceAccessible checks if a specific namespace is accessible to the user
+// by calling the accessiblenamespaces API with impersonation headers.
+func (f *LoopbackAccessibleNamespaceFetcher) IsNamespaceAccessible(ctx context.Context, username string, groups []string, extra map[string][]string, namespace string) (bool, error) {
+	url := fmt.Sprintf("%s%s/%s", f.baseURL, accessibleNamespacesAPIPath, namespace)
+
+	req, err := http.NewRequestWithContext(ctx, http.MethodGet, url, nil)
+	if err != nil {
+		return false, fmt.Errorf("failed to create request: %w", err)
+	}
+
+	// Set impersonation headers
+	req.Header.Set("Impersonate-User", username)
+	for _, group := range groups {
+		req.Header.Add("Impersonate-Group", group)
+	}
+	for key, values := range extra {
+		for _, value := range values {
+			req.Header.Add("Impersonate-Extra-"+key, value)
+		}
+	}
+
+	klog.V(4).Infof("Checking if namespace %s is accessible for user %s via loopback", namespace, username)
+
+	client := &http.Client{
+		Transport: f.roundTripper,
+		Timeout:   f.timeout,
+	}
+
+	resp, err := client.Do(req)
+	if err != nil {
+		return false, fmt.Errorf("failed to check namespace accessibility: %w", err)
+	}
+	defer resp.Body.Close()
+
+	switch resp.StatusCode {
+	case http.StatusOK:
+		return true, nil
+	case http.StatusNotFound:
+		// Namespace not accessible (or doesn't exist)
+		return false, nil
+	default:
+		body, _ := io.ReadAll(resp.Body)
+		return false, fmt.Errorf("unexpected status code %d: %s", resp.StatusCode, string(body))
+	}
+}
diff --git a/pkg/registry/core/namespace/storage/filtering_test.go b/pkg/registry/core/namespace/storage/filtering_test.go
new file mode 100644
index 00000000000..74dbbfb9494
--- /dev/null
+++ b/pkg/registry/core/namespace/storage/filtering_test.go
@@ -0,0 +1,379 @@
+/*
+Copyright 2025 The Kubernetes Authors.
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+    http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+package storage
+
+import (
+	"context"
+	"fmt"
+	"testing"
+
+	apierrors "k8s.io/apimachinery/pkg/api/errors"
+	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
+	"k8s.io/apiserver/pkg/authentication/user"
+	"k8s.io/apiserver/pkg/endpoints/filters"
+	genericapirequest "k8s.io/apiserver/pkg/endpoints/request"
+	"k8s.io/apiserver/pkg/registry/generic"
+	"k8s.io/apiserver/pkg/registry/rest"
+	etcd3testing "k8s.io/apiserver/pkg/storage/etcd3/testing"
+
+	api "k8s.io/kubernetes/pkg/apis/core"
+	"k8s.io/kubernetes/pkg/registry/registrytest"
+)
+
+// mockAccessibleFetcher implements AccessibleNamespaceFetcher for testing
+type mockAccessibleFetcher struct {
+	accessibleNamespaces []string
+	accessibleMap        map[string]bool
+	fetchError           error
+}
+
+func (m *mockAccessibleFetcher) FetchAccessibleNamespaces(ctx context.Context, username string, groups []string, extra map[string][]string) ([]string, error) {
+	if m.fetchError != nil {
+		return nil, m.fetchError
+	}
+	return m.accessibleNamespaces, nil
+}
+
+func (m *mockAccessibleFetcher) IsNamespaceAccessible(ctx context.Context, username string, groups []string, extra map[string][]string, namespace string) (bool, error) {
+	if m.fetchError != nil {
+		return false, m.fetchError
+	}
+	if m.accessibleMap != nil {
+		return m.accessibleMap[namespace], nil
+	}
+	for _, ns := range m.accessibleNamespaces {
+		if ns == namespace {
+			return true, nil
+		}
+	}
+	return false, nil
+}
+
+// newStorageWithFiltering creates a storage with filtering enabled
+func newStorageWithFiltering(t *testing.T, fetcher *mockAccessibleFetcher) (*REST, *etcd3testing.EtcdTestServer) {
+	etcdStorage, server := registrytest.NewEtcdStorage(t, "")
+	restOptions := generic.RESTOptions{StorageConfig: etcdStorage, Decorator: generic.UndecoratedStorage, DeleteCollectionWorkers: 1, ResourcePrefix: "namespaces"}
+
+	namespaceStorage, _, _, err := NewRESTWithFiltering(restOptions, fetcher)
+	if err != nil {
+		t.Fatalf("unexpected error from REST storage: %v", err)
+	}
+	return namespaceStorage, server
+}
+
+// createNamespace creates a namespace in storage
+func createNamespace(t *testing.T, storage *REST, name string) {
+	ns := &api.Namespace{
+		ObjectMeta: metav1.ObjectMeta{
+			Name: name,
+		},
+	}
+	// Use a clean context for creation (without namespace scope since namespaces are cluster-scoped)
+	ctx := genericapirequest.WithNamespace(genericapirequest.NewContext(), metav1.NamespaceNone)
+	_, err := storage.Create(ctx, ns, rest.ValidateAllObjectFunc, &metav1.CreateOptions{})
+	if err != nil {
+		t.Fatalf("failed to create namespace %s: %v", name, err)
+	}
+}
+
+// ctxWithUser creates a context with user info
+func ctxWithUser(username string, groups []string) context.Context {
+	ctx := genericapirequest.NewContext()
+	ctx = genericapirequest.WithUser(ctx, &user.DefaultInfo{
+		Name:   username,
+		Groups: groups,
+	})
+	return ctx
+}
+
+// ctxWithFilteringMode creates a context with namespace filtering mode enabled
+// This simulates what WithAuthorization filter does when user is denied list/get permission
+func ctxWithFilteringMode(ctx context.Context) context.Context {
+	return filters.WithNamespaceFilteringMode(ctx)
+}
+
+func TestListWithFiltering_NoFilteringMode_ReturnsAll(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{accessibleNamespaces: []string{"ns-a"}}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	// Create some namespaces
+	createNamespace(t, storage, "ns-a")
+	createNamespace(t, storage, "ns-b")
+	createNamespace(t, storage, "ns-c")
+
+	// List without filtering mode (user has full access)
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+
+	// List should return all namespaces (filtering mode not set)
+	result, err := storage.List(ctx, nil)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	nsList := result.(*api.NamespaceList)
+	if len(nsList.Items) != 3 {
+		t.Errorf("expected 3 namespaces, got %d", len(nsList.Items))
+	}
+}
+
+func TestListWithFiltering_FilteringMode_FilteredList(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{accessibleNamespaces: []string{"ns-a", "ns-c"}}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	// Create some namespaces
+	createNamespace(t, storage, "ns-a")
+	createNamespace(t, storage, "ns-b")
+	createNamespace(t, storage, "ns-c")
+
+	// List with filtering mode enabled (user was denied list permission)
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+	ctx = ctxWithFilteringMode(ctx)
+
+	// List should return only accessible namespaces
+	result, err := storage.List(ctx, nil)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	nsList := result.(*api.NamespaceList)
+	if len(nsList.Items) != 2 {
+		t.Errorf("expected 2 namespaces, got %d", len(nsList.Items))
+	}
+
+	// Check that only ns-a and ns-c are returned
+	names := make(map[string]bool)
+	for _, ns := range nsList.Items {
+		names[ns.Name] = true
+	}
+
+	if !names["ns-a"] {
+		t.Error("expected ns-a in result")
+	}
+	if names["ns-b"] {
+		t.Error("ns-b should not be in result")
+	}
+	if !names["ns-c"] {
+		t.Error("expected ns-c in result")
+	}
+}
+
+func TestListWithFiltering_FilteringMode_EmptyList(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{accessibleNamespaces: []string{}}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	// Create some namespaces
+	createNamespace(t, storage, "ns-a")
+	createNamespace(t, storage, "ns-b")
+
+	// List with filtering mode enabled
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+	ctx = ctxWithFilteringMode(ctx)
+
+	// List should return empty list
+	result, err := storage.List(ctx, nil)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	nsList := result.(*api.NamespaceList)
+	if len(nsList.Items) != 0 {
+		t.Errorf("expected 0 namespaces, got %d", len(nsList.Items))
+	}
+}
+
+func TestListWithFiltering_FetchError_ReturnsForbidden(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{fetchError: fmt.Errorf("service unavailable")}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+	ctx = ctxWithFilteringMode(ctx)
+
+	// List should return forbidden error
+	_, err := storage.List(ctx, nil)
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+
+	if !apierrors.IsForbidden(err) {
+		t.Errorf("expected Forbidden error, got %v", err)
+	}
+}
+
+func TestGetWithFiltering_NoFilteringMode_ReturnsNamespace(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{accessibleNamespaces: []string{"ns-a"}}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	createNamespace(t, storage, "ns-a")
+
+	// Get without filtering mode
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+
+	// Get should succeed (filtering mode not set)
+	result, err := storage.Get(ctx, "ns-a", &metav1.GetOptions{})
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	ns := result.(*api.Namespace)
+	if ns.Name != "ns-a" {
+		t.Errorf("expected ns-a, got %s", ns.Name)
+	}
+}
+
+func TestGetWithFiltering_FilteringMode_AccessibleNamespace(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{
+		accessibleNamespaces: []string{"ns-a"},
+		accessibleMap:        map[string]bool{"ns-a": true},
+	}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	createNamespace(t, storage, "ns-a")
+
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+	ctx = ctxWithFilteringMode(ctx)
+
+	// Get should succeed (namespace is accessible)
+	result, err := storage.Get(ctx, "ns-a", &metav1.GetOptions{})
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	ns := result.(*api.Namespace)
+	if ns.Name != "ns-a" {
+		t.Errorf("expected ns-a, got %s", ns.Name)
+	}
+}
+
+func TestGetWithFiltering_FilteringMode_InaccessibleNamespace_ReturnsNotFound(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{
+		accessibleNamespaces: []string{},
+		accessibleMap:        map[string]bool{"ns-a": false},
+	}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	createNamespace(t, storage, "ns-a")
+
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+	ctx = ctxWithFilteringMode(ctx)
+
+	// Get should return NotFound (namespace not accessible)
+	_, err := storage.Get(ctx, "ns-a", &metav1.GetOptions{})
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+
+	if !apierrors.IsNotFound(err) {
+		t.Errorf("expected NotFound error, got %v", err)
+	}
+}
+
+func TestGetWithFiltering_NonExistentNamespace_ReturnsNotFound(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{accessibleNamespaces: []string{}}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+	ctx = ctxWithFilteringMode(ctx)
+
+	// Get should return NotFound for non-existent namespace
+	_, err := storage.Get(ctx, "ns-nonexistent", &metav1.GetOptions{})
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+
+	if !apierrors.IsNotFound(err) {
+		t.Errorf("expected NotFound error, got %v", err)
+	}
+}
+
+func TestGetWithFiltering_FetchError_ReturnsForbidden(t *testing.T) {
+	fetcher := &mockAccessibleFetcher{fetchError: fmt.Errorf("service unavailable")}
+
+	storage, server := newStorageWithFiltering(t, fetcher)
+	defer server.Terminate(t)
+	defer storage.store.DestroyFunc()
+
+	createNamespace(t, storage, "ns-a")
+
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+	ctx = ctxWithFilteringMode(ctx)
+
+	// Get should return Forbidden when permission-browser-apiserver is unavailable.
+	// This is consistent with vanilla Kubernetes behavior.
+	_, err := storage.Get(ctx, "ns-a", &metav1.GetOptions{})
+	if err == nil {
+		t.Fatal("expected error, got nil")
+	}
+
+	if !apierrors.IsForbidden(err) {
+		t.Errorf("expected Forbidden error, got %v", err)
+	}
+}
+
+func TestListWithFiltering_NoFetcher_ReturnsAll(t *testing.T) {
+	// Test with nil fetcher (filtering disabled)
+	etcdStorage, server := registrytest.NewEtcdStorage(t, "")
+	defer server.Terminate(t)
+
+	restOptions := generic.RESTOptions{StorageConfig: etcdStorage, Decorator: generic.UndecoratedStorage, DeleteCollectionWorkers: 1, ResourcePrefix: "namespaces"}
+
+	storage, _, _, err := NewRESTWithFiltering(restOptions, nil)
+	if err != nil {
+		t.Fatalf("unexpected error from REST storage: %v", err)
+	}
+	defer storage.store.DestroyFunc()
+
+	createNamespace(t, storage, "ns-a")
+	createNamespace(t, storage, "ns-b")
+
+	// Even with filtering mode set, should return all (no fetcher)
+	ctx := ctxWithUser("test-user", []string{"system:authenticated"})
+	ctx = ctxWithFilteringMode(ctx)
+
+	result, err := storage.List(ctx, nil)
+	if err != nil {
+		t.Fatalf("unexpected error: %v", err)
+	}
+
+	nsList := result.(*api.NamespaceList)
+	if len(nsList.Items) != 2 {
+		t.Errorf("expected 2 namespaces (filtering disabled), got %d", len(nsList.Items))
+	}
+}
diff --git a/pkg/registry/core/namespace/storage/storage.go b/pkg/registry/core/namespace/storage/storage.go
index e88fad7fa8a..72c54d36816 100644
--- a/pkg/registry/core/namespace/storage/storage.go
+++ b/pkg/registry/core/namespace/storage/storage.go
@@ -26,12 +26,16 @@ import (
 	"k8s.io/apimachinery/pkg/runtime"
 	utilruntime "k8s.io/apimachinery/pkg/util/runtime"
 	"k8s.io/apimachinery/pkg/watch"
+	"k8s.io/apiserver/pkg/endpoints/filters"
+	"k8s.io/apiserver/pkg/endpoints/request"
 	"k8s.io/apiserver/pkg/registry/generic"
 	genericregistry "k8s.io/apiserver/pkg/registry/generic/registry"
 	"k8s.io/apiserver/pkg/registry/rest"
 	"k8s.io/apiserver/pkg/storage"
 	storageerr "k8s.io/apiserver/pkg/storage/errors"
 	"k8s.io/apiserver/pkg/util/dryrun"
+	restclient "k8s.io/client-go/rest"
+	"k8s.io/klog/v2"
 	api "k8s.io/kubernetes/pkg/apis/core"
 	"k8s.io/kubernetes/pkg/printers"
 	printersinternal "k8s.io/kubernetes/pkg/printers/internalversion"
@@ -40,10 +44,26 @@ import (
 	"sigs.k8s.io/structured-merge-diff/v4/fieldpath"
 )
 
+// AccessibleNamespaceFetcher is an interface for fetching accessible namespaces for a user.
+// This is typically implemented by calling an external service (e.g., permission-browser-apiserver).
+type AccessibleNamespaceFetcher interface {
+	// FetchAccessibleNamespaces returns a list of namespace names that the user has access to.
+	// Returns nil, nil if the feature is disabled or the user has full access.
+	FetchAccessibleNamespaces(ctx context.Context, username string, groups []string, extra map[string][]string) ([]string, error)
+
+	// IsNamespaceAccessible checks if a specific namespace is accessible to the user.
+	IsNamespaceAccessible(ctx context.Context, username string, groups []string, extra map[string][]string, namespace string) (bool, error)
+}
+
 // rest implements a RESTStorage for namespaces
 type REST struct {
 	store  *genericregistry.Store
 	status *genericregistry.Store
+
+	// Deckhouse: namespace filtering support.
+	// If set, namespaces will be filtered based on user permissions
+	// when IsNamespaceFilteringMode(ctx) is true.
+	accessibleFetcher AccessibleNamespaceFetcher
 }
 
 // StatusREST implements the REST endpoint for changing the status of a namespace.
@@ -58,6 +78,31 @@ type FinalizeREST struct {
 
 // NewREST returns a RESTStorage object that will work against namespaces.
 func NewREST(optsGetter generic.RESTOptionsGetter) (*REST, *StatusREST, *FinalizeREST, error) {
+	return NewRESTWithFiltering(optsGetter, nil)
+}
+
+// NewRESTWithDeckhouseFiltering returns a RESTStorage object with Deckhouse namespace filtering enabled.
+// It uses the loopback client config to call permission-browser-apiserver through kube-apiserver's
+// aggregated API mechanism with impersonation.
+// Filtering is triggered when IsNamespaceFilteringMode(ctx) is true (set by WithAuthorization filter).
+// If loopbackConfig is nil, filtering is disabled (vanilla Kubernetes behavior).
+// Deckhouse-specific: used for ACL-based namespace filtering.
+func NewRESTWithDeckhouseFiltering(optsGetter generic.RESTOptionsGetter, loopbackConfig *restclient.Config) (*REST, *StatusREST, *FinalizeREST, error) {
+	var fetcher AccessibleNamespaceFetcher
+	if loopbackConfig != nil {
+		var err error
+		fetcher, err = NewLoopbackAccessibleNamespaceFetcher(loopbackConfig)
+		if err != nil {
+			klog.Warningf("Failed to create loopback accessible namespace fetcher: %v, namespace filtering disabled", err)
+			fetcher = nil
+		}
+	}
+	return NewRESTWithFiltering(optsGetter, fetcher)
+}
+
+// NewRESTWithFiltering returns a RESTStorage object with optional namespace filtering support.
+// If fetcher is nil, filtering is disabled (default Kubernetes behavior).
+func NewRESTWithFiltering(optsGetter generic.RESTOptionsGetter, fetcher AccessibleNamespaceFetcher) (*REST, *StatusREST, *FinalizeREST, error) {
 	store := &genericregistry.Store{
 		NewFunc:                   func() runtime.Object { return &api.Namespace{} },
 		NewListFunc:               func() runtime.Object { return &api.NamespaceList{} },
@@ -88,7 +133,9 @@ func NewREST(optsGetter generic.RESTOptionsGetter) (*REST, *StatusREST, *Finaliz
 	finalizeStore.UpdateStrategy = namespace.FinalizeStrategy
 	finalizeStore.ResetFieldsStrategy = namespace.FinalizeStrategy
 
-	return &REST{store: store, status: &statusStore}, &StatusREST{store: &statusStore}, &FinalizeREST{store: &finalizeStore}, nil
+	r := &REST{store: store, status: &statusStore, accessibleFetcher: fetcher}
+
+	return r, &StatusREST{store: &statusStore}, &FinalizeREST{store: &finalizeStore}, nil
 }
 
 func (r *REST) NamespaceScoped() bool {
@@ -114,8 +161,123 @@ func (r *REST) NewList() runtime.Object {
 	return r.store.NewList()
 }
 
+// isFilteringEnabled returns true if namespace filtering is configured.
+func (r *REST) isFilteringEnabled() bool {
+	return r.accessibleFetcher != nil
+}
+
+// shouldFilter checks if filtering should be applied for this request.
+// Filtering is triggered when:
+// 1. accessibleFetcher is configured (Deckhouse filtering enabled)
+// 2. IsNamespaceFilteringMode(ctx) is true (user was denied by authorizer but bypassed)
+func (r *REST) shouldFilter(ctx context.Context) bool {
+	return r.isFilteringEnabled() && filters.IsNamespaceFilteringMode(ctx)
+}
+
+// getAccessibleNamespaces fetches accessible namespace names for the user from external service.
+func (r *REST) getAccessibleNamespaces(ctx context.Context) ([]string, error) {
+	userInfo, ok := request.UserFrom(ctx)
+	if !ok {
+		return nil, fmt.Errorf("no user info in context")
+	}
+
+	// Convert extra from map[string][]string to what fetcher expects
+	extra := make(map[string][]string)
+	for k, v := range userInfo.GetExtra() {
+		extra[k] = v
+	}
+
+	return r.accessibleFetcher.FetchAccessibleNamespaces(
+		ctx,
+		userInfo.GetName(),
+		userInfo.GetGroups(),
+		extra,
+	)
+}
+
+// isNamespaceAccessibleToUser checks if a specific namespace is accessible to the user.
+func (r *REST) isNamespaceAccessibleToUser(ctx context.Context, name string) (bool, error) {
+	userInfo, ok := request.UserFrom(ctx)
+	if !ok {
+		return false, fmt.Errorf("no user info in context")
+	}
+
+	extra := make(map[string][]string)
+	for k, v := range userInfo.GetExtra() {
+		extra[k] = v
+	}
+
+	return r.accessibleFetcher.IsNamespaceAccessible(
+		ctx,
+		userInfo.GetName(),
+		userInfo.GetGroups(),
+		extra,
+		name,
+	)
+}
+
+// filterNamespaceList filters a NamespaceList to only include accessible namespaces.
+func (r *REST) filterNamespaceList(list runtime.Object, accessibleNames []string) runtime.Object {
+	nsList, ok := list.(*api.NamespaceList)
+	if !ok {
+		return list
+	}
+
+	accessibleSet := make(map[string]struct{}, len(accessibleNames))
+	for _, name := range accessibleNames {
+		accessibleSet[name] = struct{}{}
+	}
+
+	filtered := &api.NamespaceList{
+		TypeMeta: nsList.TypeMeta,
+		ListMeta: nsList.ListMeta,
+		Items:    make([]api.Namespace, 0, len(accessibleNames)),
+	}
+
+	for _, ns := range nsList.Items {
+		if _, ok := accessibleSet[ns.Name]; ok {
+			filtered.Items = append(filtered.Items, ns)
+		}
+	}
+
+	return filtered
+}
+
 func (r *REST) List(ctx context.Context, options *metainternalversion.ListOptions) (runtime.Object, error) {
-	return r.store.List(ctx, options)
+	// Fast path: no filtering needed (either disabled or user has full access)
+	if !r.shouldFilter(ctx) {
+		return r.store.List(ctx, options)
+	}
+
+	// Slow path: user was denied list permission, fetch accessible namespaces and filter
+	klog.V(4).Info("Namespace filtering mode active, fetching accessible namespaces")
+
+	accessibleNames, err := r.getAccessibleNamespaces(ctx)
+	if err != nil {
+		klog.Warningf("Failed to fetch accessible namespaces: %v, returning forbidden", err)
+		return nil, apierrors.NewForbidden(api.Resource("namespaces"), "", fmt.Errorf("cannot list namespaces"))
+	}
+
+	if len(accessibleNames) == 0 {
+		// User has no accessible namespaces
+		return &api.NamespaceList{
+			TypeMeta: metav1.TypeMeta{
+				Kind:       "NamespaceList",
+				APIVersion: "v1",
+			},
+		}, nil
+	}
+
+	// Get full list from store (using privileged context to bypass RBAC at storage level)
+	// Note: The store.List doesn't do RBAC checks, it's done at the handler level
+	fullList, err := r.store.List(ctx, options)
+	if err != nil {
+		klog.Errorf("Failed to list namespaces from store: %v", err)
+		return nil, apierrors.NewInternalError(err)
+	}
+
+	// Filter the list
+	return r.filterNamespaceList(fullList, accessibleNames), nil
 }
 
 func (r *REST) Create(ctx context.Context, obj runtime.Object, createValidation rest.ValidateObjectFunc, options *metav1.CreateOptions) (runtime.Object, error) {
@@ -127,10 +289,39 @@ func (r *REST) Update(ctx context.Context, name string, objInfo rest.UpdatedObje
 }
 
 func (r *REST) Get(ctx context.Context, name string, options *metav1.GetOptions) (runtime.Object, error) {
+	// Fast path: no filtering needed (either disabled or user has full access)
+	if !r.shouldFilter(ctx) {
+		return r.store.Get(ctx, name, options)
+	}
+
+	// Slow path: user was denied get permission, check if namespace is accessible via external service
+	klog.V(4).Infof("Namespace filtering mode active for get %s, checking accessible namespaces", name)
+
+	accessible, err := r.isNamespaceAccessibleToUser(ctx, name)
+	if err != nil {
+		// Return Forbidden when permission-browser-apiserver is unavailable.
+		// This is consistent with vanilla Kubernetes behavior and signals to clients
+		// that the operation failed due to authorization issues.
+		klog.Warningf("Failed to check namespace accessibility for %s: %v, returning forbidden", name, err)
+		return nil, apierrors.NewForbidden(api.Resource("namespaces"), name, fmt.Errorf("cannot get namespace"))
+	}
+
+	if !accessible {
+		// Return NotFound instead of Forbidden to avoid existence disclosure.
+		// This is safe because we only reach here when we successfully contacted
+		// permission-browser-apiserver and it confirmed the user has no access.
+		klog.V(4).Infof("Namespace %s is not accessible to user, returning not found", name)
+		return nil, apierrors.NewNotFound(api.Resource("namespaces"), name)
+	}
+
+	// User has access, get the namespace
 	return r.store.Get(ctx, name, options)
 }
 
 func (r *REST) Watch(ctx context.Context, options *metainternalversion.ListOptions) (watch.Interface, error) {
+	// Note: Watch filtering is not implemented in MVP.
+	// If user doesn't have watch permission, kube-apiserver will return 403.
+	// Future improvement: filter watch events based on accessible namespaces.
 	return r.store.Watch(ctx, options)
 }
 
diff --git a/pkg/registry/core/rest/storage_core_generic.go b/pkg/registry/core/rest/storage_core_generic.go
index 664724f3bc0..bc6414fd1ba 100644
--- a/pkg/registry/core/rest/storage_core_generic.go
+++ b/pkg/registry/core/rest/storage_core_generic.go
@@ -96,7 +96,11 @@ func (c *GenericConfig) NewRESTStorage(apiResourceConfigSource serverstorage.API
 		return genericapiserver.APIGroupInfo{}, err
 	}
 
-	namespaceStorage, namespaceStatusStorage, namespaceFinalizeStorage, err := namespacestore.NewREST(restOptionsGetter)
+	// Deckhouse: Always use filtering-enabled storage with loopback client for proper auth.
+	// Actual filtering only happens when IsNamespaceFilteringMode(ctx) is true
+	// (set by WithAuthorization filter when user does not have list/get namespaces permission).
+	// The loopback client ensures authenticated calls to permission-browser-apiserver via aggregated API.
+	namespaceStorage, namespaceStatusStorage, namespaceFinalizeStorage, err := namespacestore.NewRESTWithDeckhouseFiltering(restOptionsGetter, c.LoopbackClientConfig)
 	if err != nil {
 		return genericapiserver.APIGroupInfo{}, err
 	}
diff --git a/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go b/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go
index eec02e5722f..d001f27b898 100644
--- a/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go
+++ b/staging/src/k8s.io/apiserver/pkg/endpoints/filters/authorization.go
@@ -47,6 +47,37 @@ const (
 	reasonError    = "internal error"
 )
 
+// Deckhouse: Context key for namespace filtering mode.
+// When set to true, indicates that the request was denied by authorizer but bypassed
+// because it's a namespace list/get request that should be filtered by accessible namespaces.
+type namespaceFilteringModeKey struct{}
+
+// IsNamespaceFilteringMode returns true if the request context indicates that
+// namespace filtering should be applied (user doesn't have full list/get namespaces permission).
+// Deckhouse-specific: used for ACL-based namespace filtering.
+func IsNamespaceFilteringMode(ctx context.Context) bool {
+	val, ok := ctx.Value(namespaceFilteringModeKey{}).(bool)
+	return ok && val
+}
+
+// WithNamespaceFilteringMode returns a new context with namespace filtering mode set.
+// This is primarily for testing purposes.
+// Deckhouse-specific: used for ACL-based namespace filtering.
+func WithNamespaceFilteringMode(ctx context.Context) context.Context {
+	return context.WithValue(ctx, namespaceFilteringModeKey{}, true)
+}
+
+// isNamespaceListOrGetRequest checks if the request is for listing or getting namespaces.
+// Deckhouse-specific: these requests are bypassed from 403 to allow filtered responses.
+func isNamespaceListOrGetRequest(requestInfo *request.RequestInfo) bool {
+	return requestInfo != nil &&
+		requestInfo.IsResourceRequest &&
+		requestInfo.APIGroup == "" &&
+		requestInfo.Resource == "namespaces" &&
+		requestInfo.Subresource == "" &&
+		(requestInfo.Verb == "list" || requestInfo.Verb == "get")
+}
+
 type recordAuthorizationMetricsFunc func(ctx context.Context, authorized authorizer.Decision, err error, authStart time.Time, authFinish time.Time)
 
 // WithAuthorization passes all authorized requests on to handler, and returns a forbidden error otherwise.
@@ -89,6 +120,21 @@ func withAuthorization(handler http.Handler, a authorizer.Authorizer, s runtime.
 			return
 		}
 
+		// Deckhouse: bypass 403 for namespace list/get requests to allow filtered responses.
+		// The storage layer will check IsNamespaceFilteringMode() and filter accordingly.
+		requestInfo, _ := request.RequestInfoFrom(ctx)
+		if isNamespaceListOrGetRequest(requestInfo) {
+			klog.V(4).InfoS("Bypassing authorization denial for namespace request, will filter in storage",
+				"URI", req.RequestURI, "verb", requestInfo.Verb, "reason", reason)
+			audit.AddAuditAnnotations(ctx,
+				decisionAnnotationKey, "allow-filtered", // Deckhouse: custom decision for audit
+				reasonAnnotationKey, "namespace filtering mode")
+			// Set context flag for storage layer to know filtering is required
+			filteredCtx := context.WithValue(ctx, namespaceFilteringModeKey{}, true)
+			handler.ServeHTTP(w, req.WithContext(filteredCtx))
+			return
+		}
+
 		klog.V(4).InfoS("Forbidden", "URI", req.RequestURI, "reason", reason)
 		audit.AddAuditAnnotations(ctx,
 			decisionAnnotationKey, decisionForbid,

