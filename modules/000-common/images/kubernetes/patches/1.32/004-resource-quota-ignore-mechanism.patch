diff --git a/pkg/apis/core/validation/validation.go b/pkg/apis/core/validation/validation.go
index 797783912f3..70a0b2d17e4 100644
--- a/pkg/apis/core/validation/validation.go
+++ b/pkg/apis/core/validation/validation.go
@@ -2236,6 +2236,86 @@ func allowInvalidAPIGroupInDataSourceOrRef(spec *core.PersistentVolumeClaimSpec)
 func ValidatePersistentVolumeClaim(pvc *core.PersistentVolumeClaim, opts PersistentVolumeClaimSpecValidationOptions) field.ErrorList {
 	allErrs := ValidateObjectMeta(&pvc.ObjectMeta, true, ValidatePersistentVolumeName, field.NewPath("metadata"))
 	allErrs = append(allErrs, ValidatePersistentVolumeClaimSpec(&pvc.Spec, field.NewPath("spec"), opts)...)
+	allErrs = append(allErrs, validateResourceQuotaLabels(pvc.Labels, field.NewPath("metadata", "labels"))...)
+	return allErrs
+}
+
+// isValidCPUQuantityString checks if a quantity string is valid for CPU resources.
+// Other DecimalSI suffixes (k, M, G, etc..) are not valid for CPU.
+func isValidCPUQuantityString(value string) bool {
+	if len(value) == 0 {
+		return false
+	}
+	lastChar := value[len(value)-1]
+	if lastChar >= '0' && lastChar <= '9' {
+		return true // No suffix
+	}
+	if lastChar == 'm' {
+		return true // Millicores suffix
+	}
+	return false
+}
+
+// validateResourceQuotaLabels validates the labels of a pod and pvc
+func validateResourceQuotaLabels(labels map[string]string, fldPath *field.Path) field.ErrorList {
+	allErrs := field.ErrorList{}
+	if labels == nil {
+		return allErrs
+	}
+
+	// Validate LabelResourceQuotaIgnore if present
+	if value, exists := labels[v1.LabelResourceQuotaIgnore]; exists {
+		labelPath := fldPath.Key(v1.LabelResourceQuotaIgnore)
+		if value != "true" && value != "false" {
+			allErrs = append(allErrs, field.Invalid(labelPath, value, "must be 'true' or 'false'"))
+		}
+	}
+
+	// Validate CPU quantity labels (only m or no suffix allowed)
+	cpuLabels := []string{
+		v1.LabelResourceQuotaCapCPU,
+		v1.LabelResourceQuotaDiscountCPU,
+	}
+	for _, labelKey := range cpuLabels {
+		if value, exists := labels[labelKey]; exists {
+			labelPath := fldPath.Key(labelKey)
+			quantity, err := resource.ParseQuantity(value)
+			if err != nil {
+				allErrs = append(allErrs, field.Invalid(labelPath, value, fmt.Sprintf("must be a valid quantity: %v", err)))
+			} else {
+				allErrs = append(allErrs, ValidateNonnegativeQuantity(quantity, labelPath)...)
+				// CPU must only use 'm' suffix (millicores) or no suffix (cores)
+				// Other DecimalSI suffixes like k, M, G are invalid for CPU
+				if !isValidCPUQuantityString(value) {
+					allErrs = append(allErrs, field.Invalid(labelPath, value, "must be a CPU quantity (e.g., '1', '500m', '0.5')"))
+				}
+			}
+		}
+	}
+
+	// Validate Memory/Storage quantity labels (only binary/decimal SI units allowed, not m)
+	memoryStorageLabels := []string{
+		v1.LabelResourceQuotaCapMemory,
+		v1.LabelResourceQuotaDiscountMemory,
+		v1.LabelResourceQuotaCapStorage,
+		v1.LabelResourceQuotaDiscountStorage,
+	}
+	for _, labelKey := range memoryStorageLabels {
+		if value, exists := labels[labelKey]; exists {
+			labelPath := fldPath.Key(labelKey)
+			quantity, err := resource.ParseQuantity(value)
+			if err != nil {
+				allErrs = append(allErrs, field.Invalid(labelPath, value, fmt.Sprintf("must be a valid quantity: %v", err)))
+			} else {
+				allErrs = append(allErrs, ValidateNonnegativeQuantity(quantity, labelPath)...)
+				// Memory/Storage must use BinarySI format (Ki, Mi, Gi, etc.) or DecimalSI with large units (k, M, G, etc.), not m
+				if quantity.Format == resource.DecimalSI && strings.HasSuffix(value, "m") {
+					allErrs = append(allErrs, field.Invalid(labelPath, value, "must be a memory/storage quantity (e.g., '1Gi', '500Mi', '1G'), not a CPU quantity"))
+				}
+			}
+		}
+	}
+
 	return allErrs
 }
 
@@ -4070,6 +4150,7 @@ func validatePodMetadataAndSpec(pod *core.Pod, opts PodValidationOptions) field.
 
 	allErrs := ValidateObjectMeta(&pod.ObjectMeta, true, ValidatePodName, metaPath)
 	allErrs = append(allErrs, ValidatePodSpecificAnnotations(pod.ObjectMeta.Annotations, &pod.Spec, metaPath.Child("annotations"), opts)...)
+	allErrs = append(allErrs, validateResourceQuotaLabels(pod.ObjectMeta.Labels, metaPath)...)
 	allErrs = append(allErrs, ValidatePodSpec(&pod.Spec, &pod.ObjectMeta, specPath, opts)...)
 
 	// we do additional validation only pertinent for pods and not pod templates
diff --git a/pkg/quota/v1/evaluator/core/persistent_volume_claims.go b/pkg/quota/v1/evaluator/core/persistent_volume_claims.go
index a4da87b496b..a9abf113d94 100644
--- a/pkg/quota/v1/evaluator/core/persistent_volume_claims.go
+++ b/pkg/quota/v1/evaluator/core/persistent_volume_claims.go
@@ -147,6 +147,11 @@ func (p *pvcEvaluator) Usage(item runtime.Object) (corev1.ResourceList, error) {
 		return result, err
 	}
 
+	// Check for ignore label
+	if pvc.Labels != nil && pvc.Labels[corev1.LabelResourceQuotaIgnore] == "true" {
+		return result, nil
+	}
+
 	// charge for claim
 	result[corev1.ResourcePersistentVolumeClaims] = *(resource.NewQuantity(1, resource.DecimalSI))
 	result[pvcObjectCountName] = *(resource.NewQuantity(1, resource.DecimalSI))
diff --git a/pkg/quota/v1/evaluator/core/pods.go b/pkg/quota/v1/evaluator/core/pods.go
index 8efdec6cc2b..0e034c0cbf1 100644
--- a/pkg/quota/v1/evaluator/core/pods.go
+++ b/pkg/quota/v1/evaluator/core/pods.go
@@ -363,6 +363,11 @@ func PodUsageFunc(obj runtime.Object, clock clock.Clock) (corev1.ResourceList, e
 		return corev1.ResourceList{}, err
 	}
 
+	// Check for ignore label
+	if pod.Labels != nil && pod.Labels[corev1.LabelResourceQuotaIgnore] == "true" {
+		return corev1.ResourceList{}, nil
+	}
+
 	// always quota the object count (even if the pod is end of life)
 	// object count quotas track all objects that are in storage.
 	// where "pods" tracks all pods that have not reached a terminal state,
@@ -385,10 +390,73 @@ func PodUsageFunc(obj runtime.Object, clock clock.Clock) (corev1.ResourceList, e
 	requests := resourcehelper.PodRequests(pod, opts)
 	limits := resourcehelper.PodLimits(pod, opts)
 
-	result = quota.Add(result, podComputeUsageHelper(requests, limits))
+	podUsage := podComputeUsageHelper(requests, limits)
+
+	// Apply discount and cap if specified via labels
+	// Dont handle errors here, validated earlier in pkg/apis/core/validation/validation.go
+	applyQuotaModifiers(podUsage, pod.Labels)
+
+	result = quota.Add(result, podUsage)
 	return result, nil
 }
 
+// applyQuotaModifiers applies discounts and caps to the resource in usage
+func applyQuotaModifiers(usage corev1.ResourceList, labels map[string]string) {
+	if labels == nil {
+		return
+	}
+	// CPU discount + cap
+	applyDiscount(usage, labels, corev1.LabelResourceQuotaDiscountCPU, corev1.ResourceRequestsCPU, corev1.ResourceLimitsCPU)
+	applyCap(usage, labels, corev1.LabelResourceQuotaCapCPU, corev1.ResourceRequestsCPU, corev1.ResourceLimitsCPU)
+	// Memory discount + cap
+	applyDiscount(usage, labels, corev1.LabelResourceQuotaDiscountMemory, corev1.ResourceRequestsMemory, corev1.ResourceLimitsMemory)
+	applyCap(usage, labels, corev1.LabelResourceQuotaCapMemory, corev1.ResourceRequestsMemory, corev1.ResourceLimitsMemory)
+	// Ephemeral-storage discount + cap
+	applyDiscount(usage, labels, corev1.LabelResourceQuotaDiscountStorage, corev1.ResourceRequestsEphemeralStorage, corev1.ResourceLimitsEphemeralStorage)
+	applyCap(usage, labels, corev1.LabelResourceQuotaCapStorage, corev1.ResourceRequestsEphemeralStorage, corev1.ResourceLimitsEphemeralStorage)
+}
+
+// applyDiscount subtracts discount from the resource in usage, ensuring the result is non-negative
+func applyDiscount(usage corev1.ResourceList, labels map[string]string, labelKey string, resources ...corev1.ResourceName) {
+	discountStr, exists := labels[labelKey]
+	if !exists {
+		return
+	}
+	discount, err := resource.ParseQuantity(discountStr)
+	if err != nil {
+		return
+	}
+	for _, resourceName := range resources {
+		if val, exists := usage[resourceName]; exists {
+			val.Sub(discount)
+			if val.Sign() == -1 {
+				val = *resource.NewQuantity(0, resource.DecimalSI)
+			}
+			usage[resourceName] = val
+		}
+	}
+
+}
+
+// applyCap limits the resource in usage to the cap value
+func applyCap(usage corev1.ResourceList, labels map[string]string, labelKey string, resources ...corev1.ResourceName) {
+	capStr, exists := labels[labelKey]
+	if !exists {
+		return
+	}
+	cap, err := resource.ParseQuantity(capStr)
+	if err != nil {
+		return
+	}
+	for _, resourceName := range resources {
+		if val, exists := usage[resourceName]; exists {
+			if val.Cmp(cap) > 0 {
+				usage[resourceName] = cap
+			}
+		}
+	}
+}
+
 func isBestEffort(pod *corev1.Pod) bool {
 	return qos.GetPodQOS(pod) == corev1.PodQOSBestEffort
 }
diff --git a/staging/src/k8s.io/api/core/v1/well_known_labels.go b/staging/src/k8s.io/api/core/v1/well_known_labels.go
index 8c3cb87b82a..499e454a207 100644
--- a/staging/src/k8s.io/api/core/v1/well_known_labels.go
+++ b/staging/src/k8s.io/api/core/v1/well_known_labels.go
@@ -71,4 +71,13 @@ const (
 	LabelNodeExcludeBalancers = "node.kubernetes.io/exclude-from-external-load-balancers"
 	// LabelMetadataName is the label name which, in-tree, is used to automatically label namespaces, so they can be selected easily by tools which require definitive labels
 	LabelMetadataName = "kubernetes.io/metadata.name"
+
+	// Resource quota control labels
+	LabelResourceQuotaIgnore          = "resources.k8s.io/ignore"
+	LabelResourceQuotaDiscountStorage = "resources.k8s.io/discount-storage"
+	LabelResourceQuotaCapStorage      = "resources.k8s.io/cap-storage"
+	LabelResourceQuotaDiscountCPU     = "resources.k8s.io/discount-cpu"
+	LabelResourceQuotaCapCPU          = "resources.k8s.io/cap-cpu"
+	LabelResourceQuotaDiscountMemory  = "resources.k8s.io/discount-memory"
+	LabelResourceQuotaCapMemory       = "resources.k8s.io/cap-memory"
 )
