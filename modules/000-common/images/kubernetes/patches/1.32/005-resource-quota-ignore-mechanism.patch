diff --git a/pkg/apis/core/validation/validation.go b/pkg/apis/core/validation/validation.go
index 797783912f3..f33c1f70d67 100644
--- a/pkg/apis/core/validation/validation.go
+++ b/pkg/apis/core/validation/validation.go
@@ -2236,6 +2236,34 @@ func allowInvalidAPIGroupInDataSourceOrRef(spec *core.PersistentVolumeClaimSpec)
 func ValidatePersistentVolumeClaim(pvc *core.PersistentVolumeClaim, opts PersistentVolumeClaimSpecValidationOptions) field.ErrorList {
 	allErrs := ValidateObjectMeta(&pvc.ObjectMeta, true, ValidatePersistentVolumeName, field.NewPath("metadata"))
 	allErrs = append(allErrs, ValidatePersistentVolumeClaimSpec(&pvc.Spec, field.NewPath("spec"), opts)...)
+	allErrs = append(allErrs, validatePersistentVolumeClaimLabels(pvc.Labels, field.NewPath("metadata", "labels"))...)
+	return allErrs
+}
+
+// validatePersistentVolumeClaimLabels validates the labels of a PersistentVolumeClaim
+func validatePersistentVolumeClaimLabels(labels map[string]string, fldPath *field.Path) field.ErrorList {
+	allErrs := field.ErrorList{}
+	if labels == nil {
+		return allErrs
+	}
+
+	storageLabels := []string{
+		v1.LabelResourceQuotaCapStorage,
+		v1.LabelResourceQuotaDiscountStorage,
+	}
+
+	for _, labelKey := range storageLabels {
+		if value, exists := labels[labelKey]; exists {
+			labelPath := fldPath.Key(labelKey)
+			quantity, err := resource.ParseQuantity(value)
+			if err != nil {
+				allErrs = append(allErrs, field.Invalid(labelPath, value, fmt.Sprintf("must be a valid quantity: %v", err)))
+			} else {
+				allErrs = append(allErrs, ValidateNonnegativeQuantity(quantity, labelPath)...)
+			}
+		}
+
+	}
 	return allErrs
 }
 
diff --git a/pkg/quota/v1/evaluator/core/persistent_volume_claims.go b/pkg/quota/v1/evaluator/core/persistent_volume_claims.go
index a4da87b496b..89554b690d5 100644
--- a/pkg/quota/v1/evaluator/core/persistent_volume_claims.go
+++ b/pkg/quota/v1/evaluator/core/persistent_volume_claims.go
@@ -147,6 +147,36 @@ func (p *pvcEvaluator) Usage(item runtime.Object) (corev1.ResourceList, error) {
 		return result, err
 	}
 
+	// Check for ignore label
+	if pvc.Labels != nil && pvc.Labels[corev1.LabelResourceQuotaIgnore] == "true" {
+		return result, nil
+	}
+
+	// Base storage usage
+	storageUsage := p.getStorageUsage(pvc)
+	if storageUsage == nil {
+		return result, nil
+	}
+
+	// Apply discount if specified
+	if pvc.Labels != nil {
+		if discountStr, exists := pvc.Labels[corev1.LabelResourceQuotaDiscountStorage]; exists {
+			if discount, err := resource.ParseQuantity(discountStr); err == nil {
+				storageUsage.Sub(discount)
+				if storageUsage.Sign() == -1 {
+					storageUsage = resource.NewQuantity(0, resource.DecimalSI)
+				}
+			}
+		}
+	}
+
+	// Apply cap if specified
+	if capStr, exists := pvc.Labels[corev1.LabelResourceQuotaCapStorage]; exists {
+		if cap, err := resource.ParseQuantity(capStr); err == nil && storageUsage.Cmp(cap) > 0 {
+			storageUsage = &cap
+		}
+	}
+
 	// charge for claim
 	result[corev1.ResourcePersistentVolumeClaims] = *(resource.NewQuantity(1, resource.DecimalSI))
 	result[pvcObjectCountName] = *(resource.NewQuantity(1, resource.DecimalSI))
@@ -156,14 +186,11 @@ func (p *pvcEvaluator) Usage(item runtime.Object) (corev1.ResourceList, error) {
 		result[storageClassClaim] = *(resource.NewQuantity(1, resource.DecimalSI))
 	}
 
-	requestedStorage := p.getStorageUsage(pvc)
-	if requestedStorage != nil {
-		result[corev1.ResourceRequestsStorage] = *requestedStorage
-		// charge usage to the storage class (if present)
-		if len(storageClassRef) > 0 {
-			storageClassStorage := corev1.ResourceName(storageClassRef + storageClassSuffix + string(corev1.ResourceRequestsStorage))
-			result[storageClassStorage] = *requestedStorage
-		}
+	result[corev1.ResourceRequestsStorage] = *storageUsage
+	// charge usage to the storage class (if present)
+	if len(storageClassRef) > 0 {
+		storageClassStorage := corev1.ResourceName(storageClassRef + storageClassSuffix + string(corev1.ResourceRequestsStorage))
+		result[storageClassStorage] = *storageUsage
 	}
 
 	return result, nil
diff --git a/staging/src/k8s.io/api/core/v1/well_known_labels.go b/staging/src/k8s.io/api/core/v1/well_known_labels.go
index 8c3cb87b82a..a45b1d8a181 100644
--- a/staging/src/k8s.io/api/core/v1/well_known_labels.go
+++ b/staging/src/k8s.io/api/core/v1/well_known_labels.go
@@ -71,4 +71,9 @@ const (
 	LabelNodeExcludeBalancers = "node.kubernetes.io/exclude-from-external-load-balancers"
 	// LabelMetadataName is the label name which, in-tree, is used to automatically label namespaces, so they can be selected easily by tools which require definitive labels
 	LabelMetadataName = "kubernetes.io/metadata.name"
+
+	// Resource quota control labels
+	LabelResourceQuotaIgnore          = "resources.k8s.io/ignore"
+	LabelResourceQuotaDiscountStorage = "resources.k8s.io/discount-storage"
+	LabelResourceQuotaCapStorage      = "resources.k8s.io/cap-storage"
 )
