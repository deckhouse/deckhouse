diff --git a/src/kubernetes/mod.rs b/src/kubernetes/mod.rs
index 8ef6d774f..74a0a6271 100644
--- a/src/kubernetes/mod.rs
+++ b/src/kubernetes/mod.rs
@@ -8,5 +8,6 @@

 pub mod pod_manager_logic;
 pub mod reflector;
+pub mod owner_reference;

 pub use reflector::custom_reflector;
diff --git a/src/kubernetes/owner_reference.rs b/src/kubernetes/owner_reference.rs
new file mode 100644
index 000000000..285e30610
--- /dev/null
+++ b/src/kubernetes/owner_reference.rs
@@ -0,0 +1,74 @@
+use k8s_openapi::api::apps::v1::ReplicaSet;
+use k8s_openapi::api::batch::v1::Job;
+use k8s_openapi::apimachinery::pkg::apis::meta::v1::{ObjectMeta, OwnerReference};
+use kube::{Api, Client};
+
+#[tokio::main]
+pub async fn enrich_owner_ref(client: &Client, metadata: &ObjectMeta) -> ObjectMeta {
+    info!("Start enrich_owner_ref for");
+
+    if let Some(or) = metadata.owner_references.to_owned() {
+        let mut ns = String::from("default");
+        if let Some(namespace) = metadata.namespace.to_owned() {
+            ns = namespace
+        }
+
+        info!("Owner references found");
+
+        match or[0].kind.as_str() {
+            "ReplicaSet" => {
+                info!("ReplicaSet owner references found");
+                let owner_ref =
+                    replicaset_owner_ref(&mut client.clone(), or[0].name.as_str(), ns.as_str())
+                        .await;
+                info!("ReplicaSet owner references enriched");
+
+                if let Some(owner_ref) = owner_ref {
+                    let mut new_metadata = metadata.clone();
+                    new_metadata.owner_references = Some(owner_ref);
+
+                    return new_metadata;
+                }
+            }
+            "Job" => {
+                info!("Job owner references found");
+                let owner_ref =
+                    job_owner_ref(&mut client.clone(), or[0].name.as_str(), ns.as_str()).await;
+                info!("Job owner references enriched");
+
+                if let Some(owner_ref) = owner_ref {
+                    let mut new_metadata = metadata.clone();
+                    new_metadata.owner_references = Some(owner_ref);
+
+                    return new_metadata;
+                }
+            }
+            _ => {}
+        }
+    }
+    return metadata.clone();
+}
+
+async fn replicaset_owner_ref(
+    client: &mut Client,
+    name: &str,
+    namespace: &str,
+) -> Option<Vec<OwnerReference>> {
+    let rs_api = Api::<ReplicaSet>::namespaced(client.clone(), namespace);
+    if let Ok(rs) = rs_api.get(name).await {
+        return rs.metadata.owner_references;
+    };
+    return None;
+}
+
+async fn job_owner_ref(
+    client: &mut Client,
+    name: &str,
+    namespace: &str,
+) -> Option<Vec<OwnerReference>> {
+    let job_api = Api::<Job>::namespaced(client.clone(), namespace);
+    if let Ok(job) = job_api.get(name).await {
+        return job.metadata.owner_references;
+    };
+    return None;
+}
diff --git a/src/sources/kubernetes_logs/mod.rs b/src/sources/kubernetes_logs/mod.rs
index 44023790f..2f756511d 100644
--- a/src/sources/kubernetes_logs/mod.rs
+++ b/src/sources/kubernetes_logs/mod.rs
@@ -13,6 +13,7 @@ use file_source::{
     Checkpointer, FileServer, FileServerShutdown, FingerprintStrategy, Fingerprinter, Line,
     ReadFrom,
 };
+use futures::TryStreamExt;
 use futures_util::Stream;
 use k8s_openapi::api::core::v1::{Namespace, Node, Pod};
 use kube::{
@@ -22,7 +23,7 @@ use kube::{
         reflector::{self},
         watcher,
     },
-    Client, Config as ClientConfig,
+    Client, Config as ClientConfig, Resource,
 };
 use vector_common::TimeZone;
 use vector_config::configurable_component;
@@ -62,7 +63,9 @@ use self::namespace_metadata_annotator::NamespaceMetadataAnnotator;
 use self::node_metadata_annotator::NodeMetadataAnnotator;
 use self::parser::Parser;
 use self::pod_metadata_annotator::PodMetadataAnnotator;
+use crate::kubernetes::owner_reference::enrich_owner_ref;
 use futures::{future::FutureExt, stream::StreamExt};
+
 use k8s_paths_provider::K8sPathsProvider;
 use lifecycle::Lifecycle;
 use vector_core::config::LogNamespace;
@@ -347,24 +350,6 @@ impl Source {

         let mut reflectors = Vec::new();

-        let pods = Api::<Pod>::all(client.clone());
-        let pod_watcher = watcher(
-            pods,
-            ListParams {
-                field_selector: Some(field_selector),
-                label_selector: Some(label_selector),
-                ..Default::default()
-            },
-        );
-        let pod_store_w = reflector::store::Writer::default();
-        let pod_state = pod_store_w.as_reader();
-
-        reflectors.push(tokio::spawn(custom_reflector(
-            pod_store_w,
-            pod_watcher,
-            delay_deletion,
-        )));
-
         // -----------------------------------------------------------------

         let namespaces = Api::<Namespace>::all(client.clone());
@@ -386,7 +371,7 @@ impl Source {

         // -----------------------------------------------------------------

-        let nodes = Api::<Node>::all(client);
+        let nodes = Api::<Node>::all(client.clone());
         let node_watcher = watcher(
             nodes,
             ListParams {
@@ -403,6 +388,33 @@ impl Source {
             delay_deletion,
         )));

+        // -----------------------------------------------------------------
+
+        let pods = Api::<Pod>::all(client.clone());
+        let pod_watcher = watcher(
+            pods,
+            ListParams {
+                field_selector: Some(field_selector),
+                label_selector: Some(label_selector),
+                ..Default::default()
+            },
+        )
+        .map_ok(move |ev| {
+            // tokio::time::sleep(tokio::time::Duration::new(1, 0)).await;
+            ev.modify(|pod| {
+                pod.meta_mut().owner_references =
+                    enrich_owner_ref(&client.clone(), pod.meta()).owner_references;
+            })
+        });
+        let pod_store_w = reflector::store::Writer::default();
+        let pod_state = pod_store_w.as_reader();
+
+        reflectors.push(tokio::spawn(custom_reflector(
+            pod_store_w,
+            pod_watcher,
+            delay_deletion,
+        )));
+
         let paths_provider =
             K8sPathsProvider::new(pod_state.clone(), ns_state.clone(), exclude_paths);
         let annotator = PodMetadataAnnotator::new(pod_state, pod_fields_spec);
