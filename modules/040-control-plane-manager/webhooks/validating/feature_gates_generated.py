# Code generated by go generate; DO NOT EDIT.
# This file is generated from feature_gates_map.yml

versions = {
    "1.30": {
        "deprecated": [
            "AllowServiceLBStatusOnNonLB",
            "KMSv1",
            "DynamicProvisioningScheduling",
            "CSIMigrationRBD",
            "DefaultHostNetworkHostPortsInPodTemplates",
            "nTreePluginRBDUnregister",
            "SkipReadOnlyValidationGCE",
        ],
        "kubelet": [
            "InPlacePodVerticalScaling",
            "KubeletPodResourcesGet",
            "KubeletSeparateDiskGC",
            "MemoryQoS",
            "MutatingAdmissionPolicy",
            "SELinuxMount",
            "RecoverVolumeExpansionFailure",
            "RecursiveReadOnlyMounts",
        ],
        "apiserver": [
            "CrossNamespaceVolumeDataSource",
            "HPAScaleToZero",
            "JobManagedBy",
            "MaxUnavailableStatefulSet",
            "PortForwardWebsockets",
            "ProcMountType",
            "ConsistentListFromCache",
            "CustomResourceFieldSelectors",
            "JobSuccessPolicy",
            "LoadBalancerIPMode",
            "MatchLabelKeysInPodAffinity",
            "OrderedNamespaceDeletion",
            "RelaxedEnvironmentVariableValidation",
            "RetryGenerateName",
            "ServiceAccountTokenNodeBinding",
            "StrictCostEnforcementForVAP",
            "InPlacePodVerticalScaling",
            "MutatingAdmissionPolicy",
            "SELinuxMount",
            "RecoverVolumeExpansionFailure",
            "RecursiveReadOnlyMounts",
        ],
        "kubeControllerManager": [
            "HonorPVReclaimPolicy",
            "CrossNamespaceVolumeDataSource",
            "JobManagedBy",
            "MaxUnavailableStatefulSet",
            "JobSuccessPolicy",
            "InPlacePodVerticalScaling",
            "SELinuxMount",
            "RecoverVolumeExpansionFailure",
        ],
        "kubeScheduler": [
            "SchedulerQueueingHints",
            "InPlacePodVerticalScaling",
        ],
    },
    "1.31": {
        "deprecated": [
            "AllowDNSOnlyNodeCSR",
            "AllowInsecureKubeletCertificateSigningRequests",
            "DisableNodeKubeProxyVersion",
        ],
        "kubelet": [
            "KubeletPodResourcesGet",
            "MemoryQoS",
            "MutatingAdmissionPolicy",
            "ImageVolume",
            "ResourceHealthStatus",
            "SELinuxMount",
            "RecoverVolumeExpansionFailure",
            "InPlacePodVerticalScaling",
            "ConcurrentWatchObjectDecode",
        ],
        "apiserver": [
            "HPAScaleToZero",
            "OrderedNamespaceDeletion",
            "RelaxedEnvironmentVariableValidation",
            "StrictCostEnforcementForVAP",
            "ProcMountType",
            "AuthorizeNodeWithSelectors",
            "AuthorizeWithSelectors",
            "DisableAllocatorDualWrite",
            "StrictCostEnforcementForWebhooks",
            "CrossNamespaceVolumeDataSource",
            "JobManagedBy",
            "MaxUnavailableStatefulSet",
            "MutatingAdmissionPolicy",
            "ImageVolume",
            "ResourceHealthStatus",
            "SELinuxMount",
            "RecoverVolumeExpansionFailure",
            "InPlacePodVerticalScaling",
            "ConcurrentWatchObjectDecode",
        ],
        "kubeControllerManager": [
            "CrossNamespaceVolumeDataSource",
            "JobManagedBy",
            "MaxUnavailableStatefulSet",
            "SELinuxMount",
            "RecoverVolumeExpansionFailure",
            "InPlacePodVerticalScaling",
            "ConcurrentWatchObjectDecode",
        ],
        "kubeScheduler": [
            "SchedulerQueueingHints",
            "InPlacePodVerticalScaling",
            "ConcurrentWatchObjectDecode",
        ],
    },
    "1.32": {
        "deprecated": [
            "DisableNodeKubeProxyVersion",
        ],
        "kubelet": [
            "KubeletPodResourcesGet",
            "MemoryQoS",
            "MutatingAdmissionPolicy",
            "ImageVolume",
            "ResourceHealthStatus",
            "SELinuxMount",
            "InPlacePodVerticalScaling",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "PodLogsQuerySplitStreams",
            "InPlacePodVerticalScalingAllocatedStatus",
        ],
        "apiserver": [
            "HPAScaleToZero",
            "OrderedNamespaceDeletion",
            "ProcMountType",
            "DisableAllocatorDualWrite",
            "CrossNamespaceVolumeDataSource",
            "MaxUnavailableStatefulSet",
            "MutatingAdmissionPolicy",
            "ImageVolume",
            "ResourceHealthStatus",
            "SELinuxMount",
            "InPlacePodVerticalScaling",
            "ConcurrentWatchObjectDecode",
            "AllowUnsafeMalformedObjectDeletion",
            "ComponentFlagz",
            "ComponentStatusz",
            "PodLogsQuerySplitStreams",
            "SELinuxChangePolicy",
            "InPlacePodVerticalScalingAllocatedStatus",
            "PodLifecycleSleepActionAllowZero",
            "RelaxedDNSSearchValidation",
        ],
        "kubeControllerManager": [
            "CrossNamespaceVolumeDataSource",
            "MaxUnavailableStatefulSet",
            "SELinuxChangePolicy",
            "SELinuxMount",
            "InPlacePodVerticalScaling",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
        ],
        "kubeScheduler": [
            "SchedulerAsyncPreemption",
            "InPlacePodVerticalScaling",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
        ],
    },
    "1.33": {
        "deprecated": [
            "DisableNodeKubeProxyVersion",
            "GitRepoVolumeDriver",
            "InPlacePodVerticalScalingAllocatedStatus",
            "SeparateCacheWatchRPC",
            "StorageNamespaceIndex",
            "WatchFromStorageWithoutResourceVersion",
            "WindowsHostNetwork",
        ],
        "kubelet": [
            "MemoryQoS",
            "KubeletEnsureSecretPulledImages",
            "KubeletPSI",
            "PodObservedGenerationTracking",
            "MutatingAdmissionPolicy",
            "ResourceHealthStatus",
            "PodLogsQuerySplitStreams",
            "ContainerStopSignals",
            "ImageVolume",
            "SELinuxMount",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "AllowParsingUserUIDFromCertAuth",
        ],
        "apiserver": [
            "HPAScaleToZero",
            "AllowUnsafeMalformedObjectDeletion",
            "MutatingAdmissionPolicy",
            "ResourceHealthStatus",
            "PodLogsQuerySplitStreams",
            "ContainerStopSignals",
            "ImageVolume",
            "ListFromCacheSnapshot",
            "StrictIPCIDRValidation",
            "DisableAllocatorDualWrite",
            "CrossNamespaceVolumeDataSource",
            "MaxUnavailableStatefulSet",
            "DeploymentReplicaSetTerminatingReplicas",
            "HPAConfigurableTolerance",
            "PreferSameTrafficDistribution",
            "SELinuxMount",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "AllowParsingUserUIDFromCertAuth",
        ],
        "kubeControllerManager": [
            "CrossNamespaceVolumeDataSource",
            "MaxUnavailableStatefulSet",
            "DeploymentReplicaSetTerminatingReplicas",
            "HPAConfigurableTolerance",
            "PreferSameTrafficDistribution",
            "SELinuxMount",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "AllowParsingUserUIDFromCertAuth",
            "PodObservedGenerationTracking",
        ],
        "kubeScheduler": [
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "AllowParsingUserUIDFromCertAuth",
            "PodObservedGenerationTracking",
        ],
    },
    "1.34": {
        "kubelet": [
            "MemoryQoS",
            "KubeletEnsureSecretPulledImages",
            "HostnameOverride",
            "ResourceHealthStatus",
            "PodLogsQuerySplitStreams",
            "ContainerStopSignals",
            "ImageVolume",
            "SELinuxMount",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "ContainerRestartRules",
            "EnvFiles",
            "MutatingAdmissionPolicy",
        ],
        "apiserver": [
            "HPAScaleToZero",
            "AllowUnsafeMalformedObjectDeletion",
            "StrictIPCIDRValidation",
            "CrossNamespaceVolumeDataSource",
            "MaxUnavailableStatefulSet",
            "DeploymentReplicaSetTerminatingReplicas",
            "HPAConfigurableTolerance",
            "ResourceHealthStatus",
            "PodLogsQuerySplitStreams",
            "ContainerStopSignals",
            "ImageVolume",
            "SELinuxMount",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "ContainerRestartRules",
            "EnvFiles",
            "MutatingAdmissionPolicy",
        ],
        "kubeControllerManager": [
            "CrossNamespaceVolumeDataSource",
            "MaxUnavailableStatefulSet",
            "DeploymentReplicaSetTerminatingReplicas",
            "HPAConfigurableTolerance",
            "SELinuxMount",
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "ContainerRestartRules",
        ],
        "kubeScheduler": [
            "ConcurrentWatchObjectDecode",
            "ComponentFlagz",
            "ComponentStatusz",
            "ContainerRestartRules",
        ],
    },
}

def is_forbidden(version: str, feature_name: str) -> bool:
    if version not in versions:
        return False
    
    features = versions[version]
    return "forbidden" in features and feature_name in features["forbidden"]

def is_deprecated(version: str, feature_name: str) -> bool:
    if version not in versions:
        return False
    
    features = versions[version]
    return "deprecated" in features and feature_name in features["deprecated"]

def exists_in_component(version: str, component: str, feature_name: str) -> bool:
    if version not in versions:
        return False
    
    if component not in ["kubelet", "apiserver", "kubeControllerManager", "kubeScheduler"]:
        return False
    
    features = versions[version]
    return component in features and feature_name in features[component]

def is_feature_gate_deprecated_up_to_version(feature_gate: str, target_version: str) -> bool:
    try:
        target_major, target_minor = map(int, target_version.split('.'))
    except Exception:
        return False
    
    for version in versions.keys():
        try:
            major, minor = map(int, version.split('.'))
            if (major, minor) <= (target_major, target_minor):
                if is_deprecated(version, feature_gate):
                    return True
        except Exception:
            continue
    
    return False
