diff --git a/bpf/bpf_lxc.c b/bpf/bpf_lxc.c
index e5653ec9f9..b288b5c29e 100644
--- a/bpf/bpf_lxc.c
+++ b/bpf/bpf_lxc.c
@@ -37,6 +37,7 @@
 #include "lib/lxc.h"
 #include "lib/identity.h"
 #include "lib/policy.h"
+#include "lib/dhcp.h"
 
 /* Override LB_SELECTION initially defined in node_config.h to force bpf_lxc to use the random backend selection
  * algorithm for in-cluster traffic. Otherwise, it will fail with the Maglev hash algorithm because Cilium doesn't provision
@@ -58,6 +59,7 @@
 #include "lib/nodeport.h"
 #include "lib/policy_log.h"
 
+
 /* Per-packet LB is needed if all LB cases can not be handled in bpf_sock.
  * Most services with L7 LB flag can not be redirected to their proxy port
  * in bpf_sock, so we must check for those via per packet LB as well.
@@ -1396,6 +1398,8 @@ int cil_from_container(struct __ctx_buff *ctx)
 #endif /* ENABLE_IPV6 */
 #ifdef ENABLE_IPV4
 	case bpf_htons(ETH_P_IP):
+		if (unlikely(handle_dhcp_request(ctx, &ret)))
+			break;
 		edt_set_aggregate(ctx, LXC_ID);
 		ep_tail_call(ctx, CILIUM_CALL_IPV4_FROM_LXC);
 		ret = DROP_MISSED_TAIL_CALL;
diff --git a/bpf/lib/dhcp.h b/bpf/lib/dhcp.h
new file mode 100644
index 0000000000..4454e2f735
--- /dev/null
+++ b/bpf/lib/dhcp.h
@@ -0,0 +1,391 @@
+/*
+Copyright 2024 Flant JSC
+
+Licensed under the Apache License, Version 2.0 (the "License");
+you may not use this file except in compliance with the License.
+You may obtain a copy of the License at
+
+	http://www.apache.org/licenses/LICENSE-2.0
+
+Unless required by applicable law or agreed to in writing, software
+distributed under the License is distributed on an "AS IS" BASIS,
+WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
+See the License for the specific language governing permissions and
+limitations under the License.
+*/
+
+/* - this module used as replacement for kubevirt embedded dhcp server
+ * https://github.com/kubevirt/kubevirt/blob/main/pkg/network/dhcp/server/server.go
+ * - server implement very restricted part of dhcp protocol,
+ * only offer/ack responses on discover/request
+ * - server is stateless
+ */
+
+#ifndef __LIB_DHCP__
+#define __LIB_DHCP__
+
+#define BOOT_REQUEST                          1
+#define BOOT_REPLY                            2
+
+/* DHCP HTYPE CODE */
+#define HTYPE_ETHER                           1
+#define HTYPE_IEEE802                         6
+#define HTYPE_FDDI                            8
+#define HTYPE_IEEE1394                       24
+
+/* DHCP MESSAGE CODES */
+#define DHCP_DISCOVER                         1
+#define DHCP_OFFER                            2
+#define DHCP_REQUEST                          3
+#define DHCP_ACK                              5
+
+#define DHO_PAD                               0
+#define DHO_SUBNET                            1
+#define DHO_TIME_OFFSET                       2
+#define DHO_ROUTERS                           3
+#define DHO_TIME_SERVERS                      4
+#define DHO_NAME_SERVERS                      5
+#define DHO_DOMAIN_NAME_SERVERS               6
+#define DHO_LOG_SERVER                        7
+#define DHO_COOKIE_SERVERS                    8
+#define DHO_LPR_SERVERS                       9
+#define DHO_IMPRESS_SERVER                   10
+#define DHO_RESOURCE_LOCATION_SERVERS        11
+#define DHO_HOST_NAME                        12
+#define DHO_BOOT_SIZE                        13
+#define DHO_MERIT_DUMP                       14
+#define DHO_DOMAIN_NAME                      15
+#define DHO_SWAP_SERVER                      16
+#define DHO_ROOT_PATH                        17
+#define DHO_EXTENSIONS_PATH                  18
+#define DHO_IP_FORWARDING                    19
+#define DHO_NON_LOCAL_SOURCE_ROUTING         20
+#define DHO_POLICY_FILTER                    21
+#define DHO_MAX_DGRAM_REASSEMBLY             22
+#define DHO_DEFAULT_IP_TTL                   23
+#define DHO_PATH_MTU_AGING_TIMEOUT           24
+#define DHO_PATH_MTU_PLATEAU_TABLE           25
+#define DHO_INTERFACE_MTU                    26
+#define DHO_ALL_SUBNETS_LOCAL                27
+#define DHO_BROADCAST_ADDRESS                28
+#define DHO_PERFORM_MASK_DISCOVERY           29
+#define DHO_MASK_SUPPLIER                    30
+#define DHO_ROUTER_DISCOVERY                 31
+#define DHO_ROUTER_SOLICITATION_ADDRESS      32
+#define DHO_STATIC_ROUTES                    33
+#define DHO_TRAILER_ENCAPSULATION            34
+#define DHO_ARP_CACHE_TIMEOUT                35
+#define DHO_IEEE802_3_ENCAPSULATION          36
+#define DHO_DEFAULT_TCP_TTL                  37
+#define DHO_TCP_KEEPALIVE_INTERVAL           38
+#define DHO_TCP_KEEPALIVE_GARBAGE            39
+#define DHO_NIS_SERVERS                      41
+#define DHO_NTP_SERVERS                      42
+#define DHO_VENDOR_ENCAPSULATED_OPTIONS      43
+#define DHO_NETBIOS_NAME_SERVERS             44
+#define DHO_NETBIOS_DD_SERVER                45
+#define DHO_NETBIOS_NODE_TYPE                46
+#define DHO_NETBIOS_SCOPE                    47
+#define DHO_FONT_SERVERS                     48
+#define DHO_X_DISPLAY_MANAGER                49
+#define DHO_DHCP_REQUESTED_ADDRESS           50
+#define DHO_DHCP_LEASE_TIME                  51
+#define DHO_DHCP_OPTION_OVERLOAD             52
+#define DHO_DHCP_MESSAGE_TYPE                53
+#define DHO_DHCP_SERVER_IDENTIFIER           54
+#define DHO_DHCP_PARAMETER_REQUEST_LIST      55
+#define DHO_DHCP_MESSAGE                     56
+#define DHO_DHCP_MAX_MESSAGE_SIZE            57
+#define DHO_DHCP_RENEWAL_TIME                58
+#define DHO_DHCP_REBINDING_TIME              59
+#define DHO_VENDOR_CLASS_IDENTIFIER          60
+#define DHO_DHCP_CLIENT_IDENTIFIER           61
+#define DHO_NWIP_DOMAIN_NAME                 62
+#define DHO_NWIP_SUBOPTIONS                  63
+#define DHO_NISPLUS_DOMAIN                   64
+#define DHO_NISPLUS_SERVER                   65
+#define DHO_TFTP_SERVER                      66
+#define DHO_BOOTFILE                         67
+#define DHO_MOBILE_IP_HOME_AGENT             68
+#define DHO_SMTP_SERVER                      69
+#define DHO_POP3_SERVER                      70
+#define DHO_NNTP_SERVER                      71
+#define DHO_WWW_SERVER                       72
+#define DHO_FINGER_SERVER                    73
+#define DHO_IRC_SERVER                       74
+#define DHO_STREETTALK_SERVER                75
+#define DHO_STDA_SERVER                      76
+#define DHO_USER_CLASS                       77
+#define DHO_FQDN                             81
+#define DHO_DHCP_AGENT_OPTIONS               82
+#define DHO_NDS_SERVERS                      85
+#define DHO_NDS_TREE_NAME                    86
+#define DHO_NDS_CONTEXT                      87
+#define DHO_CLIENT_LAST_TRANSACTION_TIME     91
+#define DHO_ASSOCIATED_IP                    92
+#define DHO_USER_AUTHENTICATION_PROTOCOL     98
+#define DHO_AUTO_CONFIGURE                  116
+#define DHO_NAME_SERVICE_SEARCH             117
+#define DHO_SUBNET_SELECTION                118
+#define DHO_DOMAIN_SEARCH                   119
+#define DHO_CLASSLESS_ROUTE                 121
+#define DHO_END                             255
+
+#define DHO_DHCP_MESSAGE_TYPE_LEN             3
+#define BOOTP_ABSOLUTE_MIN_LEN              240
+#define DHCP_VEND_SIZE                       60
+#define DHCP_LEASE_TIME              0x7FFFFFFE
+
+struct dhcp_opt {
+	__u8 type;
+	__u8 len;
+	__u32 data;
+} __packed;
+
+struct dhcp_packet {
+	char op;
+	char htype;
+	char hlen;
+	char hops;
+	char xid[4];
+	char secs[2];
+	char flags[2];
+	char ciaddr[4];
+	char yiaddr[4];
+	char siaddr[4];
+	char giaddr[4];
+	char chaddr[16];
+	char sname[64];
+	char file[128];
+	char cookies[4];
+};
+
+static __always_inline bool
+dhcp_prepare_options(__u8 request_type, void *options, void *data_end)
+{
+	__u8 end = DHO_END;
+	struct dhcp_opt srv_id = {
+		.type = DHO_DHCP_SERVER_IDENTIFIER,
+		.len = 4,
+		.data = IPV4_GATEWAY,
+	};
+	struct dhcp_opt lease_time = {
+		.type = DHO_DHCP_LEASE_TIME,
+		.len = 4,
+		.data = bpf_htonl(DHCP_LEASE_TIME),
+	};
+	struct dhcp_opt subnet_mask = {
+		.type = DHO_SUBNET,
+		.len = 4,
+		.data = bpf_htonl(0xFFFFFFFF),
+	};
+	struct dhcp_opt router = {
+		.type = DHO_ROUTERS,
+		.len = 4,
+		.data = IPV4_GATEWAY,
+	};
+
+	__u8 msg_type[] = {
+		DHO_DHCP_MESSAGE_TYPE,
+		1,
+		request_type == DHCP_REQUEST ? DHCP_ACK : DHCP_OFFER
+	};
+
+	if (options + sizeof(msg_type) > data_end)
+		return false;
+
+	memcpy(options, &msg_type, sizeof(msg_type));
+	options += sizeof(msg_type);
+	if (options + sizeof(srv_id) > data_end)
+		return false;
+
+	memcpy(options, &srv_id, sizeof(srv_id));
+	options += sizeof(srv_id);
+
+	if (options + sizeof(lease_time) > data_end)
+		return false;
+	memcpy(options, &lease_time, sizeof(lease_time));
+	options += sizeof(lease_time);
+
+	if (options + sizeof(subnet_mask) > data_end)
+		return false;
+	memcpy(options, &subnet_mask, sizeof(subnet_mask));
+	options += sizeof(subnet_mask);
+
+	if (options + sizeof(router) > data_end)
+		return false;
+	memcpy(options, &router, sizeof(router));
+	options += sizeof(router);
+
+	if (options + sizeof(end) > data_end)
+		return false;
+	memcpy(options, &end, sizeof(end));
+
+	return true;
+}
+
+static __always_inline bool
+dhcp_prepare_response(struct __ctx_buff *ctx, __u8 request_type)
+{
+	__u8 tmp_mac[ETH_ALEN];
+
+	struct ethhdr *eth;
+	struct iphdr *ip;
+	struct udphdr *udp;
+	struct dhcp_packet *dhcp;
+
+	void *dhcp_options;
+	void *data, *data_end;
+
+	union macaddr node_mac = NODE_MAC;
+	__u32 yiaddr = LXC_IPV4;
+	/* manually calculated, based on dhcp_prepare_options implementation */
+	__u16 dhcp_options_len = 3 + 6 + 6 + 6 + 6 + 1;
+	__u16 dhcp_padding_len = dhcp_options_len < DHCP_VEND_SIZE ?
+		DHCP_VEND_SIZE - dhcp_options_len : 0;
+	__u16 dhcp_options_with_pad_len = dhcp_options_len + dhcp_padding_len;
+
+	__u16 udp_len = sizeof(*udp) + sizeof(*dhcp) + dhcp_options_with_pad_len;
+	__u16 ip_len = sizeof(*ip) + udp_len;
+
+	__u32 len_new = sizeof(*eth) + ip_len;
+	__u32 len_old = ctx_full_len(ctx);
+	__s32 len_diff = -(len_old - len_new);
+	if (ctx_adjust_troom(ctx, len_diff) < 0)
+		return false;
+
+	if (!revalidate_data_pull(ctx, &data, &data_end, &ip))
+		return false;
+
+	if (data + len_new > data_end)
+		return false;
+
+	eth = data;
+	udp = (struct udphdr *)(ip + 1);
+	dhcp = (struct dhcp_packet *)(udp + 1);
+
+	dhcp->op = BOOT_REPLY;
+	dhcp->hops = 1;
+	memcpy(&dhcp->yiaddr, &yiaddr, sizeof(yiaddr));
+
+	dhcp_options = dhcp + 1;
+	if (!dhcp_prepare_options(request_type, dhcp_options, data_end))
+		return false;
+
+	if (dhcp_padding_len > 0) {
+		void *start_pad = dhcp_options + dhcp_options_len;
+		__bpf_memset_builtin(start_pad, 0, dhcp_padding_len);
+	}
+
+	udp->source = bpf_htons(67);
+	udp->dest = bpf_htons(68);
+	udp->len = bpf_htons(udp_len);
+	udp->check = 0;
+
+	ip->ihl = 5;
+	ip->version = IPVERSION;
+	ip->ttl = IPDEFTTL;
+	ip->protocol = IPPROTO_UDP;
+	ip->frag_off = bpf_htons(IP_DF);
+	ip->id = 0;
+	ip->tos = 0;
+	ip->tot_len = bpf_htons(ip_len);
+	ip->saddr = IPV4_GATEWAY;
+	ip->daddr = yiaddr;
+	ip->check = 0;
+	ip->check = csum_fold(csum_diff(NULL, 0, ip, sizeof(*ip), 0));
+
+	memcpy(tmp_mac, eth->h_source, ETH_ALEN);
+	memcpy(eth->h_source, &node_mac, ETH_ALEN);
+	memcpy(eth->h_dest, tmp_mac, ETH_ALEN);
+
+	return true;
+}
+
+static __always_inline bool
+is_valid_dhcp_request(__u8 type)
+{
+	return type == DHCP_DISCOVER || type == DHCP_REQUEST;
+}
+
+static __always_inline bool
+is_dhcp_request(struct __ctx_buff *ctx, __u8 *request_type)
+{
+	bool is_dhcp_flow;
+	struct iphdr *ip;
+	struct udphdr *udp;
+	struct dhcp_packet *dhcp;
+	__u32 dhcp_len;
+	__u8 *dhcp_options;
+
+	char dhcp_magic_cookie[4] = {0x63, 0x82, 0x53, 0x63};
+	void *data_end = ctx_data_end(ctx);
+	void *data = ctx_data(ctx);
+	/* skip eth check - it is already done in cil_from_container */
+	ip = (struct iphdr *) (data + ETH_HLEN);
+	if ((void *)(ip + 1) > data_end)
+		return false;
+
+	if (unlikely(ip->version != 4))
+		return false;
+
+	if (ip->protocol != IPPROTO_UDP)
+		return false;
+
+	udp = (struct udphdr *)(ip + 1);
+	if ((void *)(udp + 1) > data_end)
+		return false;
+
+	is_dhcp_flow = bpf_ntohs(udp->dest) == 67 && bpf_ntohs(udp->source) == 68;
+	if (likely(!is_dhcp_flow))
+		return false;
+
+	dhcp_len = sizeof(struct ethhdr) + sizeof(*ip) + sizeof(*udp) + sizeof(*dhcp);
+	if (data + dhcp_len > data_end)
+		return false;
+
+	dhcp = (struct dhcp_packet *)(udp + 1);
+	if (dhcp->op != BOOT_REQUEST)
+		return false;
+
+	if (memcmp(dhcp_magic_cookie, &dhcp->cookies, sizeof(dhcp->cookies)) != 0)
+		return false;
+
+	dhcp_options = (__u8 *)(dhcp + 1);
+	if ((void*)dhcp_options + DHO_DHCP_MESSAGE_TYPE_LEN > data_end)
+		return false;
+
+	if (dhcp_options[0] != DHO_DHCP_MESSAGE_TYPE && dhcp_options[1] != 1)
+		return false;
+
+	*request_type = dhcp_options[2];
+
+	return true;
+}
+
+static __always_inline bool
+handle_dhcp_request(struct __ctx_buff *ctx, int *ret)
+{
+	__u8 request_type;
+
+	if (likely(!is_dhcp_request(ctx, &request_type)))
+		return false;
+
+	if (!is_valid_dhcp_request(request_type)) {
+		/* drop unsupported request types: release, inform */
+		*ret = CTX_ACT_DROP;
+		return true;
+	}
+
+	if (!dhcp_prepare_response(ctx, request_type)) {
+		/* drop malformed packet */
+		*ret = CTX_ACT_DROP;
+		return true;
+	}
+
+	*ret = redirect_self(ctx);
+	return true;
+}
+
+
+#endif /* __LIB_DHCP__ */
