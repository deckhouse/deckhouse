From 82d0915de4f807a1147970c1128207a625bbc551 Mon Sep 17 00:00:00 2001
From: Dmitriy Andreychenko <dmitriy.andreychenko@flant.com>
Date: Thu, 21 Aug 2025 18:17:41 +0300
Subject: [PATCH] upstream fix lb algo selection

Signed-off-by: Dmitriy Andreychenko <dmitriy.andreychenko@flant.com>
---
 bpf/lib/lb.h | 62 +++++++++++++++++++++++++---------------------------
 1 file changed, 30 insertions(+), 32 deletions(-)

diff --git a/bpf/lib/lb.h b/bpf/lib/lb.h
index 8769cce01a..a749b81d21 100644
--- a/bpf/lib/lb.h
+++ b/bpf/lib/lb.h
@@ -791,7 +791,7 @@ lb6_select_backend_id_maglev(struct __ctx_buff *ctx __maybe_unused,
 #ifdef LB_SELECTION_PER_SERVICE
 static __always_inline __u32 lb6_algorithm(const struct lb6_service *svc)
 {
-	return svc->affinity_timeout >> LB_ALGORITHM_SHIFT;
+	return svc->affinity_timeout >> LB_ALGORITHM_SHIFT ? : LB_SELECTION;
 }
 
 static __always_inline __u32
@@ -799,19 +799,20 @@ lb6_select_backend_id(struct __ctx_buff *ctx, struct lb6_key *key,
 		      const struct ipv6_ct_tuple *tuple,
 		      const struct lb6_service *svc)
 {
-	switch (lb6_algorithm(svc)) {
-	case LB_SELECTION_MAGLEV:
-		return lb6_select_backend_id_maglev(ctx, key, tuple, svc);
-	case LB_SELECTION_RANDOM:
-		return lb6_select_backend_id_random(ctx, key, tuple, svc);
-	default:
-#if LB_SELECTION == LB_SELECTION_RANDOM
-		return lb6_select_backend_id_random(ctx, key, tuple, svc);
-#elif LB_SELECTION == LB_SELECTION_MAGLEV
-		return lb6_select_backend_id_maglev(ctx, key, tuple, svc);
-#else
-# error "Invalid load balancer backend selection algorithm!"
-#endif /* LB_SELECTION */
+	__u32 alg = lb6_algorithm(svc);
+select:
+	switch (alg) {
+ 	case LB_SELECTION_MAGLEV:
+ 		return lb6_select_backend_id_maglev(ctx, key, tuple, svc);
+ 	case LB_SELECTION_RANDOM:
+ 		return lb6_select_backend_id_random(ctx, key, tuple, svc);
+ 	default:
+		/* We only enter here upon downgrade if some future algorithm
+		 * annotation was select that we do not support as annotation.
+		 * Fallback to default in this case.
+		 */
+		alg = LB_SELECTION;
+		goto select;
 	}
 }
 #elif LB_SELECTION == LB_SELECTION_RANDOM || LB_SELECTION == LB_SELECTION_LEAST_CONN
@@ -1731,7 +1732,7 @@ _lb_lct_conn_open(__u32 backend_id)
 #ifdef LB_SELECTION_PER_SERVICE
 static __always_inline __u32 lb4_algorithm(const struct lb4_service *svc)
 {
-	return svc->affinity_timeout >> LB_ALGORITHM_SHIFT;
+	return svc->affinity_timeout >> LB_ALGORITHM_SHIFT ? : LB_SELECTION;
 }
 
 static __always_inline __u32
@@ -1739,23 +1740,20 @@ lb4_select_backend_id(struct __ctx_buff *ctx, struct lb4_key *key,
 		      const struct ipv4_ct_tuple *tuple,
 		      const struct lb4_service *svc)
 {
-	switch (lb4_algorithm(svc)) {
-	case LB_SELECTION_MAGLEV:
-		return lb4_select_backend_id_maglev(ctx, key, tuple, svc);
-	case LB_SELECTION_RANDOM:
-		return lb4_select_backend_id_random(ctx, key, tuple, svc);
-	case LB_SELECTION_LEAST_CONN:
-		return lb4_select_backend_id_least_conn(ctx, key, tuple, svc);
-	default:
-#if LB_SELECTION == LB_SELECTION_RANDOM
-		return lb4_select_backend_id_random(ctx, key, tuple, svc);
-#elif LB_SELECTION == LB_SELECTION_MAGLEV
-		return lb4_select_backend_id_maglev(ctx, key, tuple, svc);
-#elif LB_SELECTION == LB_SELECTION_LEAST_CONN
-		return lb4_select_backend_id_least_conn(ctx, key, tuple, svc);
-#else
-# error "Invalid load balancer backend selection algorithm!"
-#endif /* LB_SELECTION */
+	__u32 alg = lb4_algorithm(svc);
+select:
+	switch (alg) {
+ 	case LB_SELECTION_MAGLEV:
+ 		return lb4_select_backend_id_maglev(ctx, key, tuple, svc);
+ 	case LB_SELECTION_RANDOM:
+ 		return lb4_select_backend_id_random(ctx, key, tuple, svc);
+ 	default:
+		/* We only enter here upon downgrade if some future algorithm
+		 * annotation was select that we do not support as annotation.
+		 * Fallback to default in this case.
+		 */
+		alg = LB_SELECTION;
+		goto select;
 	}
 }
 #elif LB_SELECTION == LB_SELECTION_RANDOM
-- 
2.34.1

