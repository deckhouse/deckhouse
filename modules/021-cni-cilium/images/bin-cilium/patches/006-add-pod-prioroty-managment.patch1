diff --git a/cilium/cmd/bpf_endpoint_delete.go b/cilium/cmd/bpf_endpoint_delete.go
index 9b35099eb9..e7a6d97d16 100644
--- a/cilium/cmd/bpf_endpoint_delete.go
+++ b/cilium/cmd/bpf_endpoint_delete.go
@@ -9,7 +9,7 @@ import (
 	"github.com/spf13/cobra"
 
 	"github.com/cilium/cilium/pkg/common"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 )
 
 var bpfEndpointDeleteCmd = &cobra.Command{
diff --git a/cilium/cmd/bpf_endpoint_list.go b/cilium/cmd/bpf_endpoint_list.go
index f047affb3c..2f20ad4a04 100644
--- a/cilium/cmd/bpf_endpoint_list.go
+++ b/cilium/cmd/bpf_endpoint_list.go
@@ -10,7 +10,7 @@ import (
 
 	"github.com/cilium/cilium/pkg/command"
 	"github.com/cilium/cilium/pkg/common"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 )
 
 const (
diff --git a/daemon/cmd/daemon.go b/daemon/cmd/daemon.go
index 16bb59e973..e8b3068d9d 100644
--- a/daemon/cmd/daemon.go
+++ b/daemon/cmd/daemon.go
@@ -72,6 +72,8 @@ import (
 	"github.com/cilium/cilium/pkg/maps/ctmap"
 	ipcachemap "github.com/cilium/cilium/pkg/maps/ipcache"
 	"github.com/cilium/cilium/pkg/maps/lbmap"
+
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	"github.com/cilium/cilium/pkg/maps/policymap"
 	"github.com/cilium/cilium/pkg/metrics"
 	monitoragent "github.com/cilium/cilium/pkg/monitor/agent"
@@ -546,6 +548,8 @@ func newDaemon(ctx context.Context, cleaner *daemonCleanup, params *daemonParams
 		authManager:          params.AuthManager,
 	}
 
+	lxcmap.SetGlobalIPCache(d.ipcache)
+
 	d.configModifyQueue = eventqueue.NewEventQueueBuffered("config-modify-queue", ConfigModifyQueueSize)
 	d.configModifyQueue.Run()
 
diff --git a/daemon/cmd/datapath.go b/daemon/cmd/datapath.go
index 073bc25d89..be12a8e06b 100644
--- a/daemon/cmd/datapath.go
+++ b/daemon/cmd/datapath.go
@@ -26,6 +26,7 @@ import (
 	"github.com/cilium/cilium/pkg/identity"
 	ippkg "github.com/cilium/cilium/pkg/ip"
 	"github.com/cilium/cilium/pkg/ipcache"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	ipcachetypes "github.com/cilium/cilium/pkg/ipcache/types"
 	"github.com/cilium/cilium/pkg/labels"
 	"github.com/cilium/cilium/pkg/logging/logfields"
@@ -34,7 +35,6 @@ import (
 	ipcachemap "github.com/cilium/cilium/pkg/maps/ipcache"
 	"github.com/cilium/cilium/pkg/maps/ipmasq"
 	"github.com/cilium/cilium/pkg/maps/lbmap"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
 	"github.com/cilium/cilium/pkg/maps/metricsmap"
 	"github.com/cilium/cilium/pkg/maps/nat"
 	"github.com/cilium/cilium/pkg/maps/neighborsmap"
diff --git a/daemon/cmd/state.go b/daemon/cmd/state.go
index c3fa2d23c0..c623c48060 100644
--- a/daemon/cmd/state.go
+++ b/daemon/cmd/state.go
@@ -19,6 +19,7 @@ import (
 	"github.com/cilium/cilium/pkg/controller"
 	"github.com/cilium/cilium/pkg/endpoint"
 	"github.com/cilium/cilium/pkg/ipam"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	"github.com/cilium/cilium/pkg/k8s"
 	slim_corev1 "github.com/cilium/cilium/pkg/k8s/slim/k8s/api/core/v1"
 	"github.com/cilium/cilium/pkg/k8s/watchers/resources"
@@ -26,7 +27,6 @@ import (
 	"github.com/cilium/cilium/pkg/lock"
 	"github.com/cilium/cilium/pkg/logging/logfields"
 	"github.com/cilium/cilium/pkg/maps/ctmap"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
 	nodeTypes "github.com/cilium/cilium/pkg/node/types"
 	"github.com/cilium/cilium/pkg/option"
 )
diff --git a/daemon/cmd/status.go b/daemon/cmd/status.go
index 77f4e60d15..c58ba01d72 100644
--- a/daemon/cmd/status.go
+++ b/daemon/cmd/status.go
@@ -21,6 +21,7 @@ import (
 	datapathOption "github.com/cilium/cilium/pkg/datapath/option"
 	datapath "github.com/cilium/cilium/pkg/datapath/types"
 	"github.com/cilium/cilium/pkg/identity"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	k8smetrics "github.com/cilium/cilium/pkg/k8s/metrics"
 	"github.com/cilium/cilium/pkg/kvstore"
 	"github.com/cilium/cilium/pkg/lock"
@@ -28,7 +29,6 @@ import (
 	ipcachemap "github.com/cilium/cilium/pkg/maps/ipcache"
 	ipmasqmap "github.com/cilium/cilium/pkg/maps/ipmasq"
 	"github.com/cilium/cilium/pkg/maps/lbmap"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
 	"github.com/cilium/cilium/pkg/maps/metricsmap"
 	"github.com/cilium/cilium/pkg/maps/timestamp"
 	tunnelmap "github.com/cilium/cilium/pkg/maps/tunnel"
diff --git a/operator/pkg/ciliumendpointslice/endpointslice.go b/operator/pkg/ciliumendpointslice/endpointslice.go
index de0288ef1f..9acb023a61 100644
--- a/operator/pkg/ciliumendpointslice/endpointslice.go
+++ b/operator/pkg/ciliumendpointslice/endpointslice.go
@@ -55,6 +55,8 @@ const (
 	// Default CES Synctime, multiple consecutive syncs with k8s-apiserver are
 	// batched and synced together after a short delay.
 	DefaultCESSyncTime = 500 * time.Millisecond
+	// Force CES update
+	ForceCESSyncTime = 5 * time.Millisecond
 )
 
 var (
diff --git a/operator/pkg/ciliumendpointslice/manager.go b/operator/pkg/ciliumendpointslice/manager.go
index 6de6fb7166..4e3a4b5caa 100644
--- a/operator/pkg/ciliumendpointslice/manager.go
+++ b/operator/pkg/ciliumendpointslice/manager.go
@@ -47,7 +47,7 @@ type cesTracker struct {
 // operations is an interface to all operations that a CES manager can perform.
 type operations interface {
 	// External APIs to Insert/Remove CEP in local dataStore
-	InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint, ns string) string
+	InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint, ns string, baseDelay time.Duration) string
 	updateCEPToCESMapping(cepName string, cesName string)
 	RemoveCEPFromCache(cepName string, baseDelay time.Duration)
 	removeCEPFromCES(cepName string, cesName string, baseDelay time.Duration, identity int64, checkIdentity bool)
@@ -60,7 +60,7 @@ type operations interface {
 	getRemovedCEPs(string) map[string]struct{}
 	clearRemovedCEPs(string, map[string]struct{})
 	createCES(cesName string) *cesTracker
-	addCEPtoCES(cep *cilium_v2.CoreCiliumEndpoint, ces *cesTracker)
+	addCEPtoCES(cep *cilium_v2.CoreCiliumEndpoint, ces *cesTracker, baseDelay time.Duration)
 	insertCESInWorkQueue(ces *cesTracker, baseDelay time.Duration)
 	// APIs to collect metrics of CES and CEP
 	getTotalCEPCount() int
@@ -149,7 +149,7 @@ func newCESManagerIdentity(workQueue workqueue.RateLimitingInterface, maxCEPsInC
 
 // addCEPtoCES inserts the CEP in a CES, if the CEP already exists in a CES
 // it replaces with new CEP.
-func (c *cesMgr) addCEPtoCES(cep *cilium_v2.CoreCiliumEndpoint, ces *cesTracker) {
+func (c *cesMgr) addCEPtoCES(cep *cilium_v2.CoreCiliumEndpoint, ces *cesTracker, baseDelay time.Duration) {
 	ces.backendMutex.Lock()
 	defer ces.backendMutex.Unlock()
 	// If cep already exists in ces, compare new cep with cached cep.
@@ -171,7 +171,6 @@ func (c *cesMgr) addCEPtoCES(cep *cilium_v2.CoreCiliumEndpoint, ces *cesTracker)
 			break
 		}
 	}
-
 	// Insert the cep in ces endpoints list.
 	ces.ces.Endpoints = append(ces.ces.Endpoints, *cep)
 	// If this CEP is re-generated again before previous CEP-DELETE completed.
@@ -181,7 +180,7 @@ func (c *cesMgr) addCEPtoCES(cep *cilium_v2.CoreCiliumEndpoint, ces *cesTracker)
 	}
 	// Increment the cepInsert counter
 	ces.cepInserted += 1
-	c.insertCESInWorkQueue(ces, DefaultCESSyncTime)
+	c.insertCESInWorkQueue(ces, baseDelay)
 	return
 }
 
@@ -301,7 +300,7 @@ func (c *cesMgr) getCESCopyFromCache(cesName string) (*cilium_v2.CiliumEndpointS
 
 // InsertCEPInCache is used to insert CEP in local cache, this may result in creating a new
 // CES object or updating an existing CES object.
-func (c *cesMgr) InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint, ns string) string {
+func (c *cesMgr) InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint, ns string, baseDelay time.Duration) string {
 	log.WithFields(logrus.Fields{
 		logfields.CEPName: GetCEPNameFromCCEP(cep, ns),
 	}).Debug("Insert CEP in local cache")
@@ -312,7 +311,7 @@ func (c *cesMgr) InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint, ns string)
 	if cesName, exists := c.desiredCESs.getCESName(cepName); exists {
 		if ces, ok := c.desiredCESs.getCESTracker(cesName); ok {
 			// add a cep into the ces
-			c.addCEPtoCES(cep, ces)
+			c.addCEPtoCES(cep, ces, baseDelay)
 			return cesName
 		} else {
 			log.WithFields(logrus.Fields{
@@ -345,7 +344,7 @@ func (c *cesMgr) InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint, ns string)
 	c.updateCEPToCESMapping(GetCEPNameFromCCEP(cep, ns), cesName)
 
 	// Queue the CEP in CES
-	c.addCEPtoCES(cep, cb)
+	c.addCEPtoCES(cep, cb, baseDelay)
 	return cesName
 }
 
@@ -603,7 +602,7 @@ func (c *cesManagerIdentity) deleteCESFromCache(cesName string) {
 
 // InsertCEPInCache is used to insert CEP in local cache, this may result in creating a new
 // CES object or updating an existing CES object. CEPs are grouped based on CEP identity.
-func (c *cesManagerIdentity) InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint, ns string) string {
+func (c *cesManagerIdentity) InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint, ns string, baseDelay time.Duration) string {
 	// check the given cep is already exists in any of the CES.
 	// if yes, compare the given CEP Identity with the CEPs stored in CES.
 	// If they are same UPDATE the CEP in the CES. This will trigger CES UPDATE to k8s-apiserver.
@@ -618,7 +617,7 @@ func (c *cesManagerIdentity) InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint,
 		} else {
 			if ces, ok := c.desiredCESs.getCESTracker(cesName); ok {
 				// add a cep into the ces
-				c.addCEPtoCES(cep, ces)
+				c.addCEPtoCES(cep, ces, baseDelay)
 				return cesName
 			} else {
 				log.WithFields(logrus.Fields{
@@ -669,7 +668,7 @@ func (c *cesManagerIdentity) InsertCEPInCache(cep *cilium_v2.CoreCiliumEndpoint,
 	c.desiredCESs.insertCEP(GetCEPNameFromCCEP(cep, ns), cesName)
 
 	// Queue the CEP in CES
-	c.addCEPtoCES(cep, cb)
+	c.addCEPtoCES(cep, cb, baseDelay)
 	return cesName
 }
 
diff --git a/operator/pkg/ciliumendpointslice/manager_test.go b/operator/pkg/ciliumendpointslice/manager_test.go
index bf47c44de9..ece7d4a286 100644
--- a/operator/pkg/ciliumendpointslice/manager_test.go
+++ b/operator/pkg/ciliumendpointslice/manager_test.go
@@ -73,9 +73,9 @@ func TestInsertAndRemoveCEPsInCache(t *testing.T) {
 	// Insert CEPs in Cache and count total number of CES and CEP
 	t.Run("Test Inserting CEPs in cache and count number of CEPs and CESs", func(*testing.T) {
 		m := newCESManagerFcfs(newQueue(), 2)
-		m.InsertCEPInCache(cep1, "kube-system")
-		m.InsertCEPInCache(cep2, "kube-system")
-		m.InsertCEPInCache(cep3, "kube-system")
+		m.InsertCEPInCache(cep1, "kube-system", DefaultCESSyncTime)
+		m.InsertCEPInCache(cep2, "kube-system", DefaultCESSyncTime)
+		m.InsertCEPInCache(cep3, "kube-system", DefaultCESSyncTime)
 		assert.Equal(t, m.getCESCount(), 2, "Total number of CESs allocated is 2")
 		assert.Equal(t, m.getTotalCEPCount(), 3, "Total number of CEPs inserted is 3")
 	})
@@ -84,15 +84,15 @@ func TestInsertAndRemoveCEPsInCache(t *testing.T) {
 	t.Run("Test Removing CEPs from cache and check number of CEPs and CESs", func(*testing.T) {
 		m := newCESManagerFcfs(newQueue(), 2)
 		u := newDesiredCESMap()
-		cn := m.InsertCEPInCache(cep1, "kube-system")
+		cn := m.InsertCEPInCache(cep1, "kube-system", DefaultCESSyncTime)
 		u.insertCEP(cep1.Name, cn)
-		cn = m.InsertCEPInCache(cep2, "kube-system")
+		cn = m.InsertCEPInCache(cep2, "kube-system", DefaultCESSyncTime)
 		u.insertCEP(cep2.Name, cn)
-		cn = m.InsertCEPInCache(cep3, "kube-system")
+		cn = m.InsertCEPInCache(cep3, "kube-system", DefaultCESSyncTime)
 		u.insertCEP(cep3.Name, cn)
-		cn = m.InsertCEPInCache(cep4, "kube-system")
+		cn = m.InsertCEPInCache(cep4, "kube-system", DefaultCESSyncTime)
 		u.insertCEP(cep4.Name, cn)
-		cn = m.InsertCEPInCache(cep5, "kube-system")
+		cn = m.InsertCEPInCache(cep5, "kube-system", DefaultCESSyncTime)
 		u.insertCEP(cep5.Name, cn)
 		// Check all 5 CEP are inserted
 		assert.Equal(t, m.getCESCount(), 3, "Total number of CESs allocated is 3")
@@ -148,7 +148,7 @@ func TestInsertAndRemoveCEPsInCache(t *testing.T) {
 			newCES := m.createCES(cesName)
 			newCES.ces.Namespace = ns
 			for _, cep := range cepList {
-				m.addCEPtoCES(&cep, newCES)
+				m.addCEPtoCES(&cep, newCES, DefaultCESSyncTime)
 			}
 
 			m.updateCESInCache(newCES.ces, true)
@@ -162,15 +162,15 @@ func TestInsertAndRemoveCEPsInCache(t *testing.T) {
 		ces5 := createCES("ces5", "namespace-a", []capi_v2a1.CoreCiliumEndpoint{*cep3})
 
 		// All CEPs should be added to the same CES (ces2) in default namespace.
-		m.InsertCEPInCache(cep4, "default")
+		m.InsertCEPInCache(cep4, "default", DefaultCESSyncTime)
 		assert.Equal(t, 3, len(ces2.ces.Endpoints), "The largest CES in default namespace has 3 CEPs")
-		m.InsertCEPInCache(cep5, "default")
+		m.InsertCEPInCache(cep5, "default", DefaultCESSyncTime)
 		assert.Equal(t, 4, len(ces2.ces.Endpoints), "The largest CES in default namespace has 4 CEPs")
-		m.InsertCEPInCache(cep1a, "default")
+		m.InsertCEPInCache(cep1a, "default", DefaultCESSyncTime)
 		assert.Equal(t, 5, len(ces2.ces.Endpoints), "The largest CES in default namespace has 5 CEPs")
 
 		// All CEPs should be added to the same CES (ces4) in namespace-a.
-		m.InsertCEPInCache(cep4, "namespace-a")
+		m.InsertCEPInCache(cep4, "namespace-a", DefaultCESSyncTime)
 		assert.Equal(t, 3, len(ces4.ces.Endpoints), "The largest CES in namespace-a has 3 CEPs")
 		assert.Equal(t, 5, len(ces2.ces.Endpoints), "The largest CES in default namespace still has 5 CEPs")
 
@@ -185,8 +185,8 @@ func TestDeepCopyCEPs(t *testing.T) {
 	// Insert CEPs in Cache, then do the deep copy and compare CESs.
 	t.Run("Test Inserting CEPs in cache and count number of CEPs and CESs", func(*testing.T) {
 		m := newCESManagerFcfs(newQueue(), 2)
-		m.InsertCEPInCache(cep1, "kube-system")
-		cn := m.InsertCEPInCache(cep2, "kube-system")
+		m.InsertCEPInCache(cep1, "kube-system", DefaultCESSyncTime)
+		cn := m.InsertCEPInCache(cep2, "kube-system", DefaultCESSyncTime)
 		ces, _ := m.getCESFromCache(cn)
 		assert.Equal(t, m.getCESCount(), 1, "Total number of CESs allocated is 1")
 		assert.Equal(t, m.getTotalCEPCount(), 2, "Total number of CEPs inserted is 2")
@@ -206,10 +206,10 @@ func TestDeepCopyCEPs(t *testing.T) {
 		assert.Equal(t, ces.DeepEqual(CES), true, "Local CES should match with CES in datastore")
 
 		m1 := newCESManagerIdentity(newQueue(), 2)
-		m1.InsertCEPInCache(cep1, "kube-system")
-		m1.InsertCEPInCache(cep1a, "kube-system")
-		m1.InsertCEPInCache(cep2b, "kube-system")
-		cn = m1.InsertCEPInCache(cep2, "kube-system")
+		m1.InsertCEPInCache(cep1, "kube-system", DefaultCESSyncTime)
+		m1.InsertCEPInCache(cep1a, "kube-system", DefaultCESSyncTime)
+		m1.InsertCEPInCache(cep2b, "kube-system", DefaultCESSyncTime)
+		cn = m1.InsertCEPInCache(cep2, "kube-system", DefaultCESSyncTime)
 		ces, _ = m1.getCESFromCache(cn)
 		assert.Equal(t, m1.getCESCount(), 2, "Total number of CESs allocated is 2")
 		assert.Equal(t, m1.getTotalCEPCount(), 4, "Total number of CEPs inserted is 4")
@@ -233,8 +233,8 @@ func TestDeepCopyCEPs(t *testing.T) {
 func TestRemovedCEPs(t *testing.T) {
 	t.Run("Test Deleting CEPs and Insert", func(*testing.T) {
 		m := newCESManagerFcfs(newQueue(), 2)
-		m.InsertCEPInCache(cep1, "kube-system")
-		cesName := m.InsertCEPInCache(cep2, "kube-system")
+		m.InsertCEPInCache(cep1, "kube-system", DefaultCESSyncTime)
+		cesName := m.InsertCEPInCache(cep2, "kube-system", DefaultCESSyncTime)
 		m.RemoveCEPFromCache(GetCEPNameFromCCEP(cep1, "kube-system"), DefaultCESSyncTime)
 		m.RemoveCEPFromCache(GetCEPNameFromCCEP(cep2, "kube-system"), DefaultCESSyncTime)
 		remCEPs := m.getRemovedCEPs(cesName)
diff --git a/operator/watchers/cilium_endpoint.go b/operator/watchers/cilium_endpoint.go
index 7c1b240f77..30b1a2780f 100644
--- a/operator/watchers/cilium_endpoint.go
+++ b/operator/watchers/cilium_endpoint.go
@@ -7,8 +7,11 @@ import (
 	"context"
 	"errors"
 	"fmt"
+	"math"
 	"strconv"
+	"strings"
 	"sync"
+	"time"
 
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/client-go/tools/cache"
@@ -19,6 +22,7 @@ import (
 	k8sClient "github.com/cilium/cilium/pkg/k8s/client"
 	"github.com/cilium/cilium/pkg/k8s/informer"
 	"github.com/cilium/cilium/pkg/k8s/utils"
+	"github.com/cilium/cilium/pkg/labels"
 	"github.com/cilium/cilium/pkg/logging/logfields"
 	"github.com/cilium/cilium/pkg/option"
 )
@@ -73,6 +77,10 @@ func identityIndexFunc(obj interface{}) ([]string, error) {
 // CiliumEndpointsInit starts a CiliumEndpointWatcher
 func CiliumEndpointsInit(ctx context.Context, wg *sync.WaitGroup, clientset k8sClient.Clientset) {
 	once.Do(func() {
+		filter = priorityFilter{
+			ipToCepList: make(map[string][]coreCiliumEndpointInfo),
+		}
+
 		CiliumEndpointStore = cache.NewIndexer(cache.DeletionHandlingMetaNamespaceKeyFunc, indexers)
 
 		var cacheResourceHandler cache.ResourceEventHandlerFuncs
@@ -88,7 +96,7 @@ func CiliumEndpointsInit(ctx context.Context, wg *sync.WaitGroup, clientset k8sC
 				UpdateFunc: func(oldObj, newObj interface{}) {
 					if oldCEP := objToCiliumEndpoint(oldObj); oldCEP != nil {
 						if newCEP := objToCiliumEndpoint(newObj); newCEP != nil {
-							if oldCEP.DeepEqual(newCEP) {
+							if oldCEP.DeepEqual(newCEP) && !isUpdateForced(oldCEP, newCEP) {
 								return
 							}
 							endpointUpdated(newCEP)
@@ -139,6 +147,7 @@ func transformToCiliumEndpoint(obj interface{}) (interface{}, error) {
 				ResourceVersion: concreteObj.ResourceVersion,
 				OwnerReferences: concreteObj.OwnerReferences,
 				UID:             concreteObj.UID,
+				Labels:          concreteObj.Labels,
 			},
 			Status: cilium_api_v2.EndpointStatus{
 				Identity:   concreteObj.Status.Identity,
@@ -210,15 +219,234 @@ func HasCE(ns, name string) (*cilium_api_v2.CiliumEndpoint, bool, error) {
 	return cep, exists, nil
 }
 
+func isUpdateForced(oldCEP, newCEP *cilium_api_v2.CiliumEndpoint) bool {
+	if _, exist := oldCEP.Labels[labels.IDNamePriority]; exist {
+		return false
+	}
+
+	forced := false
+	if lbl, exist := newCEP.Labels[labels.IDNamePriority]; exist {
+		priority := getPriority(lbl)
+		forced = priority == High
+	}
+	return forced
+}
+
+type cepPriority uint32
+
+const (
+	High    cepPriority = 0
+	Default cepPriority = math.MaxUint32
+)
+
+func (c cepPriority) isLess(rv cepPriority) bool {
+	return c > rv
+}
+
+func getPriority(s string) cepPriority {
+	if num, err := strconv.ParseUint(s, 10, 32); err == nil {
+		return cepPriority(num)
+	}
+	return Default
+}
+
+type coreCiliumEndpointInfo struct {
+	cep      *cilium_api_v2.CiliumEndpoint
+	priority cepPriority
+}
+
+type priorityFilter struct {
+	ipToCepList map[string][]coreCiliumEndpointInfo
+}
+
+var filter priorityFilter
+
+func getCepPriority(cep *cilium_api_v2.CiliumEndpoint) cepPriority {
+	var priority cepPriority = Default
+	for _, lbl := range cep.Status.Identity.Labels {
+		if !strings.Contains(lbl, labels.IDNamePriority) {
+			continue
+		}
+
+		parts := strings.SplitN(lbl, "=", 2)
+		if len(parts) < 2 {
+			continue
+		}
+
+		priority = getPriority(parts[1])
+		break
+	}
+
+	if lbl, exist := cep.Labels[labels.IDNamePriority]; exist {
+		priority = getPriority(lbl)
+	}
+
+	return priority
+}
+
+func getCepAddressPair(cep *cilium_api_v2.CiliumEndpoint) cilium_api_v2.AddressPair {
+	var shared cilium_api_v2.AddressPair
+	for _, pair := range cep.Status.Networking.Addressing {
+		if pair.IPV4 == "" {
+			continue
+		}
+		shared = *pair
+		break
+	}
+	return shared
+}
+
+// WARNING this update logic will work only if CEP(new and old) network addresses is not changed !!!
+// If some address was removed in new CEP - it will never removed from map
+func (c *priorityFilter) filterAddressByPriority(cep *cilium_api_v2.CiliumEndpoint) (*cilium_api_v2.CiliumEndpoint, time.Duration, *cilium_api_v2.CiliumEndpoint) {
+	var oldOwner *cilium_api_v2.CiliumEndpoint
+	newOwner := cep
+	delay := ces.DefaultCESSyncTime
+	priority := getCepPriority(cep)
+
+	// filter support only one ip4 address for pod
+	shared := getCepAddressPair(cep)
+	if shared.IPV4 == "" {
+		return oldOwner, delay, newOwner
+	}
+
+	info := coreCiliumEndpointInfo{
+		cep:      cep,
+		priority: priority,
+	}
+
+	if cepList, exist := c.ipToCepList[shared.IPV4]; exist {
+		isInserted := false
+		// new cep will have higher priority than old ceps with same priority
+		highest := &info
+		currentOwner := cepList[0].cep
+		for i := range cepList {
+			if len(cepList[i].cep.Status.Networking.Addressing) != 0 {
+				currentOwner = cepList[i].cep
+			}
+			if equalCeps(cep, cepList[i].cep) {
+				isInserted = true
+				cepList[i].cep = cep
+				// forced update only on first appearance
+				if cepList[i].priority != priority && priority == High {
+					delay = ces.ForceCESSyncTime
+				}
+				cepList[i].priority = priority
+			}
+			if highest.priority.isLess(cepList[i].priority) {
+				highest = &cepList[i]
+			}
+		}
+		if !isInserted {
+			if priority == High {
+				delay = ces.ForceCESSyncTime
+			}
+			c.ipToCepList[shared.IPV4] = append(cepList, info)
+		}
+		// possibly cases:
+		// 1) income cep is highest and already ip4 owner(only update income cep)
+		// 2) income cep is highest and replace other owner cep(hide ip4 address for previous owner and make owner income cep)
+		// 3) income cep is lowest and need to be replaced by other cep
+		// 4) income cep is lowest and other cep is already owner
+		emptyAddrList := cilium_api_v2.AddressPairList{}
+		isOwner := equalCeps(cep, currentOwner)
+		isHighest := equalCeps(cep, highest.cep)
+		if isOwner && isHighest {
+			// just skip
+		} else if isOwner && !isHighest {
+			cep.Status.Networking.Addressing = emptyAddrList
+			addr := &cilium_api_v2.AddressPair{
+				IPV4: shared.IPV4,
+				IPV6: shared.IPV6,
+			}
+			highest.cep.Status.Networking.Addressing = append(emptyAddrList, addr)
+			oldOwner = cep
+			newOwner = highest.cep
+		} else if !isOwner && isHighest {
+			currentOwner.Status.Networking.Addressing = emptyAddrList
+			oldOwner = currentOwner
+		} else { // !isOwner && !isHighest
+			cep.Status.Networking.Addressing = emptyAddrList
+		}
+	} else {
+		c.ipToCepList[shared.IPV4] = []coreCiliumEndpointInfo{info}
+		if priority == High {
+			delay = ces.ForceCESSyncTime
+		}
+	}
+	return oldOwner, delay, newOwner
+}
+
+func equalCeps(cep0, cep1 *cilium_api_v2.CiliumEndpoint) bool {
+	return cep0.Name == cep1.Name && cep0.Namespace == cep1.Namespace
+}
+
+func (c *priorityFilter) removeCEPFromFilter(cep *cilium_api_v2.CiliumEndpoint) *cilium_api_v2.CiliumEndpoint {
+	if cep.Status.Networking == nil || cep.GetName() == "" || cep.Namespace == "" {
+		return nil
+	}
+	// filter support only one ip4 address for pod
+	shared := getCepAddressPair(cep)
+	if shared.IPV4 == "" {
+		return nil
+	}
+
+	var hiddenCep *cilium_api_v2.CiliumEndpoint
+	if cepList, exist := c.ipToCepList[shared.IPV4]; exist {
+		if len(cepList) == 1 {
+			prev := cepList[0]
+			if equalCeps(prev.cep, cep) {
+				delete(filter.ipToCepList, shared.IPV4)
+			}
+			return nil
+		}
+		needRestoring := false
+		// remove CEP from slice with several elements
+		newList := []coreCiliumEndpointInfo{}
+		for _, prev := range cepList {
+			if !equalCeps(prev.cep, cep) {
+				newList = append(newList, prev)
+			} else {
+				// if removed CEP have address - restoring hidden CEP
+				needRestoring = len(prev.cep.Status.Networking.Addressing) != 0
+			}
+		}
+		c.ipToCepList[shared.IPV4] = newList
+		if !needRestoring {
+			return nil
+		}
+		// find most priorioty hidden cep for restoring its network access
+		highest := &newList[0]
+		for i := 1; i < len(newList); i++ {
+			if newList[i].priority.isLess(highest.priority) {
+				highest = &newList[i]
+			}
+		}
+		hiddenCep = highest.cep
+		hiddenCep.Status.Networking.Addressing = append(hiddenCep.Status.Networking.Addressing, &shared)
+	}
+	return hiddenCep
+}
+
 func endpointUpdated(cep *cilium_api_v2.CiliumEndpoint) {
 	if cep.Status.Networking == nil || cep.Status.Identity == nil || cep.GetName() == "" || cep.Namespace == "" {
 		return
 	}
-	cesController.Manager.InsertCEPInCache(k8s.ConvertCEPToCoreCEP(cep), cep.Namespace)
+
+	oldOwner, delay, newOwner := filter.filterAddressByPriority(cep)
+	if oldOwner != nil {
+		cesController.Manager.InsertCEPInCache(k8s.ConvertCEPToCoreCEP(oldOwner), oldOwner.Namespace, ces.DefaultCESSyncTime)
+	}
+	cesController.Manager.InsertCEPInCache(k8s.ConvertCEPToCoreCEP(newOwner), newOwner.Namespace, delay)
 }
 
 func endpointDeleted(cep *cilium_api_v2.CiliumEndpoint) {
-	cesController.Manager.RemoveCEPFromCache(ces.GetCEPNameFromCCEP(k8s.ConvertCEPToCoreCEP(cep), cep.Namespace), ces.DefaultCESSyncTime)
+	hiddenCep := filter.removeCEPFromFilter(cep)
+
+	cesController.Manager.RemoveCEPFromCache(ces.GetCEPNameFromCCEP(k8s.ConvertCEPToCoreCEP(cep), cep.Namespace), ces.DelayedCESSyncTime)
+	if hiddenCep != nil {
+		cesController.Manager.InsertCEPInCache(k8s.ConvertCEPToCoreCEP(hiddenCep), hiddenCep.Namespace, ces.DefaultCESSyncTime)
+	}
 }
 
 // objToCiliumEndpoint attempts to cast object to a CiliumEndpoint object
diff --git a/pkg/datapath/alignchecker/alignchecker.go b/pkg/datapath/alignchecker/alignchecker.go
index ebf4d4a1bb..b3dd580977 100644
--- a/pkg/datapath/alignchecker/alignchecker.go
+++ b/pkg/datapath/alignchecker/alignchecker.go
@@ -6,6 +6,7 @@ package alignchecker
 import (
 	check "github.com/cilium/cilium/pkg/alignchecker"
 	"github.com/cilium/cilium/pkg/bpf"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	"github.com/cilium/cilium/pkg/maps/authmap"
 	"github.com/cilium/cilium/pkg/maps/bwmap"
 	"github.com/cilium/cilium/pkg/maps/ctmap"
@@ -14,7 +15,6 @@ import (
 	"github.com/cilium/cilium/pkg/maps/fragmap"
 	ipcachemap "github.com/cilium/cilium/pkg/maps/ipcache"
 	"github.com/cilium/cilium/pkg/maps/lbmap"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
 	"github.com/cilium/cilium/pkg/maps/metricsmap"
 	"github.com/cilium/cilium/pkg/maps/neighborsmap"
 	"github.com/cilium/cilium/pkg/maps/policymap"
diff --git a/pkg/datapath/linux/config/config.go b/pkg/datapath/linux/config/config.go
index 333076b2ff..3863ff4b2d 100644
--- a/pkg/datapath/linux/config/config.go
+++ b/pkg/datapath/linux/config/config.go
@@ -26,6 +26,7 @@ import (
 	datapath "github.com/cilium/cilium/pkg/datapath/types"
 	"github.com/cilium/cilium/pkg/defaults"
 	"github.com/cilium/cilium/pkg/identity"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	"github.com/cilium/cilium/pkg/labels"
 	"github.com/cilium/cilium/pkg/logging"
 	"github.com/cilium/cilium/pkg/logging/logfields"
@@ -44,7 +45,6 @@ import (
 	"github.com/cilium/cilium/pkg/maps/ipmasq"
 	"github.com/cilium/cilium/pkg/maps/l2respondermap"
 	"github.com/cilium/cilium/pkg/maps/lbmap"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
 	"github.com/cilium/cilium/pkg/maps/metricsmap"
 	"github.com/cilium/cilium/pkg/maps/nat"
 	"github.com/cilium/cilium/pkg/maps/neighborsmap"
diff --git a/pkg/endpoint/bpf.go b/pkg/endpoint/bpf.go
index 7cf0dcf319..6aeb7ca63c 100644
--- a/pkg/endpoint/bpf.go
+++ b/pkg/endpoint/bpf.go
@@ -27,11 +27,11 @@ import (
 	"github.com/cilium/cilium/pkg/controller"
 	"github.com/cilium/cilium/pkg/endpoint/regeneration"
 	"github.com/cilium/cilium/pkg/fqdn/restore"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	"github.com/cilium/cilium/pkg/loadinfo"
 	"github.com/cilium/cilium/pkg/logging/logfields"
 	"github.com/cilium/cilium/pkg/maps/bwmap"
 	"github.com/cilium/cilium/pkg/maps/ctmap"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
 	"github.com/cilium/cilium/pkg/maps/policymap"
 	"github.com/cilium/cilium/pkg/metrics"
 	"github.com/cilium/cilium/pkg/option"
diff --git a/pkg/endpoint/endpoint.go b/pkg/endpoint/endpoint.go
index 4a2b401797..64b4012b74 100644
--- a/pkg/endpoint/endpoint.go
+++ b/pkg/endpoint/endpoint.go
@@ -38,6 +38,7 @@ import (
 	"github.com/cilium/cilium/pkg/identity/identitymanager"
 	ippkg "github.com/cilium/cilium/pkg/ip"
 	ipamOption "github.com/cilium/cilium/pkg/ipam/option"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	slim_corev1 "github.com/cilium/cilium/pkg/k8s/slim/k8s/api/core/v1"
 	"github.com/cilium/cilium/pkg/labels"
 	"github.com/cilium/cilium/pkg/labelsfilter"
@@ -46,7 +47,6 @@ import (
 	"github.com/cilium/cilium/pkg/logging/logfields"
 	"github.com/cilium/cilium/pkg/mac"
 	"github.com/cilium/cilium/pkg/maps/ctmap"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
 	"github.com/cilium/cilium/pkg/maps/policymap"
 	"github.com/cilium/cilium/pkg/metrics"
 	"github.com/cilium/cilium/pkg/monitor/notifications"
diff --git a/pkg/ipcache/ipcache.go b/pkg/ipcache/ipcache.go
index 59f89704c1..bb61ec3ed9 100644
--- a/pkg/ipcache/ipcache.go
+++ b/pkg/ipcache/ipcache.go
@@ -12,6 +12,10 @@ import (
 
 	"github.com/sirupsen/logrus"
 
+	"fmt"
+	"sync"
+
+	"github.com/cilium/cilium/pkg/bpf"
 	cmtypes "github.com/cilium/cilium/pkg/clustermesh/types"
 	"github.com/cilium/cilium/pkg/controller"
 	"github.com/cilium/cilium/pkg/identity"
@@ -22,12 +26,340 @@ import (
 	"github.com/cilium/cilium/pkg/labels/cidr"
 	"github.com/cilium/cilium/pkg/lock"
 	"github.com/cilium/cilium/pkg/logging/logfields"
+	"github.com/cilium/cilium/pkg/mac"
 	"github.com/cilium/cilium/pkg/metrics"
+	"github.com/cilium/cilium/pkg/node"
 	"github.com/cilium/cilium/pkg/option"
 	"github.com/cilium/cilium/pkg/source"
 	"github.com/cilium/cilium/pkg/types"
+	"github.com/cilium/ebpf"
+)
+
+// lxcmap module code start
+
+const (
+	MapName = "cilium_lxc"
+
+	// MaxEntries represents the maximum number of endpoints in the map
+	MaxEntries = 65535
+
+	// PortMapMax represents the maximum number of Ports Mapping per container.
+	PortMapMax = 16
+)
+
+var (
+	// LXCMap represents the BPF map for endpoints
+	lxcMap     *bpf.Map
+	lxcMapOnce sync.Once
 )
 
+type LxcEndpointInfo struct {
+	key    *EndpointKey
+	info   *EndpointInfo
+	active bool
+}
+
+var globalIPCache *IPCache
+
+func SetGlobalIPCache(ipcache *IPCache) {
+	globalIPCache = ipcache
+}
+
+func (ipc *IPCache) isIPCacheHostLocal(epAddr string, nodeIPv4 net.IP) bool {
+	ipKeyPair := ipc.ipToHostIPCache[epAddr]
+	host := ipKeyPair.IP
+	if host == nil {
+		// cilium_health ep always have nil host - force default behavior
+		return true
+	}
+	return host.Equal(nodeIPv4)
+}
+
+func (ipc *IPCache) checkLxcMapRelation(ip string, hostIP, oldHostIP net.IP) {
+	if hostIP.Equal(oldHostIP) {
+		return
+	}
+
+	hostIP4 := hostIP.To4()
+	if hostIP4 == nil {
+		return
+	}
+
+	lxc, exist := ipc.ipToEndpointInfo[ip]
+	if !exist {
+		return
+	}
+
+	nodeIPv4 := node.GetIPv4()
+	isLocal := nodeIPv4.Equal(hostIP4)
+	if isLocal && !lxc.active {
+		LXCMap().Update(lxc.key, lxc.info)
+		lxc.active = true
+		log.WithFields(logrus.Fields{
+			logfields.IPAddr: ip,
+		}).Debug("restore record in in cilium_lxc map")
+	} else if !isLocal && lxc.active {
+		LXCMap().Delete(lxc.key)
+		lxc.active = false
+		log.WithFields(logrus.Fields{
+			logfields.IPAddr: ip,
+		}).Debug("hiding record in in cilium_lxc map")
+	}
+}
+
+func getEndpointAddress(v *EndpointKey) string {
+	ip := v.ToIP()
+	if ip == nil {
+		return ""
+	}
+
+	ip4 := ip.To4()
+	if ip4 == nil {
+		return ""
+	}
+
+	return ip4.String()
+}
+
+func LXCMap() *bpf.Map {
+	lxcMapOnce.Do(func() {
+		lxcMap = bpf.NewMap(MapName,
+			ebpf.Hash,
+			&EndpointKey{},
+			&EndpointInfo{},
+			MaxEntries,
+			0,
+		).WithCache().WithPressureMetric().
+			WithEvents(option.Config.GetEventBufferConfig(MapName))
+	})
+	return lxcMap
+}
+
+const (
+	// EndpointFlagHost indicates that this endpoint represents the host
+	EndpointFlagHost = 1
+)
+
+// EndpointFrontend is the interface to implement for an object to synchronize
+// with the endpoint BPF map.
+type EndpointFrontend interface {
+	LXCMac() mac.MAC
+	GetNodeMAC() mac.MAC
+	GetIfIndex() int
+	GetID() uint64
+	IPv4Address() netip.Addr
+	IPv6Address() netip.Addr
+	GetIdentity() identity.NumericIdentity
+}
+
+// GetBPFKeys returns all keys which should represent this endpoint in the BPF
+// endpoints map
+func GetBPFKeys(e EndpointFrontend) []*EndpointKey {
+	keys := []*EndpointKey{}
+	if e.IPv6Address().IsValid() {
+		keys = append(keys, NewEndpointKey(e.IPv6Address().AsSlice()))
+	}
+
+	if e.IPv4Address().IsValid() {
+		keys = append(keys, NewEndpointKey(e.IPv4Address().AsSlice()))
+	}
+
+	return keys
+}
+
+// GetBPFValue returns the value which should represent this endpoint in the
+// BPF endpoints map
+// Must only be called if init() succeeded.
+func GetBPFValue(e EndpointFrontend) (*EndpointInfo, error) {
+	mac, err := e.LXCMac().Uint64()
+	if err != nil {
+		return nil, fmt.Errorf("invalid LXC MAC: %w", err)
+	}
+
+	nodeMAC, err := e.GetNodeMAC().Uint64()
+	if err != nil {
+		return nil, fmt.Errorf("invalid node MAC: %w", err)
+	}
+
+	info := &EndpointInfo{
+		IfIndex: uint32(e.GetIfIndex()),
+		// Store security identity in network byte order so it can be
+		// written into the packet without an additional byte order
+		// conversion.
+		LxcID:   uint16(e.GetID()),
+		MAC:     mac,
+		NodeMAC: nodeMAC,
+		SecID:   e.GetIdentity().Uint32(),
+	}
+
+	return info, nil
+
+}
+
+type pad3uint32 [3]uint32
+
+// EndpointInfo represents the value of the endpoints BPF map.
+//
+// Must be in sync with struct endpoint_info in <bpf/lib/common.h>
+type EndpointInfo struct {
+	IfIndex uint32 `align:"ifindex"`
+	Unused  uint16 `align:"unused"`
+	LxcID   uint16 `align:"lxc_id"`
+	Flags   uint32 `align:"flags"`
+	// go alignment
+	_       uint32
+	MAC     mac.Uint64MAC `align:"mac"`
+	NodeMAC mac.Uint64MAC `align:"node_mac"`
+	SecID   uint32        `align:"sec_id"`
+	Pad     pad3uint32    `align:"pad"`
+}
+
+type EndpointKey struct {
+	bpf.EndpointKey
+}
+
+// NewEndpointKey returns an EndpointKey based on the provided IP address. The
+// address family is automatically detected
+func NewEndpointKey(ip net.IP) *EndpointKey {
+	return &EndpointKey{
+		EndpointKey: bpf.NewEndpointKey(ip, 0),
+	}
+}
+
+func (k *EndpointKey) New() bpf.MapKey { return &EndpointKey{} }
+
+// IsHost returns true if the EndpointInfo represents a host IP
+func (v *EndpointInfo) IsHost() bool {
+	return v.Flags&EndpointFlagHost != 0
+}
+
+// String returns the human readable representation of an EndpointInfo
+func (v *EndpointInfo) String() string {
+	if v.Flags&EndpointFlagHost != 0 {
+		return "(localhost)"
+	}
+
+	return fmt.Sprintf("id=%-5d sec_id=%-5d flags=0x%04X ifindex=%-3d mac=%s nodemac=%s",
+		v.LxcID,
+		v.SecID,
+		v.Flags,
+		v.IfIndex,
+		v.MAC,
+		v.NodeMAC,
+	)
+}
+
+func (v *EndpointInfo) New() bpf.MapValue { return &EndpointInfo{} }
+
+// WriteEndpoint updates the BPF map with the endpoint information and links
+// the endpoint information to all keys provided.
+func WriteEndpoint(f EndpointFrontend) error {
+	info, err := GetBPFValue(f)
+	if err != nil {
+		return err
+	}
+
+	// FIXME: Revert on failure
+	nodeIPv4 := node.GetIPv4()
+	// for prevent race conditions between ipcache upsert method used common mutex
+	globalIPCache.Lock()
+	defer globalIPCache.Unlock()
+	for _, v := range GetBPFKeys(f) {
+
+		epAddr := getEndpointAddress(v)
+		if epAddr == "" {
+			continue
+		}
+
+		if globalIPCache.isIPCacheHostLocal(epAddr, nodeIPv4) {
+			if err := LXCMap().Update(v, info); err != nil {
+				return err
+			}
+			globalIPCache.ipToEndpointInfo[epAddr] = &LxcEndpointInfo{
+				key:    v,
+				info:   info,
+				active: true,
+			}
+		} else {
+			LXCMap().Delete(v)
+			globalIPCache.ipToEndpointInfo[epAddr] = &LxcEndpointInfo{
+				key:    v,
+				info:   info,
+				active: false,
+			}
+			log.WithFields(logrus.Fields{
+				logfields.IPAddr: epAddr,
+			}).Debug("hiding pod address in cilium_lxc map")
+		}
+	}
+
+	return nil
+}
+
+// AddHostEntry adds a special endpoint which represents the local host
+func AddHostEntry(ip net.IP) error {
+	key := NewEndpointKey(ip)
+	ep := &EndpointInfo{Flags: EndpointFlagHost}
+	return LXCMap().Update(key, ep)
+}
+
+// SyncHostEntry checks if a host entry exists in the lxcmap and adds one if needed.
+// Returns boolean indicating if a new entry was added and an error.
+func SyncHostEntry(ip net.IP) (bool, error) {
+	key := NewEndpointKey(ip)
+	value, err := LXCMap().Lookup(key)
+	if err != nil || value.(*EndpointInfo).Flags&EndpointFlagHost == 0 {
+		err = AddHostEntry(ip)
+		if err == nil {
+			return true, nil
+		}
+	}
+	return false, err
+}
+
+// DELETE elements from new map
+
+// DeleteEntry deletes a single map entry
+func DeleteEntry(ip net.IP) error {
+	delete(globalIPCache.ipToEndpointInfo, ip.To4().String())
+	return LXCMap().Delete(NewEndpointKey(ip))
+}
+
+// DeleteElement deletes the endpoint using all keys which represent the
+// endpoint. It returns the number of errors encountered during deletion.
+func DeleteElement(f EndpointFrontend) []error {
+	var errors []error
+	for _, k := range GetBPFKeys(f) {
+		ip := getEndpointAddress(k)
+		delete(globalIPCache.ipToEndpointInfo, ip)
+		if err := LXCMap().Delete(k); err != nil {
+			errors = append(errors, fmt.Errorf("Unable to delete key %v from %s: %w", k, bpf.MapPath(MapName), err))
+		}
+	}
+
+	return errors
+}
+
+// DumpToMap dumps the contents of the lxcmap into a map and returns it
+func DumpToMap() (map[string]EndpointInfo, error) {
+	m := map[string]EndpointInfo{}
+	callback := func(key bpf.MapKey, value bpf.MapValue) {
+		if info, ok := value.(*EndpointInfo); ok {
+			if endpointKey, ok := key.(*EndpointKey); ok {
+				m[endpointKey.ToIP().String()] = *info
+			}
+		}
+	}
+
+	if err := LXCMap().DumpWithCallback(callback); err != nil {
+		return nil, fmt.Errorf("unable to read BPF endpoint list: %w", err)
+	}
+
+	return m, nil
+}
+
+// lxcmap end
+
 // Identity is the identity representation of an IP<->Identity cache.
 type Identity struct {
 	// ID is the numeric identity
@@ -99,6 +431,7 @@ type IPCache struct {
 	identityToIPCache map[identity.NumericIdentity]map[string]struct{}
 	ipToHostIPCache   map[string]IPKeyPair
 	ipToK8sMetadata   map[string]K8sMetadata
+	ipToEndpointInfo  map[string]*LxcEndpointInfo
 
 	listeners []IPIdentityMappingListener
 
@@ -140,6 +473,7 @@ func NewIPCache(c *Configuration) *IPCache {
 		identityToIPCache: map[identity.NumericIdentity]map[string]struct{}{},
 		ipToHostIPCache:   map[string]IPKeyPair{},
 		ipToK8sMetadata:   map[string]K8sMetadata{},
+		ipToEndpointInfo:  map[string]*LxcEndpointInfo{},
 		controllers:       controller.NewManager(),
 		namedPorts:        types.NewNamedPortMultiMap(),
 		metadata:          newMetadata(),
@@ -389,6 +723,8 @@ func (ipc *IPCache) upsertLocked(
 
 	scopedLog.Debug("Upserting IP into ipcache layer")
 
+	ipc.checkLxcMapRelation(ip, hostIP, oldHostIP)
+
 	// Update both maps.
 	ipc.ipToIdentityCache[ip] = newIdentity
 	// Delete the old identity, if any.
@@ -686,6 +1022,13 @@ func (ipc *IPCache) DeleteOnMetadataMatch(IP string, source source.Source, names
 	return false
 }
 
+func (ipc *IPCache) IsIPcacheOwner(IP string, source source.Source, namespace, name string) (isOwner bool) {
+	ipc.mutex.Lock()
+	defer ipc.mutex.Unlock()
+	k8sMeta := ipc.getK8sMetadata(IP)
+	return k8sMeta != nil && k8sMeta.Namespace == namespace && k8sMeta.PodName == name
+}
+
 // Delete removes the provided IP-to-security-identity mapping from the IPCache.
 func (ipc *IPCache) Delete(IP string, source source.Source) (namedPortsChanged bool) {
 	ipc.mutex.Lock()
diff --git a/pkg/k8s/watchers/cilium_endpoint.go b/pkg/k8s/watchers/cilium_endpoint.go
index aad3684254..75ef4c1093 100644
--- a/pkg/k8s/watchers/cilium_endpoint.go
+++ b/pkg/k8s/watchers/cilium_endpoint.go
@@ -254,6 +254,21 @@ func (k *K8sWatcher) endpointDeleted(endpoint *types.CiliumEndpoint) {
 	}
 }
 
+func (k *K8sWatcher) endpointIsIPcacheOwner(c *types.CiliumEndpoint) bool {
+	isOwner := true
+	if c.Networking != nil {
+		for _, pair := range c.Networking.Addressing {
+			if pair.IPV4 != "" {
+				isOwner = k.ipcache.IsIPcacheOwner(pair.IPV4, source.CustomResource, c.Namespace, c.Name)
+				if !isOwner {
+					break
+				}
+			}
+		}
+	}
+	return isOwner
+}
+
 // CreateCiliumEndpointLocalPodIndexFunc returns an IndexFunc that indexes only local
 // CiliumEndpoints, by their local Node IP.
 func CreateCiliumEndpointLocalPodIndexFunc() cache.IndexFunc {
diff --git a/pkg/k8s/watchers/cilium_endpoint_slice_subscriber.go b/pkg/k8s/watchers/cilium_endpoint_slice_subscriber.go
index 418b23cbc2..5fa9753dee 100644
--- a/pkg/k8s/watchers/cilium_endpoint_slice_subscriber.go
+++ b/pkg/k8s/watchers/cilium_endpoint_slice_subscriber.go
@@ -21,6 +21,7 @@ import (
 type endpointWatcher interface {
 	endpointUpdated(oldC, newC *types.CiliumEndpoint)
 	endpointDeleted(c *types.CiliumEndpoint)
+	endpointIsIPcacheOwner(c *types.CiliumEndpoint) bool
 }
 
 type localEndpointCache interface {
@@ -166,12 +167,17 @@ func (cs *cesSubscriber) deleteCEPfromCES(CEPName, CESName string, c *types.Cili
 			"CEPName": CEPName,
 		}).Info("CEP deleted, calling endpointDeleted")
 		cs.epWatcher.endpointDeleted(c)
-	} else {
+	} else if cs.epWatcher.endpointIsIPcacheOwner(c) {
 		log.WithFields(logrus.Fields{
 			"CESName": CESName,
 			"CEPName": CEPName,
 		}).Info("CEP deleted, other CEP exists, calling endpointUpdated")
 		cs.epWatcher.endpointUpdated(c, cep)
+	} else {
+		log.WithFields(logrus.Fields{
+			"CESName": CESName,
+			"CEPName": CEPName,
+		}).Debug("not last CEP deleted and CEP don't own ipcache, skip ipcache changes")
 	}
 }
 
diff --git a/pkg/k8s/watchers/cilium_endpoint_slice_subscriber_test.go b/pkg/k8s/watchers/cilium_endpoint_slice_subscriber_test.go
index 7ef00e36ff..b0fba3c0f8 100644
--- a/pkg/k8s/watchers/cilium_endpoint_slice_subscriber_test.go
+++ b/pkg/k8s/watchers/cilium_endpoint_slice_subscriber_test.go
@@ -48,6 +48,10 @@ func createFakeEPWatcher() *fakeEPWatcher {
 	return &fakeEPWatcher{}
 }
 
+func (fw *fakeEPWatcher) endpointIsIPcacheOwner(c *types.CiliumEndpoint) bool {
+	return true
+}
+
 func (fw *fakeEPWatcher) endpointUpdated(oldC, newC *types.CiliumEndpoint) {
 	fw.lastUpdate = endpointUpdate{oldC, newC}
 }
diff --git a/pkg/k8s/watchers/watcher.go b/pkg/k8s/watchers/watcher.go
index 0a0b3935e8..cd83cbb521 100644
--- a/pkg/k8s/watchers/watcher.go
+++ b/pkg/k8s/watchers/watcher.go
@@ -218,6 +218,7 @@ type ipcacheManager interface {
 	UpsertLabels(prefix netip.Prefix, lbls labels.Labels, src source.Source, resource ipcacheTypes.ResourceID)
 	RemoveLabelsExcluded(lbls labels.Labels, toExclude map[netip.Prefix]struct{}, resource ipcacheTypes.ResourceID)
 	DeleteOnMetadataMatch(IP string, source source.Source, namespace, name string) (namedPortsChanged bool)
+	IsIPcacheOwner(IP string, source source.Source, namespace, name string) (isOwner bool)
 }
 
 type K8sWatcher struct {
diff --git a/pkg/labels/labels.go b/pkg/labels/labels.go
index 1c026356fa..ad0af6e774 100644
--- a/pkg/labels/labels.go
+++ b/pkg/labels/labels.go
@@ -59,6 +59,10 @@ const (
 	// IDNameUnknown is the label used to to identify an endpoint with an
 	// unknown identity.
 	IDNameUnknown = "unknown"
+
+	// IDNamePriority is the label used to set pod priority on shared ip4-address
+	// network access
+	IDNamePriority = "network.deckhouse.io/pod-common-ip-priority"
 )
 
 var (
diff --git a/pkg/maps/bwmap/bwmap.go b/pkg/maps/bwmap/bwmap.go
index 3a392e852c..7217fcd447 100644
--- a/pkg/maps/bwmap/bwmap.go
+++ b/pkg/maps/bwmap/bwmap.go
@@ -10,7 +10,7 @@ import (
 
 	"github.com/cilium/cilium/pkg/bpf"
 	"github.com/cilium/cilium/pkg/ebpf"
-	"github.com/cilium/cilium/pkg/maps/lxcmap"
+	lxcmap "github.com/cilium/cilium/pkg/ipcache"
 	"github.com/cilium/cilium/pkg/option"
 )
 
diff --git a/pkg/maps/lxcmap/doc.go b/pkg/maps/lxcmap/doc.go
deleted file mode 100644
index 01af96c4ad..0000000000
--- a/pkg/maps/lxcmap/doc.go
+++ /dev/null
@@ -1,9 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-// Copyright Authors of Cilium
-
-// Package lxcmap represents the endpoints BPF map in the BPF programs. It is
-// implemented as a hash table containing an entry for all local endpoints.
-// The hashtable can be accessed through the key EndpointKey and points which
-// points to the value EndpointInfo.
-// +groupName=maps
-package lxcmap
diff --git a/pkg/maps/lxcmap/lxcmap.go b/pkg/maps/lxcmap/lxcmap.go
deleted file mode 100644
index 51261df078..0000000000
--- a/pkg/maps/lxcmap/lxcmap.go
+++ /dev/null
@@ -1,239 +0,0 @@
-// SPDX-License-Identifier: Apache-2.0
-// Copyright Authors of Cilium
-
-package lxcmap
-
-import (
-	"fmt"
-	"net"
-	"net/netip"
-	"sync"
-
-	"github.com/cilium/ebpf"
-
-	"github.com/cilium/cilium/pkg/bpf"
-	"github.com/cilium/cilium/pkg/identity"
-	"github.com/cilium/cilium/pkg/mac"
-	"github.com/cilium/cilium/pkg/option"
-)
-
-const (
-	MapName = "cilium_lxc"
-
-	// MaxEntries represents the maximum number of endpoints in the map
-	MaxEntries = 65535
-
-	// PortMapMax represents the maximum number of Ports Mapping per container.
-	PortMapMax = 16
-)
-
-var (
-	// LXCMap represents the BPF map for endpoints
-	lxcMap     *bpf.Map
-	lxcMapOnce sync.Once
-)
-
-func LXCMap() *bpf.Map {
-	lxcMapOnce.Do(func() {
-		lxcMap = bpf.NewMap(MapName,
-			ebpf.Hash,
-			&EndpointKey{},
-			&EndpointInfo{},
-			MaxEntries,
-			0,
-		).WithCache().WithPressureMetric().
-			WithEvents(option.Config.GetEventBufferConfig(MapName))
-	})
-	return lxcMap
-}
-
-const (
-	// EndpointFlagHost indicates that this endpoint represents the host
-	EndpointFlagHost = 1
-)
-
-// EndpointFrontend is the interface to implement for an object to synchronize
-// with the endpoint BPF map.
-type EndpointFrontend interface {
-	LXCMac() mac.MAC
-	GetNodeMAC() mac.MAC
-	GetIfIndex() int
-	GetID() uint64
-	IPv4Address() netip.Addr
-	IPv6Address() netip.Addr
-	GetIdentity() identity.NumericIdentity
-}
-
-// GetBPFKeys returns all keys which should represent this endpoint in the BPF
-// endpoints map
-func GetBPFKeys(e EndpointFrontend) []*EndpointKey {
-	keys := []*EndpointKey{}
-	if e.IPv6Address().IsValid() {
-		keys = append(keys, NewEndpointKey(e.IPv6Address().AsSlice()))
-	}
-
-	if e.IPv4Address().IsValid() {
-		keys = append(keys, NewEndpointKey(e.IPv4Address().AsSlice()))
-	}
-
-	return keys
-}
-
-// GetBPFValue returns the value which should represent this endpoint in the
-// BPF endpoints map
-// Must only be called if init() succeeded.
-func GetBPFValue(e EndpointFrontend) (*EndpointInfo, error) {
-	mac, err := e.LXCMac().Uint64()
-	if err != nil {
-		return nil, fmt.Errorf("invalid LXC MAC: %w", err)
-	}
-
-	nodeMAC, err := e.GetNodeMAC().Uint64()
-	if err != nil {
-		return nil, fmt.Errorf("invalid node MAC: %w", err)
-	}
-
-	info := &EndpointInfo{
-		IfIndex: uint32(e.GetIfIndex()),
-		// Store security identity in network byte order so it can be
-		// written into the packet without an additional byte order
-		// conversion.
-		LxcID:   uint16(e.GetID()),
-		MAC:     mac,
-		NodeMAC: nodeMAC,
-		SecID:   e.GetIdentity().Uint32(),
-	}
-
-	return info, nil
-
-}
-
-type pad3uint32 [3]uint32
-
-// EndpointInfo represents the value of the endpoints BPF map.
-//
-// Must be in sync with struct endpoint_info in <bpf/lib/common.h>
-type EndpointInfo struct {
-	IfIndex uint32 `align:"ifindex"`
-	Unused  uint16 `align:"unused"`
-	LxcID   uint16 `align:"lxc_id"`
-	Flags   uint32 `align:"flags"`
-	// go alignment
-	_       uint32
-	MAC     mac.Uint64MAC `align:"mac"`
-	NodeMAC mac.Uint64MAC `align:"node_mac"`
-	SecID   uint32        `align:"sec_id"`
-	Pad     pad3uint32    `align:"pad"`
-}
-
-type EndpointKey struct {
-	bpf.EndpointKey
-}
-
-// NewEndpointKey returns an EndpointKey based on the provided IP address. The
-// address family is automatically detected
-func NewEndpointKey(ip net.IP) *EndpointKey {
-	return &EndpointKey{
-		EndpointKey: bpf.NewEndpointKey(ip, 0),
-	}
-}
-
-func (k *EndpointKey) New() bpf.MapKey { return &EndpointKey{} }
-
-// IsHost returns true if the EndpointInfo represents a host IP
-func (v *EndpointInfo) IsHost() bool {
-	return v.Flags&EndpointFlagHost != 0
-}
-
-// String returns the human readable representation of an EndpointInfo
-func (v *EndpointInfo) String() string {
-	if v.Flags&EndpointFlagHost != 0 {
-		return "(localhost)"
-	}
-
-	return fmt.Sprintf("id=%-5d sec_id=%-5d flags=0x%04X ifindex=%-3d mac=%s nodemac=%s",
-		v.LxcID,
-		v.SecID,
-		v.Flags,
-		v.IfIndex,
-		v.MAC,
-		v.NodeMAC,
-	)
-}
-
-func (v *EndpointInfo) New() bpf.MapValue { return &EndpointInfo{} }
-
-// WriteEndpoint updates the BPF map with the endpoint information and links
-// the endpoint information to all keys provided.
-func WriteEndpoint(f EndpointFrontend) error {
-	info, err := GetBPFValue(f)
-	if err != nil {
-		return err
-	}
-
-	// FIXME: Revert on failure
-	for _, v := range GetBPFKeys(f) {
-		if err := LXCMap().Update(v, info); err != nil {
-			return err
-		}
-	}
-
-	return nil
-}
-
-// AddHostEntry adds a special endpoint which represents the local host
-func AddHostEntry(ip net.IP) error {
-	key := NewEndpointKey(ip)
-	ep := &EndpointInfo{Flags: EndpointFlagHost}
-	return LXCMap().Update(key, ep)
-}
-
-// SyncHostEntry checks if a host entry exists in the lxcmap and adds one if needed.
-// Returns boolean indicating if a new entry was added and an error.
-func SyncHostEntry(ip net.IP) (bool, error) {
-	key := NewEndpointKey(ip)
-	value, err := LXCMap().Lookup(key)
-	if err != nil || value.(*EndpointInfo).Flags&EndpointFlagHost == 0 {
-		err = AddHostEntry(ip)
-		if err == nil {
-			return true, nil
-		}
-	}
-	return false, err
-}
-
-// DeleteEntry deletes a single map entry
-func DeleteEntry(ip net.IP) error {
-	return LXCMap().Delete(NewEndpointKey(ip))
-}
-
-// DeleteElement deletes the endpoint using all keys which represent the
-// endpoint. It returns the number of errors encountered during deletion.
-func DeleteElement(f EndpointFrontend) []error {
-	var errors []error
-	for _, k := range GetBPFKeys(f) {
-		if err := LXCMap().Delete(k); err != nil {
-			errors = append(errors, fmt.Errorf("Unable to delete key %v from %s: %w", k, bpf.MapPath(MapName), err))
-		}
-	}
-
-	return errors
-}
-
-// DumpToMap dumps the contents of the lxcmap into a map and returns it
-func DumpToMap() (map[string]EndpointInfo, error) {
-	m := map[string]EndpointInfo{}
-	callback := func(key bpf.MapKey, value bpf.MapValue) {
-		if info, ok := value.(*EndpointInfo); ok {
-			if endpointKey, ok := key.(*EndpointKey); ok {
-				m[endpointKey.ToIP().String()] = *info
-			}
-		}
-	}
-
-	if err := LXCMap().DumpWithCallback(callback); err != nil {
-		return nil, fmt.Errorf("unable to read BPF endpoint list: %w", err)
-	}
-
-	return m, nil
-}
diff --git a/pkg/testutils/ipcache/ipcache.go b/pkg/testutils/ipcache/ipcache.go
index 995602f115..1bd3f40a82 100644
--- a/pkg/testutils/ipcache/ipcache.go
+++ b/pkg/testutils/ipcache/ipcache.go
@@ -21,6 +21,10 @@ func (m *MockIPCache) GetNamedPorts() types.NamedPortMultiMap {
 	return nil
 }
 
+func (m *MockIPCache) IsIPcacheOwner(IP string, source source.Source, namespace, name string) (isOwner bool) {
+	return true
+}
+
 func (m *MockIPCache) AddListener(listener ipcache.IPIdentityMappingListener) {}
 
 func (m *MockIPCache) AllocateCIDRs(prefixes []netip.Prefix, oldNIDs []identity.NumericIdentity, newlyAllocatedIdentities map[netip.Prefix]*identity.Identity) ([]*identity.Identity, error) {
-- 
2.34.1

