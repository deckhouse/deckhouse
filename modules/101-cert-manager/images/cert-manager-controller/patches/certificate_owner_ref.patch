diff --git a/deploy/crds/crd-certificates.yaml b/deploy/crds/crd-certificates.yaml
index f0183dcd4..ef5f620a9 100644
--- a/deploy/crds/crd-certificates.yaml
+++ b/deploy/crds/crd-certificates.yaml
@@ -82,6 +82,9 @@ spec:
                         enum:
                           - DER
                           - CombinedPEM
+                certificateOwnerRef:
+                  description: CertificateOwnerRef is whether to set the certificate resource as an owner of secret where the tls certificate is stored. When this flag is enabled, the secret will be automatically removed when the certificate resource is deleted. If unset (`nil`) `--enable-certificate-owner-ref` CLI parameter value is used. Default value is `nil`.
+                  type: boolean
                 commonName:
                   description: 'CommonName is a common name to be used on the Certificate. The CommonName should have a length of 64 characters or fewer to avoid generating invalid CSRs. This value is ignored by TLS clients when any subject alt name is set. This is x509 behaviour: https://tools.ietf.org/html/rfc6125#section-6.4.4'
                   type: string
diff --git a/internal/apis/certmanager/v1/zz_generated.conversion.go b/internal/apis/certmanager/v1/zz_generated.conversion.go
index 0b132fed6..fe25cfaea 100644
--- a/internal/apis/certmanager/v1/zz_generated.conversion.go
+++ b/internal/apis/certmanager/v1/zz_generated.conversion.go
@@ -834,6 +834,7 @@ func autoConvert_v1_CertificateSpec_To_certmanager_CertificateSpec(in *v1.Certif
 	out.EncodeUsagesInRequest = (*bool)(unsafe.Pointer(in.EncodeUsagesInRequest))
 	out.RevisionHistoryLimit = (*int32)(unsafe.Pointer(in.RevisionHistoryLimit))
 	out.AdditionalOutputFormats = *(*[]certmanager.CertificateAdditionalOutputFormat)(unsafe.Pointer(&in.AdditionalOutputFormats))
+	// WARNING: in.CertificateOwnerRef requires manual conversion: does not exist in peer-type
 	return nil
 }

diff --git a/pkg/apis/certmanager/v1/types_certificate.go b/pkg/apis/certmanager/v1/types_certificate.go
index 6f98c2caf..a87be2012 100644
--- a/pkg/apis/certmanager/v1/types_certificate.go
+++ b/pkg/apis/certmanager/v1/types_certificate.go
@@ -196,6 +196,12 @@ type CertificateSpec struct {
 	// the controller and webhook components.
 	// +optional
 	AdditionalOutputFormats []CertificateAdditionalOutputFormat `json:"additionalOutputFormats,omitempty"`
+
+	// CertificateOwnerRef is whether to set the certificate resource as an owner of secret where the tls certificate is stored.
+	// When this flag is enabled, the secret will be automatically removed when the certificate resource is deleted.
+	// If unset (`nil`) `--enable-certificate-owner-ref` CLI parameter value is used. Default value is `nil`.
+	// +optional
+	CertificateOwnerRef *bool `json:"certificateOwnerRef,omitempty"`
 }

 // CertificatePrivateKey contains configuration options for private keys
diff --git a/pkg/apis/certmanager/v1/zz_generated.deepcopy.go b/pkg/apis/certmanager/v1/zz_generated.deepcopy.go
index e7f86c515..11ff045f1 100644
--- a/pkg/apis/certmanager/v1/zz_generated.deepcopy.go
+++ b/pkg/apis/certmanager/v1/zz_generated.deepcopy.go
@@ -467,6 +467,11 @@ func (in *CertificateSpec) DeepCopyInto(out *CertificateSpec) {
 		*out = make([]CertificateAdditionalOutputFormat, len(*in))
 		copy(*out, *in)
 	}
+	if in.CertificateOwnerRef != nil {
+		in, out := &in.CertificateOwnerRef, &out.CertificateOwnerRef
+		*out = new(bool)
+		**out = **in
+	}
 	return
 }

diff --git a/pkg/controller/certificates/internal/secretsmanager/secret.go b/pkg/controller/certificates/internal/secretsmanager/secret.go
index ef631acfa..e2eb8d45c 100644
--- a/pkg/controller/certificates/internal/secretsmanager/secret.go
+++ b/pkg/controller/certificates/internal/secretsmanager/secret.go
@@ -107,6 +107,11 @@ func (s *SecretsManager) UpdateData(ctx context.Context, crt *cmapi.Certificate,
 		WithAnnotations(secret.Annotations).WithLabels(secret.Labels).
 		WithData(secret.Data).WithType(secret.Type)

+	// Check the CertificateOwnerRef field of the certificate, and if it is not nil, override enableSecretOwnerReferences with the CertificateOwnerRef value.
+	if crt.Spec.CertificateOwnerRef != nil {
+		s.enableSecretOwnerReferences = *crt.Spec.CertificateOwnerRef
+	}
+
 	// If Secret owner reference is enabled, set it on the Secret. This results
 	// in a no-op if the Secret already exists and has the owner reference set,
 	// and visa-versa.
diff --git a/pkg/controller/certificates/internal/secretsmanager/secret_test.go b/pkg/controller/certificates/internal/secretsmanager/secret_test.go
index a3cc4c58f..f46a24a0a 100644
--- a/pkg/controller/certificates/internal/secretsmanager/secret_test.go
+++ b/pkg/controller/certificates/internal/secretsmanager/secret_test.go
@@ -24,9 +24,6 @@ import (
 	"testing"
 	"time"

-	"github.com/jetstack/cert-manager/internal/controller/feature"
-	testpkg "github.com/jetstack/cert-manager/pkg/controller/test"
-	utilfeature "github.com/jetstack/cert-manager/pkg/util/feature"
 	"github.com/stretchr/testify/assert"
 	corev1 "k8s.io/api/core/v1"
 	apierrors "k8s.io/apimachinery/pkg/api/errors"
@@ -39,6 +36,10 @@ import (
 	fakeclock "k8s.io/utils/clock/testing"
 	"k8s.io/utils/pointer"

+	"github.com/jetstack/cert-manager/internal/controller/feature"
+	testpkg "github.com/jetstack/cert-manager/pkg/controller/test"
+	utilfeature "github.com/jetstack/cert-manager/pkg/util/feature"
+
 	cmapi "github.com/jetstack/cert-manager/pkg/apis/certmanager/v1"
 	cmmeta "github.com/jetstack/cert-manager/pkg/apis/meta/v1"
 	controllerpkg "github.com/jetstack/cert-manager/pkg/controller"
@@ -73,6 +74,30 @@ func Test_SecretsManager(t *testing.T) {
 		gen.SetCertificateDNSNames("example.com"),
 	), fixedClock)

+	baseCertWithCertificateOwnerRefEnabled := gen.Certificate("test",
+		gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "ca-issuer", Kind: "Issuer", Group: "foo.io"}),
+		gen.SetCertificateSecretName("output"),
+		gen.SetCertificateRenewBefore(time.Hour*36),
+		gen.SetCertificateDNSNames("example.com"),
+		gen.SetCertificateUID(apitypes.UID("test-uid")),
+		gen.SetCertificateOwnerRef(true),
+	)
+	baseCertBundleWithCertificateOwnerRefEnabled := internaltest.MustCreateCryptoBundle(t, gen.CertificateFrom(baseCertWithCertificateOwnerRefEnabled,
+		gen.SetCertificateDNSNames("example.com"),
+	), fixedClock)
+
+	baseCertWithCertificateOwnerRefDisabled := gen.Certificate("test",
+		gen.SetCertificateIssuer(cmmeta.ObjectReference{Name: "ca-issuer", Kind: "Issuer", Group: "foo.io"}),
+		gen.SetCertificateSecretName("output"),
+		gen.SetCertificateRenewBefore(time.Hour*36),
+		gen.SetCertificateDNSNames("example.com"),
+		gen.SetCertificateUID(apitypes.UID("test-uid")),
+		gen.SetCertificateOwnerRef(false),
+	)
+	baseCertBundleWithCertificateOwnerRefDisabled := internaltest.MustCreateCryptoBundle(t, gen.CertificateFrom(baseCertWithCertificateOwnerRefDisabled,
+		gen.SetCertificateDNSNames("example.com"),
+	), fixedClock)
+
 	baseCertWithSecretTemplate := gen.CertificateFrom(baseCertBundle.Certificate,
 		gen.SetCertificateSecretTemplate(map[string]string{
 			"template":  "annotation",
@@ -156,6 +181,48 @@ func Test_SecretsManager(t *testing.T) {
 			expectedErr: false,
 		},

+		"if secret does not exist, but certificateOwnerRef is set to true, create new Secret, with owner disabled": {
+			certificateOptions: controllerpkg.CertificateOptions{EnableOwnerRef: false},
+			certificate:        baseCertBundleWithCertificateOwnerRefEnabled.Certificate,
+			existingSecret:     nil,
+			secretData:         SecretData{Certificate: baseCertBundle.CertBytes, CA: []byte("test-ca"), PrivateKey: []byte("test-key")},
+			applyFn: func(t *testing.T) testcoreclients.ApplyFn {
+				return func(_ context.Context, gotCnf *applycorev1.SecretApplyConfiguration, gotOpts metav1.ApplyOptions) (*corev1.Secret, error) {
+					expUID := apitypes.UID("test-uid")
+					expCnf := applycorev1.Secret("output", gen.DefaultTestNamespace).
+						WithAnnotations(
+							map[string]string{
+								cmapi.CertificateNameKey: "test", cmapi.IssuerGroupAnnotationKey: "foo.io",
+								cmapi.IssuerKindAnnotationKey: "Issuer", cmapi.IssuerNameAnnotationKey: "ca-issuer",
+
+								cmapi.CommonNameAnnotationKey: baseCertBundle.Cert.Subject.CommonName, cmapi.AltNamesAnnotationKey: strings.Join(baseCertBundle.Cert.DNSNames, ","),
+								cmapi.IPSANAnnotationKey:  strings.Join(utilpki.IPAddressesToString(baseCertBundle.Cert.IPAddresses), ","),
+								cmapi.URISANAnnotationKey: strings.Join(utilpki.URLsToString(baseCertBundle.Cert.URIs), ","),
+							}).
+						WithLabels(make(map[string]string)).
+						WithData(map[string][]byte{
+							corev1.TLSCertKey:       baseCertBundle.CertBytes,
+							corev1.TLSPrivateKeyKey: []byte("test-key"),
+							cmmeta.TLSCAKey:         []byte("test-ca"),
+						}).
+						WithType(corev1.SecretTypeTLS).
+						WithOwnerReferences(&applymetav1.OwnerReferenceApplyConfiguration{
+							APIVersion: pointer.String("cert-manager.io/v1"), Kind: pointer.String("Certificate"),
+							Name: pointer.String("test"), UID: &expUID,
+							Controller: pointer.Bool(true), BlockOwnerDeletion: pointer.Bool(true),
+						})
+
+					assert.Equal(t, expCnf, gotCnf)
+
+					expOpts := metav1.ApplyOptions{FieldManager: "cert-manager-test"}
+					assert.Equal(t, expOpts, gotOpts)
+
+					return nil, nil
+				}
+			},
+			expectedErr: false,
+		},
+
 		"if secret does not exist, create new Secret, with owner enabled": {
 			certificateOptions: controllerpkg.CertificateOptions{EnableOwnerRef: true},
 			certificate:        baseCertBundle.Certificate,
@@ -164,7 +231,6 @@ func Test_SecretsManager(t *testing.T) {
 			applyFn: func(t *testing.T) testcoreclients.ApplyFn {
 				return func(_ context.Context, gotCnf *applycorev1.SecretApplyConfiguration, gotOpts metav1.ApplyOptions) (*corev1.Secret, error) {
 					expUID := apitypes.UID("test-uid")
-
 					expCnf := applycorev1.Secret("output", gen.DefaultTestNamespace).
 						WithAnnotations(
 							map[string]string{
@@ -192,6 +258,35 @@ func Test_SecretsManager(t *testing.T) {
 			expectedErr: false,
 		},

+		"if secret does not exist, but certificateOwnerRef is set to false, create new Secret, with owner enabled": {
+			certificateOptions: controllerpkg.CertificateOptions{EnableOwnerRef: true},
+			certificate:        baseCertBundleWithCertificateOwnerRefDisabled.Certificate,
+			existingSecret:     nil,
+			secretData:         SecretData{Certificate: baseCertBundle.CertBytes, CA: []byte("test-ca"), PrivateKey: []byte("test-key")},
+			applyFn: func(t *testing.T) testcoreclients.ApplyFn {
+				return func(_ context.Context, gotCnf *applycorev1.SecretApplyConfiguration, gotOpts metav1.ApplyOptions) (*corev1.Secret, error) {
+					expCnf := applycorev1.Secret("output", gen.DefaultTestNamespace).
+						WithAnnotations(
+							map[string]string{
+								cmapi.CertificateNameKey: "test", cmapi.IssuerGroupAnnotationKey: "foo.io", cmapi.IssuerKindAnnotationKey: "Issuer",
+								cmapi.IssuerNameAnnotationKey: "ca-issuer", cmapi.CommonNameAnnotationKey: baseCertBundle.Cert.Subject.CommonName,
+								cmapi.AltNamesAnnotationKey: strings.Join(baseCertBundle.Cert.DNSNames, ","), cmapi.IPSANAnnotationKey: strings.Join(utilpki.IPAddressesToString(baseCertBundle.Cert.IPAddresses), ","),
+								cmapi.URISANAnnotationKey: strings.Join(utilpki.URLsToString(baseCertBundle.Cert.URIs), ","),
+							}).
+						WithLabels(make(map[string]string)).
+						WithData(map[string][]byte{corev1.TLSCertKey: baseCertBundle.CertBytes, corev1.TLSPrivateKeyKey: []byte("test-key"), cmmeta.TLSCAKey: []byte("test-ca")}).
+						WithType(corev1.SecretTypeTLS)
+					assert.Equal(t, expCnf, gotCnf)
+
+					expOpts := metav1.ApplyOptions{FieldManager: "cert-manager-test"}
+					assert.Equal(t, expOpts, gotOpts)
+
+					return nil, nil
+				}
+			},
+			expectedErr: false,
+		},
+
 		"if secret does exist, update existing Secret and leave custom annotations, with owner disabled": {
 			certificateOptions: controllerpkg.CertificateOptions{EnableOwnerRef: false},
 			certificate:        baseCertBundle.Certificate,
@@ -236,6 +331,59 @@ func Test_SecretsManager(t *testing.T) {
 			},
 			expectedErr: false,
 		},
+
+		"if secret does exist, but certificateOwnerRef is set to true, update existing Secret and leave custom annotations, with owner disabled": {
+			certificateOptions: controllerpkg.CertificateOptions{EnableOwnerRef: false},
+			certificate:        baseCertBundleWithCertificateOwnerRefEnabled.Certificate,
+			existingSecret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{
+					Namespace:   gen.DefaultTestNamespace,
+					Name:        "output",
+					Annotations: map[string]string{"my-custom": "annotation"},
+					Labels:      map[string]string{},
+				},
+				Data: map[string][]byte{corev1.TLSCertKey: []byte("foo"), corev1.TLSPrivateKeyKey: []byte("foo"), cmmeta.TLSCAKey: []byte("foo")},
+				Type: corev1.SecretTypeTLS,
+			},
+			secretData: SecretData{Certificate: baseCertBundle.CertBytes, CA: []byte("test-ca"), PrivateKey: []byte("test-key")},
+			applyFn: func(t *testing.T) testcoreclients.ApplyFn {
+				return func(_ context.Context, gotCnf *applycorev1.SecretApplyConfiguration, gotOpts metav1.ApplyOptions) (*corev1.Secret, error) {
+					expUID := apitypes.UID("test-uid")
+					expCnf := applycorev1.Secret("output", gen.DefaultTestNamespace).
+						WithAnnotations(
+							map[string]string{
+								cmapi.CertificateNameKey: "test", cmapi.IssuerGroupAnnotationKey: "foo.io",
+								cmapi.IssuerKindAnnotationKey: "Issuer", cmapi.IssuerNameAnnotationKey: "ca-issuer",
+
+								cmapi.CommonNameAnnotationKey: baseCertBundle.Cert.Subject.CommonName,
+								cmapi.AltNamesAnnotationKey:   strings.Join(baseCertBundle.Cert.DNSNames, ","),
+								cmapi.IPSANAnnotationKey:      strings.Join(utilpki.IPAddressesToString(baseCertBundle.Cert.IPAddresses), ","),
+								cmapi.URISANAnnotationKey:     strings.Join(utilpki.URLsToString(baseCertBundle.Cert.URIs), ","),
+							}).
+						WithLabels(make(map[string]string)).
+						WithData(map[string][]byte{
+							corev1.TLSCertKey:       baseCertBundle.CertBytes,
+							corev1.TLSPrivateKeyKey: []byte("test-key"),
+							cmmeta.TLSCAKey:         []byte("test-ca"),
+						}).
+						WithType(corev1.SecretTypeTLS).
+						WithOwnerReferences(&applymetav1.OwnerReferenceApplyConfiguration{
+							APIVersion: pointer.String("cert-manager.io/v1"), Kind: pointer.String("Certificate"),
+							Name: pointer.String("test"), UID: &expUID,
+							Controller: pointer.Bool(true), BlockOwnerDeletion: pointer.Bool(true),
+						})
+
+					assert.Equal(t, expCnf, gotCnf)
+
+					expOpts := metav1.ApplyOptions{FieldManager: "cert-manager-test"}
+					assert.Equal(t, expOpts, gotOpts)
+
+					return nil, nil
+				}
+			},
+			expectedErr: false,
+		},
+
 		"if secret does exist, update existing Secret and leave custom annotations, with owner enabled": {
 			certificateOptions: controllerpkg.CertificateOptions{EnableOwnerRef: true},
 			certificate:        baseCertBundle.Certificate,
@@ -287,6 +435,51 @@ func Test_SecretsManager(t *testing.T) {
 			expectedErr: false,
 		},

+		"if secret does exist, but certificateOwnerRef is set to false ,update existing Secret and leave custom annotations, with owner enabled": {
+			certificateOptions: controllerpkg.CertificateOptions{EnableOwnerRef: true},
+			certificate:        baseCertBundleWithCertificateOwnerRefDisabled.Certificate,
+			existingSecret: &corev1.Secret{
+				ObjectMeta: metav1.ObjectMeta{
+					Namespace:   gen.DefaultTestNamespace,
+					Name:        "output",
+					Annotations: map[string]string{"my-custom": "annotation"},
+					Labels:      map[string]string{},
+				},
+				Data: map[string][]byte{corev1.TLSCertKey: []byte("foo"), corev1.TLSPrivateKeyKey: []byte("foo"), cmmeta.TLSCAKey: []byte("foo")},
+				Type: corev1.SecretTypeTLS,
+			},
+			secretData: SecretData{Certificate: baseCertBundle.CertBytes, CA: []byte("test-ca"), PrivateKey: []byte("test-key")},
+			applyFn: func(t *testing.T) testcoreclients.ApplyFn {
+				return func(_ context.Context, gotCnf *applycorev1.SecretApplyConfiguration, gotOpts metav1.ApplyOptions) (*corev1.Secret, error) {
+					expCnf := applycorev1.Secret("output", gen.DefaultTestNamespace).
+						WithAnnotations(
+							map[string]string{
+								cmapi.CertificateNameKey: "test", cmapi.IssuerGroupAnnotationKey: "foo.io",
+								cmapi.IssuerKindAnnotationKey: "Issuer", cmapi.IssuerNameAnnotationKey: "ca-issuer",
+
+								cmapi.CommonNameAnnotationKey: baseCertBundle.Cert.Subject.CommonName,
+								cmapi.AltNamesAnnotationKey:   strings.Join(baseCertBundle.Cert.DNSNames, ","),
+								cmapi.IPSANAnnotationKey:      strings.Join(utilpki.IPAddressesToString(baseCertBundle.Cert.IPAddresses), ","),
+								cmapi.URISANAnnotationKey:     strings.Join(utilpki.URLsToString(baseCertBundle.Cert.URIs), ","),
+							}).
+						WithLabels(make(map[string]string)).
+						WithData(map[string][]byte{
+							corev1.TLSCertKey:       baseCertBundle.CertBytes,
+							corev1.TLSPrivateKeyKey: []byte("test-key"),
+							cmmeta.TLSCAKey:         []byte("test-ca"),
+						}).
+						WithType(corev1.SecretTypeTLS)
+					assert.Equal(t, expCnf, gotCnf)
+
+					expOpts := metav1.ApplyOptions{FieldManager: "cert-manager-test"}
+					assert.Equal(t, expOpts, gotOpts)
+
+					return nil, nil
+				}
+			},
+			expectedErr: false,
+		},
+
 		"if secret does not exist, create new Secret using the secret template": {
 			certificateOptions: controllerpkg.CertificateOptions{EnableOwnerRef: false},
 			certificate:        baseCertWithSecretTemplate,
diff --git a/test/unit/gen/certificate.go b/test/unit/gen/certificate.go
index 8b997daf8..f045f94b7 100644
--- a/test/unit/gen/certificate.go
+++ b/test/unit/gen/certificate.go
@@ -267,3 +267,9 @@ func SetCertificateAdditionalOutputFormats(additionalOutputFormats ...v1.Certifi
 		crt.Spec.AdditionalOutputFormats = additionalOutputFormats
 	}
 }
+
+func SetCertificateOwnerRef(ownerRef bool) CertificateModifier {
+	return func(crt *v1.Certificate) {
+		crt.Spec.CertificateOwnerRef = &ownerRef
+	}
+}
