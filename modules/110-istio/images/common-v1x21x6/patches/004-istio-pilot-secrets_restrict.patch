diff --git a/pilot/pkg/credentials/kube/secrets.go b/pilot/pkg/credentials/kube/secrets.go
index fbde05a819..847953d7b8 100644
--- a/pilot/pkg/credentials/kube/secrets.go
+++ b/pilot/pkg/credentials/kube/secrets.go
@@ -30,6 +30,7 @@ import (
 	authorizationv1client "k8s.io/client-go/kubernetes/typed/authorization/v1"
 
 	"istio.io/istio/pilot/pkg/credentials"
+	"istio.io/istio/pilot/pkg/features"
 	securitymodel "istio.io/istio/pilot/pkg/security/model"
 	"istio.io/istio/pkg/kube"
 	"istio.io/istio/pkg/kube/controllers"
@@ -76,6 +77,19 @@ type authorizationResponse struct {
 
 var _ credentials.Controller = &CredentialsController{}
 
+const (
+	allowedSecretInAllNamespaces = "d8-istio-sidecar-registry"
+)
+
+var (
+	allowedSecretsInWatchNamespace = map[string]bool{
+		"cacerts":                            true,
+		"d8-remote-clusters-public-metadata": true,
+		"d8-remote-authn-keypair":            true,
+		"d8-istio-sidecar-registry":          true,
+	}
+)
+
 func NewCredentialsController(kc kube.Client) *CredentialsController {
 	// We only care about TLS certificates and docker config for Wasm image pulling.
 	// Unfortunately, it is not as simple as selecting type=kubernetes.io/tls and type=kubernetes.io/dockerconfigjson.
@@ -87,8 +101,33 @@ func NewCredentialsController(kc kube.Client) *CredentialsController {
 	fieldSelector := fields.AndSelectors(
 		fields.OneTermNotEqualSelector("type", "helm.sh/release.v1"),
 		fields.OneTermNotEqualSelector("type", string(v1.SecretTypeServiceAccountToken))).String()
+
+	watchNamespace := features.InformerWatchNamespace
+
+	objectFilter := func(obj any) bool {
+		secret, ok := obj.(*v1.Secret)
+		if !ok {
+			return false
+		}
+
+		secretName := secret.GetName()
+		secretNamespace := secret.GetNamespace()
+
+		if secretName == allowedSecretInAllNamespaces {
+			return true
+		}
+
+		if watchNamespace != "" && secretNamespace == watchNamespace {
+			return allowedSecretsInWatchNamespace[secretName]
+		}
+
+		return false
+	}
+
 	secrets := kclient.NewFiltered[*v1.Secret](kc, kclient.Filter{
+		Namespace:     "",
 		FieldSelector: fieldSelector,
+		ObjectFilter:  objectFilter,
 	})
 
 	return &CredentialsController{
