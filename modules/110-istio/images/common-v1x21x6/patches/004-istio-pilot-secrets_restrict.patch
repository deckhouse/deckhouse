diff --git a/pilot/pkg/credentials/kube/secrets.go b/pilot/pkg/credentials/kube/secrets.go
index fbde05a819..937959a6f9 100644
--- a/pilot/pkg/credentials/kube/secrets.go
+++ b/pilot/pkg/credentials/kube/secrets.go
@@ -17,6 +17,7 @@ package kube
 import (
 	"context"
 	"fmt"
+	"os"
 	"sort"
 	"strings"
 	"sync"
@@ -26,8 +27,10 @@ import (
 	v1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/fields"
+	klabels "k8s.io/apimachinery/pkg/labels"
 	sa "k8s.io/apiserver/pkg/authentication/serviceaccount"
 	authorizationv1client "k8s.io/client-go/kubernetes/typed/authorization/v1"
+	"k8s.io/client-go/tools/cache"
 
 	"istio.io/istio/pilot/pkg/credentials"
 	securitymodel "istio.io/istio/pilot/pkg/security/model"
@@ -60,11 +63,12 @@ const (
 )
 
 type CredentialsController struct {
-	secrets kclient.Client[*v1.Secret]
+	secrets kclient.Informer[*v1.Secret]
 	sar     authorizationv1client.SubjectAccessReviewInterface
 
 	mu                 sync.RWMutex
 	authorizationCache map[authorizationKey]authorizationResponse
+	allowedSecretNames []string // List of secret names that are allowed to be accessed
 }
 
 type authorizationKey string
@@ -74,8 +78,69 @@ type authorizationResponse struct {
 	authorized error
 }
 
+type secretInformerGroup struct {
+	informers []kclient.Informer[*v1.Secret]
+}
+
+var _ kclient.Informer[*v1.Secret] = &secretInformerGroup{}
 var _ credentials.Controller = &CredentialsController{}
 
+func newSecretInformerGroup(informers []kclient.Informer[*v1.Secret]) kclient.Informer[*v1.Secret] {
+	return &secretInformerGroup{informers: informers}
+}
+
+func (s *secretInformerGroup) Get(name, namespace string) *v1.Secret {
+	for _, inf := range s.informers {
+		if secret := inf.Get(name, namespace); secret != nil {
+			return secret
+		}
+	}
+	return nil
+}
+
+func (s *secretInformerGroup) List(namespace string, selector klabels.Selector) []*v1.Secret {
+	var res []*v1.Secret
+	for _, inf := range s.informers {
+		res = append(res, inf.List(namespace, selector)...)
+	}
+	return res
+}
+
+func (s *secretInformerGroup) ListUnfiltered(namespace string, selector klabels.Selector) []*v1.Secret {
+	var res []*v1.Secret
+	for _, inf := range s.informers {
+		res = append(res, inf.ListUnfiltered(namespace, selector)...)
+	}
+	return res
+}
+
+func (s *secretInformerGroup) AddEventHandler(h cache.ResourceEventHandler) {
+	for _, inf := range s.informers {
+		inf.AddEventHandler(h)
+	}
+}
+
+func (s *secretInformerGroup) HasSynced() bool {
+	for _, inf := range s.informers {
+		if !inf.HasSynced() {
+			return false
+		}
+	}
+	return true
+}
+
+func (s *secretInformerGroup) ShutdownHandlers() {
+	for _, inf := range s.informers {
+		inf.ShutdownHandlers()
+	}
+}
+
+func (s *secretInformerGroup) Start(stop <-chan struct{}) {
+	for _, inf := range s.informers {
+		inf.Start(stop)
+	}
+}
+
 func NewCredentialsController(kc kube.Client) *CredentialsController {
 	// We only care about TLS certificates and docker config for Wasm image pulling.
 	// Unfortunately, it is not as simple as selecting type=kubernetes.io/tls and type=kubernetes.io/dockerconfigjson.
@@ -84,17 +149,35 @@ func NewCredentialsController(kc kube.Client) *CredentialsController {
 	// This makes the assumption we will never care about Helm secrets or SA token secrets - two common
 	// large secrets in clusters.
 	// This is a best effort optimization only; the code would behave correctly if we watched all secrets.
-	fieldSelector := fields.AndSelectors(
-		fields.OneTermNotEqualSelector("type", "helm.sh/release.v1"),
-		fields.OneTermNotEqualSelector("type", string(v1.SecretTypeServiceAccountToken))).String()
-	secrets := kclient.NewFiltered[*v1.Secret](kc, kclient.Filter{
-		FieldSelector: fieldSelector,
-	})
+	rawNames := os.Getenv("ISTIO_CREDENTIALS_SECRET_NAMES")
+	var names []string
+	if rawNames != "" {
+		for _, n := range strings.Split(rawNames, ",") {
+			n = strings.TrimSpace(n)
+			if n == "" {
+				continue
+			}
+			names = append(names, n)
+		}
+	}
+
+	var secrets kclient.Informer[*v1.Secret]
+	var informers []kclient.Informer[*v1.Secret]
+	for _, n := range names {
+		fs := fields.OneTermEqualSelector("metadata.name", n).String()
+
+		informers = append(informers, kclient.NewFiltered[*v1.Secret](kc, kclient.Filter{
+			FieldSelector: fs,
+			Namespace:     "d8-istio",
+		}))
+	}
+	secrets = newSecretInformerGroup(informers)
 
 	return &CredentialsController{
 		secrets:            secrets,
 		sar:                kc.Kube().AuthorizationV1().SubjectAccessReviews(),
 		authorizationCache: make(map[authorizationKey]authorizationResponse),
+		allowedSecretNames: names,
 	}
 }
 
@@ -147,6 +230,32 @@ func (s *CredentialsController) Authorize(serviceAccount, namespace string) erro
 		return cached
 	}
 	err := func() error {
+		// If we have a list of allowed secret names, check 'get' permission for each specific secret
+		// instead of 'list' permission for all secrets. This allows more granular RBAC.
+		if len(s.allowedSecretNames) > 0 {
+			for _, secretName := range s.allowedSecretNames {
+				resp, err := s.sar.Create(context.Background(), &authorizationv1.SubjectAccessReview{
+					ObjectMeta: metav1.ObjectMeta{},
+					Spec: authorizationv1.SubjectAccessReviewSpec{
+						ResourceAttributes: &authorizationv1.ResourceAttributes{
+							Namespace: namespace,
+							Verb:      "get",
+							Resource:  "secrets",
+							Name:      secretName,
+						},
+						User: user,
+					},
+				}, metav1.CreateOptions{})
+				if err != nil {
+					return err
+				}
+				if !resp.Status.Allowed {
+					return fmt.Errorf("%s/%s is not authorized to read secret %s/%s: %v", serviceAccount, namespace, namespace, secretName, resp.Status.Reason)
+				}
+			}
+			return nil
+		}
+		// Fallback to 'list' check if no specific secrets are configured
 		resp, err := s.sar.Create(context.Background(), &authorizationv1.SubjectAccessReview{
 			ObjectMeta: metav1.ObjectMeta{},
 			Spec: authorizationv1.SubjectAccessReviewSpec{
diff --git a/pilot/pkg/util/informermetric/informerutil.go b/pilot/pkg/util/informermetric/informerutil.go
index 72cc6405c2..14ee9aafb6 100644
--- a/pilot/pkg/util/informermetric/informerutil.go
+++ b/pilot/pkg/util/informermetric/informerutil.go
@@ -15,6 +15,7 @@
 package informermetric
 
 import (
+	"strings"
 	"sync"
 
 	"k8s.io/client-go/tools/cache"
@@ -50,6 +51,16 @@ func ErrorHandlerForCluster(clusterID cluster.ID) cache.WatchErrorHandler {
 	defer mu.Unlock()
 	clusterMetric := errorMetric.With(clusterLabel.Value(clusterID.String()))
 	h := func(_ *cache.Reflector, err error) {
+		if err == nil {
+			return
+		}
+		// Skip errors related to "get secrets" as these are expected when using
+		// restricted RBAC with resourceNames (only get/watch permissions, no list)
+		errStr := err.Error()
+		if strings.Contains(errStr, "unknown (get secrets)") || strings.Contains(errStr, "get secrets") {
+			log.Debugf("Skipping expected watch error in cluster %s: %v", clusterID, err)
+			return
+		}
 		clusterMetric.Increment()
 		log.Errorf("watch error in cluster %s: %v", clusterID, err)
 	}
