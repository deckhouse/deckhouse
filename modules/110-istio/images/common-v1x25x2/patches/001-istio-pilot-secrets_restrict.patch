diff --git a/pilot/pkg/credentials/kube/secrets.go b/pilot/pkg/credentials/kube/secrets.go
index 70bd09c858..fe61bce6b1 100644
--- a/pilot/pkg/credentials/kube/secrets.go
+++ b/pilot/pkg/credentials/kube/secrets.go
@@ -17,6 +17,7 @@ package kube
 import (
 	"context"
 	"fmt"
+	"os"
 	"sort"
 	"strings"
 	"sync"
@@ -26,8 +27,10 @@ import (
 	v1 "k8s.io/api/core/v1"
 	metav1 "k8s.io/apimachinery/pkg/apis/meta/v1"
 	"k8s.io/apimachinery/pkg/fields"
+	klabels "k8s.io/apimachinery/pkg/labels"
 	sa "k8s.io/apiserver/pkg/authentication/serviceaccount"
 	authorizationv1client "k8s.io/client-go/kubernetes/typed/authorization/v1"
+	"k8s.io/client-go/tools/cache"
 
 	"istio.io/istio/pilot/pkg/credentials"
 	securitymodel "istio.io/istio/pilot/pkg/security/model"
@@ -60,7 +63,7 @@ const (
 )
 
 type CredentialsController struct {
-	secrets kclient.Client[*v1.Secret]
+	secrets kclient.Informer[*v1.Secret]
 	sar     authorizationv1client.SubjectAccessReviewInterface
 
 	mu                 sync.RWMutex
@@ -74,8 +77,94 @@ type authorizationResponse struct {
 	authorized error
 }
 
+type secretInformerGroup struct {
+	informers []kclient.Informer[*v1.Secret]
+}
+
+var _ kclient.Informer[*v1.Secret] = &secretInformerGroup{}
 var _ credentials.Controller = &CredentialsController{}
 
+func newSecretInformerGroup(informers []kclient.Informer[*v1.Secret]) kclient.Informer[*v1.Secret] {
+	return &secretInformerGroup{informers: informers}
+}
+
+func (s *secretInformerGroup) Get(name, namespace string) *v1.Secret {
+	for _, inf := range s.informers {
+		if secret := inf.Get(name, namespace); secret != nil {
+			return secret
+		}
+	}
+	return nil
+}
+
+func (s *secretInformerGroup) List(namespace string, selector klabels.Selector) []*v1.Secret {
+	var res []*v1.Secret
+	for _, inf := range s.informers {
+		res = append(res, inf.List(namespace, selector)...)
+	}
+	return res
+}
+
+func (s *secretInformerGroup) ListUnfiltered(namespace string, selector klabels.Selector) []*v1.Secret {
+	var res []*v1.Secret
+	for _, inf := range s.informers {
+		res = append(res, inf.ListUnfiltered(namespace, selector)...)
+	}
+	return res
+}
+
+func (s *secretInformerGroup) AddEventHandler(h cache.ResourceEventHandler) cache.ResourceEventHandlerRegistration {
+	// We need to add the handler to all informers, but we can only return one registration.
+	// We'll add to all and return the first one's registration.
+	var reg cache.ResourceEventHandlerRegistration
+	for i, inf := range s.informers {
+		r := inf.AddEventHandler(h)
+		if i == 0 {
+			reg = r
+		}
+	}
+	return reg
+}
+
+func (s *secretInformerGroup) HasSynced() bool {
+	for _, inf := range s.informers {
+		if !inf.HasSynced() {
+			return false
+		}
+	}
+	return true
+}
+
+func (s *secretInformerGroup) HasSyncedIgnoringHandlers() bool {
+	for _, inf := range s.informers {
+		if !inf.HasSyncedIgnoringHandlers() {
+			return false
+		}
+	}
+	return true
+}
+
+func (s *secretInformerGroup) ShutdownHandlers() {
+	for _, inf := range s.informers {
+		inf.ShutdownHandlers()
+	}
+}
+
+func (s *secretInformerGroup) Start(stop <-chan struct{}) {
+	for _, inf := range s.informers {
+		inf.Start(stop)
+	}
+}
+
+func (s *secretInformerGroup) Index(extract func(*v1.Secret) []string) kclient.RawIndexer {
+	// For simplicity, we'll use the first informer's index.
+	// In practice, this might need more sophisticated handling.
+	if len(s.informers) > 0 {
+		return s.informers[0].Index(extract)
+	}
+	return nil
+}
+
 func NewCredentialsController(kc kube.Client, handlers []func(name string, namespace string)) *CredentialsController {
 	// We only care about TLS certificates and docker config for Wasm image pulling.
 	// Unfortunately, it is not as simple as selecting type=kubernetes.io/tls and type=kubernetes.io/dockerconfigjson.
@@ -84,13 +173,44 @@ func NewCredentialsController(kc kube.Client, handlers []func(name string, names
 	// This makes the assumption we will never care about Helm secrets or SA token secrets - two common
 	// large secrets in clusters.
 	// This is a best effort optimization only; the code would behave correctly if we watched all secrets.
-	fieldSelector := fields.AndSelectors(
-		fields.OneTermNotEqualSelector("type", "helm.sh/release.v1"),
-		fields.OneTermNotEqualSelector("type", string(v1.SecretTypeServiceAccountToken))).String()
-	secrets := kclient.NewFiltered[*v1.Secret](kc, kclient.Filter{
-		FieldSelector: fieldSelector,
-		ObjectFilter:  kc.ObjectFilter(),
-	})
+	rawNames := os.Getenv("ISTIO_CREDENTIALS_SECRET_NAMES")
+	var names []string
+	if rawNames != "" {
+		for _, n := range strings.Split(rawNames, ",") {
+			n = strings.TrimSpace(n)
+			if n == "" {
+				continue
+			}
+			names = append(names, n)
+		}
+	}
+
+	var secrets kclient.Informer[*v1.Secret]
+	var informers []kclient.Informer[*v1.Secret]
+	if len(names) > 0 {
+		// Create separate informers for each specified secret in d8-istio namespace
+		for _, n := range names {
+			fs := fields.OneTermEqualSelector("metadata.name", n).String()
+			client := kclient.NewFiltered[*v1.Secret](kc, kclient.Filter{
+				FieldSelector: fs,
+				Namespace:     "d8-istio",
+				ObjectFilter:  kc.ObjectFilter(),
+			})
+			// Client[T] includes Informer[T], so we can use it as Informer[T]
+			informers = append(informers, client)
+		}
+		secrets = newSecretInformerGroup(informers)
+	} else {
+		// Fallback to original behavior if ISTIO_CREDENTIALS_SECRET_NAMES is not set
+		fieldSelector := fields.AndSelectors(
+			fields.OneTermNotEqualSelector("type", "helm.sh/release.v1"),
+			fields.OneTermNotEqualSelector("type", string(v1.SecretTypeServiceAccountToken))).String()
+		client := kclient.NewFiltered[*v1.Secret](kc, kclient.Filter{
+			FieldSelector: fieldSelector,
+			ObjectFilter:  kc.ObjectFilter(),
+		})
+		secrets = client
+	}
 
 	for _, h := range handlers {
 		// register handler before informer starts
