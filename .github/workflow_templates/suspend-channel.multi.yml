{!{/*
  Multifile generator of suspend workflows.

  One workflow file for each channel: suspend-alpha.yml, suspend-beta.yml, etc.

  The only reason to use separate files for each channel
  is a filtering on 'Actions' page.

*/}!}

{!{- range $channel := slice "alpha" "beta" "early-access" "stable" "rock-solid" -}!}
{!{- $ctx := dict "channel" $channel }!}
{!{- $outFile := printf "suspend-%s.yml" $channel }!}
{!{- $outPath := filepath.Join (getenv "OUTDIR") (toLower $outFile) }!}
{!{- tmpl.Exec "suspend_channel_workflow_template" $ctx | file.Write $outPath }!}
{!{- end -}!}

{!{- define "suspend_channel_workflow_template" -}!}
{!{- $channel := .channel -}!}
{!{- $workflowName := printf "Suspend the %s" $channel -}!}
name: '{!{ $workflowName }!}'

on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: 'Id of issue where label was set'
        required: true
      issue_number:
        description: 'Number of issue where label was set'
        required: true
      comment_id:
        description: 'Id of comment in issue where to put workflow run status'
        required: true

env:
{!{ tmpl.Exec "werf_envs" | strings.Indent 2 }!}
  DEPLOY_CHANNEL: {!{ .channel }!}

# Note: no concurrency section for suspend workflows.

jobs:
{!{ tmpl.Exec "git_info_job" . | strings.Indent 2 }!}

  run_suspend:
    name: Suspend deckhouse release on {!{ .channel }!} channel
    environment:
      name: {!{ .channel }!}
    needs:
      - git_info
    runs-on: self-hosted
    steps:
{!{ tmpl.Exec "started_at_output" . | strings.Indent 6 }!}
{!{ tmpl.Exec "checkout_from_event_ref_step" . | strings.Indent 6 }!}
{!{ tmpl.Exec "update_comment_on_start" $workflowName | strings.Indent 6 }!}
{!{ tmpl.Exec "login_dev_registry_step" . | strings.Indent 6 }!}
{!{ tmpl.Exec "login_rw_registry_step" . | strings.Indent 6 }!}

      - name: Check push enabled
        id: check_push
        env:
          SKIP_PUSH_FOR_SUSPEND: ${{secrets.SKIP_PUSH_FOR_SUSPEND}}
          REPO: ${{github.repository}}
        run: |
          if [[ ${REPO} == "deckhouse/deckhouse" ]]; then
            echo "::set-output name=enable::true"
          fi
          if [[ ${SKIP_PUSH_FOR_SUSPEND} != "true" ]]; then
            echo "::set-output name=enable::true"
          fi

{!{/*
Pull deckhouse images from cache, tag with channel name and push to dev and prod registries.
Images:
- deckhouse/release-channel image
Destination registries:
- DECKHOUSE_REGISTRY_HOST
- DEV_REGISTRY_PATH
*/}!}
{!{ range $werfEnv := slice "CE" "EE" "FE" }!}
      - name: Publish release images for {!{ $werfEnv }!}
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          WERF_ENV: {!{ $werfEnv }!}
          ENABLE_PUSH: ${{steps.check_push.outputs.enable}}
        run: |
          # Some precautions.
          if [[ -z $DEV_REGISTRY_PATH ]] ; then
            echo "DEV_REGISTRY_PATH is not set!"
            exit 1
          fi
          if [[ -z $WERF_ENV ]] ; then
            echo "WERF_ENV is not set!"
            exit 1
          fi

          # Variables
          #   1. Edition and channel.
          # CE/EE/FE -> ce/ee/fe
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')
          RELEASE_CHANNEL={!{ $channel }!}

          echo "‚öìÔ∏è üí´ [$(date -u)] Start publishing suspend image for '${REGISTRY_SUFFIX}' edition onto '${RELEASE_CHANNEL}' release channel."

          #   2. Prod registry: use github packages if DECKHOUSE_REGISTRY_HOST not set (run in the test repo).
          DST_REGISTRY_PATH=${DECKHOUSE_REGISTRY_HOST}/deckhouse
          if [[ -z "${DECKHOUSE_REGISTRY_HOST}" ]]; then
            DST_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
            echo "‚öìÔ∏è [$(date -u)] DECKHOUSE_REGISTRY_HOST is empty. Publish to Github Container Registry '${DST_REGISTRY_PATH}'"
          fi

          #   3. Build and publish release-channel image to prod registry.
          RELEASE_VERSION_IMAGE=${DST_REGISTRY_PATH}/${REGISTRY_SUFFIX}/release-channel:${RELEASE_CHANNEL}

          echo "{\"version\": \"$CI_COMMIT_REF_NAME\", \"suspend\": true}" > version.json
          cat <<EOF >Dockerfile
          FROM spotify/scratch
          COPY version.json version.json
          EOF
          docker build . -t ${RELEASE_VERSION_IMAGE}

          if [[ ${ENABLE_PUSH} == "true" ]] ; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Push 'suspend' image as ${RELEASE_VERSION_IMAGE}."
            docker image push ${RELEASE_VERSION_IMAGE}
          else
            echo "‚öìÔ∏è [$(date -u)] SKIP_PUSH_FOR_SUSPEND=true, skip running 'docker image push ${RELEASE_VERSION_IMAGE}'."
          fi

          echo "Delete local 'release-channel' image ${RELEASE_VERSION_IMAGE}"
          docker image rmi ${RELEASE_VERSION_IMAGE} || true

          echo "Release version image: ${RELEASE_VERSION_IMAGE}"
{!{- end }!}

{!{ tmpl.Exec "update_comment_on_finish" (slice "job,final" $workflowName) | strings.Indent 6 }!}

{!{ end -}!}
