{!{/*
Multifile generator of e2e workflows.

One workflow file for each provider.

Workflow consists of jobs for each possible pair of CRI and Kubernetes version.
Jobs are enabled according to outputs from check labels job.

A note on werf.yaml and deckhouse image tag:

$CI_COMMIT_REF_NAME environment variable is used in werf.yaml, so it is needed
    for successful run of werf commands.

$CI_COMMIT_REF_SLUG is a tag of published deckhouse images. It has a form
    of "pr<PR_NUMBER>" for pull requests and deckouse Deployment uses this tag
    to auto update testing cluster on new commits.
    The Git tag is slugified in case it constains a plus sign.

*/}!}

{!{- $providerNames := slice "AWS" "Azure" "GCP" "Yandex.Cloud" "OpenStack" "vSphere" "Static" -}!}
{!{- $criNames := slice "Docker" "Containerd" -}!}
{!{- $kubernetesVersions := slice "1.19" "1.20" "1.21" "1.22" -}!}

{!{- range $providerName := $providerNames -}!}
{!{-   $provider := $providerName | replaceAll "." "-" | toLower -}!}
{!{-   $ctx := dict "provider" $provider "providerName" $providerName "criNames" $criNames "kubernetesVersions" $kubernetesVersions }!}
{!{-   $outFile := printf "e2e-%s.yml" $provider }!}
{!{-   $outPath := filepath.Join (getenv "OUTDIR") $outFile }!}
{!{-   tmpl.Exec "e2e_workflow_template" $ctx | file.Write $outPath }!}
{!{- end -}!}


{!{/* Template with e2e jobs for one provider. */}!}
{!{- define "e2e_workflow_template" -}!}
{!{- $ctx := . -}!}
{!{- $workflowName := printf "e2e: %s" $ctx.providerName -}!}
# <template: e2e_workflow_template>
name: '{!{ $workflowName }!}'
on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: 'ID of issue where label was set'
        required: false
      issue_number:
        description: 'Number of issue where label was set'
        required: false
      comment_id:
        description: 'ID of comment in issue where to put workflow run status'
        required: false
      ci_commit_ref_name:
        description: 'Git ref name for image tags'
        required: false
      pull_request_ref:
        description: 'Git ref for checkout PR sources'
        required: false
      pull_request_sha:
        description: 'Git SHA for restoring artifacts from cache'
        required: false
      pull_request_head_label:
        description: 'Head label of pull request. e.g. my_repo:my_feature_branch'
        required: false
      cri:
        description: 'A comma-separated list of cri to test. Available: Docker and Containerd.'
        required: false
      ver:
        description: 'A comma-separated list of versions to test. Available: from 1.19 to 1.22.'
        required: false
env:
{!{ tmpl.Exec "werf_envs" | strings.Indent 2 }!}
{!{ tmpl.Exec "image_versions_envs" | strings.Indent 2 }!}
{!{ tmpl.Exec "terraform_versions_envs" | strings.Indent 2 }!}

# Note: no concurrency section for e2e workflows.
# Usually you run e2e and wait until it ends.

jobs:
  started_at:
    name: Save start timestamp
    outputs:
      started_at: ${{ steps.started_at.outputs.started_at }}
    runs-on: "ubuntu-latest"
    steps:
{!{ tmpl.Exec "started_at_output" . | strings.Indent 6 }!}

{!{ tmpl.Exec "git_info_job" . | strings.Indent 2 }!}

{!{ tmpl.Exec "check_e2e_labels_job" $ctx | strings.Indent 2 }!}

{!{/* Jobs for each CRI and Kubernetes version */}!}
{!{- $lastCommentNeeds := slice "started_at" -}!}
{!{- $jobNames := dict -}!}
{!{- range $criName := $ctx.criNames -}!}
{!{-   range $kubernetesVersion := $ctx.kubernetesVersions -}!}
{!{-     $kubernetesVersionSlug := $kubernetesVersion | replaceAll "." "_" | toLower -}!}
{!{-     $cri := $criName | toLower -}!}
{!{-     $criEnv := $cri | toUpper -}!}
{!{-     $layout := "WithoutNAT" -}!}
{!{-     if eq $ctx.provider "azure"  -}!}
{!{-       $layout = "Standard" -}!}
{!{-     end -}!}
{!{-     if eq $ctx.provider "vsphere"  -}!}
{!{-       $layout = "Standard" -}!}
{!{-     end -}!}
{!{-     if eq $ctx.provider "static"  -}!}
{!{-       $layout = "Static" -}!}
{!{-     end -}!}
{!{-     $jobID := printf "run_%s_%s" $cri $kubernetesVersionSlug -}!}
{!{-     $jobName := printf "%s, %s, Kubernetes %s" $workflowName $criName $kubernetesVersion -}!}
{!{-     $lastCommentNeeds = $lastCommentNeeds | append $jobID -}!}
{!{-     $jobNames = coll.Merge $jobNames (dict $jobID $jobName) }!}
{!{-     $jobCtx := coll.Merge $ctx (dict "cri" $cri "criName" $criName "criEnv" $criEnv "layout" $layout "kubernetesVersion" $kubernetesVersion "kubernetesVersionSlug" $kubernetesVersionSlug "workflowName" $workflowName "jobName" $jobName "jobID" $jobID) }!}
{!{     tmpl.Exec "e2e_run_job_template" $jobCtx | strings.Indent 2 }!}
{!{-   end -}!}
{!{- end }!}

  last_comment:
    name: Update comment on finish
    needs: {!{ $lastCommentNeeds | toJSON }!}
    if: ${{ always() }}
    runs-on: ubuntu-latest
    env:
      JOB_NAMES: |
        {!{ $jobNames | toJSON }!}
    steps:
{!{ tmpl.Exec "checkout_step" $ctx | strings.Indent 6 }!}
{!{ tmpl.Exec "update_comment_on_finish" (slice "workflow,final,no-skipped,restore-separate" $workflowName) | strings.Indent 6 }!}
# </template: e2e_workflow_template>
{!{ end -}!}


{!{/* One e2e job. */}!}
{!{- define "e2e_run_job_template" -}!}
{!{- $ctx := . -}!}
{!{- $runsOnLabel := "e2e-common" -}!}
{!{- if eq $ctx.provider "vsphere"  -}!}
{!{-   $runsOnLabel = "e2e-vsphere" -}!}
{!{- end -}!}
# <template: e2e_run_job_template>
{!{ $ctx.jobID }!}:
  name: "{!{ $ctx.jobName }!}"
  needs:
    - check_e2e_labels
    - git_info
  if: needs.check_e2e_labels.outputs.run_{!{ $ctx.cri }!}_{!{ $ctx.kubernetesVersionSlug }!} == 'true'
  env:
    PROVIDER: {!{ $ctx.providerName }!}
    CRI: {!{ $ctx.criName }!}
    LAYOUT: {!{ $ctx.layout }!}
    KUBERNETES_VERSION: "{!{ $ctx.kubernetesVersion }!}"
    EVENT_LABEL: ${{ github.event.label.name }}
  runs-on: [self-hosted, {!{ $runsOnLabel }!}]
  steps:
{!{ tmpl.Exec "started_at_output" . | strings.Indent 4 }!}
{!{ tmpl.Exec "checkout_from_event_ref_step" . | strings.Indent 4 }!}
{!{ tmpl.Exec "update_comment_on_start" $ctx.jobName | strings.Indent 4 }!}
{!{ tmpl.Exec "login_dev_registry_step" . | strings.Indent 4 }!}
{!{ tmpl.Exec "login_rw_registry_step" . | strings.Indent 4 }!}
{!{ tmpl.Exec "werf_install_step" . | strings.Indent 4 }!}

    - name: Setup
      id: setup
      env:
        DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
        CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
        CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
      run: |
        # Random delay to sparse 'update comment' steps in time.
        delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
        echo Delay for $delay
        sleep $delay

        # Calculate unique prefix for e2e test.
        # GITHUB_RUN_ID is a unique number for each workflow run.
        # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
        prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
        echo "::set-output name=prefix::${prefix}"
        echo "prefix=${prefix}"

        # Create tmppath for test script.
        tmppath=/mnt/cloud-layouts/layouts/${prefix}
        if [[ -d "${tmppath}" ]] ; then
          echo "Temporary dir already exists: ${tmppath}. ERROR!"
          ls -la ${tmppath}
          exit 1
        else
          echo "Create temporary dir for job: ${tmppath}."
          mkdir -p "${tmppath}"
        fi
        echo "::set-output name=tmppath::${tmppath}"

        ## Deckhouse 'install' image name
        ## Source: ci_templates/build.yml

        # Use dev-registry for Git branches.
        BRANCH_REGISTRY_PATH="${DEV_REGISTRY_PATH}"
        # Use rw-registry for Git tags.
        SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

        if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
          # Use Github Container Registry for test repositories.
          BRANCH_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}/dev"
          SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
        fi

        IMAGE_NAME=
        if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${CI_COMMIT_REF_SLUG}
          echo "Deckhouse Deployment will use image ${IMAGE_NAME} to test Git branch ${CI_COMMIT_BRANCH}"
        fi
        if [[ -n $CI_COMMIT_TAG ]] ; then
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
          IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          echo "Deckhouse Deployment will use image ${IMAGE_NAME} to test Git tag ${CI_COMMIT_TAG}"
        fi

        echo "::set-output name=install-image-name::${IMAGE_NAME}"

        # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
        echo "Name: ${IMAGE_NAME}" | tr '[:lower:]' '[:upper:]'
        echo "⚓️ [$(date -u)] Pull 'dev/install' image '${IMAGE_NAME}'."
        docker pull "${IMAGE_NAME}"

    - name: "Run e2e test: {!{ $ctx.providerName }!}/{!{ $ctx.criName }!}/{!{ $ctx.kubernetesVersion }!}"
      env:
        PROVIDER: {!{ $ctx.providerName }!}
        CRI: {!{ $ctx.criName }!}
        LAYOUT: {!{ $ctx.layout }!}
        KUBERNETES_VERSION: "{!{ $ctx.kubernetesVersion }!}"
        LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
        LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
        WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
        CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
        CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
        CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
        CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
        TMPPATH: ${{ steps.setup.outputs.tmppath}}
        PREFIX: ${{ steps.setup.outputs.prefix}}
        INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
{!{- tmpl.Exec "e2e_run_template" (slice .provider "run-test") | strings.Indent 6 }!}

    - name: Cleanup bootstrapped cluster
      if: always()
      env:
        JOB_STATUS: ${{ job.status }}
        PROVIDER: {!{ $ctx.providerName }!}
        CRI: {!{ $ctx.criName }!}
        LAYOUT: {!{ $ctx.layout }!}
        KUBERNETES_VERSION: "{!{ $ctx.kubernetesVersion }!}"
        LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
        LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
        WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
        CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
        CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
        CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
        CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
        TMPPATH: ${{ steps.setup.outputs.tmppath}}
        PREFIX: ${{ steps.setup.outputs.prefix}}
        INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
{!{- tmpl.Exec "e2e_run_template" (slice .provider "cleanup") | strings.Indent 6 }!}

    - name: Save test results
      if: always()
      uses: {!{ index (ds "actions") "actions/upload-artifact" }!}
      with:
        name: test_output_{!{ printf "%s_%s_%s" $ctx.provider $ctx.cri $ctx.kubernetesVersionSlug }!}
        path: |
          testing/cloud_layouts/

    - name: Cleanup temp directory
      if: always()
      env:
        TMPPATH: ${{ steps.setup.outputs.tmppath}}
      run: |
        echo "Remove temporary directory '${TMPPATH}' ..."
        if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
          rm -rf "${TMPPATH}"
        else
          echo Not a directory.
        fi

{!{ tmpl.Exec "update_comment_on_finish" (slice "job,separate" $ctx.jobName) | strings.Indent 4 }!}

    - name: Check alerting credentials
      id: check_alerting
      env:
        KEY: ${{secrets.CLOUD_LAYOUT_TESTS_MADISON_KEY}}
      run: |
        if [[ -n $KEY ]]; then echo "::set-output name=has_credentials::true"; fi

    - name: Alert on fail in default branch
      if: ${{ steps.check_alerting.outputs.has_credentials == 'true' && github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
      env:
        PROVIDER: {!{ $ctx.providerName }!}
        CRI: {!{ $ctx.criName }!}
        LAYOUT: {!{ $ctx.layout }!}
        KUBERNETES_VERSION: "{!{ $ctx.kubernetesVersion }!}"
      run: |
        WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
        echo $WORKFLOW_URL

        alertData=$(cat <<EOF
        {
          "labels": {
            "severity_level": 7,
            "trigger": "CloudLayoutTestFailed",
            "provider": "${PROVIDER}",
            "layout": "${LAYOUT}",
            "cri": "${CRI}",
            "kubernetes_version": "${KUBERNETES_VERSION}"
          },
          "annotations": {
            "summary": "Cloud Layout Test failed",
            "description": "Check Github workflow log for more information",
            "plk_protocol_version": "1",
            "plk_link_url/job": "${WORKFLOW_URL}",
            "plk_link_title_en/job": "Github job run",
            "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
            "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
          }
        }
        EOF
        )

        curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
          -H 'Content-Type: application/json' \
          -d "${alertData}"
# </template: e2e_run_job_template>
{!{ end -}!}
