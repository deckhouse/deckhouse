{!{/*
Multifile generator of e2e workflows.

One workflow file for each provider.

Workflow consists of jobs for each possible pair of CRI and Kubernetes version.
Jobs are enabled according to outputs from check labels job.

A note on werf.yaml and deckhouse image tag:

$CI_COMMIT_REF_NAME environment variable is used in werf.yaml, so it is needed
    for successful run of werf commands.

$CI_COMMIT_REF_SLUG is a tag of published deckhouse images. It has a form
    of "pr<PR_NUMBER>" for pull requests and deckouse Deployment uses this tag
    to auto update testing cluster on new commits.
    The Git tag is slugified in case it constains a plus sign.

*/}!}

{!{- $providerNames := slice "AWS" "Azure" "GCP" "Yandex.Cloud" "OpenStack" "vSphere" "Static" -}!}
{!{- $criNames := slice "Docker" "Containerd" -}!}
{!{- $kubernetesVersions := slice "1.19" "1.20" "1.21" "1.22" -}!}

{!{- range $providerName := $providerNames -}!}
{!{-   $provider := $providerName | replaceAll "." "-" | toLower -}!}
{!{-   $ctx := dict "provider" $provider "providerName" $providerName "criNames" $criNames "kubernetesVersions" $kubernetesVersions }!}
{!{-   $outFile := printf "e2e-%s.yml" $provider }!}
{!{-   $outPath := filepath.Join (getenv "OUTDIR") $outFile }!}
{!{-   tmpl.Exec "e2e_workflow_template" $ctx | file.Write $outPath }!}
{!{- end -}!}


{!{/* Template with e2e jobs for one provider. */}!}
{!{- define "e2e_workflow_template" -}!}
{!{- $ctx := . -}!}
{!{- $workflowName := printf "e2e: %s" $ctx.providerName -}!}
# <template: e2e_workflow_template>
name: '{!{ $workflowName }!}'
on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: 'ID of issue where label was set'
        required: false
      issue_number:
        description: 'Number of issue where label was set'
        required: false
      comment_id:
        description: 'ID of comment in issue where to put workflow run status'
        required: false
      ci_commit_ref_name:
        description: 'Git ref name for image tags'
        required: false
      pull_request_ref:
        description: 'Git ref for checkout PR sources'
        required: false
      pull_request_sha:
        description: 'Git SHA for restoring artifacts from cache'
        required: false
      cri:
        description: 'A comma-separated list of cri to test. Available: Docker and Containerd.'
        required: false
      ver:
        description: 'A comma-separated list of versions to test. Available: from 1.19 to 1.22.'
        required: false
env:
{!{ tmpl.Exec "werf_envs" | strings.Indent 2 }!}
{!{ tmpl.Exec "image_versions_envs" | strings.Indent 2 }!}
{!{ tmpl.Exec "terraform_versions_envs" | strings.Indent 2 }!}

# Note: no concurrency section for e2e workflows.
# Usually you run e2e and wait until it ends.

jobs:
{!{ tmpl.Exec "git_info_job" . | strings.Indent 2 }!}

{!{ tmpl.Exec "check_e2e_labels_job" $ctx | strings.Indent 2 }!}

{!{/* Jobs for each CRI and Kubernetes version */}!}
{!{- range $criName := $ctx.criNames -}!}
{!{-   range $kubernetesVersion := $ctx.kubernetesVersions -}!}
{!{-     $kubernetesVersionSlug := $kubernetesVersion | replaceAll "." "_" | toLower -}!}
{!{-     $cri := $criName | toLower -}!}
{!{-     $criEnv := $cri | toUpper -}!}
{!{-     $layout := "WithoutNAT" -}!}
{!{-     if eq $ctx.provider "azure"  -}!}
{!{-       $layout = "Standard" -}!}
{!{-     end -}!}
{!{-     if eq $ctx.provider "vsphere"  -}!}
{!{-       $layout = "Standard" -}!}
{!{-     end -}!}
{!{-     if eq $ctx.provider "static"  -}!}
{!{-       $layout = "Static" -}!}
{!{-     end -}!}
{!{-     $jobCtx := coll.Merge $ctx (dict "cri" $cri "criName" $criName "criEnv" $criEnv "layout" $layout "kubernetesVersion" $kubernetesVersion "kubernetesVersionSlug" $kubernetesVersionSlug "workflowName" $workflowName) }!}
{!{     tmpl.Exec "e2e_run_job_template" $jobCtx | strings.Indent 2 }!}
{!{-   end -}!}
{!{- end }!}
# </template: e2e_workflow_template>
{!{ end -}!}


{!{/* One e2e job. */}!}
{!{- define "e2e_run_job_template" -}!}
{!{- $ctx := . -}!}
{!{- $runsOnLabel := "e2e-common" -}!}
{!{- if eq $ctx.provider "vsphere"  -}!}
{!{-   $runsOnLabel = "e2e-vsphere" -}!}
{!{- end -}!}
# <template: e2e_run_job_template>
run_{!{ $ctx.cri }!}_{!{ $ctx.kubernetesVersionSlug }!}:
  name: "{!{ $ctx.criName }!}, k8s {!{ $ctx.kubernetesVersion }!}"
  needs:
    - check_e2e_labels
    - git_info
  if: needs.check_e2e_labels.outputs.run_{!{ $ctx.cri }!}_{!{ $ctx.kubernetesVersionSlug }!} == 'true'
  env:
    PROVIDER: {!{ $ctx.providerName }!}
    CRI: {!{ $ctx.criName }!}
    LAYOUT: {!{ $ctx.layout }!}
    KUBERNETES_VERSION: {!{ $ctx.kubernetesVersion }!}
    EVENT_LABEL: ${{ github.event.label.name }}
  runs-on: [self-hosted, {!{ $runsOnLabel }!}]
  steps:
{!{ tmpl.Exec "checkout_from_event_ref_step" . | strings.Indent 4 }!}
{!{ tmpl.Exec "update_comment_on_start" (printf "%s, %s, k8s %s" $ctx.workflowName $ctx.criName $ctx.kubernetesVersion) | strings.Indent 4 }!}
{!{ tmpl.Exec "login_dev_registry_step" . | strings.Indent 4 }!}
{!{ tmpl.Exec "login_readonly_registry_step" . | strings.Indent 4 }!}
{!{ tmpl.Exec "login_rw_registry_step" . | strings.Indent 4 }!}
{!{ tmpl.Exec "werf_install_step" . | strings.Indent 4 }!}

    - name: Setup
      id: setup
      env:
        DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
      run: |
        # Random delay to sparse 'update comment' steps in time.
        delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
        echo Delay for $delay
        sleep $delay

        # Calculate unique prefix for e2e test.
        prefix=${GITHUB_RUN_ID}-$(echo ${KUBERNETES_VERSION} | tr '.' '-')
        echo "::set-output name=prefix::${prefix}"
        echo "prefix=${prefix}"

        # Create tmppath for test script.
        tmppath=/mnt/cloud-layouts/layouts/${prefix}
        if [[ -d "${tmppath}" ]] ; then
          echo "Temporary dir already exists: ${tmppath}. ERROR!"
          ls -la ${tmppath}
          exit 1
        else
          echo "Create temporary dir for job: ${tmppath}."
          mkdir -p "${tmppath}"
        fi
        echo "::set-output name=tmppath::${tmppath}"

        CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
        CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

        if [[ -n "${CI_COMMIT_TAG}" ]] ; then
          CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
          echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
        fi
        if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
          CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
          echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
        fi
        echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

        ## Deckhouse 'install' image name
        ## Source: ci_templates/build.yml

        IMAGE_NAME=
        if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}

          if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
            IMAGE_NAME=${DEV_REGISTRY_PATH}/dev/install:${IMAGE_TAG}
          else
            IMAGE_NAME=${CI_REGISTRY_IMAGE}/dev/install:${IMAGE_TAG}
          fi
        fi

        if [[ -n $CI_COMMIT_TAG ]] ; then
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
          if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
            IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${IMAGE_TAG}
          else
            echo "DECKHOUSE_REGISTRY_HOST is empty."
            exit 1
          fi
        fi

        echo "::set-output name=install-image-name::${IMAGE_NAME}"

        echo "Pull dev/install image."
        docker pull "${IMAGE_NAME}"

    - name: "Run e2e test: {!{ $ctx.providerName }!}/{!{ $ctx.criName }!}/{!{ $ctx.kubernetesVersion }!}"
      env:
        PROVIDER: {!{ $ctx.providerName }!}
        CRI: {!{ $ctx.criName }!}
        LAYOUT: {!{ $ctx.layout }!}
        KUBERNETES_VERSION: "{!{ $ctx.kubernetesVersion }!}"
        LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
        LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
        WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
        CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
        CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
        CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
        CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
        TMPPATH: ${{ steps.setup.outputs.tmppath}}
        PREFIX: ${{ steps.setup.outputs.prefix}}
        INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
{!{- tmpl.Exec "e2e_run_template" (slice .provider "run-test") | strings.Indent 6 }!}

    - name: Cleanup bootstrapped cluster
      if: always()
      env:
        JOB_STATUS: ${{ job.status }}
        PROVIDER: {!{ $ctx.providerName }!}
        CRI: {!{ $ctx.criName }!}
        LAYOUT: {!{ $ctx.layout }!}
        KUBERNETES_VERSION: "{!{ $ctx.kubernetesVersion }!}"
        LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
        LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
        WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
        CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
        CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
        CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
        CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
        TMPPATH: ${{ steps.setup.outputs.tmppath}}
        PREFIX: ${{ steps.setup.outputs.prefix}}
        INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
{!{- tmpl.Exec "e2e_run_template" (slice .provider "cleanup") | strings.Indent 6 }!}

    - name: Save test results
      if: always()
      uses: {!{ index (ds "actions") "actions/upload-artifact" }!}
      with:
        name: test_output_{!{ printf "%s_%s_%s" $ctx.provider $ctx.cri $ctx.kubernetesVersionSlug }!}
        path: |
          testing/cloud_layouts/

    - name: Cleanup temp directory
      if: always()
      env:
        TMPPATH: ${{ steps.setup.outputs.tmppath}}
      run: |
        echo "Remove temporary directory '${TMPPATH}' ..."
        if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
          rm -rf "${TMPPATH}"
        else
          echo Not a directory.
        fi

{!{ tmpl.Exec "update_comment_on_finish" (slice "job" (printf "%s, Kubernetes %s" $ctx.workflowName $ctx.kubernetesVersion)) | strings.Indent 4 }!}

    - name: Alert on fail in default branch
      if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
      env:
        PROVIDER: {!{ $ctx.providerName }!}
        CRI: {!{ $ctx.criName }!}
        LAYOUT: {!{ $ctx.layout }!}
        KUBERNETES_VERSION: "{!{ $ctx.kubernetesVersion }!}"
      run: |
        WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
        echo $WORKFLOW_URL

        alertData=$(cat <<EOF
        {
          "labels": {
            "severity_level": 7,
            "trigger": "CloudLayoutTestFailed",
            "provider": "${PROVIDER}",
            "layout": "${LAYOUT}",
            "cri": "${CRI}",
            "kubernetes_version": "${KUBERNETES_VERSION}"
          },
          "annotations": {
            "summary": "Cloud Layout Test failed",
            "description": "Check Github workflow log for more information",
            "plk_protocol_version": "1",
            "plk_link_url/job": "${WORKFLOW_URL}",
            "plk_link_title_en/job": "Github job run",
            "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
            "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
          }
        }
        EOF
        )

        curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
          -H 'Content-Type: application/json' \
          -d "${alertData}"
# </template: e2e_run_job_template>
{!{ end -}!}
