#
# THIS FILE IS GENERATED, PLEASE DO NOT EDIT.
#

# Copyright 2022 Flant JSC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
name: 'Daily e2e tests'
on:
  schedule:
  - cron: '0 1 * * 1-5'
  workflow_dispatch:

env:
  WERF_DRY_RUN: "false"

  # <template: werf_envs>
  WERF_VERSION: "v2.46.0"
  WERF_ENV: "FE"
  TEST_TIMEOUT: "15m"
  # Use fixed string 'sys/deckhouse-oss' for repo name. ${CI_PROJECT_PATH} is not available here in GitHub.
  REGISTRY_PATH: "sys/deckhouse-oss"
  # Registry for additional repositories used for testing Github Actions workflows.
  GHA_TEST_REGISTRY_PATH: "ghcr.io/${{ github.repository }}"
  # Need for ssh: default.
  DOCKER_BUILDKIT: "1"
  WERF_FINAL_IMAGES_ONLY: true
  WERF_LOG_TERMINAL_WIDTH: "200"
  WERF_LOG_TIME: true
  WERF_GIT_WORK_TREE_POOL_LIMIT: "10"
  GOPROXY: "${{vars.GOPROXY}}"
  # </template: werf_envs>

# Always run a single job at a time.
# Note: Concurrency is currently in beta and subject to change.
# https://docs.github.com/en/actions/reference/workflow-syntax-for-github-actions#concurrency
concurrency:
  group: e2e-daily

permissions:
  contents: read
  id-token: write

jobs:
  skip_tests_repos:
    name: Skip tests repos
    runs-on: "regular"
    if: ${{ false || github.repository == 'deckhouse/deckhouse' }}
    steps:
    - name: Do nothing
      run: echo "Empty action to fulfil Github requirements."


# Note: git_info is needed for werf.yaml
  # <template: git_info_job>

  git_info:
    name: Get git info
    runs-on: "regular"
    needs:
    - skip_tests_repos
    outputs:
      ci_commit_tag: ${{ steps.git_info.outputs.ci_commit_tag }}
      ci_commit_branch: ${{ steps.git_info.outputs.ci_commit_branch }}
      ci_commit_ref_name: ${{ steps.git_info.outputs.ci_commit_ref_name }}
      ci_commit_ref_slug: ${{ steps.git_info.outputs.ci_commit_ref_slug }}
      ref_full: ${{ steps.git_info.outputs.ref_full }}
      github_sha: ${{ steps.git_info.outputs.github_sha }}
      pr_number: ${{ steps.git_info.outputs.pr_number }}
    # Skip the CI for automation PRs, e.g. changelog, don't skip if Pull Request title contains "[run ci]".
    if: ${{ contains(github.event.pull_request.title, '[run ci]') || github.event.pull_request.user.login != 'deckhouse-BOaTswain' }}
    steps:
      - id: git_info
        name: Get tag name and SHA
        uses: actions/github-script@v6.4.1
        with:
          script: |
            const { GITHUB_REF_TYPE, GITHUB_REF_NAME, GITHUB_REF } = process.env

            let refSlug = ''
            let refName = ''
            let refFull = ''
            let githubBranch = ''
            let githubTag = ''
            let githubSHA = ''
            let prNumber = ''
            if (context.eventName === "workflow_dispatch" && context.payload.inputs && context.payload.inputs.pull_request_ref) {
              // Trigger: workflow_dispatch with pull_request_ref.
              // Extract pull request number from 'refs/pull/<NUM>/merge'
              prNumber = context.payload.inputs.pull_request_ref.replace('refs/pull/', '').replace('/merge', '').replace('/head', '')

              refSlug       = `pr${prNumber}`
              refName       = context.payload.inputs.ci_commit_ref_name
              refFull       = context.payload.inputs.pull_request_ref
              githubBranch  = refName
              githubSHA     = context.payload.inputs.pull_request_sha
              core.info(`workflow_dispatch event: set git info from inputs. inputs: ${JSON.stringify(context.payload.inputs)}`)
            } else if (context.eventName === "pull_request" || context.eventName === "pull_request_target" ) {
              // For PRs from forks, tag images with `prXXX` to avoid clashes between branches.
              const targetRepo = context.payload.repository.full_name;
              const prRepo = context.payload.pull_request.head.repo.full_name
              const prRef = context.payload.pull_request.head.ref

              refSlug = `pr${context.issue.number}`;
              refName = (prRepo === targetRepo) ? prRef : refSlug;
              refFull = `refs/pull/${context.issue.number}/head`
              githubBranch = refName
              githubSHA = context.payload.pull_request.head.sha
              core.info(`pull request event: set git info from pull_request.head. pr:${prRepo}:${prRef} target:${targetRepo}:${context.ref}`)
              prNumber = context.issue.number
            } else {
              // Other triggers: workflow_dispatch without pull_request_ref, schedule, push...
              // refName is 'main' or tag name, so slugification is not necessary.
              refSlug       = GITHUB_REF_NAME
              refName       = GITHUB_REF_NAME
              refFull       = GITHUB_REF
              githubTag     = GITHUB_REF_TYPE == "tag"    ? refName : ""
              githubBranch  = GITHUB_REF_TYPE == "branch" ? refName : ""
              githubSHA     = context.sha
              core.info(`${context.eventName} event: set git info from context: ${JSON.stringify({GITHUB_REF_NAME, GITHUB_REF_TYPE, sha: context.sha })}`)
            }

            core.setCommandEcho(true)
            core.setOutput('ci_commit_ref_slug', refSlug)
            core.setOutput('ci_commit_ref_name', refName)
            core.setOutput(`ci_commit_tag`, githubTag)
            core.setOutput(`ci_commit_branch`, githubBranch)
            core.setOutput(`ref_full`, refFull)
            core.setOutput('github_sha', githubSHA)
            core.setOutput('pr_number', prNumber)
            core.setCommandEcho(false)

  # </template: git_info_job>
  # <template: e2e_run_job_template>
  run_aws_containerd_automatic:
    name: "AWS, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "aws;WithoutNAT;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: AWS
      CRI: Containerd
      LAYOUT: WithoutNAT
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/AWS access_key | LAYOUT_AWS_ACCESS_KEY ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/AWS secret_key | LAYOUT_AWS_SECRET_ACCESS_KEY ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')


          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"


          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: AWS/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: AWS
          CRI: Containerd
          LAYOUT: WithoutNAT
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "9b567623-91a9-4493-96de-f5c0b6acacfe"
          LAYOUT_AWS_ACCESS_KEY: ${{ steps.secrets.outputs.LAYOUT_AWS_ACCESS_KEY }}
          LAYOUT_AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.LAYOUT_AWS_SECRET_ACCESS_KEY }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh run-test' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_AWS_ACCESS_KEY=${LAYOUT_AWS_ACCESS_KEY:-not_provided}
          export LAYOUT_AWS_SECRET_ACCESS_KEY=${LAYOUT_AWS_SECRET_ACCESS_KEY:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh run-test

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: success()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: AWS
          CRI: Containerd
          LAYOUT: WithoutNAT
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "9b567623-91a9-4493-96de-f5c0b6acacfe"
          LAYOUT_AWS_ACCESS_KEY: ${{ steps.secrets.outputs.LAYOUT_AWS_ACCESS_KEY }}
          LAYOUT_AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.LAYOUT_AWS_SECRET_ACCESS_KEY }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_AWS_ACCESS_KEY=${LAYOUT_AWS_ACCESS_KEY:-not_provided}
          export LAYOUT_AWS_SECRET_ACCESS_KEY=${LAYOUT_AWS_SECRET_ACCESS_KEY:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_aws_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_eks_containerd_automatic:
    name: "EKS, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "eks;WithoutNAT;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: EKS
      CRI: Containerd
      LAYOUT: WithoutNAT
      KUBERNETES_VERSION: "1.32"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/AWS access_key | LAYOUT_AWS_ACCESS_KEY ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/AWS secret_key | LAYOUT_AWS_SECRET_ACCESS_KEY ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')

          # Create tmppath for test script.
          TMP_DIR_PATH=/tmp/cloud-layouts/layouts/${DHCTL_PREFIX}
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          TERRAFORM_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
            TERRAFORM_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/e2e-opentofu-eks:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
            TERRAFORM_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/e2e-opentofu-eks:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            TERRAFORM_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/e2e-opentofu-eks:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"
          docker pull "${TERRAFORM_IMAGE_NAME}"

          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "dhctl-log-file=${TMP_DIR_PATH}/dhctl.log" >> $GITHUB_OUTPUT
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "terraform-image-name=${TERRAFORM_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: EKS/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: EKS
          CRI: Containerd
          LAYOUT: WithoutNAT
          KUBERNETES_VERSION: "1.32"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          TERRAFORM_IMAGE_NAME: ${{ steps.setup.outputs.terraform-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          LAYOUT_AWS_ACCESS_KEY: ${{ steps.secrets.outputs.LAYOUT_AWS_ACCESS_KEY }}
          LAYOUT_AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.LAYOUT_AWS_SECRET_ACCESS_KEY }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          DHCTL_LOG_FILE: ${{ steps.setup.outputs.dhctl-log-file}}
          STAGE_DECKHOUSE_DOCKERCFG: ${{steps.secrets.outputs.STAGE_DECKHOUSE_DOCKERCFG}}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
        run: |
          echo "Execute 'script_eks.sh run-test' via 'docker run', using environment:
            TERRAFORM_IMAGE_NAME=${TERRAFORM_IMAGE_NAME}
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "

          ls -lh $(pwd)/testing

          dhctl_log_file="${DHCTL_LOG_FILE}-${PROVIDER}-${LAYOUT}-${CRI}-${KUBERNETES_VERSION}"
          echo "DHCTL log file: $dhctl_log_file"

          user_runner_id=$(id -u):$(id -g)
          echo "user_runner_id $user_runner_id"
          chmod 755 $(pwd)/testing/cloud_layouts/script_eks.sh

          docker run --rm \
          -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
          -e STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG} \
          -e DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG} \
          -e PREFIX=${PREFIX} \
          -e INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG} \
          -e CRI=${CRI} \
          -e LAYOUT_AWS_ACCESS_KEY=${LAYOUT_AWS_ACCESS_KEY:-not_provided} \
          -e LAYOUT_AWS_SECRET_ACCESS_KEY=${LAYOUT_AWS_SECRET_ACCESS_KEY:-not_provided} \
          -e LAYOUT_AWS_DEFAULT_REGION=eu-central-1 \
          -e LAYOUT=${LAYOUT} \
          -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
          -e CRI=${CRI} \
          -e USER_RUNNER_ID=${user_runner_id} \
          -e FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }} \
          -v $(pwd)/testing:/deckhouse/testing \
          -v $(pwd)/release.yaml:/deckhouse/release.yaml \
          -v ${TMP_DIR_PATH}:/tmp \
          ${TERRAFORM_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script_eks.sh run-test
          docker run --rm \
          -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
          -e STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG} \
          -e DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG} \
          -e PREFIX=${PREFIX} \
          -e INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG} \
          -e LAYOUT=${LAYOUT:-not_provided} \
          -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
          -e CRI=${CRI} \
          -e FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }} \
          -v "$PWD/config.yml:/config.yml" \
          -v ${TMP_DIR_PATH}:/tmp \
          -v "$PWD/resources.yml:/resources.yml" \
          -v $(pwd)/testing:/deckhouse/testing \
          -v $(pwd)/release.yaml:/deckhouse/release.yaml \
          ${INSTALL_IMAGE_NAME} \
          bash -c "dhctl bootstrap-phase install-deckhouse \
            --kubeconfig=/tmp/eks-${LAYOUT}-${CRI}-${KUBERNETES_VERSION}.kubeconfig \
            --config=/deckhouse/testing/cloud_layouts/EKS/WithoutNAT/configuration.yaml && \
          dhctl bootstrap-phase create-resources \
            --kubeconfig=/tmp/eks-${LAYOUT}-${CRI}-${KUBERNETES_VERSION}.kubeconfig \
            --resources=/deckhouse/testing/cloud_layouts/EKS/WithoutNAT/resources.yaml"

          docker run --rm \
          -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
          -e STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG} \
          -e DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG} \
          -e PREFIX=${PREFIX} \
          -e INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG} \
          -e CRI=${CRI} \
          -e LAYOUT_AWS_ACCESS_KEY=${LAYOUT_AWS_ACCESS_KEY:-not_provided} \
          -e LAYOUT_AWS_SECRET_ACCESS_KEY=${LAYOUT_AWS_SECRET_ACCESS_KEY:-not_provided} \
          -e LAYOUT_AWS_DEFAULT_REGION=eu-central-1 \
          -e LAYOUT=${LAYOUT} \
          -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
          -e KUBECONFIG=/tmp/eks-${LAYOUT}-${CRI}-${KUBERNETES_VERSION}.kubeconfig \
          -e CRI=${CRI} \
          -e FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }} \
          -e USER_RUNNER_ID=${user_runner_id} \
          -v $(pwd)/testing:/deckhouse/testing \
          -v $(pwd)/release.yaml:/deckhouse/release.yaml \
          -v ${TMP_DIR_PATH}:/tmp \
          ${TERRAFORM_IMAGE_NAME} \
          bash -c "/deckhouse/testing/cloud_layouts/script_eks.sh wait_deckhouse_ready && \
          /deckhouse/testing/cloud_layouts/script_eks.sh wait_cluster_ready &&\
          /deckhouse/testing/cloud_layouts/script_eks.sh trigger_deckhouse_update"

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: always()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: EKS
          CRI: Containerd
          LAYOUT: WithoutNAT
          KUBERNETES_VERSION: "1.32"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          TERRAFORM_IMAGE_NAME: ${{ steps.setup.outputs.terraform-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          LAYOUT_AWS_ACCESS_KEY: ${{ steps.secrets.outputs.LAYOUT_AWS_ACCESS_KEY }}
          LAYOUT_AWS_SECRET_ACCESS_KEY: ${{ steps.secrets.outputs.LAYOUT_AWS_SECRET_ACCESS_KEY }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          DHCTL_LOG_FILE: ${{ steps.setup.outputs.dhctl-log-file}}
          STAGE_DECKHOUSE_DOCKERCFG: ${{steps.secrets.outputs.STAGE_DECKHOUSE_DOCKERCFG}}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
        run: |
          echo "Execute 'script_eks.sh cleanup' via 'docker run', using environment:
            TERRAFORM_IMAGE_NAME=${TERRAFORM_IMAGE_NAME}
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "

          ls -lh $(pwd)/testing

          dhctl_log_file="${DHCTL_LOG_FILE}-${PROVIDER}-${LAYOUT}-${CRI}-${KUBERNETES_VERSION}"
          echo "DHCTL log file: $dhctl_log_file"

          user_runner_id=$(id -u):$(id -g)
          echo "user_runner_id $user_runner_id"
          chmod 755 $(pwd)/testing/cloud_layouts/script_eks.sh

          docker run --rm \
          -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
          -e STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG} \
          -e DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG} \
          -e PREFIX=${PREFIX} \
          -e INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG} \
          -e CRI=${CRI} \
          -e LAYOUT_AWS_ACCESS_KEY=${LAYOUT_AWS_ACCESS_KEY:-not_provided} \
          -e LAYOUT_AWS_SECRET_ACCESS_KEY=${LAYOUT_AWS_SECRET_ACCESS_KEY:-not_provided} \
          -e LAYOUT_AWS_DEFAULT_REGION=eu-central-1 \
          -e LAYOUT=${LAYOUT} \
          -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
          -e CRI=${CRI} \
          -e USER_RUNNER_ID=${user_runner_id} \
          -e FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }} \
          -v $(pwd)/testing:/deckhouse/testing \
          -v $(pwd)/release.yaml:/deckhouse/release.yaml \
          -v ${TMP_DIR_PATH}:/tmp \
          ${TERRAFORM_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script_eks.sh cleanup

        # </template: e2e_run_template>

      - name: Save dhctl state
        id: save_failed_cluster_state
        if: ${{ !success() }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: failed_cluster_state_eks_containerd_automatic
          path: |
            ${{ steps.setup.outputs.tmp-dir-path}}/dhctl
            ${{ steps.setup.outputs.tmp-dir-path}}/*.tfstate
            ${{ steps.setup.outputs.tmp-dir-path}}/logs

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_eks_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_azure_containerd_automatic:
    name: "Azure, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "azure;Standard;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: Azure
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/Azure subscriptionId | LAYOUT_AZURE_SUBSCRIPTION_ID ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/Azure clientId | LAYOUT_AZURE_CLIENT_ID ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/Azure clientSecret | LAYOUT_AZURE_CLIENT_SECRET ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/Azure tenantId | LAYOUT_AZURE_TENANT_ID ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')


          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"


          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: Azure/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "3900de40-547c-4c62-927c-ef42018d62f4"
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ steps.secrets.outputs.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ steps.secrets.outputs.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ steps.secrets.outputs.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ steps.secrets.outputs.LAYOUT_AZURE_TENANT_ID }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh run-test' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided}
          export LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided}
          export LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided}
          export LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh run-test

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: success()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "3900de40-547c-4c62-927c-ef42018d62f4"
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ steps.secrets.outputs.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ steps.secrets.outputs.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ steps.secrets.outputs.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ steps.secrets.outputs.LAYOUT_AZURE_TENANT_ID }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided}
          export LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided}
          export LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided}
          export LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_azure_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_gcp_containerd_automatic:
    name: "GCP, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "gcp;WithoutNAT;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: GCP
      CRI: Containerd
      LAYOUT: WithoutNAT
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/GCP credentials_json_b64 | LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')


          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"


          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: GCP/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: GCP
          CRI: Containerd
          LAYOUT: WithoutNAT
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "565ed77c-0ae0-4baa-9ece-6603bcf3139a"
          LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON: ${{ steps.secrets.outputs.LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
          TEST_AUTOSCALER_ENABLED: "true"
        run: |
          echo "Execute 'script-commander.sh run-test' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export TEST_AUTOSCALER_ENABLED=${TEST_AUTOSCALER_ENABLED:-not_provided}
          export LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON=${LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh run-test

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: success()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: GCP
          CRI: Containerd
          LAYOUT: WithoutNAT
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "565ed77c-0ae0-4baa-9ece-6603bcf3139a"
          LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON: ${{ steps.secrets.outputs.LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
          TEST_AUTOSCALER_ENABLED: "true"
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export TEST_AUTOSCALER_ENABLED=${TEST_AUTOSCALER_ENABLED:-not_provided}
          export LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON=${LAYOUT_GCP_SERVICE_ACCOUT_KEY_JSON:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_gcp_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_yandex_cloud_containerd_automatic:
    name: "Yandex.Cloud, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "yandex-cloud;WithoutNAT;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: Yandex.Cloud
      CRI: Containerd
      LAYOUT: WithoutNAT
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/Yandex cloud_id | LAYOUT_YANDEX_CLOUD_ID ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/Yandex folder_id | LAYOUT_YANDEX_FOLDER_ID ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/Yandex authorized_key_json_b64 | LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')


          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"


          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: Yandex.Cloud/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: Yandex.Cloud
          CRI: Containerd
          LAYOUT: WithoutNAT
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "6a47d23a-e16f-4e7a-bf57-a65f7c05e8ae"
          LAYOUT_YANDEX_CLOUD_ID: ${{ steps.secrets.outputs.LAYOUT_YANDEX_CLOUD_ID }}
          LAYOUT_YANDEX_FOLDER_ID: ${{ steps.secrets.outputs.LAYOUT_YANDEX_FOLDER_ID }}
          LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON: ${{ steps.secrets.outputs.LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh run-test' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_YANDEX_CLOUD_ID=${LAYOUT_YANDEX_CLOUD_ID:-not_provided}
          export LAYOUT_YANDEX_FOLDER_ID=${LAYOUT_YANDEX_FOLDER_ID:-not_provided}
          export LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON=${LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh run-test

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: success()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: Yandex.Cloud
          CRI: Containerd
          LAYOUT: WithoutNAT
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "6a47d23a-e16f-4e7a-bf57-a65f7c05e8ae"
          LAYOUT_YANDEX_CLOUD_ID: ${{ steps.secrets.outputs.LAYOUT_YANDEX_CLOUD_ID }}
          LAYOUT_YANDEX_FOLDER_ID: ${{ steps.secrets.outputs.LAYOUT_YANDEX_FOLDER_ID }}
          LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON: ${{ steps.secrets.outputs.LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_YANDEX_CLOUD_ID=${LAYOUT_YANDEX_CLOUD_ID:-not_provided}
          export LAYOUT_YANDEX_FOLDER_ID=${LAYOUT_YANDEX_FOLDER_ID:-not_provided}
          export LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON=${LAYOUT_YANDEX_SERVICE_ACCOUNT_KEY_JSON:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_yandex-cloud_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_openstack_containerd_automatic:
    name: "OpenStack, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "openstack;Standard;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: OpenStack
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')


          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"


          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: OpenStack/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh run-test' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh run-test

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: success()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_openstack_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_vsphere_containerd_automatic:
    name: "vSphere, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "vsphere;Standard;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: vSphere
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/vsphere-new e2e-username | LAYOUT_VSPHERE_USERNAME ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/vsphere-new e2e-password | LAYOUT_VSPHERE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/vsphere-new base-domain | LAYOUT_VSPHERE_BASE_DOMAIN ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')


          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"


          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: vSphere/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: vSphere
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "3e331a3d-8757-41b6-8c7e-4a8f5d2caea9"
          LAYOUT_VSPHERE_USERNAME: ${{ steps.secrets.outputs.LAYOUT_VSPHERE_USERNAME }}
          LAYOUT_VSPHERE_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_VSPHERE_PASSWORD }}
          LAYOUT_VSPHERE_BASE_DOMAIN: ${{ steps.secrets.outputs.LAYOUT_VSPHERE_BASE_DOMAIN }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh run-test' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_VSPHERE_USERNAME=${LAYOUT_VSPHERE_USERNAME:-not_provided}
          export LAYOUT_VSPHERE_PASSWORD=${LAYOUT_VSPHERE_PASSWORD:-not_provided}
          export LAYOUT_VSPHERE_BASE_DOMAIN=${LAYOUT_VSPHERE_BASE_DOMAIN:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh run-test

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: success()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: vSphere
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "3e331a3d-8757-41b6-8c7e-4a8f5d2caea9"
          LAYOUT_VSPHERE_USERNAME: ${{ steps.secrets.outputs.LAYOUT_VSPHERE_USERNAME }}
          LAYOUT_VSPHERE_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_VSPHERE_PASSWORD }}
          LAYOUT_VSPHERE_BASE_DOMAIN: ${{ steps.secrets.outputs.LAYOUT_VSPHERE_BASE_DOMAIN }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_VSPHERE_USERNAME=${LAYOUT_VSPHERE_USERNAME:-not_provided}
          export LAYOUT_VSPHERE_PASSWORD=${LAYOUT_VSPHERE_PASSWORD:-not_provided}
          export LAYOUT_VSPHERE_BASE_DOMAIN=${LAYOUT_VSPHERE_BASE_DOMAIN:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_vsphere_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_vcd_containerd_automatic:
    name: "VCD, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "vcd;Standard;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: VCD
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/vCD password | LAYOUT_VCD_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/vCD login | LAYOUT_VCD_USERNAME ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/vCD server | LAYOUT_VCD_SERVER ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/vCD org | LAYOUT_VCD_ORG ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')

          # Create tmppath for test script.
          TMP_DIR_PATH=/tmp/cloud-layouts/layouts/${DHCTL_PREFIX}
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "dhctl-log-file=${TMP_DIR_PATH}/dhctl.log" >> $GITHUB_OUTPUT
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: VCD/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: VCD
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          LAYOUT_VCD_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_VCD_PASSWORD }}
          LAYOUT_VCD_USERNAME: ${{ steps.secrets.outputs.LAYOUT_VCD_USERNAME }}
          LAYOUT_STATIC_BASTION_IP: 80.249.129.56
          LAYOUT_VCD_SERVER: ${{ steps.secrets.outputs.LAYOUT_VCD_SERVER }}
          LAYOUT_VCD_ORG: ${{ steps.secrets.outputs.LAYOUT_VCD_ORG }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          DHCTL_LOG_FILE: ${{ steps.setup.outputs.dhctl-log-file}}
          STAGE_DECKHOUSE_DOCKERCFG: ${{steps.secrets.outputs.STAGE_DECKHOUSE_DOCKERCFG}}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "

          ls -lh $(pwd)/testing

          dhctl_log_file="${DHCTL_LOG_FILE}-${PROVIDER}-${LAYOUT}-${CRI}-${KUBERNETES_VERSION}"
          echo "DHCTL log file: $dhctl_log_file"

          user_runner_id=$(id -u):$(id -g)
          echo "user_runner_id $user_runner_id"
          docker run --rm \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e MASTERS_COUNT=${MASTERS_COUNT} \
            -e DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG} \
            -e INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e DHCTL_LOG_FILE="/tmp/$(basename ${dhctl_log_file})" \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_VCD_PASSWORD=${LAYOUT_VCD_PASSWORD:-not_provided} \
            -e LAYOUT_VCD_USERNAME=${LAYOUT_VCD_USERNAME:-not_provided} \
            -e LAYOUT_VCD_SERVER=${LAYOUT_VCD_SERVER:-not_provided} \
            -e LAYOUT_VCD_ORG=${LAYOUT_VCD_ORG:-not_provided} \
            -e LAYOUT_STATIC_BASTION_IP=80.249.129.56 \
            -e USER_RUNNER_ID=${user_runner_id} \
            -e FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v $(pwd)/release.yaml:/deckhouse/release.yaml \
            -v ${TMP_DIR_PATH}:/tmp \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: always()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: VCD
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          LAYOUT_VCD_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_VCD_PASSWORD }}
          LAYOUT_VCD_USERNAME: ${{ steps.secrets.outputs.LAYOUT_VCD_USERNAME }}
          LAYOUT_STATIC_BASTION_IP: 80.249.129.56
          LAYOUT_VCD_SERVER: ${{ steps.secrets.outputs.LAYOUT_VCD_SERVER }}
          LAYOUT_VCD_ORG: ${{ steps.secrets.outputs.LAYOUT_VCD_ORG }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          DHCTL_LOG_FILE: ${{ steps.setup.outputs.dhctl-log-file}}
          STAGE_DECKHOUSE_DOCKERCFG: ${{steps.secrets.outputs.STAGE_DECKHOUSE_DOCKERCFG}}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "

          ls -lh $(pwd)/testing

          dhctl_log_file="${DHCTL_LOG_FILE}-${PROVIDER}-${LAYOUT}-${CRI}-${KUBERNETES_VERSION}"
          echo "DHCTL log file: $dhctl_log_file"

          user_runner_id=$(id -u):$(id -g)
          echo "user_runner_id $user_runner_id"
          docker run --rm \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e MASTERS_COUNT=${MASTERS_COUNT} \
            -e DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG} \
            -e INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e DHCTL_LOG_FILE="/tmp/$(basename ${dhctl_log_file})" \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_VCD_PASSWORD=${LAYOUT_VCD_PASSWORD:-not_provided} \
            -e LAYOUT_VCD_USERNAME=${LAYOUT_VCD_USERNAME:-not_provided} \
            -e LAYOUT_VCD_SERVER=${LAYOUT_VCD_SERVER:-not_provided} \
            -e LAYOUT_VCD_ORG=${LAYOUT_VCD_ORG:-not_provided} \
            -e LAYOUT_STATIC_BASTION_IP=80.249.129.56 \
            -e USER_RUNNER_ID=${user_runner_id} \
            -e FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v $(pwd)/release.yaml:/deckhouse/release.yaml \
            -v ${TMP_DIR_PATH}:/tmp \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save dhctl state
        id: save_failed_cluster_state
        if: ${{ !success() }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: failed_cluster_state_vcd_containerd_automatic
          path: |
            ${{ steps.setup.outputs.tmp-dir-path}}/dhctl
            ${{ steps.setup.outputs.tmp-dir-path}}/*.tfstate
            ${{ steps.setup.outputs.tmp-dir-path}}/logs

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_vcd_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_static_containerd_automatic:
    name: "Static, Containerd, Kubernetes Automatic"
    needs:
      - git_info
    outputs:
      ssh_master_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_master_connection_string }}
      ssh_bastion_connection_string: ${{ steps.check_stay_failed_cluster.outputs.ssh_bastion_connection_string }}
      run_id: ${{ github.run_id }}
      # need for find state in artifact
      cluster_prefix: ${{ steps.setup.outputs.dhctl-prefix }}
      ran_for: "static;Static;containerd;Automatic"
      failed_cluster_stayed: ${{ steps.check_stay_failed_cluster.outputs.failed_cluster_stayed }}
      issue_number: ${{ inputs.issue_number }}
      install_image_path: ${{ steps.setup.outputs.install-image-path }}
    env:
      PROVIDER: Static
      CRI: Containerd
      LAYOUT: Static
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          REF_FULL: ${{needs.git_info.outputs.ref_full}}
          INITIAL_REF_SLUG: ${{ github.event.inputs.initial_ref_slug }}
          MANUAL_RUN: "false"
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # GITHUB_RUN_ATTEMPT is a unique number for each attempt of a particular workflow run in a repository.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          # CRI and PROVIDER values are trimmed to reduce prefix length.
          if [[ "${KUBERNETES_VERSION}" == "Automatic" ]] ; then
            KUBERNETES_VERSION_SUF="auto"
          else
            KUBERNETES_VERSION_SUF=${KUBERNETES_VERSION}
          fi
          DHCTL_PREFIX=$(echo "${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION_SUF}")

          if [[ "${MANUAL_RUN}" == "false" ]] ; then
            # for jobs which run multiple providers concurrency (daily e2e, for example)
            # add provider suffix to prevent "directory already exists" error
            DHCTL_PREFIX="${DHCTL_PREFIX}-$(echo ${PROVIDER} | head -c 2)"
          fi
          # converts to DNS-like (all letters in lower case and replace all dots to dash)
          # because it prefix will use for k8s resources names (nodes, for example)
          DHCTL_PREFIX=$(echo "$DHCTL_PREFIX" | tr '.' '-' | tr '[:upper:]' '[:lower:]')


          ## Source: ci_templates/build.yml

          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Use rw-registry for Git tags.
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"

          if [[ "$CI_COMMIT_REF_SLUG" =~ ^release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          else
            # Use dev-registry for Git branches.
            BRANCH_REGISTRY_PATH="${DECKHOUSE_DEV_REGISTRY_HOST}/${REGISTRY_PATH}"
          fi

          if [[ -z ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
            # DECKHOUSE_REGISTRY_HOST is empty, so this repo is not the main repo.
            # Use dev-regisry for branches and Github Container Registry for semver tags.
            SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi

          # Add edition name for non-FE tests on branch
          if [[ -n ${WERF_ENV} && ${WERF_ENV,,} != "fe" ]]; then
            IMAGE_EDITION=${WERF_ENV,,}
          fi

          # Prepare initial image tag for deploy/deckhouse to test switching from previous release.
          INITIAL_IMAGE_TAG=
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INITIAL_IMAGE_TAG=${INITIAL_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}
          fi

          # Prepare image tag for deploy/deckhouse (DECKHOUSE_IMAGE_TAG option in testing/cloud_layouts/script.sh).
          # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
          # Use it as image tag. Add suffix to not overlap with PRs in main repo.
          IMAGE_TAG=${CI_COMMIT_REF_SLUG}${IMAGE_EDITION:+-${IMAGE_EDITION}}${REPO_SUFFIX:+-${REPO_SUFFIX}}

          INSTALL_IMAGE_NAME=
          if [[ -n ${CI_COMMIT_BRANCH} ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${IMAGE_TAG}
          fi
          if [[ -n ${CI_COMMIT_TAG} ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            INSTALL_IMAGE_NAME=${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${CI_COMMIT_REF_SLUG}
          fi
          if [[ -n ${INITIAL_REF_SLUG} ]] ; then
            INSTALL_IMAGE_NAME=${BRANCH_REGISTRY_PATH}/install:${INITIAL_IMAGE_TAG}
            git fetch origin ${INITIAL_REF_SLUG}
            git checkout origin/${INITIAL_REF_SLUG} -- testing/cloud_layouts
          fi
          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"


          IMAGE_INSTALL_PATH="/${INSTALL_IMAGE_NAME#*/}"

          echo '::echo::on'
          echo "dhctl-prefix=${DHCTL_PREFIX}" >> $GITHUB_OUTPUT
          echo "install-image-name=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "install-image-path=${IMAGE_INSTALL_PATH}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: "Run e2e test: Static/Containerd/Automatic"
        id: e2e_test_run
        timeout-minutes: 120
        env:
          PROVIDER: Static
          CRI: Containerd
          LAYOUT: Static
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          INITIAL_IMAGE_TAG: ${{ steps.setup.outputs.initial-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "dbe33391-02c1-4f23-a77b-0edb8b079ff6"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh run-test' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export AWS_ACCESS_KEY_ID=${{ secrets.S3_E2E_ACCESS_KEY_ID }}
          export DECKHOUSE_E2E_DOCKERCFG=${{ secrets.DECKHOUSE_E2E_DOCKERCFG }}
          export DECKHOUSE_E2E_MODULES_DOCKERCFG=${{ secrets.DECKHOUSE_E2E_MODULES_DOCKERCFG }}
          export AWS_SECRET_ACCESS_KEY=${{ secrets.S3_E2E_SECRET_ACCESS_KEY }}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh run-test

        # </template: e2e_run_template>

      - name: Check pause label
        if: ${{ success() && needs.git_info.outputs.pr_number }}
        uses: actions/github-script@v6.4.1
        env:
          PR_NUMBER: ${{needs.git_info.outputs.pr_number}}
        with:
          script: |
            const waitPauseRemove = require('./.github/scripts/js/e2e/wait-remove-pause-label.js')({ github, context, core });
            await waitPauseRemove();

      - name: Cleanup bootstrapped cluster
        if: success()
        id: cleanup_cluster
        timeout-minutes: 60
        env:
          PROVIDER: Static
          CRI: Containerd
          LAYOUT: Static
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          PREFIX: ${{ steps.setup.outputs.dhctl-prefix}}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "dbe33391-02c1-4f23-a77b-0edb8b079ff6"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export AWS_ACCESS_KEY_ID=${{ secrets.S3_E2E_ACCESS_KEY_ID }}
          export DECKHOUSE_E2E_DOCKERCFG=${{ secrets.DECKHOUSE_E2E_DOCKERCFG }}
          export DECKHOUSE_E2E_MODULES_DOCKERCFG=${{ secrets.DECKHOUSE_E2E_MODULES_DOCKERCFG }}
          export AWS_SECRET_ACCESS_KEY=${{ secrets.S3_E2E_SECRET_ACCESS_KEY }}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: ${{ steps.setup.outputs.dhctl-log-file }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: test_output_static_containerd_automatic
          path: |
            ${{ steps.setup.outputs.dhctl-log-file}}*
            ${{ steps.setup.outputs.tmp-dir-path}}/logs
            testing/cloud_layouts/
            !testing/cloud_layouts/**/sshkey

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
  # </template: e2e_run_job_template>


  send_alert_about_workflow_problem:
    name: Send alert about workflow problem
    runs-on: "regular"
    needs: ["skip_tests_repos","git_info","run_aws_containerd_automatic","run_eks_containerd_automatic","run_azure_containerd_automatic","run_gcp_containerd_automatic","run_yandex_cloud_containerd_automatic","run_openstack_containerd_automatic","run_vsphere_containerd_automatic","run_vcd_containerd_automatic","run_static_containerd_automatic"]
    if: ${{ failure() && github.repository == 'deckhouse/deckhouse' }}
    steps:
    # <template: send_alert_loop_template>
    - name: Check loop alerting credentials
      id: check_loop_alerting
      if: always()
      env:
        LOOP_TOKEN: ${{secrets.LOOP_CVE_REPORTS_SEND_TOKEN}}
      run: |
        if [[ -n $LOOP_TOKEN ]]; then echo "has_credentials=true" >> $GITHUB_OUTPUT; fi
    - name: Send loop alert on fail
      if: ${{ steps.check_loop_alerting.outputs.has_credentials == 'true' }}
      env:
        LOOP_TOKEN: ${{secrets.LOOP_CVE_REPORTS_SEND_TOKEN}}
        LOOP_CHANEL_ID: ${{secrets.LOOP_E2E_REPORT_CHANEL_ID}}
      run: |
        WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"

        alertData=$(cat <<EOF
        {
        "channel_id": "${LOOP_CHANEL_ID}",
        "message": "🛑Daily e2e test failure🛑\n[URL](${WORKFLOW_URL})"
        }
        EOF
        )

        for (( iter = 1; iter < 60; iter++ )); do
          if curl -f -L -X POST "https://loop.flant.ru/api/v4/posts" -H "Content-Type: application/json" -H "Authorization: Bearer ${LOOP_TOKEN}" --data "${alertData}"; then
            exit 0
          fi

          echo "Alert was not sent. Wait 5 seconds before next attempt"
          sleep 5
        done

        echo "Alert was not sent. Timeout"
        exit 1
      # </template: send_alert_loop_template>