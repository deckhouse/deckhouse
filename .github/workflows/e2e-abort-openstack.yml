#
# THIS FILE IS GENERATED, PLEASE DO NOT EDIT.
#

# <template: e2e_workflow_template>
name: 'destroy cluster: OpenStack'
on:
  workflow_dispatch:
    inputs:
      run_id:
        description: 'GitHub Action running id with failed e2e test'
        required: true
      state_artifact_name:
        description: 'GitHub artifact name with dhctl/terraform status'
        required: true
      cluster_prefix:
        description: 'Dhctl cluster prefix'
        required: true
      issue_number:
        description: 'ID of comment in issue with creation message'
        required: true
      comment_id:
        description: 'ID of comment in issue where to put workflow run status'
        required: true
      layout:
        description: 'Cloud provider layout which was tested'
        required: true
      test_config:
        description: 'JSON string of parameters which was tested'
        required: false
        default: '{"cri":"Containerd","ver":"1.29","edition":"FE"}'
      # needs for run correct installer image for abort
      installer_image_path:
        description: 'Installer image without host'
        required: true
      # needs for destroy cloud clusters if cluster was bootstrapped fully, but e2e was not pass
      ssh_master_connection_string:
        description: 'SSH connection string'
        required: false
env:

  # <template: werf_envs>
  WERF_VERSION: "v2.46.0"
  WERF_ENV: "FE"
  WERF_TELEMETRY_EXTRA_ATTRIBUTE_TEAM: "flantTeam=deckhouse/core"
  TEST_TIMEOUT: "15m"
  # Use fixed string 'sys/deckhouse-oss' for repo name. ${CI_PROJECT_PATH} is not available here in GitHub.
  REGISTRY_PATH: "sys/deckhouse-oss"
  # Registry for additional repositories used for testing Github Actions workflows.
  GHA_TEST_REGISTRY_PATH: "ghcr.io/${{ github.repository }}"
  # Need for ssh: default.
  DOCKER_BUILDKIT: "1"
  WERF_FINAL_IMAGES_ONLY: true
  WERF_LOG_TERMINAL_WIDTH: "200"
  WERF_LOG_TIME: true
  WERF_GIT_WORK_TREE_POOL_LIMIT: "10"
  GOPROXY: "${{vars.GOPROXY}}"
  # </template: werf_envs>

# Note: no concurrency section for e2e workflows.
# Usually you run e2e and wait until it ends.

permissions:
  contents: read
  id-token: write

jobs:
  started_at:
    name: Save start timestamp
    outputs:
      started_at: ${{ steps.started_at.outputs.started_at }}
    runs-on: "regular"
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

  # <template: check_e2e_labels_job>
  check_e2e_labels:
    name: Check e2e labels
    runs-on: "regular"
    permissions:
      contents: read
      issues: write
      pull-requests: write
    outputs:

      run_containerd_1_29: ${{ steps.check.outputs.run_containerd_1_29 }}
      run_containerd_1_30: ${{ steps.check.outputs.run_containerd_1_30 }}
      run_containerd_1_31: ${{ steps.check.outputs.run_containerd_1_31 }}
      run_containerd_1_32: ${{ steps.check.outputs.run_containerd_1_32 }}
      run_containerd_1_33: ${{ steps.check.outputs.run_containerd_1_33 }}
      run_containerd_1_34: ${{ steps.check.outputs.run_containerd_1_34 }}
      run_containerd_automatic: ${{ steps.check.outputs.run_containerd_automatic }}
      run_containerdv2_1_29: ${{ steps.check.outputs.run_containerdv2_1_29 }}
      run_containerdv2_1_30: ${{ steps.check.outputs.run_containerdv2_1_30 }}
      run_containerdv2_1_31: ${{ steps.check.outputs.run_containerdv2_1_31 }}
      run_containerdv2_1_32: ${{ steps.check.outputs.run_containerdv2_1_32 }}
      run_containerdv2_1_33: ${{ steps.check.outputs.run_containerdv2_1_33 }}
      run_containerdv2_1_34: ${{ steps.check.outputs.run_containerdv2_1_34 }}
      run_containerdv2_automatic: ${{ steps.check.outputs.run_containerdv2_automatic }}
      edition: ${{ steps.check.outputs.edition }}
      multimaster: ${{ steps.check.outputs.multimaster }}
      cis: ${{ steps.check.outputs.cis }}
      autoscaler: ${{ steps.check.outputs.autoscaler }}
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2

      # </template: checkout_step>
      - name: Check e2e labels
        id: check
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{ secrets.GITHUB_TOKEN }}
          script: |
            const provider = 'openstack';
            const kubernetesDefaultVersion = '1.32';

            const ci = require('./.github/scripts/js/ci');
            return await ci.checkE2ELabels({github, context, core, provider, kubernetesDefaultVersion});
  # </template: check_e2e_labels_job>



  # <template: e2e_run_job_template>
  run_containerd_1_29:
    name: "destroy cluster: OpenStack, Containerd, Kubernetes 1.29"
    if: ${{ fromJson(inputs.test_config).cri == 'containerd' && fromJson(inputs.test_config).ver == '1.29' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.29"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.29';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.29"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.29';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_30:
    name: "destroy cluster: OpenStack, Containerd, Kubernetes 1.30"
    if: ${{ fromJson(inputs.test_config).cri == 'containerd' && fromJson(inputs.test_config).ver == '1.30' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.30"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.30';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.30"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.30';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_31:
    name: "destroy cluster: OpenStack, Containerd, Kubernetes 1.31"
    if: ${{ fromJson(inputs.test_config).cri == 'containerd' && fromJson(inputs.test_config).ver == '1.31' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.31"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.31';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.31"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.31';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_32:
    name: "destroy cluster: OpenStack, Containerd, Kubernetes 1.32"
    if: ${{ fromJson(inputs.test_config).cri == 'containerd' && fromJson(inputs.test_config).ver == '1.32' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.32"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.32';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.32"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.32';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_33:
    name: "destroy cluster: OpenStack, Containerd, Kubernetes 1.33"
    if: ${{ fromJson(inputs.test_config).cri == 'containerd' && fromJson(inputs.test_config).ver == '1.33' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.33"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.33';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.33"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.33';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_34:
    name: "destroy cluster: OpenStack, Containerd, Kubernetes 1.34"
    if: ${{ fromJson(inputs.test_config).cri == 'containerd' && fromJson(inputs.test_config).ver == '1.34' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.34"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.34';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.34"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes 1.34';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_automatic:
    name: "destroy cluster: OpenStack, Containerd, Kubernetes Automatic"
    if: ${{ fromJson(inputs.test_config).cri == 'containerd' && fromJson(inputs.test_config).ver == 'Automatic' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes Automatic';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, Containerd, Kubernetes Automatic';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerdv2_1_29:
    name: "destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.29"
    if: ${{ fromJson(inputs.test_config).cri == 'containerdv2' && fromJson(inputs.test_config).ver == '1.29' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: ContainerdV2
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.29"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.29';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: ContainerdV2
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.29"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.29';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerdv2_1_30:
    name: "destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.30"
    if: ${{ fromJson(inputs.test_config).cri == 'containerdv2' && fromJson(inputs.test_config).ver == '1.30' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: ContainerdV2
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.30"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.30';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: ContainerdV2
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.30"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.30';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerdv2_1_31:
    name: "destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.31"
    if: ${{ fromJson(inputs.test_config).cri == 'containerdv2' && fromJson(inputs.test_config).ver == '1.31' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: ContainerdV2
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.31"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.31';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: ContainerdV2
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.31"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.31';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerdv2_1_32:
    name: "destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.32"
    if: ${{ fromJson(inputs.test_config).cri == 'containerdv2' && fromJson(inputs.test_config).ver == '1.32' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: ContainerdV2
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.32"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.32';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: ContainerdV2
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.32"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.32';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerdv2_1_33:
    name: "destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.33"
    if: ${{ fromJson(inputs.test_config).cri == 'containerdv2' && fromJson(inputs.test_config).ver == '1.33' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: ContainerdV2
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.33"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.33';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: ContainerdV2
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.33"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.33';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerdv2_1_34:
    name: "destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.34"
    if: ${{ fromJson(inputs.test_config).cri == 'containerdv2' && fromJson(inputs.test_config).ver == '1.34' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: ContainerdV2
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.34"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.34';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: ContainerdV2
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.34"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.34';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerdv2_automatic:
    name: "destroy cluster: OpenStack, ContainerdV2, Kubernetes Automatic"
    if: ${{ fromJson(inputs.test_config).cri == 'containerdv2' && fromJson(inputs.test_config).ver == 'Automatic' && github.event.inputs.layout == 'Standard' }}
    env:
      PROVIDER: OpenStack
      CRI: ContainerdV2
      LAYOUT: Standard
      KUBERNETES_VERSION: "Automatic"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes Automatic';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/LAYOUT_STAGE_DECKHOUSE_DOCKERCFG DOCKERCFG | LAYOUT_STAGE_DECKHOUSE_DOCKERCFG ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/e2e/e2e-os-password password | LAYOUT_OS_PASSWORD ;

      # </template: import_secrets>

      # <template: login_dev_registry_step>
      - name: Check dev registry credentials
        id: check_dev_registry
        env:
          HOST: ${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to dev registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_dev_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_DEV_REGISTRY_HOST }}
          DECKHOUSE_REGISTRY_STAGE_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          DHCTL_PREFIX: ${{ github.event.inputs.cluster_prefix }}
          INSTALL_IMAGE_PATH: ${{ github.event.inputs.installer_image_path }}
          MULTIMASTER: ${{ needs.check_e2e_labels.outputs.multimaster }}
        run: |
          # Create tmppath for test script.
          TMP_DIR_PATH="/tmp/cloud-layouts/layouts/${GITHUB_RUN_ID}-${GITHUB_RUN_ATTEMPT}-${DHCTL_PREFIX}"
          if [[ -d "${TMP_DIR_PATH}" ]] ; then
            echo "Temporary dir already exists: ${TMP_DIR_PATH}. ERROR!"
            ls -la ${TMP_DIR_PATH}
            exit 1
          else
            echo "Create temporary dir for job: ${TMP_DIR_PATH}."
            mkdir -p "${TMP_DIR_PATH}"
          fi

          if [[ "$INSTALL_IMAGE_PATH" =~ release-[0-9]+\.[0-9]+ ]]; then
            # Use stage-registry for release branches.
            DECKHOUSE_REGISTRY_HOST=${DECKHOUSE_REGISTRY_STAGE_HOST}
          fi

          INSTALL_IMAGE_NAME="${DECKHOUSE_REGISTRY_HOST:-}${INSTALL_IMAGE_PATH}"

          SAFE_IMAGE_NAME=$(echo ${INSTALL_IMAGE_NAME} | tr '[:lower:]' '[:upper:]')
          echo "Deckhouse Deployment will use install image ${SAFE_IMAGE_NAME} to test Git ref ${REF_FULL}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "⚓️ [$(date -u)] Pull 'dev/install' image '${SAFE_IMAGE_NAME}'."
          docker pull "${INSTALL_IMAGE_NAME}"

          arrPath=(${INSTALL_IMAGE_PATH//:/ })
          DECKHOUSE_IMAGE_TAG="${arrPath[1]}"

          if [ "${MULTIMASTER}" == true ] ; then
            MASTERS_COUNT=3
          else
            MASTERS_COUNT=1
          fi
          echo "Multimaster set ${MULTIMASTER}, MASTERS_COUNT set ${MASTERS_COUNT}"

          echo '::echo::on'
          echo "tmp-dir-path=${TMP_DIR_PATH}" >> $GITHUB_OUTPUT
          echo "install-image-full=${INSTALL_IMAGE_NAME}" >> $GITHUB_OUTPUT
          echo "deckhouse-image-tag=${DECKHOUSE_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "initial-image-tag=${INITIAL_IMAGE_TAG}" >> $GITHUB_OUTPUT
          echo "masters-count=${MASTERS_COUNT}" >> $GITHUB_OUTPUT

          echo '::echo::off'

      - name: Cleanup bootstrapped cluster
        if: ${{ success() || cancelled() }}
        id: cleanup_cluster
        env:
          PROVIDER: OpenStack
          CRI: ContainerdV2
          LAYOUT: Standard
          KUBERNETES_VERSION: "Automatic"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_STAGE_DECKHOUSE_DOCKERCFG: ${{ steps.secrets.outputs.LAYOUT_STAGE_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          TMP_DIR_PATH: ${{ steps.setup.outputs.tmp-dir-path}}
          PREFIX: ${{ github.event.inputs.cluster_prefix }}
          MASTERS_COUNT: ${{ steps.setup.outputs.masters-count }}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-full }}
          DECKHOUSE_IMAGE_TAG: ${{ steps.setup.outputs.deckhouse-image-tag }}
          SSH_MASTER_CONNECTION_STRING: ${{ github.event.inputs.ssh_master_connection_string }}
        # <template: e2e_run_template>
          TEMPLATE_ID: "cb79a126-4234-4dac-a01e-2d3804266e3e"
          LAYOUT_OS_PASSWORD: ${{ steps.secrets.outputs.LAYOUT_OS_PASSWORD }}
          COMMENT_ID: ${{ inputs.comment_id }}
          GITHUB_API_SERVER: ${{ github.api_url }}
          REPOSITORY: ${{ github.repository }}
          GITHUB_TOKEN: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          COMMANDER_TOKEN: ${{secrets.E2E_COMMANDER_TOKEN}}
          COMMANDER_HOST: ${{secrets.E2E_COMMANDER_HOST}}
        run: |
          echo "Execute 'script-commander.sh cleanup' via 'shell', using environment:
            INSTALL_IMAGE_NAME=${INSTALL_IMAGE_NAME}
            DECKHOUSE_IMAGE_TAG=${DECKHOUSE_IMAGE_TAG}
            INITIAL_IMAGE_TAG=${INITIAL_IMAGE_TAG}
            PREFIX=${PREFIX}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            TMP_DIR_PATH=${TMP_DIR_PATH}
            MASTERS_COUNT=${MASTERS_COUNT}
          "


          export DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG}
          export STAGE_DECKHOUSE_DOCKERCFG=${LAYOUT_STAGE_DECKHOUSE_DOCKERCFG}
          export PROVIDER=${PROVIDER:-not_provided}
          export MASTER_CONNECTION_STRING=${SSH_MASTER_CONNECTION_STRING:-}
          export LAYOUT=${LAYOUT:-not_provided}
          export SSH_KEY=${LAYOUT_SSH_KEY:-not_provided}
          export LAYOUT_OS_PASSWORD=${LAYOUT_OS_PASSWORD:-not_provided}
          export FOX_DOCKERCFG=${{ secrets.FOX_DOCKERCFG }}

          # for logs upload
          ssh_connect_str_file="ssh-connect_str-${PREFIX}"
          echo "ssh_connection_str_file=${ssh_connect_str_file}" >> $GITHUB_OUTPUT

          bash $(pwd)/testing/cloud_layouts/script-commander.sh cleanup

        # </template: e2e_run_template>

      - name: Remove failed cluster label
        if: ${{ success() }}
        uses: actions-ecosystem/action-remove-labels@v1
        with:
          github_token: ${{ secrets.BOATSWAIN_GITHUB_TOKEN }}
          number: ${{ github.event.inputs.issue_number }}
          labels: "e2e/cluster/failed"

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi
          if [ -n $USER_RUNNER_ID ]; then
            echo "Fix temp directories owner..."
            chown -R $USER_RUNNER_ID "$(pwd)/testing" || true
            chown -R $USER_RUNNER_ID "/deckhouse/testing" || true
            chown -R $USER_RUNNER_ID /tmp || true
          else
            echo "Fix temp directories permissions..."
            chmod -f -R 777 "$(pwd)/testing" || true
            chmod -f -R 777 "/deckhouse/testing" || true
            chmod -f -R 777 /tmp || true
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'job,separate';
            const name = 'destroy cluster: OpenStack, ContainerdV2, Kubernetes Automatic';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
  # </template: e2e_run_job_template>


  last_comment:
    name: Update comment on finish
    needs: ["started_at","run_containerd_1_29","run_containerd_1_30","run_containerd_1_31","run_containerd_1_32","run_containerd_1_33","run_containerd_1_34","run_containerd_automatic","run_containerdv2_1_29","run_containerdv2_1_30","run_containerdv2_1_31","run_containerdv2_1_32","run_containerdv2_1_33","run_containerdv2_1_34","run_containerdv2_automatic"]
    if: ${{ always() }}
    runs-on: "regular"
    env:
      JOB_NAMES: |
        {"run_containerd_1_29":"destroy cluster: OpenStack, Containerd, Kubernetes 1.29","run_containerd_1_30":"destroy cluster: OpenStack, Containerd, Kubernetes 1.30","run_containerd_1_31":"destroy cluster: OpenStack, Containerd, Kubernetes 1.31","run_containerd_1_32":"destroy cluster: OpenStack, Containerd, Kubernetes 1.32","run_containerd_1_33":"destroy cluster: OpenStack, Containerd, Kubernetes 1.33","run_containerd_1_34":"destroy cluster: OpenStack, Containerd, Kubernetes 1.34","run_containerd_automatic":"destroy cluster: OpenStack, Containerd, Kubernetes Automatic","run_containerdv2_1_29":"destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.29","run_containerdv2_1_30":"destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.30","run_containerdv2_1_31":"destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.31","run_containerdv2_1_32":"destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.32","run_containerdv2_1_33":"destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.33","run_containerdv2_1_34":"destroy cluster: OpenStack, ContainerdV2, Kubernetes 1.34","run_containerdv2_automatic":"destroy cluster: OpenStack, ContainerdV2, Kubernetes Automatic"}
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2

      # </template: checkout_step>
      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v6.4.1
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          retries: 3
          script: |
            const statusConfig = 'workflow,final,no-skipped,restore-separate';
            const name = 'destroy cluster: OpenStack';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

# </template: e2e_workflow_template>
