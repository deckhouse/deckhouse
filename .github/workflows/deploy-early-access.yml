#
# THIS FILE IS GENERATED, PLEASE DO NOT EDIT.
#

# Copyright 2022 Flant JSC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.


name: 'Deploy to early-access'

on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: 'Id of issue where label was set'
        required: false
      issue_number:
        description: 'Number of issue where label was set'
        required: false
      comment_id:
        description: 'Id of comment in issue where to put workflow run status'
        required: false
      editions:
        description: 'Comma separated editions to deploy. Example: ee,fe,ce,be,se,se-plus'
        required: false
      cooldown:
        description: 'Postpone release until specified datetime (YYYY-MM-DD HH:MM) UTC only. Example: 2026-06-06 16:16'
        required: false

env:

  # <template: werf_envs>
  WERF_CHANNEL: "alpha"
  WERF_ENV: "FE"
  TEST_TIMEOUT: "15m"
  # Use fixed string 'sys/deckhouse-oss' for repo name. ${CI_PROJECT_PATH} is not available here in GitHub.
  DEV_REGISTRY_PATH: "${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}/sys/deckhouse-oss"
  # Registry for additional repositories used for testing Github Actions workflows.
  GHA_TEST_REGISTRY_PATH: "ghcr.io/${{ github.repository }}"
  # Need for ssh: default.
  DOCKER_BUILDKIT: "1"
  WERF_LOG_TERMINAL_WIDTH: "200"
  # </template: werf_envs>
  DEPLOY_CHANNEL: early-access

jobs:

  # <template: git_info_job>

  git_info:
    name: Get git info
    runs-on: ubuntu-latest
    outputs:
      ci_commit_tag: ${{ steps.git_info.outputs.ci_commit_tag }}
      ci_commit_branch: ${{ steps.git_info.outputs.ci_commit_branch }}
      ci_commit_ref_name: ${{ steps.git_info.outputs.ci_commit_ref_name }}
      ci_commit_ref_slug: ${{ steps.git_info.outputs.ci_commit_ref_slug }}
      ref_full: ${{ steps.git_info.outputs.ref_full }}
      github_sha: ${{ steps.git_info.outputs.github_sha }}
      pr_number: ${{ steps.git_info.outputs.pr_number }}
    # Skip the CI for automation PRs, e.g. changelog
    if: ${{ github.event.pull_request.user.login != 'deckhouse-BOaTswain' }}
    steps:
      - id: git_info
        name: Get tag name and SHA
        uses: actions/github-script@v6.4.1
        with:
          script: |
            const { GITHUB_REF_TYPE, GITHUB_REF_NAME, GITHUB_REF } = process.env

            let refSlug = ''
            let refName = ''
            let refFull = ''
            let githubBranch = ''
            let githubTag = ''
            let githubSHA = ''
            let prNumber = ''
            if (context.eventName === "workflow_dispatch" && context.payload.inputs && context.payload.inputs.pull_request_ref) {
              // Trigger: workflow_dispatch with pull_request_ref.
              // Extract pull request number from 'refs/pull/<NUM>/merge'
              prNumber = context.payload.inputs.pull_request_ref.replace('refs/pull/', '').replace('/merge', '').replace('/head', '')

              refSlug       = `pr${prNumber}`
              refName       = context.payload.inputs.ci_commit_ref_name
              refFull       = context.payload.inputs.pull_request_ref
              githubBranch  = refName
              githubSHA     = context.payload.inputs.pull_request_sha
              core.info(`workflow_dispatch event: set git info from inputs. inputs: ${JSON.stringify(context.payload.inputs)}`)
            } else if (context.eventName === "pull_request" || context.eventName === "pull_request_target" ) {
              // For PRs from forks, tag images with `prXXX` to avoid clashes between branches.
              const targetRepo = context.payload.repository.full_name;
              const prRepo = context.payload.pull_request.head.repo.full_name
              const prRef = context.payload.pull_request.head.ref

              refSlug = `pr${context.issue.number}`;
              refName = (prRepo === targetRepo) ? prRef : refSlug;
              refFull = `refs/pull/${context.issue.number}/head`
              githubBranch = refName
              githubSHA = context.payload.pull_request.head.sha
              core.info(`pull request event: set git info from pull_request.head. pr:${prRepo}:${prRef} target:${targetRepo}:${context.ref}`)
              prNumber = context.issue.number
            } else {
              // Other triggers: workflow_dispatch without pull_request_ref, schedule, push...
              // refName is 'main' or tag name, so slugification is not necessary.
              refSlug       = GITHUB_REF_NAME
              refName       = GITHUB_REF_NAME
              refFull       = GITHUB_REF
              githubTag     = GITHUB_REF_TYPE == "tag"    ? refName : ""
              githubBranch  = GITHUB_REF_TYPE == "branch" ? refName : ""
              githubSHA     = context.sha
              core.info(`${context.eventName} event: set git info from context: ${JSON.stringify({GITHUB_REF_NAME, GITHUB_REF_TYPE, sha: context.sha })}`)
            }

            core.setCommandEcho(true)
            core.setOutput('ci_commit_ref_slug', refSlug)
            core.setOutput('ci_commit_ref_name', refName)
            core.setOutput(`ci_commit_tag`, githubTag)
            core.setOutput(`ci_commit_branch`, githubBranch)
            core.setOutput(`ref_full`, refFull)
            core.setOutput('github_sha', githubSHA)
            core.setOutput('pr_number', prNumber)
            core.setCommandEcho(false)

  # </template: git_info_job>
  detect_editions:
    name: Detect editions
    runs-on: ubuntu-latest
    outputs:
      DEPLOY_CE: ${{steps.detect_editions.outputs.DEPLOY_CE}}
      DEPLOY_EE: ${{steps.detect_editions.outputs.DEPLOY_EE}}
      DEPLOY_FE: ${{steps.detect_editions.outputs.DEPLOY_FE}}
      DEPLOY_BE: ${{steps.detect_editions.outputs.DEPLOY_BE}}
      DEPLOY_SE: ${{steps.detect_editions.outputs.DEPLOY_SE}}
      DEPLOY_SE-plus: ${{steps.detect_editions.outputs.DEPLOY_SE-plus}}
    steps:
      - name: Detect editions
        id: detect_editions
        env:
          EDITIONS: ${{ github.event.inputs.editions }}
        run: |
          echo "Input allowed editions: '${EDITIONS}'"

          RESTRICTED=no

          for edition in CE EE FE BE SE SE-plus ; do
            if grep -i ",${edition}," <<<",${EDITIONS}," 2>/dev/null 1>&2 ; then
              echo "  - enable deploy of ${edition} edition."
              echo "DEPLOY_${edition}=true" >> $GITHUB_OUTPUT
              RESTRICTED=yes
            fi
          done

          if [[ $RESTRICTED == "no" ]] ; then
            echo "No restrictions. Enable deploy to all editions."
            for edition in CE EE FE BE SE SE-plus ; do
              echo "DEPLOY_${edition}=true" >> $GITHUB_OUTPUT
            done
          fi



  enable_CE:
    if: ${{ needs.detect_editions.outputs.DEPLOY_CE == 'true' }}
    name: Enable CE
    needs:
      - detect_editions
    runs-on: ubuntu-latest
    steps:
      - run: ": Enable CE"

  enable_EE:
    if: ${{ needs.detect_editions.outputs.DEPLOY_EE == 'true' }}
    name: Enable EE
    needs:
      - detect_editions
    runs-on: ubuntu-latest
    steps:
      - run: ": Enable EE"

  enable_FE:
    if: ${{ needs.detect_editions.outputs.DEPLOY_FE == 'true' }}
    name: Enable FE
    needs:
      - detect_editions
    runs-on: ubuntu-latest
    steps:
      - run: ": Enable FE"

  enable_BE:
    if: ${{ needs.detect_editions.outputs.DEPLOY_BE == 'true' }}
    name: Enable BE
    needs:
      - detect_editions
    runs-on: ubuntu-latest
    steps:
      - run: ": Enable BE"

  enable_SE:
    if: ${{ needs.detect_editions.outputs.DEPLOY_SE == 'true' }}
    name: Enable SE
    needs:
      - detect_editions
    runs-on: ubuntu-latest
    steps:
      - run: ": Enable SE"

  enable_SE-plus:
    if: ${{ needs.detect_editions.outputs.DEPLOY_SE-plus == 'true' }}
    name: Enable SE-plus
    needs:
      - detect_editions
    runs-on: ubuntu-latest
    steps:
      - run: ": Enable SE-plus"


  run_deploy:
    name: Deploy ${{needs.git_info.outputs.ci_commit_tag}} to early-access
    environment:
      name: early-access
    needs:
      - git_info
      - detect_editions
    runs-on: [self-hosted, regular]
    steps:

      - name: Run deploy stub
        run: exit 0

  prepare_channel_releases:
    name: Prepare channel releases
    runs-on: [self-hosted, regular]
    needs:
      - run_deploy
    steps:
      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2

      # </template: checkout_step>

      - name: Setup Python
        uses: actions/setup-python@v5
        with:
          python-version: '3.12.3'

      - name: Install dependencies
        run: pip install ghapi fastcore

      - name: Prepare files for collecting and deployment
        run: |
          mkdir -p publish-channels/.helm/templates
          tee publish-channels/werf.yaml << EOF
          project: deckhouse-channels
          configVersion: 1
          EOF

          tee publish-channels/.helm/templates/configmap.yaml << EOF
          apiVersion: v1
          kind: ConfigMap
          metadata:
            name: release-channels-data
          data:
            channels.yaml: |
          {{ $.Files.Get "channels.yaml" | indent 4 }}
          EOF

      - name: Generate channel releases config map
        run: python .github/scripts/python/generate-channel-releases-cm.py
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload artifacts
        uses: actions/upload-artifact@v4.4.0
        with:
          name: channels-artifact
          path: publish-channels
          include-hidden-files: true


  deploy_channels_cm_stage:
    name: "Deploy channels to staging"
    runs-on: [self-hosted, regular]
    needs:
      - prepare_channel_releases
    env:
      WERF_CHANNEL: "ea"
    steps:
      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2

      # </template: checkout_step>

      - name: Download artifacts
        uses: actions/download-artifact@v4.1.8
        with:
          name: channels-artifact
          path: publish-channels

      - name: Check artifacts
        run: |
          echo "Check working file structure"
          ls -1AR publish-channels

          echo "Print content of werf.yaml"
          cat publish-channels/werf.yaml

          echo "Print content of configmap.yaml"
          cat publish-channels/.helm/templates/configmap.yaml

          echo "Print content of channels.yaml"
          cat publish-channels/.helm/channels.yaml

      - name: Converge
        uses: werf/actions/converge@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
          kube-config-base64-data: "${{ secrets.KUBECONFIG_BASE64_DEV }}"
          env: web-stage
        env:
          WERF_NAMESPACE: "deckhouse-web-stage"
          WERF_DIR: "publish-channels"
          WERF_DEV: "true"

