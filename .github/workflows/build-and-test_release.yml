#
# THIS FILE IS GENERATED, PLEASE DO NOT EDIT.
#

# Copyright 2022 Flant JSC
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

# on push to tags

name: Build and test for release

on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: 'Id of issue where label was set'
        required: false
      issue_number:
        description: 'Number of issue where label was set'
        required: false
      comment_id:
        description: 'Id of comment in issue where to put workflow run status'
        required: false
      editions:
        description: 'Comma-separated list of editions to build'
        required: false
        type: string
      svace_enabled:
        description: 'Enable svace build and analyze'
        type: boolean
        required: false

env:

  # <template: werf_envs>
  WERF_VERSION: "v2.46.0"
  WERF_ENV: "FE"
  TEST_TIMEOUT: "15m"
  # Use fixed string 'sys/deckhouse-oss' for repo name. ${CI_PROJECT_PATH} is not available here in GitHub.
  REGISTRY_PATH: "sys/deckhouse-oss"
  # Registry for additional repositories used for testing Github Actions workflows.
  GHA_TEST_REGISTRY_PATH: "ghcr.io/${{ github.repository }}"
  # Need for ssh: default.
  DOCKER_BUILDKIT: "1"
  WERF_FINAL_IMAGES_ONLY: true
  WERF_LOG_TERMINAL_WIDTH: "200"
  WERF_LOG_TIME: true
  WERF_GIT_WORK_TREE_POOL_LIMIT: "10"
  GOPROXY: "${{vars.GOPROXY}}"
  # </template: werf_envs>

# Cancel in-progress jobs for the same tag/branch.
concurrency:
  group: ${{ github.workflow }}-${{ github.ref }}
  cancel-in-progress: true

permissions:
  contents: read
  id-token: write
  pull-requests: read

jobs:

  # <template: git_info_job>

  git_info:
    name: Get git info
    runs-on: "regular"
    outputs:
      ci_commit_tag: ${{ steps.git_info.outputs.ci_commit_tag }}
      ci_commit_branch: ${{ steps.git_info.outputs.ci_commit_branch }}
      ci_commit_ref_name: ${{ steps.git_info.outputs.ci_commit_ref_name }}
      ci_commit_ref_slug: ${{ steps.git_info.outputs.ci_commit_ref_slug }}
      ref_full: ${{ steps.git_info.outputs.ref_full }}
      github_sha: ${{ steps.git_info.outputs.github_sha }}
      pr_number: ${{ steps.git_info.outputs.pr_number }}
    # Skip the CI for automation PRs, e.g. changelog, don't skip if Pull Request title contains "[run ci]".
    if: ${{ contains(github.event.pull_request.title, '[run ci]') || github.event.pull_request.user.login != 'deckhouse-BOaTswain' }}
    steps:
      - id: git_info
        name: Get tag name and SHA
        uses: actions/github-script@v6.4.1
        with:
          script: |
            const { GITHUB_REF_TYPE, GITHUB_REF_NAME, GITHUB_REF } = process.env

            let refSlug = ''
            let refName = ''
            let refFull = ''
            let githubBranch = ''
            let githubTag = ''
            let githubSHA = ''
            let prNumber = ''
            if (context.eventName === "workflow_dispatch" && context.payload.inputs && context.payload.inputs.pull_request_ref) {
              // Trigger: workflow_dispatch with pull_request_ref.
              // Extract pull request number from 'refs/pull/<NUM>/merge'
              prNumber = context.payload.inputs.pull_request_ref.replace('refs/pull/', '').replace('/merge', '').replace('/head', '')

              refSlug       = `pr${prNumber}`
              refName       = context.payload.inputs.ci_commit_ref_name
              refFull       = context.payload.inputs.pull_request_ref
              githubBranch  = refName
              githubSHA     = context.payload.inputs.pull_request_sha
              core.info(`workflow_dispatch event: set git info from inputs. inputs: ${JSON.stringify(context.payload.inputs)}`)
            } else if (context.eventName === "pull_request" || context.eventName === "pull_request_target" ) {
              // For PRs from forks, tag images with `prXXX` to avoid clashes between branches.
              const targetRepo = context.payload.repository.full_name;
              const prRepo = context.payload.pull_request.head.repo.full_name
              const prRef = context.payload.pull_request.head.ref

              refSlug = `pr${context.issue.number}`;
              refName = (prRepo === targetRepo) ? prRef : refSlug;
              refFull = `refs/pull/${context.issue.number}/head`
              githubBranch = refName
              githubSHA = context.payload.pull_request.head.sha
              core.info(`pull request event: set git info from pull_request.head. pr:${prRepo}:${prRef} target:${targetRepo}:${context.ref}`)
              prNumber = context.issue.number
            } else {
              // Other triggers: workflow_dispatch without pull_request_ref, schedule, push...
              // refName is 'main' or tag name, so slugification is not necessary.
              refSlug       = GITHUB_REF_NAME
              refName       = GITHUB_REF_NAME
              refFull       = GITHUB_REF
              githubTag     = GITHUB_REF_TYPE == "tag"    ? refName : ""
              githubBranch  = GITHUB_REF_TYPE == "branch" ? refName : ""
              githubSHA     = context.sha
              core.info(`${context.eventName} event: set git info from context: ${JSON.stringify({GITHUB_REF_NAME, GITHUB_REF_TYPE, sha: context.sha })}`)
            }

            core.setCommandEcho(true)
            core.setOutput('ci_commit_ref_slug', refSlug)
            core.setOutput('ci_commit_ref_name', refName)
            core.setOutput(`ci_commit_tag`, githubTag)
            core.setOutput(`ci_commit_branch`, githubBranch)
            core.setOutput(`ref_full`, refFull)
            core.setOutput('github_sha', githubSHA)
            core.setOutput('pr_number', prNumber)
            core.setCommandEcho(false)

  # </template: git_info_job>
  detect_editions:
    name: Detect editions
    runs-on: "regular"
    outputs:
      BUILD_CE: ${{steps.detect_editions.outputs.BUILD_CE}}
      BUILD_EE: ${{steps.detect_editions.outputs.BUILD_EE}}
      BUILD_BE: ${{steps.detect_editions.outputs.BUILD_BE}}
      BUILD_SE: ${{steps.detect_editions.outputs.BUILD_SE}}
      BUILD_SE-plus: ${{steps.detect_editions.outputs.BUILD_SE-plus}}
    steps:
      - name: Detect editions
        id: detect_editions
        env:
          EDITIONS: ${{ github.event.inputs.editions }}
        run: |
          echo "Input allowed editions: '${EDITIONS}'"

          EMPTY_EDITIONS=yes

          for edition in CE EE BE SE SE-plus ; do
            if grep -i ",${edition}," <<<",${EDITIONS}," 2>/dev/null 1>&2 ; then
              echo "  - enable build of ${edition} edition."
              echo "BUILD_${edition}=true" >> $GITHUB_OUTPUT
              EMPTY_EDITIONS=no
            fi
          done

          if [[ $EMPTY_EDITIONS == "yes" ]] ; then
            echo "No editions requested. Building only FE."
          fi

  check_branch_name:
    name: Check branch name
    runs-on: ubuntu-latest
    steps:

    # <template: checkout_step>
    - name: Checkout sources
      uses: actions/checkout@v3.5.2

    # </template: checkout_step>
      with:
        fetch-depth: 0
    - name: Check branch name
      id: check_branch_name
      env:
        CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
      run: |
        if [ -z "${CI_COMMIT_TAG}" ]; then
          exit 0 # Skip job if there is no tag
        fi
        TAG_NAME="${GITHUB_REF#refs/tags/}" # Remove "refs/tags/" prefix
        echo "TAG_NAME=${TAG_NAME}"
        MAJOR=$(echo "$TAG_NAME" | cut -d'.' -f1 | tr -d 'v')
        MINOR=$(echo "$TAG_NAME" | cut -d'.' -f2)
        RELEASE_BRANCH_NAME="release-${MAJOR}.${MINOR}"
        echo "RELEASE_BRANCH_NAME=${RELEASE_BRANCH_NAME}"
        echo "GITHUB_SHA=${GITHUB_SHA}"
        echo "Current commit in branch:"
        git branch -r --contains ${GITHUB_SHA}
        # grep returns exit code 1 if branch not found
        git branch -r --contains ${GITHUB_SHA} | grep ${RELEASE_BRANCH_NAME}


  # <template: check_changelog_template>
  check_changelog:
    name: Check changelog
    runs-on: "regular"
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2

      # </template: checkout_step>
      - name: Check for tag
        run: |
          if [[ "${GITHUB_REF}" != refs/tags/* ]]; then
            echo "Not a tag push, skipping changelog check."
            exit 0
          fi

          TAG_VERSION="${GITHUB_REF#refs/tags/}"
          FILE="./CHANGELOG/CHANGELOG-${TAG_VERSION}.yml"

          if [ ! -f "$FILE" ]; then
            echo "‚ùå Expected changelog file $FILE not found. Please create it before pushing the release tag."
            exit 1
          else
            echo "‚úÖ Changelog file $FILE found."
          fi
  # </template: check_changelog_template>


  build_fe:
    name: Build FE
    needs:
      - git_info
      # - check_changelog
    env:
      WERF_ENV: "FE"
      SVACE_ANALYZE_HOST: "${{ secrets.SVACE_ANALYZE_HOST }}"
      SVACE_ANALYZE_SSH_USER: "${{ secrets.SVACE_ANALYZE_SSH_USER }}"
      SVACE_ENABLED: ${{ github.event.inputs.svace_enabled }}
    # <template: build_template>
    runs-on: [self-hosted, stage]
    outputs:
      tests_image_name: ${{ steps.build.outputs.tests_image_name }}
    steps:


      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/cosign_key access_token | COSIGN_KEY ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret SOURCE_REPO_GIT | SOURCE_REPO_GIT ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret CLOUD_PROVIDERS_SOURCE_REPO | CLOUD_PROVIDERS_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret OBSERVABILITY_SOURCE_REPO | OBSERVABILITY_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret DECKHOUSE_PRIVATE_REPO | DECKHOUSE_PRIVATE_REPO ;

      # </template: import_secrets>

      # <template: checkout_full_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          fetch-depth: 0
      # </template: checkout_full_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>


      # <template: login_readonly_registry_step>
      - name: Check readonly registry credentials
        id: check_readonly_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_READ_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to readonly registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_readonly_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      # <template: add_ssh_keys>
      - name: Start ssh-agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{secrets.SOURCE_REPO_SSH_KEY}}
            ${{ secrets.SVACE_ANALYZE_SSH_PRIVATE_KEY }}
      - name: Add ssh_known_hosts
        run: |
          HOST=$(grep -oP '(?<=@)[^/:]+' <<< ${{secrets.SOURCE_REPO_GIT}})
          echo "::add-mask::$HOST"
          IPS=$(nslookup "$HOST" | awk '/^Address: / { print $2 }')
          for IP in $IPS; do
            echo "::add-mask::$IP"
          done
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
            CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
            if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
            fi
          done <<< "$HOST_KEYS"
      - name: Add svace analyze server to ssh_known_hosts
        continue-on-error: true
        run: |
          host=${{ secrets.SVACE_ANALYZE_HOST }}
          host_ip=$(nslookup "$host" | awk '/^Address: / { print $2 }')
          echo "::add-mask::$host_ip"
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$host" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
              CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
              if grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
                  ssh-keygen -R $host
                  ssh-keygen -R $host_ip
              fi
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
          done <<< "$HOST_KEYS"
      # </template: add_ssh_keys>

      - name: Set up Go 1.24
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false

      - name: Run go generate
        run: |
          (make generate)
          (cd modules/500-upmeter/hooks/smokemini/internal/snapshot && go generate -v)

      - name: Check generated code
        run: git diff --exit-code || (echo 'Regenerated code does not match source, please run "make generate"' && exit 1)

      - name: Build and push deckhouse images
        id: build
        env:
          DECKHOUSE_REGISTRY_STAGE_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          DECKHOUSE_REGISTRY_STAGE_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          GHCR_IO_REGISTRY_USER: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          GHCR_IO_REGISTRY_PASSWORD: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          DECKHOUSE_REGISTRY_USER : ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          DECKHOUSE_REGISTRY_PASSWORD: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          SOURCE_REPO: "${{ steps.secrets.outputs.SOURCE_REPO_GIT }}"
          CLOUD_PROVIDERS_SOURCE_REPO: "${{ steps.secrets.outputs.CLOUD_PROVIDERS_SOURCE_REPO }}"
          OBSERVABILITY_SOURCE_REPO: "${{ steps.secrets.outputs.OBSERVABILITY_SOURCE_REPO }}"
          DECKHOUSE_PRIVATE_REPO: "${{ steps.secrets.outputs.DECKHOUSE_PRIVATE_REPO }}"
          COSIGN_KEY: ${{ steps.secrets.outputs.COSIGN_KEY }}
          COSIGN_VAULT_ADDRESS: "https://seguro.flant.com"
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          COSIGN_VAULT_KEY: "dh-2025-aug-ec"
          COSIGN_TRANSIT_SECRET_ENGINE_PATH: "dh-signer"
          COSIGN_AUTH_ROLE: "dh-signer_dh-signer"
          REGISTRY_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          REGISTRY_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
        run: |
          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Put tags on produced images and push to dev and release repositories.
          #
          # There are 2 modes: "dev" and "release".
          # The "dev" mode builds branches only:
          # - Build using dev-registry as primary and deckhouse registry as secondary.
          # - Push dev and dev/install images with prNUM tags and push to dev-registry.
          # The "release" mode builds branches and tags:
          # - Build using deckhouse registry as final and dev-registry as primary.
          # - Push dev and dev/install images to dev-registry with tag equal to a branch name (main or release-X.Y).
          # - Push dev, dev/install and release-channel-version images to deckhouse registry with tag equels to a Git tag.

          # IMAGE_NAME is a name of image from werf.yaml.
          # IMAGE_DST is an image name for docker push.
          function publish_image() {
            IMAGE_NAME=$1
            IMAGE_DST=$2
            IMAGE_SRC="$(jq -r ".Images.\"${IMAGE_NAME}\".DockerImageName" images_tags_werf.json)"
            echo "‚öìÔ∏è üí´ [$(date -u)] Publishing '${IMAGE_NAME}' image to ${IMAGE_DST}".
            echo "‚öìÔ∏è üì• [$(date -u)] Pull '${IMAGE_NAME}' image as ${IMAGE_SRC}."
            docker pull "${IMAGE_SRC}"
            echo "‚öìÔ∏è üè∑ [$(date -u)] Tag '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image tag "${IMAGE_SRC}" "${IMAGE_DST}"
            echo "‚öìÔ∏è üì§ [$(date -u)] Push '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image push "${IMAGE_DST}"
            echo "‚öìÔ∏è üßπ [$(date -u)] Remove local tag for '${IMAGE_NAME}'."
            docker image rmi "${IMAGE_DST}" || true;
          }

          # CE/EE/FE -> ce/ee/fe
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          # Temporary directory is moved to ensure
          TEMP_WORKDIR="$(dirname "${{github.workspace}}")/${{github.run_id}}-$REGISTRY_SUFFIX"
          echo "build_report_dir=$(echo ${TEMP_WORKDIR})" >> $GITHUB_OUTPUT
          mkdir -p "$TEMP_WORKDIR"
          STAGE_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_PATH="${STAGE_REGISTRY_PATH}"
          export WERF_REPO="${STAGE_REGISTRY_PATH}"

          # Registry path to publish images for Git tags.
          if [[ -n ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"
          else
          SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi
          # Release tag build, set deckhouse registry as final
          export WERF_FINAL_REPO="${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}"

          # The Git tag may contain a '+' sign, so use slugify for this situation.
          # Slugify doesn't change a tag with safe-only characters.
          IMAGE_TAG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
          export WERF_DISABLE_META_TAGS=true

          type werf && source $(werf ci-env github --verbose --as-file)
          werf build \
            --parallel=true --parallel-tasks-limit=10 \
            --save-build-report=true \
            --tmp-dir="$TEMP_WORKDIR" \
            --build-report-path images_tags_werf.json

          cp images_tags_werf.json "$TEMP_WORKDIR"

          # Publish images for Git branch.
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images to dev-registry for branch '${CI_COMMIT_BRANCH}' and edition '${WERF_ENV}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${REGISTRY_PATH}:${IMAGE_TAG}"
            publish_image 'dev/install' "${REGISTRY_PATH}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:${IMAGE_TAG}"
            publish_image 'e2e-opentofu-eks' "${REGISTRY_PATH}/e2e-opentofu-eks:${IMAGE_TAG}"

            # For release branches, also push release-channel to dev
            if [[ ${WERF_ENV,,} == "fe" && "${CI_COMMIT_BRANCH}" =~ release-([0-9]+\.[0-9]+) ]]; then
              publish_image 'dev' "${REGISTRY_PATH}:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install' "${REGISTRY_PATH}/install:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:v${BASH_REMATCH[1]}.0"
              publish_image 'release-channel-version' "${REGISTRY_PATH}/release-channel:v${BASH_REMATCH[1]}.0"
            fi
          else
            echo "Branch unset, skipping branch publish."
          fi

          # Publish images for Git tag.
          if [[ "${CI_COMMIT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images for Git tag '${CI_COMMIT_TAG}' and registry suffix '${REGISTRY_SUFFIX}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}:${IMAGE_TAG}"
            publish_image 'dev/install' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install-standalone:${IMAGE_TAG}"
            publish_image 'release-channel-version' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/release-channel:${IMAGE_TAG}"
          else
            echo "Not a release tag, skipping tag publish."
          fi

          # Save 'tests' image name to pass it as output for 'tests' jobs.
          TESTS_IMAGE_NAME="$(jq -r '.Images."tests".DockerImageName' images_tags_werf.json)"
          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Tests image name: '${TESTS_IMAGE_NAME}'" | tr '[:lower:]' '[:upper:]'
          # Encode as gzip+base64 to evade github's SecretMasker error: "Skip output since it may contain secret".
          echo "tests_image_name=$(echo ${TESTS_IMAGE_NAME} | gzip | base64 -w0)" >> $GITHUB_OUTPUT

          # Filter out data from build report
          egrep -v '(DockerRepo|DockerImageName)' "$TEMP_WORKDIR/images_tags_werf.json" > "$TEMP_WORKDIR/images_tags_werf_filtered.json"
          mv "$TEMP_WORKDIR/images_tags_werf_filtered.json" "$TEMP_WORKDIR/images_tags_werf.json"

      - name: Check DKP images manifests in public registry
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        id: check_images
        env:
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          DECKHOUSE_REGISTRY_READ_HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          EDITION=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          ./tools/check-release-images.sh --tag ${CI_COMMIT_REF_SLUG} --edition ${EDITION} --images-path ${DECKHOUSE_REGISTRY_READ_HOST}/deckhouse/


      - uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.12.3'

      - name: Copy attestations
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          export REGISTRY_FROM="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_TO="${DECKHOUSE_REGISTRY_HOST}/deckhouse/${WERF_ENV,,}"
          export IMAGES_TAGS_PATH=${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json
          python .github/scripts/python/copy_attestations.py

      - name: Save build report
        if: ${{ always() && (steps.build.outcome == 'success' || steps.build.outcome == 'failure') }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: build_report_${{ env.WERF_ENV }}
          path: |
            ${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json

    # </template: build_template>


      # <template: send_fail_report>
      - name: Send fail report
        if: ${{ failure() && github.repository == 'deckhouse/deckhouse' }}
        env:
          LOOP_SERVICE_NOTIFICATIONS: ${{ secrets.LOOP_SERVICE_NOTIFICATIONS }}
          JOB_NAME: ${{ github.job }}
          WORKFLOW_NAME: ${{ github.workflow }}
          WORKFLOW_URL: ${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}/
        run: |
          bash ./.github/scripts/send-report.sh --webhook "ci_fail"
      # </template: send_fail_report>

  build_ee:
    name: Build EE
    if: ${{ startsWith(github.ref, 'refs/tags/v') || (needs.detect_editions.outputs.BUILD_EE == 'true') }}
    needs:
      - git_info
      - build_fe
      - detect_editions
    env:
      WERF_ENV: "EE"
    # <template: build_template>
    runs-on: [self-hosted, stage]
    outputs:
      tests_image_name: ${{ steps.build.outputs.tests_image_name }}
    steps:


      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/cosign_key access_token | COSIGN_KEY ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret SOURCE_REPO_GIT | SOURCE_REPO_GIT ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret CLOUD_PROVIDERS_SOURCE_REPO | CLOUD_PROVIDERS_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret OBSERVABILITY_SOURCE_REPO | OBSERVABILITY_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret DECKHOUSE_PRIVATE_REPO | DECKHOUSE_PRIVATE_REPO ;

      # </template: import_secrets>

      # <template: checkout_full_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          fetch-depth: 0
      # </template: checkout_full_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>


      # <template: login_readonly_registry_step>
      - name: Check readonly registry credentials
        id: check_readonly_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_READ_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to readonly registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_readonly_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      # <template: add_ssh_keys>
      - name: Start ssh-agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{secrets.SOURCE_REPO_SSH_KEY}}
            ${{ secrets.SVACE_ANALYZE_SSH_PRIVATE_KEY }}
      - name: Add ssh_known_hosts
        run: |
          HOST=$(grep -oP '(?<=@)[^/:]+' <<< ${{secrets.SOURCE_REPO_GIT}})
          echo "::add-mask::$HOST"
          IPS=$(nslookup "$HOST" | awk '/^Address: / { print $2 }')
          for IP in $IPS; do
            echo "::add-mask::$IP"
          done
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
            CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
            if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
            fi
          done <<< "$HOST_KEYS"
      - name: Add svace analyze server to ssh_known_hosts
        continue-on-error: true
        run: |
          host=${{ secrets.SVACE_ANALYZE_HOST }}
          host_ip=$(nslookup "$host" | awk '/^Address: / { print $2 }')
          echo "::add-mask::$host_ip"
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$host" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
              CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
              if grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
                  ssh-keygen -R $host
                  ssh-keygen -R $host_ip
              fi
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
          done <<< "$HOST_KEYS"
      # </template: add_ssh_keys>

      - name: Set up Go 1.24
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false

      - name: Run go generate
        run: |
          (make generate)
          (cd modules/500-upmeter/hooks/smokemini/internal/snapshot && go generate -v)

      - name: Check generated code
        run: git diff --exit-code || (echo 'Regenerated code does not match source, please run "make generate"' && exit 1)

      - name: Build and push deckhouse images
        id: build
        env:
          DECKHOUSE_REGISTRY_STAGE_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          DECKHOUSE_REGISTRY_STAGE_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          GHCR_IO_REGISTRY_USER: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          GHCR_IO_REGISTRY_PASSWORD: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          DECKHOUSE_REGISTRY_USER : ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          DECKHOUSE_REGISTRY_PASSWORD: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          SOURCE_REPO: "${{ steps.secrets.outputs.SOURCE_REPO_GIT }}"
          CLOUD_PROVIDERS_SOURCE_REPO: "${{ steps.secrets.outputs.CLOUD_PROVIDERS_SOURCE_REPO }}"
          OBSERVABILITY_SOURCE_REPO: "${{ steps.secrets.outputs.OBSERVABILITY_SOURCE_REPO }}"
          DECKHOUSE_PRIVATE_REPO: "${{ steps.secrets.outputs.DECKHOUSE_PRIVATE_REPO }}"
          COSIGN_KEY: ${{ steps.secrets.outputs.COSIGN_KEY }}
          COSIGN_VAULT_ADDRESS: "https://seguro.flant.com"
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          COSIGN_VAULT_KEY: "dh-2025-aug-ec"
          COSIGN_TRANSIT_SECRET_ENGINE_PATH: "dh-signer"
          COSIGN_AUTH_ROLE: "dh-signer_dh-signer"
          REGISTRY_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          REGISTRY_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
        run: |
          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Put tags on produced images and push to dev and release repositories.
          #
          # There are 2 modes: "dev" and "release".
          # The "dev" mode builds branches only:
          # - Build using dev-registry as primary and deckhouse registry as secondary.
          # - Push dev and dev/install images with prNUM tags and push to dev-registry.
          # The "release" mode builds branches and tags:
          # - Build using deckhouse registry as final and dev-registry as primary.
          # - Push dev and dev/install images to dev-registry with tag equal to a branch name (main or release-X.Y).
          # - Push dev, dev/install and release-channel-version images to deckhouse registry with tag equels to a Git tag.

          # IMAGE_NAME is a name of image from werf.yaml.
          # IMAGE_DST is an image name for docker push.
          function publish_image() {
            IMAGE_NAME=$1
            IMAGE_DST=$2
            IMAGE_SRC="$(jq -r ".Images.\"${IMAGE_NAME}\".DockerImageName" images_tags_werf.json)"
            echo "‚öìÔ∏è üí´ [$(date -u)] Publishing '${IMAGE_NAME}' image to ${IMAGE_DST}".
            echo "‚öìÔ∏è üì• [$(date -u)] Pull '${IMAGE_NAME}' image as ${IMAGE_SRC}."
            docker pull "${IMAGE_SRC}"
            echo "‚öìÔ∏è üè∑ [$(date -u)] Tag '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image tag "${IMAGE_SRC}" "${IMAGE_DST}"
            echo "‚öìÔ∏è üì§ [$(date -u)] Push '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image push "${IMAGE_DST}"
            echo "‚öìÔ∏è üßπ [$(date -u)] Remove local tag for '${IMAGE_NAME}'."
            docker image rmi "${IMAGE_DST}" || true;
          }

          # CE/EE/FE -> ce/ee/fe
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          # Temporary directory is moved to ensure
          TEMP_WORKDIR="$(dirname "${{github.workspace}}")/${{github.run_id}}-$REGISTRY_SUFFIX"
          echo "build_report_dir=$(echo ${TEMP_WORKDIR})" >> $GITHUB_OUTPUT
          mkdir -p "$TEMP_WORKDIR"
          STAGE_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_PATH="${STAGE_REGISTRY_PATH}"
          export WERF_REPO="${STAGE_REGISTRY_PATH}"

          # Registry path to publish images for Git tags.
          if [[ -n ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"
          else
          SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi
          # Release tag build, set deckhouse registry as final
          export WERF_FINAL_REPO="${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}"

          # The Git tag may contain a '+' sign, so use slugify for this situation.
          # Slugify doesn't change a tag with safe-only characters.
          IMAGE_TAG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
          export WERF_DISABLE_META_TAGS=true

          type werf && source $(werf ci-env github --verbose --as-file)
          werf build \
            --parallel=true --parallel-tasks-limit=10 \
            --save-build-report=true \
            --tmp-dir="$TEMP_WORKDIR" \
            --build-report-path images_tags_werf.json

          cp images_tags_werf.json "$TEMP_WORKDIR"

          # Publish images for Git branch.
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images to dev-registry for branch '${CI_COMMIT_BRANCH}' and edition '${WERF_ENV}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${REGISTRY_PATH}:${IMAGE_TAG}"
            publish_image 'dev/install' "${REGISTRY_PATH}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:${IMAGE_TAG}"
            publish_image 'e2e-opentofu-eks' "${REGISTRY_PATH}/e2e-opentofu-eks:${IMAGE_TAG}"

            # For release branches, also push release-channel to dev
            if [[ ${WERF_ENV,,} == "fe" && "${CI_COMMIT_BRANCH}" =~ release-([0-9]+\.[0-9]+) ]]; then
              publish_image 'dev' "${REGISTRY_PATH}:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install' "${REGISTRY_PATH}/install:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:v${BASH_REMATCH[1]}.0"
              publish_image 'release-channel-version' "${REGISTRY_PATH}/release-channel:v${BASH_REMATCH[1]}.0"
            fi
          else
            echo "Branch unset, skipping branch publish."
          fi

          # Publish images for Git tag.
          if [[ "${CI_COMMIT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images for Git tag '${CI_COMMIT_TAG}' and registry suffix '${REGISTRY_SUFFIX}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}:${IMAGE_TAG}"
            publish_image 'dev/install' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install-standalone:${IMAGE_TAG}"
            publish_image 'release-channel-version' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/release-channel:${IMAGE_TAG}"
          else
            echo "Not a release tag, skipping tag publish."
          fi

          # Save 'tests' image name to pass it as output for 'tests' jobs.
          TESTS_IMAGE_NAME="$(jq -r '.Images."tests".DockerImageName' images_tags_werf.json)"
          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Tests image name: '${TESTS_IMAGE_NAME}'" | tr '[:lower:]' '[:upper:]'
          # Encode as gzip+base64 to evade github's SecretMasker error: "Skip output since it may contain secret".
          echo "tests_image_name=$(echo ${TESTS_IMAGE_NAME} | gzip | base64 -w0)" >> $GITHUB_OUTPUT

          # Filter out data from build report
          egrep -v '(DockerRepo|DockerImageName)' "$TEMP_WORKDIR/images_tags_werf.json" > "$TEMP_WORKDIR/images_tags_werf_filtered.json"
          mv "$TEMP_WORKDIR/images_tags_werf_filtered.json" "$TEMP_WORKDIR/images_tags_werf.json"

      - name: Check DKP images manifests in public registry
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        id: check_images
        env:
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          DECKHOUSE_REGISTRY_READ_HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          EDITION=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          ./tools/check-release-images.sh --tag ${CI_COMMIT_REF_SLUG} --edition ${EDITION} --images-path ${DECKHOUSE_REGISTRY_READ_HOST}/deckhouse/


      - uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.12.3'

      - name: Copy attestations
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          export REGISTRY_FROM="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_TO="${DECKHOUSE_REGISTRY_HOST}/deckhouse/${WERF_ENV,,}"
          export IMAGES_TAGS_PATH=${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json
          python .github/scripts/python/copy_attestations.py

      - name: Save build report
        if: ${{ always() && (steps.build.outcome == 'success' || steps.build.outcome == 'failure') }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: build_report_${{ env.WERF_ENV }}
          path: |
            ${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json

    # </template: build_template>


      # <template: send_fail_report>
      - name: Send fail report
        if: ${{ failure() && github.repository == 'deckhouse/deckhouse' }}
        env:
          LOOP_SERVICE_NOTIFICATIONS: ${{ secrets.LOOP_SERVICE_NOTIFICATIONS }}
          JOB_NAME: ${{ github.job }}
          WORKFLOW_NAME: ${{ github.workflow }}
          WORKFLOW_URL: ${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}/
        run: |
          bash ./.github/scripts/send-report.sh --webhook "ci_fail"
      # </template: send_fail_report>

  build_se:
    name: Build SE
    if: ${{ startsWith(github.ref, 'refs/tags/v') || (needs.detect_editions.outputs.BUILD_SE == 'true') }}
    needs:
      - git_info
      - build_fe
      - detect_editions
    env:
      WERF_ENV: "SE"
    # <template: build_template>
    runs-on: [self-hosted, stage]
    outputs:
      tests_image_name: ${{ steps.build.outputs.tests_image_name }}
    steps:


      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/cosign_key access_token | COSIGN_KEY ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret SOURCE_REPO_GIT | SOURCE_REPO_GIT ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret CLOUD_PROVIDERS_SOURCE_REPO | CLOUD_PROVIDERS_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret OBSERVABILITY_SOURCE_REPO | OBSERVABILITY_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret DECKHOUSE_PRIVATE_REPO | DECKHOUSE_PRIVATE_REPO ;

      # </template: import_secrets>

      # <template: checkout_full_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          fetch-depth: 0
      # </template: checkout_full_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>


      # <template: login_readonly_registry_step>
      - name: Check readonly registry credentials
        id: check_readonly_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_READ_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to readonly registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_readonly_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      # <template: add_ssh_keys>
      - name: Start ssh-agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{secrets.SOURCE_REPO_SSH_KEY}}
            ${{ secrets.SVACE_ANALYZE_SSH_PRIVATE_KEY }}
      - name: Add ssh_known_hosts
        run: |
          HOST=$(grep -oP '(?<=@)[^/:]+' <<< ${{secrets.SOURCE_REPO_GIT}})
          echo "::add-mask::$HOST"
          IPS=$(nslookup "$HOST" | awk '/^Address: / { print $2 }')
          for IP in $IPS; do
            echo "::add-mask::$IP"
          done
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
            CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
            if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
            fi
          done <<< "$HOST_KEYS"
      - name: Add svace analyze server to ssh_known_hosts
        continue-on-error: true
        run: |
          host=${{ secrets.SVACE_ANALYZE_HOST }}
          host_ip=$(nslookup "$host" | awk '/^Address: / { print $2 }')
          echo "::add-mask::$host_ip"
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$host" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
              CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
              if grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
                  ssh-keygen -R $host
                  ssh-keygen -R $host_ip
              fi
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
          done <<< "$HOST_KEYS"
      # </template: add_ssh_keys>

      - name: Set up Go 1.24
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false

      - name: Run go generate
        run: |
          (make generate)
          (cd modules/500-upmeter/hooks/smokemini/internal/snapshot && go generate -v)

      - name: Check generated code
        run: git diff --exit-code || (echo 'Regenerated code does not match source, please run "make generate"' && exit 1)

      - name: Build and push deckhouse images
        id: build
        env:
          DECKHOUSE_REGISTRY_STAGE_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          DECKHOUSE_REGISTRY_STAGE_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          GHCR_IO_REGISTRY_USER: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          GHCR_IO_REGISTRY_PASSWORD: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          DECKHOUSE_REGISTRY_USER : ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          DECKHOUSE_REGISTRY_PASSWORD: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          SOURCE_REPO: "${{ steps.secrets.outputs.SOURCE_REPO_GIT }}"
          CLOUD_PROVIDERS_SOURCE_REPO: "${{ steps.secrets.outputs.CLOUD_PROVIDERS_SOURCE_REPO }}"
          OBSERVABILITY_SOURCE_REPO: "${{ steps.secrets.outputs.OBSERVABILITY_SOURCE_REPO }}"
          DECKHOUSE_PRIVATE_REPO: "${{ steps.secrets.outputs.DECKHOUSE_PRIVATE_REPO }}"
          COSIGN_KEY: ${{ steps.secrets.outputs.COSIGN_KEY }}
          COSIGN_VAULT_ADDRESS: "https://seguro.flant.com"
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          COSIGN_VAULT_KEY: "dh-2025-aug-ec"
          COSIGN_TRANSIT_SECRET_ENGINE_PATH: "dh-signer"
          COSIGN_AUTH_ROLE: "dh-signer_dh-signer"
          REGISTRY_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          REGISTRY_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
        run: |
          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Put tags on produced images and push to dev and release repositories.
          #
          # There are 2 modes: "dev" and "release".
          # The "dev" mode builds branches only:
          # - Build using dev-registry as primary and deckhouse registry as secondary.
          # - Push dev and dev/install images with prNUM tags and push to dev-registry.
          # The "release" mode builds branches and tags:
          # - Build using deckhouse registry as final and dev-registry as primary.
          # - Push dev and dev/install images to dev-registry with tag equal to a branch name (main or release-X.Y).
          # - Push dev, dev/install and release-channel-version images to deckhouse registry with tag equels to a Git tag.

          # IMAGE_NAME is a name of image from werf.yaml.
          # IMAGE_DST is an image name for docker push.
          function publish_image() {
            IMAGE_NAME=$1
            IMAGE_DST=$2
            IMAGE_SRC="$(jq -r ".Images.\"${IMAGE_NAME}\".DockerImageName" images_tags_werf.json)"
            echo "‚öìÔ∏è üí´ [$(date -u)] Publishing '${IMAGE_NAME}' image to ${IMAGE_DST}".
            echo "‚öìÔ∏è üì• [$(date -u)] Pull '${IMAGE_NAME}' image as ${IMAGE_SRC}."
            docker pull "${IMAGE_SRC}"
            echo "‚öìÔ∏è üè∑ [$(date -u)] Tag '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image tag "${IMAGE_SRC}" "${IMAGE_DST}"
            echo "‚öìÔ∏è üì§ [$(date -u)] Push '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image push "${IMAGE_DST}"
            echo "‚öìÔ∏è üßπ [$(date -u)] Remove local tag for '${IMAGE_NAME}'."
            docker image rmi "${IMAGE_DST}" || true;
          }

          # CE/EE/FE -> ce/ee/fe
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          # Temporary directory is moved to ensure
          TEMP_WORKDIR="$(dirname "${{github.workspace}}")/${{github.run_id}}-$REGISTRY_SUFFIX"
          echo "build_report_dir=$(echo ${TEMP_WORKDIR})" >> $GITHUB_OUTPUT
          mkdir -p "$TEMP_WORKDIR"
          STAGE_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_PATH="${STAGE_REGISTRY_PATH}"
          export WERF_REPO="${STAGE_REGISTRY_PATH}"

          # Registry path to publish images for Git tags.
          if [[ -n ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"
          else
          SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi
          # Release tag build, set deckhouse registry as final
          export WERF_FINAL_REPO="${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}"

          # The Git tag may contain a '+' sign, so use slugify for this situation.
          # Slugify doesn't change a tag with safe-only characters.
          IMAGE_TAG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
          export WERF_DISABLE_META_TAGS=true

          type werf && source $(werf ci-env github --verbose --as-file)
          werf build \
            --parallel=true --parallel-tasks-limit=10 \
            --save-build-report=true \
            --tmp-dir="$TEMP_WORKDIR" \
            --build-report-path images_tags_werf.json

          cp images_tags_werf.json "$TEMP_WORKDIR"

          # Publish images for Git branch.
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images to dev-registry for branch '${CI_COMMIT_BRANCH}' and edition '${WERF_ENV}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${REGISTRY_PATH}:${IMAGE_TAG}"
            publish_image 'dev/install' "${REGISTRY_PATH}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:${IMAGE_TAG}"
            publish_image 'e2e-opentofu-eks' "${REGISTRY_PATH}/e2e-opentofu-eks:${IMAGE_TAG}"

            # For release branches, also push release-channel to dev
            if [[ ${WERF_ENV,,} == "fe" && "${CI_COMMIT_BRANCH}" =~ release-([0-9]+\.[0-9]+) ]]; then
              publish_image 'dev' "${REGISTRY_PATH}:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install' "${REGISTRY_PATH}/install:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:v${BASH_REMATCH[1]}.0"
              publish_image 'release-channel-version' "${REGISTRY_PATH}/release-channel:v${BASH_REMATCH[1]}.0"
            fi
          else
            echo "Branch unset, skipping branch publish."
          fi

          # Publish images for Git tag.
          if [[ "${CI_COMMIT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images for Git tag '${CI_COMMIT_TAG}' and registry suffix '${REGISTRY_SUFFIX}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}:${IMAGE_TAG}"
            publish_image 'dev/install' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install-standalone:${IMAGE_TAG}"
            publish_image 'release-channel-version' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/release-channel:${IMAGE_TAG}"
          else
            echo "Not a release tag, skipping tag publish."
          fi

          # Save 'tests' image name to pass it as output for 'tests' jobs.
          TESTS_IMAGE_NAME="$(jq -r '.Images."tests".DockerImageName' images_tags_werf.json)"
          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Tests image name: '${TESTS_IMAGE_NAME}'" | tr '[:lower:]' '[:upper:]'
          # Encode as gzip+base64 to evade github's SecretMasker error: "Skip output since it may contain secret".
          echo "tests_image_name=$(echo ${TESTS_IMAGE_NAME} | gzip | base64 -w0)" >> $GITHUB_OUTPUT

          # Filter out data from build report
          egrep -v '(DockerRepo|DockerImageName)' "$TEMP_WORKDIR/images_tags_werf.json" > "$TEMP_WORKDIR/images_tags_werf_filtered.json"
          mv "$TEMP_WORKDIR/images_tags_werf_filtered.json" "$TEMP_WORKDIR/images_tags_werf.json"

      - name: Check DKP images manifests in public registry
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        id: check_images
        env:
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          DECKHOUSE_REGISTRY_READ_HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          EDITION=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          ./tools/check-release-images.sh --tag ${CI_COMMIT_REF_SLUG} --edition ${EDITION} --images-path ${DECKHOUSE_REGISTRY_READ_HOST}/deckhouse/


      - uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.12.3'

      - name: Copy attestations
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          export REGISTRY_FROM="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_TO="${DECKHOUSE_REGISTRY_HOST}/deckhouse/${WERF_ENV,,}"
          export IMAGES_TAGS_PATH=${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json
          python .github/scripts/python/copy_attestations.py

      - name: Save build report
        if: ${{ always() && (steps.build.outcome == 'success' || steps.build.outcome == 'failure') }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: build_report_${{ env.WERF_ENV }}
          path: |
            ${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json

    # </template: build_template>


  build_se_plus:
    name: Build SE-plus
    if: ${{ startsWith(github.ref, 'refs/tags/v') || (needs.detect_editions.outputs.BUILD_SE-plus == 'true') }}
    needs:
      - git_info
      - build_fe
      - detect_editions
    env:
      WERF_ENV: "SE-plus"
    # <template: build_template>
    runs-on: [self-hosted, stage]
    outputs:
      tests_image_name: ${{ steps.build.outputs.tests_image_name }}
    steps:


      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/cosign_key access_token | COSIGN_KEY ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret SOURCE_REPO_GIT | SOURCE_REPO_GIT ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret CLOUD_PROVIDERS_SOURCE_REPO | CLOUD_PROVIDERS_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret OBSERVABILITY_SOURCE_REPO | OBSERVABILITY_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret DECKHOUSE_PRIVATE_REPO | DECKHOUSE_PRIVATE_REPO ;

      # </template: import_secrets>

      # <template: checkout_full_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          fetch-depth: 0
      # </template: checkout_full_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>


      # <template: login_readonly_registry_step>
      - name: Check readonly registry credentials
        id: check_readonly_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_READ_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to readonly registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_readonly_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      # <template: add_ssh_keys>
      - name: Start ssh-agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{secrets.SOURCE_REPO_SSH_KEY}}
            ${{ secrets.SVACE_ANALYZE_SSH_PRIVATE_KEY }}
      - name: Add ssh_known_hosts
        run: |
          HOST=$(grep -oP '(?<=@)[^/:]+' <<< ${{secrets.SOURCE_REPO_GIT}})
          echo "::add-mask::$HOST"
          IPS=$(nslookup "$HOST" | awk '/^Address: / { print $2 }')
          for IP in $IPS; do
            echo "::add-mask::$IP"
          done
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
            CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
            if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
            fi
          done <<< "$HOST_KEYS"
      - name: Add svace analyze server to ssh_known_hosts
        continue-on-error: true
        run: |
          host=${{ secrets.SVACE_ANALYZE_HOST }}
          host_ip=$(nslookup "$host" | awk '/^Address: / { print $2 }')
          echo "::add-mask::$host_ip"
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$host" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
              CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
              if grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
                  ssh-keygen -R $host
                  ssh-keygen -R $host_ip
              fi
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
          done <<< "$HOST_KEYS"
      # </template: add_ssh_keys>

      - name: Set up Go 1.24
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false

      - name: Run go generate
        run: |
          (make generate)
          (cd modules/500-upmeter/hooks/smokemini/internal/snapshot && go generate -v)

      - name: Check generated code
        run: git diff --exit-code || (echo 'Regenerated code does not match source, please run "make generate"' && exit 1)

      - name: Build and push deckhouse images
        id: build
        env:
          DECKHOUSE_REGISTRY_STAGE_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          DECKHOUSE_REGISTRY_STAGE_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          GHCR_IO_REGISTRY_USER: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          GHCR_IO_REGISTRY_PASSWORD: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          DECKHOUSE_REGISTRY_USER : ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          DECKHOUSE_REGISTRY_PASSWORD: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          SOURCE_REPO: "${{ steps.secrets.outputs.SOURCE_REPO_GIT }}"
          CLOUD_PROVIDERS_SOURCE_REPO: "${{ steps.secrets.outputs.CLOUD_PROVIDERS_SOURCE_REPO }}"
          OBSERVABILITY_SOURCE_REPO: "${{ steps.secrets.outputs.OBSERVABILITY_SOURCE_REPO }}"
          DECKHOUSE_PRIVATE_REPO: "${{ steps.secrets.outputs.DECKHOUSE_PRIVATE_REPO }}"
          COSIGN_KEY: ${{ steps.secrets.outputs.COSIGN_KEY }}
          COSIGN_VAULT_ADDRESS: "https://seguro.flant.com"
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          COSIGN_VAULT_KEY: "dh-2025-aug-ec"
          COSIGN_TRANSIT_SECRET_ENGINE_PATH: "dh-signer"
          COSIGN_AUTH_ROLE: "dh-signer_dh-signer"
          REGISTRY_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          REGISTRY_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
        run: |
          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Put tags on produced images and push to dev and release repositories.
          #
          # There are 2 modes: "dev" and "release".
          # The "dev" mode builds branches only:
          # - Build using dev-registry as primary and deckhouse registry as secondary.
          # - Push dev and dev/install images with prNUM tags and push to dev-registry.
          # The "release" mode builds branches and tags:
          # - Build using deckhouse registry as final and dev-registry as primary.
          # - Push dev and dev/install images to dev-registry with tag equal to a branch name (main or release-X.Y).
          # - Push dev, dev/install and release-channel-version images to deckhouse registry with tag equels to a Git tag.

          # IMAGE_NAME is a name of image from werf.yaml.
          # IMAGE_DST is an image name for docker push.
          function publish_image() {
            IMAGE_NAME=$1
            IMAGE_DST=$2
            IMAGE_SRC="$(jq -r ".Images.\"${IMAGE_NAME}\".DockerImageName" images_tags_werf.json)"
            echo "‚öìÔ∏è üí´ [$(date -u)] Publishing '${IMAGE_NAME}' image to ${IMAGE_DST}".
            echo "‚öìÔ∏è üì• [$(date -u)] Pull '${IMAGE_NAME}' image as ${IMAGE_SRC}."
            docker pull "${IMAGE_SRC}"
            echo "‚öìÔ∏è üè∑ [$(date -u)] Tag '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image tag "${IMAGE_SRC}" "${IMAGE_DST}"
            echo "‚öìÔ∏è üì§ [$(date -u)] Push '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image push "${IMAGE_DST}"
            echo "‚öìÔ∏è üßπ [$(date -u)] Remove local tag for '${IMAGE_NAME}'."
            docker image rmi "${IMAGE_DST}" || true;
          }

          # CE/EE/FE -> ce/ee/fe
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          # Temporary directory is moved to ensure
          TEMP_WORKDIR="$(dirname "${{github.workspace}}")/${{github.run_id}}-$REGISTRY_SUFFIX"
          echo "build_report_dir=$(echo ${TEMP_WORKDIR})" >> $GITHUB_OUTPUT
          mkdir -p "$TEMP_WORKDIR"
          STAGE_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_PATH="${STAGE_REGISTRY_PATH}"
          export WERF_REPO="${STAGE_REGISTRY_PATH}"

          # Registry path to publish images for Git tags.
          if [[ -n ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"
          else
          SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi
          # Release tag build, set deckhouse registry as final
          export WERF_FINAL_REPO="${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}"

          # The Git tag may contain a '+' sign, so use slugify for this situation.
          # Slugify doesn't change a tag with safe-only characters.
          IMAGE_TAG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
          export WERF_DISABLE_META_TAGS=true

          type werf && source $(werf ci-env github --verbose --as-file)
          werf build \
            --parallel=true --parallel-tasks-limit=10 \
            --save-build-report=true \
            --tmp-dir="$TEMP_WORKDIR" \
            --build-report-path images_tags_werf.json

          cp images_tags_werf.json "$TEMP_WORKDIR"

          # Publish images for Git branch.
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images to dev-registry for branch '${CI_COMMIT_BRANCH}' and edition '${WERF_ENV}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${REGISTRY_PATH}:${IMAGE_TAG}"
            publish_image 'dev/install' "${REGISTRY_PATH}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:${IMAGE_TAG}"
            publish_image 'e2e-opentofu-eks' "${REGISTRY_PATH}/e2e-opentofu-eks:${IMAGE_TAG}"

            # For release branches, also push release-channel to dev
            if [[ ${WERF_ENV,,} == "fe" && "${CI_COMMIT_BRANCH}" =~ release-([0-9]+\.[0-9]+) ]]; then
              publish_image 'dev' "${REGISTRY_PATH}:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install' "${REGISTRY_PATH}/install:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:v${BASH_REMATCH[1]}.0"
              publish_image 'release-channel-version' "${REGISTRY_PATH}/release-channel:v${BASH_REMATCH[1]}.0"
            fi
          else
            echo "Branch unset, skipping branch publish."
          fi

          # Publish images for Git tag.
          if [[ "${CI_COMMIT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images for Git tag '${CI_COMMIT_TAG}' and registry suffix '${REGISTRY_SUFFIX}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}:${IMAGE_TAG}"
            publish_image 'dev/install' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install-standalone:${IMAGE_TAG}"
            publish_image 'release-channel-version' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/release-channel:${IMAGE_TAG}"
          else
            echo "Not a release tag, skipping tag publish."
          fi

          # Save 'tests' image name to pass it as output for 'tests' jobs.
          TESTS_IMAGE_NAME="$(jq -r '.Images."tests".DockerImageName' images_tags_werf.json)"
          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Tests image name: '${TESTS_IMAGE_NAME}'" | tr '[:lower:]' '[:upper:]'
          # Encode as gzip+base64 to evade github's SecretMasker error: "Skip output since it may contain secret".
          echo "tests_image_name=$(echo ${TESTS_IMAGE_NAME} | gzip | base64 -w0)" >> $GITHUB_OUTPUT

          # Filter out data from build report
          egrep -v '(DockerRepo|DockerImageName)' "$TEMP_WORKDIR/images_tags_werf.json" > "$TEMP_WORKDIR/images_tags_werf_filtered.json"
          mv "$TEMP_WORKDIR/images_tags_werf_filtered.json" "$TEMP_WORKDIR/images_tags_werf.json"

      - name: Check DKP images manifests in public registry
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        id: check_images
        env:
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          DECKHOUSE_REGISTRY_READ_HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          EDITION=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          ./tools/check-release-images.sh --tag ${CI_COMMIT_REF_SLUG} --edition ${EDITION} --images-path ${DECKHOUSE_REGISTRY_READ_HOST}/deckhouse/


      - uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.12.3'

      - name: Copy attestations
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          export REGISTRY_FROM="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_TO="${DECKHOUSE_REGISTRY_HOST}/deckhouse/${WERF_ENV,,}"
          export IMAGES_TAGS_PATH=${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json
          python .github/scripts/python/copy_attestations.py

      - name: Save build report
        if: ${{ always() && (steps.build.outcome == 'success' || steps.build.outcome == 'failure') }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: build_report_${{ env.WERF_ENV }}
          path: |
            ${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json

    # </template: build_template>


  build_be:
    name: Build BE
    if: ${{ startsWith(github.ref, 'refs/tags/v') || (needs.detect_editions.outputs.BUILD_BE == 'true') }}
    needs:
      - git_info
      - build_fe
      - detect_editions
    env:
      WERF_ENV: "BE"
    # <template: build_template>
    runs-on: [self-hosted, stage]
    outputs:
      tests_image_name: ${{ steps.build.outputs.tests_image_name }}
    steps:


      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/cosign_key access_token | COSIGN_KEY ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret SOURCE_REPO_GIT | SOURCE_REPO_GIT ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret CLOUD_PROVIDERS_SOURCE_REPO | CLOUD_PROVIDERS_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret OBSERVABILITY_SOURCE_REPO | OBSERVABILITY_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret DECKHOUSE_PRIVATE_REPO | DECKHOUSE_PRIVATE_REPO ;

      # </template: import_secrets>

      # <template: checkout_full_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          fetch-depth: 0
      # </template: checkout_full_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>


      # <template: login_readonly_registry_step>
      - name: Check readonly registry credentials
        id: check_readonly_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_READ_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to readonly registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_readonly_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      # <template: add_ssh_keys>
      - name: Start ssh-agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{secrets.SOURCE_REPO_SSH_KEY}}
            ${{ secrets.SVACE_ANALYZE_SSH_PRIVATE_KEY }}
      - name: Add ssh_known_hosts
        run: |
          HOST=$(grep -oP '(?<=@)[^/:]+' <<< ${{secrets.SOURCE_REPO_GIT}})
          echo "::add-mask::$HOST"
          IPS=$(nslookup "$HOST" | awk '/^Address: / { print $2 }')
          for IP in $IPS; do
            echo "::add-mask::$IP"
          done
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
            CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
            if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
            fi
          done <<< "$HOST_KEYS"
      - name: Add svace analyze server to ssh_known_hosts
        continue-on-error: true
        run: |
          host=${{ secrets.SVACE_ANALYZE_HOST }}
          host_ip=$(nslookup "$host" | awk '/^Address: / { print $2 }')
          echo "::add-mask::$host_ip"
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$host" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
              CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
              if grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
                  ssh-keygen -R $host
                  ssh-keygen -R $host_ip
              fi
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
          done <<< "$HOST_KEYS"
      # </template: add_ssh_keys>

      - name: Set up Go 1.24
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false

      - name: Run go generate
        run: |
          (make generate)
          (cd modules/500-upmeter/hooks/smokemini/internal/snapshot && go generate -v)

      - name: Check generated code
        run: git diff --exit-code || (echo 'Regenerated code does not match source, please run "make generate"' && exit 1)

      - name: Build and push deckhouse images
        id: build
        env:
          DECKHOUSE_REGISTRY_STAGE_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          DECKHOUSE_REGISTRY_STAGE_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          GHCR_IO_REGISTRY_USER: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          GHCR_IO_REGISTRY_PASSWORD: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          DECKHOUSE_REGISTRY_USER : ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          DECKHOUSE_REGISTRY_PASSWORD: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          SOURCE_REPO: "${{ steps.secrets.outputs.SOURCE_REPO_GIT }}"
          CLOUD_PROVIDERS_SOURCE_REPO: "${{ steps.secrets.outputs.CLOUD_PROVIDERS_SOURCE_REPO }}"
          OBSERVABILITY_SOURCE_REPO: "${{ steps.secrets.outputs.OBSERVABILITY_SOURCE_REPO }}"
          DECKHOUSE_PRIVATE_REPO: "${{ steps.secrets.outputs.DECKHOUSE_PRIVATE_REPO }}"
          COSIGN_KEY: ${{ steps.secrets.outputs.COSIGN_KEY }}
          COSIGN_VAULT_ADDRESS: "https://seguro.flant.com"
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          COSIGN_VAULT_KEY: "dh-2025-aug-ec"
          COSIGN_TRANSIT_SECRET_ENGINE_PATH: "dh-signer"
          COSIGN_AUTH_ROLE: "dh-signer_dh-signer"
          REGISTRY_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          REGISTRY_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
        run: |
          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Put tags on produced images and push to dev and release repositories.
          #
          # There are 2 modes: "dev" and "release".
          # The "dev" mode builds branches only:
          # - Build using dev-registry as primary and deckhouse registry as secondary.
          # - Push dev and dev/install images with prNUM tags and push to dev-registry.
          # The "release" mode builds branches and tags:
          # - Build using deckhouse registry as final and dev-registry as primary.
          # - Push dev and dev/install images to dev-registry with tag equal to a branch name (main or release-X.Y).
          # - Push dev, dev/install and release-channel-version images to deckhouse registry with tag equels to a Git tag.

          # IMAGE_NAME is a name of image from werf.yaml.
          # IMAGE_DST is an image name for docker push.
          function publish_image() {
            IMAGE_NAME=$1
            IMAGE_DST=$2
            IMAGE_SRC="$(jq -r ".Images.\"${IMAGE_NAME}\".DockerImageName" images_tags_werf.json)"
            echo "‚öìÔ∏è üí´ [$(date -u)] Publishing '${IMAGE_NAME}' image to ${IMAGE_DST}".
            echo "‚öìÔ∏è üì• [$(date -u)] Pull '${IMAGE_NAME}' image as ${IMAGE_SRC}."
            docker pull "${IMAGE_SRC}"
            echo "‚öìÔ∏è üè∑ [$(date -u)] Tag '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image tag "${IMAGE_SRC}" "${IMAGE_DST}"
            echo "‚öìÔ∏è üì§ [$(date -u)] Push '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image push "${IMAGE_DST}"
            echo "‚öìÔ∏è üßπ [$(date -u)] Remove local tag for '${IMAGE_NAME}'."
            docker image rmi "${IMAGE_DST}" || true;
          }

          # CE/EE/FE -> ce/ee/fe
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          # Temporary directory is moved to ensure
          TEMP_WORKDIR="$(dirname "${{github.workspace}}")/${{github.run_id}}-$REGISTRY_SUFFIX"
          echo "build_report_dir=$(echo ${TEMP_WORKDIR})" >> $GITHUB_OUTPUT
          mkdir -p "$TEMP_WORKDIR"
          STAGE_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_PATH="${STAGE_REGISTRY_PATH}"
          export WERF_REPO="${STAGE_REGISTRY_PATH}"

          # Registry path to publish images for Git tags.
          if [[ -n ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"
          else
          SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi
          # Release tag build, set deckhouse registry as final
          export WERF_FINAL_REPO="${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}"

          # The Git tag may contain a '+' sign, so use slugify for this situation.
          # Slugify doesn't change a tag with safe-only characters.
          IMAGE_TAG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
          export WERF_DISABLE_META_TAGS=true

          type werf && source $(werf ci-env github --verbose --as-file)
          werf build \
            --parallel=true --parallel-tasks-limit=10 \
            --save-build-report=true \
            --tmp-dir="$TEMP_WORKDIR" \
            --build-report-path images_tags_werf.json

          cp images_tags_werf.json "$TEMP_WORKDIR"

          # Publish images for Git branch.
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images to dev-registry for branch '${CI_COMMIT_BRANCH}' and edition '${WERF_ENV}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${REGISTRY_PATH}:${IMAGE_TAG}"
            publish_image 'dev/install' "${REGISTRY_PATH}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:${IMAGE_TAG}"
            publish_image 'e2e-opentofu-eks' "${REGISTRY_PATH}/e2e-opentofu-eks:${IMAGE_TAG}"

            # For release branches, also push release-channel to dev
            if [[ ${WERF_ENV,,} == "fe" && "${CI_COMMIT_BRANCH}" =~ release-([0-9]+\.[0-9]+) ]]; then
              publish_image 'dev' "${REGISTRY_PATH}:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install' "${REGISTRY_PATH}/install:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:v${BASH_REMATCH[1]}.0"
              publish_image 'release-channel-version' "${REGISTRY_PATH}/release-channel:v${BASH_REMATCH[1]}.0"
            fi
          else
            echo "Branch unset, skipping branch publish."
          fi

          # Publish images for Git tag.
          if [[ "${CI_COMMIT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images for Git tag '${CI_COMMIT_TAG}' and registry suffix '${REGISTRY_SUFFIX}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}:${IMAGE_TAG}"
            publish_image 'dev/install' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install-standalone:${IMAGE_TAG}"
            publish_image 'release-channel-version' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/release-channel:${IMAGE_TAG}"
          else
            echo "Not a release tag, skipping tag publish."
          fi

          # Save 'tests' image name to pass it as output for 'tests' jobs.
          TESTS_IMAGE_NAME="$(jq -r '.Images."tests".DockerImageName' images_tags_werf.json)"
          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Tests image name: '${TESTS_IMAGE_NAME}'" | tr '[:lower:]' '[:upper:]'
          # Encode as gzip+base64 to evade github's SecretMasker error: "Skip output since it may contain secret".
          echo "tests_image_name=$(echo ${TESTS_IMAGE_NAME} | gzip | base64 -w0)" >> $GITHUB_OUTPUT

          # Filter out data from build report
          egrep -v '(DockerRepo|DockerImageName)' "$TEMP_WORKDIR/images_tags_werf.json" > "$TEMP_WORKDIR/images_tags_werf_filtered.json"
          mv "$TEMP_WORKDIR/images_tags_werf_filtered.json" "$TEMP_WORKDIR/images_tags_werf.json"

      - name: Check DKP images manifests in public registry
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        id: check_images
        env:
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          DECKHOUSE_REGISTRY_READ_HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          EDITION=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          ./tools/check-release-images.sh --tag ${CI_COMMIT_REF_SLUG} --edition ${EDITION} --images-path ${DECKHOUSE_REGISTRY_READ_HOST}/deckhouse/


      - uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.12.3'

      - name: Copy attestations
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          export REGISTRY_FROM="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_TO="${DECKHOUSE_REGISTRY_HOST}/deckhouse/${WERF_ENV,,}"
          export IMAGES_TAGS_PATH=${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json
          python .github/scripts/python/copy_attestations.py

      - name: Save build report
        if: ${{ always() && (steps.build.outcome == 'success' || steps.build.outcome == 'failure') }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: build_report_${{ env.WERF_ENV }}
          path: |
            ${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json

    # </template: build_template>


  build_ce:
    name: Build CE
    if: ${{ startsWith(github.ref, 'refs/tags/v') || (needs.detect_editions.outputs.BUILD_CE == 'true') }}
    needs:
      - git_info
      - build_fe
      - detect_editions
    env:
      WERF_ENV: "CE"
    # <template: build_template>
    runs-on: [self-hosted, stage]
    outputs:
      tests_image_name: ${{ steps.build.outputs.tests_image_name }}
    steps:


      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "started_at=${unixTimestamp}" >> $GITHUB_OUTPUT
      # </template: started_at_output>

      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/cosign_key access_token | COSIGN_KEY ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_DEV_REGISTRY_HOST | DECKHOUSE_DEV_REGISTRY_HOST ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken login | DECKHOUSE_DEV_REGISTRY_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/dev-registry/writetoken password | DECKHOUSE_DEV_REGISTRY_PASSWORD ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret SOURCE_REPO_GIT | SOURCE_REPO_GIT ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret CLOUD_PROVIDERS_SOURCE_REPO | CLOUD_PROVIDERS_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret OBSERVABILITY_SOURCE_REPO | OBSERVABILITY_SOURCE_REPO ;
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/fox_pull_secret DECKHOUSE_PRIVATE_REPO | DECKHOUSE_PRIVATE_REPO ;

      # </template: import_secrets>

      # <template: checkout_full_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2
        with:
          fetch-depth: 0
      # </template: checkout_full_step>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>


      # <template: login_readonly_registry_step>
      - name: Check readonly registry credentials
        id: check_readonly_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_READ_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to readonly registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_readonly_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Check rw registry credentials
        id: check_rw_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to rw registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      - name: Login to Github Container Registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_rw_registry.outputs.has_credentials != 'true' }}
        with:
          registry: ghcr.io
          username: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          password: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>


      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v2
        with:
          version: ${{env.WERF_VERSION}}
      # </template: werf_install_step>

      # <template: add_ssh_keys>
      - name: Start ssh-agent
        uses: webfactory/ssh-agent@v0.9.0
        with:
          ssh-private-key: |
            ${{secrets.SOURCE_REPO_SSH_KEY}}
            ${{ secrets.SVACE_ANALYZE_SSH_PRIVATE_KEY }}
      - name: Add ssh_known_hosts
        run: |
          HOST=$(grep -oP '(?<=@)[^/:]+' <<< ${{secrets.SOURCE_REPO_GIT}})
          echo "::add-mask::$HOST"
          IPS=$(nslookup "$HOST" | awk '/^Address: / { print $2 }')
          for IP in $IPS; do
            echo "::add-mask::$IP"
          done
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$HOST" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
            CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
            if ! grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
            fi
          done <<< "$HOST_KEYS"
      - name: Add svace analyze server to ssh_known_hosts
        continue-on-error: true
        run: |
          host=${{ secrets.SVACE_ANALYZE_HOST }}
          host_ip=$(nslookup "$host" | awk '/^Address: / { print $2 }')
          echo "::add-mask::$host_ip"
          mkdir -p ~/.ssh
          touch ~/.ssh/known_hosts
          HOST_KEYS=$(ssh-keyscan -H "$host" 2>/dev/null)
          while IFS= read -r KEY_LINE; do
              CONSTANT_PART=$(awk '{print $2, $3}' <<< "$KEY_LINE")
              if grep -q "$CONSTANT_PART" ~/.ssh/known_hosts; then
                  ssh-keygen -R $host
                  ssh-keygen -R $host_ip
              fi
              echo "$KEY_LINE" >> ~/.ssh/known_hosts
          done <<< "$HOST_KEYS"
      # </template: add_ssh_keys>

      - name: Set up Go 1.24
        uses: actions/setup-go@v5
        with:
          go-version: '1.24'
          cache: false

      - name: Run go generate
        run: |
          (make generate)
          (cd modules/500-upmeter/hooks/smokemini/internal/snapshot && go generate -v)

      - name: Check generated code
        run: git diff --exit-code || (echo 'Regenerated code does not match source, please run "make generate"' && exit 1)

      - name: Build and push deckhouse images
        id: build
        env:
          DECKHOUSE_REGISTRY_STAGE_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          DECKHOUSE_REGISTRY_STAGE_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          GHCR_IO_REGISTRY_USER: ${{ secrets.GHCR_IO_REGISTRY_USER }}
          GHCR_IO_REGISTRY_PASSWORD: ${{ secrets.GHCR_IO_REGISTRY_PASSWORD }}
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          DECKHOUSE_REGISTRY_USER : ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          DECKHOUSE_REGISTRY_PASSWORD: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          SOURCE_REPO: "${{ steps.secrets.outputs.SOURCE_REPO_GIT }}"
          CLOUD_PROVIDERS_SOURCE_REPO: "${{ steps.secrets.outputs.CLOUD_PROVIDERS_SOURCE_REPO }}"
          OBSERVABILITY_SOURCE_REPO: "${{ steps.secrets.outputs.OBSERVABILITY_SOURCE_REPO }}"
          DECKHOUSE_PRIVATE_REPO: "${{ steps.secrets.outputs.DECKHOUSE_PRIVATE_REPO }}"
          COSIGN_KEY: ${{ steps.secrets.outputs.COSIGN_KEY }}
          COSIGN_VAULT_ADDRESS: "https://seguro.flant.com"
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_BRANCH: ${{needs.git_info.outputs.ci_commit_branch}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          COSIGN_VAULT_KEY: "dh-2025-aug-ec"
          COSIGN_TRANSIT_SECRET_ENGINE_PATH: "dh-signer"
          COSIGN_AUTH_ROLE: "dh-signer_dh-signer"
          REGISTRY_USER: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          REGISTRY_PASSWORD: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
        run: |
          # Extract REPO_SUFFIX from repository name: trim prefix 'deckhouse/deckhouse-'.
          REPO_SUFFIX=${GITHUB_REPOSITORY#deckhouse/deckhouse-}
          if [[ $REPO_SUFFIX == $GITHUB_REPOSITORY ]] ; then
            # REPO_SUFFIX should be empty for main repo 'deckhouse/deckhouse'.
            REPO_SUFFIX=
          fi

          # Put tags on produced images and push to dev and release repositories.
          #
          # There are 2 modes: "dev" and "release".
          # The "dev" mode builds branches only:
          # - Build using dev-registry as primary and deckhouse registry as secondary.
          # - Push dev and dev/install images with prNUM tags and push to dev-registry.
          # The "release" mode builds branches and tags:
          # - Build using deckhouse registry as final and dev-registry as primary.
          # - Push dev and dev/install images to dev-registry with tag equal to a branch name (main or release-X.Y).
          # - Push dev, dev/install and release-channel-version images to deckhouse registry with tag equels to a Git tag.

          # IMAGE_NAME is a name of image from werf.yaml.
          # IMAGE_DST is an image name for docker push.
          function publish_image() {
            IMAGE_NAME=$1
            IMAGE_DST=$2
            IMAGE_SRC="$(jq -r ".Images.\"${IMAGE_NAME}\".DockerImageName" images_tags_werf.json)"
            echo "‚öìÔ∏è üí´ [$(date -u)] Publishing '${IMAGE_NAME}' image to ${IMAGE_DST}".
            echo "‚öìÔ∏è üì• [$(date -u)] Pull '${IMAGE_NAME}' image as ${IMAGE_SRC}."
            docker pull "${IMAGE_SRC}"
            echo "‚öìÔ∏è üè∑ [$(date -u)] Tag '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image tag "${IMAGE_SRC}" "${IMAGE_DST}"
            echo "‚öìÔ∏è üì§ [$(date -u)] Push '${IMAGE_NAME}' image as ${IMAGE_DST}."
            docker image push "${IMAGE_DST}"
            echo "‚öìÔ∏è üßπ [$(date -u)] Remove local tag for '${IMAGE_NAME}'."
            docker image rmi "${IMAGE_DST}" || true;
          }

          # CE/EE/FE -> ce/ee/fe
          REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          # Temporary directory is moved to ensure
          TEMP_WORKDIR="$(dirname "${{github.workspace}}")/${{github.run_id}}-$REGISTRY_SUFFIX"
          echo "build_report_dir=$(echo ${TEMP_WORKDIR})" >> $GITHUB_OUTPUT
          mkdir -p "$TEMP_WORKDIR"
          STAGE_REGISTRY_PATH="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_PATH="${STAGE_REGISTRY_PATH}"
          export WERF_REPO="${STAGE_REGISTRY_PATH}"

          # Registry path to publish images for Git tags.
          if [[ -n ${DECKHOUSE_REGISTRY_HOST:-} ]] ; then
          SEMVER_REGISTRY_PATH="${DECKHOUSE_REGISTRY_HOST}/deckhouse"
          else
          SEMVER_REGISTRY_PATH="${GHA_TEST_REGISTRY_PATH}"
          fi
          # Release tag build, set deckhouse registry as final
          export WERF_FINAL_REPO="${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}"

          # The Git tag may contain a '+' sign, so use slugify for this situation.
          # Slugify doesn't change a tag with safe-only characters.
          IMAGE_TAG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
          export WERF_DISABLE_META_TAGS=true

          type werf && source $(werf ci-env github --verbose --as-file)
          werf build \
            --parallel=true --parallel-tasks-limit=10 \
            --save-build-report=true \
            --tmp-dir="$TEMP_WORKDIR" \
            --build-report-path images_tags_werf.json

          cp images_tags_werf.json "$TEMP_WORKDIR"

          # Publish images for Git branch.
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images to dev-registry for branch '${CI_COMMIT_BRANCH}' and edition '${WERF_ENV}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${REGISTRY_PATH}:${IMAGE_TAG}"
            publish_image 'dev/install' "${REGISTRY_PATH}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:${IMAGE_TAG}"
            publish_image 'e2e-opentofu-eks' "${REGISTRY_PATH}/e2e-opentofu-eks:${IMAGE_TAG}"

            # For release branches, also push release-channel to dev
            if [[ ${WERF_ENV,,} == "fe" && "${CI_COMMIT_BRANCH}" =~ release-([0-9]+\.[0-9]+) ]]; then
              publish_image 'dev' "${REGISTRY_PATH}:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install' "${REGISTRY_PATH}/install:v${BASH_REMATCH[1]}.0"
              publish_image 'dev/install-standalone' "${REGISTRY_PATH}/install-standalone:v${BASH_REMATCH[1]}.0"
              publish_image 'release-channel-version' "${REGISTRY_PATH}/release-channel:v${BASH_REMATCH[1]}.0"
            fi
          else
            echo "Branch unset, skipping branch publish."
          fi

          # Publish images for Git tag.
          if [[ "${CI_COMMIT_TAG}" =~ ^v[0-9]+\.[0-9]+\.[0-9]+$ ]]; then
            echo "‚öìÔ∏è üí´ [$(date -u)] Publish images for Git tag '${CI_COMMIT_TAG}' and registry suffix '${REGISTRY_SUFFIX}' using tag '${IMAGE_TAG}' ..."
            publish_image 'dev' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}:${IMAGE_TAG}"
            publish_image 'dev/install' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install:${IMAGE_TAG}"
            publish_image 'dev/install-standalone' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/install-standalone:${IMAGE_TAG}"
            publish_image 'release-channel-version' "${SEMVER_REGISTRY_PATH}/${REGISTRY_SUFFIX}/release-channel:${IMAGE_TAG}"
          else
            echo "Not a release tag, skipping tag publish."
          fi

          # Save 'tests' image name to pass it as output for 'tests' jobs.
          TESTS_IMAGE_NAME="$(jq -r '.Images."tests".DockerImageName' images_tags_werf.json)"
          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Tests image name: '${TESTS_IMAGE_NAME}'" | tr '[:lower:]' '[:upper:]'
          # Encode as gzip+base64 to evade github's SecretMasker error: "Skip output since it may contain secret".
          echo "tests_image_name=$(echo ${TESTS_IMAGE_NAME} | gzip | base64 -w0)" >> $GITHUB_OUTPUT

          # Filter out data from build report
          egrep -v '(DockerRepo|DockerImageName)' "$TEMP_WORKDIR/images_tags_werf.json" > "$TEMP_WORKDIR/images_tags_werf_filtered.json"
          mv "$TEMP_WORKDIR/images_tags_werf_filtered.json" "$TEMP_WORKDIR/images_tags_werf.json"

      - name: Check DKP images manifests in public registry
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        id: check_images
        env:
          CI_COMMIT_REF_SLUG: ${{needs.git_info.outputs.ci_commit_ref_slug}}
          DECKHOUSE_REGISTRY_READ_HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          EDITION=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]')

          ./tools/check-release-images.sh --tag ${CI_COMMIT_REF_SLUG} --edition ${EDITION} --images-path ${DECKHOUSE_REGISTRY_READ_HOST}/deckhouse/


      - uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.12.3'

      - name: Copy attestations
        if: ${{ github.repository == 'deckhouse/deckhouse' && startsWith(github.ref, 'refs/tags/v') }}
        env:
          DECKHOUSE_REGISTRY_HOST: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          STAGE_REGISTRY_HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          export REGISTRY_FROM="${DECKHOUSE_REGISTRY_STAGE_HOST}/${REGISTRY_PATH}"
          export REGISTRY_TO="${DECKHOUSE_REGISTRY_HOST}/deckhouse/${WERF_ENV,,}"
          export IMAGES_TAGS_PATH=${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json
          python .github/scripts/python/copy_attestations.py

      - name: Save build report
        if: ${{ always() && (steps.build.outcome == 'success' || steps.build.outcome == 'failure') }}
        uses: actions/upload-artifact@v4.4.0
        with:
          name: build_report_${{ env.WERF_ENV }}
          path: |
            ${{ steps.build.outputs.build_report_dir }}/images_tags_werf.json

    # </template: build_template>


  analyze_deckhouse:
    if: ${{ github.event.inputs.svace_enabled == 'true' }}
    name: Deckhouse static analysis
    needs:
      - build_fe
    runs-on: [self-hosted, regular]
    steps:
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/24cb1d7c-717a-4f92-8547-26f632916a7a/Svace_CI SVACE_ANALYZE_HOST | SVACE_ANALYZE_HOST ;
            projects/data/24cb1d7c-717a-4f92-8547-26f632916a7a/Svace_CI SVACE_ANALYZE_SSH_USER | SVACE_ANALYZE_SSH_USER ;
            projects/data/24cb1d7c-717a-4f92-8547-26f632916a7a/Svace_CI SVACER_URL | SVACER_URL ;
            projects/data/24cb1d7c-717a-4f92-8547-26f632916a7a/Svace_CI SVACER_IMPORT_USER | SVACER_IMPORT_USER ;
            projects/data/24cb1d7c-717a-4f92-8547-26f632916a7a/Svace_CI SVACER_IMPORT_PASSWORD | SVACER_IMPORT_PASSWORD ;
            projects/data/24cb1d7c-717a-4f92-8547-26f632916a7a/Svace_CI SVACE_ANALYZE_SSH_PRIVATE_KEY | SVACE_ANALYZE_SSH_PRIVATE_KEY ;

      # </template: import_secrets>
      - uses: deckhouse/modules-actions/svace_analyze@v4
        with:
          project_group: "DKP"
          ci_commit_ref_name: ${{ github.ref_name }}
          ci_commit_hash: ${{ github.sha }}
          svace_analyze_host: "${{ steps.secrets.outputs.SVACE_ANALYZE_HOST }}"
          svace_analyze_ssh_user: "${{ steps.secrets.outputs.SVACE_ANALYZE_SSH_USER }}"
          svacer_url: "${{ steps.secrets.outputs.SVACER_URL }}"
          svacer_import_user: "${{ steps.secrets.outputs.SVACER_IMPORT_USER }}"
          svacer_import_password: "${{ steps.secrets.outputs.SVACER_IMPORT_PASSWORD }}"
          svace_analyze_ssh_private_key: "${{ steps.secrets.outputs.SVACE_ANALYZE_SSH_PRIVATE_KEY }}"

  list_changed_modules:
    name: List changed modules
    continue-on-error: true
    if: ${{ startsWith(github.ref, 'refs/tags/v') && needs.build_fe.result == 'success' }}
    needs:
      - git_info
      - build_fe
    runs-on: [self-hosted, regular]
    steps:
      - uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.12.3'

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2

      # </template: checkout_step>
      # <template: import_secrets>
      - name: Split repository name
        id: split
        env:
          REPO: ${{ github.repository }}
        run: echo "name=${REPO##*/}" >> $GITHUB_OUTPUT
      - name: Import secrets
        id: secrets
        uses: hashicorp/vault-action@v2
        with:
          url: https://seguro.flant.com
          path: github
          role: "${{ steps.split.outputs.name }}"
          method: jwt
          jwtGithubAudience: github-access-aud
          secrets: |
            projects/data/6db2f1ee-9b6f-4f4f-8381-2fb43060478a/github/registry_host DECKHOUSE_REGISTRY_STAGE_HOST | DECKHOUSE_REGISTRY_STAGE_HOST ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken login | DECKHOUSE_REGISTRY_STAGE_USER ;
            projects/data/101ceaca-97cd-462f-aed5-070d9b9de175/stage-registry/writetoken password | DECKHOUSE_REGISTRY_STAGE_PASSWORD ;

      # </template: import_secrets>

      # <template: login_stage_registry_step>
      - name: Check stage registry credentials
        id: check_stage_registry
        env:
          HOST: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_STAGE_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to stage registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_stage_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}
          username: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_USER }}
          password: ${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_PASSWORD }}
          logout: false
      # </template: login_stage_registry_step>

      # <template: login_readonly_registry_step>
      - name: Check readonly registry credentials
        id: check_readonly_registry
        env:
          HOST: ${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}
        run: |
          if [[ -n $HOST ]]; then
            echo "has_credentials=true" >> $GITHUB_OUTPUT
            echo "web_registry_path=${{secrets.DECKHOUSE_REGISTRY_READ_HOST }}/deckhouse/site" >> $GITHUB_OUTPUT
          fi
      - name: Login to readonly registry
        uses: docker/login-action@v2.1.0
        if: ${{ steps.check_readonly_registry.outputs.has_credentials == 'true' }}
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # </template: check-tag-for-release-branch>
      - name: Check tag for release branch
        id: check-tag-for-release-branch
        uses: actions/github-script@v6.4.1
        with:
          result-encoding: string
          script: |
            const { data: tags } = await github.rest.repos.listTags({
              owner: context.repo.owner,
              repo: context.repo.repo,
              per_page: 100
            });

            const prefix = `v${version}.`;
            const versionTags = tags.filter(tag => tag.name.startsWith(prefix));
            console.log(`Filtered tags: ${versionTags.map(t => t.name).join(', ')}`);

            if (versionTags.length === 0) {
              console.log('No tags found for this version, skipping');
              return false;
            }

            const compareTags = (a, b) => {
              const aVersion = a.name.split('.').map(Number);
              const bVersion = b.name.split('.').map(Number);
              for (let i = 0; i < 3; i++) {
                if (aVersion[i] !== bVersion[i]) {
                  return bVersion[i] - aVersion[i];
                }
              }
              return 0;
            };

            versionTags.sort(compareTags);
            const latestTag = versionTags[0];
            console.log(`Latest tag for ${version}: ${latestTag.name}`);

            const patchVersion = latestTag.name.split('.')[2];
            const patchNumber = parseInt(patchVersion);
            console.log(`Patch version: ${patchNumber}`);
            return patchNumber >= 1;
      # example use ${{ steps.check-tag-for-release-branch.outputs.result == 'true' }}
      # </template: check-tag-for-release-branch>
      - name: List changed modules from latest released version
        id: list_changed_modules
        if: ${{ steps.check-tag-for-release-branch.outputs.result == 'true' }}
        env:
          IMAGE_TO: "${{ steps.secrets.outputs.DECKHOUSE_REGISTRY_STAGE_HOST }}/sys/deckhouse-oss:${{ github.ref_name }}"
          COMPARE_MAX_ATTEMPTS: 10
          COMPARE_RETRY_DELAY: 30
        run: |
          TAG_FROM="$(git ls-remote --tags origin | grep -F tags/v${GITHUB_REF_NAME} | awk -F '/' '{print $3}' | sort -V | tail -n 1)"
          if [[ -n "${TAG_FROM}" ]]; then
            export IMAGE_FROM="${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}/deckhouse/fe:${TAG_FROM}"
            python .github/scripts/python/compare_version_modules.py
          else
            echo "No released versions exist. Skipping."
          fi

      # <template: send_fail_report>
      - name: Send fail report
        if: ${{ failure() && github.repository == 'deckhouse/deckhouse' }}
        env:
          LOOP_SERVICE_NOTIFICATIONS: ${{ secrets.LOOP_SERVICE_NOTIFICATIONS }}
          JOB_NAME: ${{ github.job }}
          WORKFLOW_NAME: ${{ github.workflow }}
          WORKFLOW_URL: ${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}/
        run: |
          bash ./.github/scripts/send-report.sh --webhook "ci_fail"
      # </template: send_fail_report>

  compare_internal_modules:
    name: Compare internal modules
    needs:
      - build_fe
      - build_ee
      - build_ce
      - build_be
      - build_se
      - build_se_plus
    if: ${{ always() && needs.build_fe.result == 'success' }}
    runs-on: regular
    steps:
      - uses: actions/setup-python@v5.6.0
        with:
          python-version: '3.12.3'

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v3.5.2

      # </template: checkout_step>
      - name: Get artifacts
        uses: actions/download-artifact@v4.1.8
      - name: Compare modules
        run: python .github/scripts/python/compare_internal_modules.py
