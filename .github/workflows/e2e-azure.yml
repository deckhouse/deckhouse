#
# THIS FILE IS GENERATED, PLEASE DO NOT EDIT.
#

# <template: e2e_workflow_template>
name: 'e2e: Azure'
on:
  workflow_dispatch:
    inputs:
      issue_id:
        description: 'ID of issue where label was set'
        required: false
      issue_number:
        description: 'Number of issue where label was set'
        required: false
      comment_id:
        description: 'ID of comment in issue where to put workflow run status'
        required: false
      ci_commit_ref_name:
        description: 'Git ref name for image tags'
        required: false
      pull_request_ref:
        description: 'Git ref for checkout PR sources'
        required: false
      pull_request_sha:
        description: 'Git SHA for restoring artifacts from cache'
        required: false
      pull_request_head_label:
        description: 'Head label of pull request. e.g. my_repo:my_feature_branch'
        required: false
      cri:
        description: 'A comma-separated list of cri to test. Available: Docker and Containerd.'
        required: false
      ver:
        description: 'A comma-separated list of versions to test. Available: from 1.19 to 1.22.'
        required: false
env:

  # <template: werf_envs>
  # Don't forget to update .gitlab-ci-simple.yml if necessary
  WERF_CHANNEL: "ea"
  WERF_ENV: "FE"
  # We use stapel image from own registry due to docker hub pull amount limitation.
  # To re-push stapel image from docker hub use command:
  # `skopeo copy docker://flant/werf-stapel:0.6.1 docker://registry-write.deckhouse.io/flant/werf-stapel:0.6.1`
  WERF_STAPEL_IMAGE_NAME: "${{secrets.DECKHOUSE_REGISTRY_READ_HOST}}/flant/werf-stapel"
  WERF_STAPEL_IMAGE_VERSION: "0.6.1"
  TEST_TIMEOUT: "15m"
  # Use fixed string 'sys/deckhouse-oss' for repo name. ${CI_PROJECT_PATH} is not available here in Github.
  DEV_REGISTRY_PATH: "${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}/sys/deckhouse-oss"
  BASE_IMAGES_REGISTRY_PATH: "registry.deckhouse.io/base_images/"

  FLANT_REGISTRY_PATH: "${{ secrets.FLANT_REGISTRY_HOST }}/sys/deckhouse-oss"
  # </template: werf_envs>


  # command to copy image to our registry - crane copy alpine:3.12.1@sha256:HASHVALUE ${OUR_PRIVATE_REGISTRY}/base_images/alpine:3.12.1@sha256:HASHVALUE
  # https://github.com/google/go-containerregistry/blob/main/cmd/crane/doc/crane.md
  BASE_ALPINE: "registry.deckhouse.io/base_images/alpine:3.12.1@sha256:c0e9560cda118f9ec63ddefb4a173a2b2a0347082d7dff7dc14272e7841a5b5a"
  BASE_ALPINE_3_15: "registry.deckhouse.io/base_images/alpine:3.15@sha256:21a3deaa0d32a8057914f36584b5288d2e5ecc984380bc0118285c70fa8c9300"
  BASE_DEBIAN: "registry.deckhouse.io/base_images/debian:buster-20210111@sha256:b16f66714660c4b3ea14d273ad8c35079b81b35d65d1e206072d226c7ff78299"
  BASE_DEBIAN_BULLSEYE: "registry.deckhouse.io/base_images/debian:bullseye@sha256:039f72a400b48c272c6348f0a3f749509b18e611901a21379abc7eb6edd53392"
  BASE_ETCD: "k8s.gcr.io/etcd:3.5.1-0@sha256:64b9ea357325d5db9f8a723dcf503b5a449177b17ac87d69481e126bb724c263"
  BASE_GOLANG_16_ALPINE: "registry.deckhouse.io/base_images/golang:1.16.3-alpine3.12@sha256:371dc6bf7e0c7ce112a29341b000c40d840aef1dbb4fdcb3ae5c0597e28f3061"
  BASE_GOLANG_16_BUSTER: "registry.deckhouse.io/base_images/golang:1.16.3-buster@sha256:9d64369fd3c633df71d7465d67d43f63bb31192193e671742fa1c26ebc3a6210"
  BASE_GOLANG_17_ALPINE: "registry.deckhouse.io/base_images/golang:1.17.3-alpine3.14@sha256:78a88e6a712e60f9d942450e02508f3c0d8aa931853f02793a4c3aa30063eae0"
  BASE_GOLANG_17_BUSTER: "registry.deckhouse.io/base_images/golang:1.17.3-buster@sha256:be7aa81b44dc85ddf4008bc5f3d5a5acfca8517620d0c4a393601c8e0495fb05"
  BASE_GOLANG_ALPINE: "registry.deckhouse.io/base_images/golang:1.15.3-alpine3.12@sha256:df0119b970c8e5e9f0f5c40f6b55edddf616bab2b911927ebc3b361c469ea29c"
  BASE_GOLANG_BUSTER: "registry.deckhouse.io/base_images/golang:1.15.3-buster@sha256:fb04edf20446eed8af9eb6137d02fdf607f47028a0a806131f8b175a09620aab"
  BASE_JEKYLL: "registry.deckhouse.io/base_images/jekyll/jekyll:3.8@sha256:9521c8aae4739fcbc7137ead19f91841b833d671542f13e91ca40280e88d6e34"
  BASE_NGINX_ALPINE: "registry.deckhouse.io/base_images/nginx:1.21.6-alpine@sha256:050385609d832fae11b007fbbfba77d0bba12bf72bc0dca0ac03e09b1998580f"
  BASE_NODE_16_ALPINE: "registry.deckhouse.io/base_images/node:16.13.0-alpine3.14@sha256:5277c7d171e02ee76417bb290ef488aa80e4e64572119eec0cb9fffbcffb8f6a"
  BASE_PYTHON_ALPINE: "registry.deckhouse.io/base_images/python:3.7.9-alpine3.12@sha256:8c224566c41fcc1674f9b78ff2a364a1209370a5b7e7619e8ead2bdcd0fd8b52"
  BASE_RUST: "registry.deckhouse.io/base_images/rust:1.57.0@sha256:7d2592d1a6a73055fbadc0c76868046736ce5fa834ed5c201e3b21f27c28947e"
  BASE_SCRATCH: "registry.deckhouse.io/base_images/spotify/scratch@sha256:db4cabf15c8b9eb70dabe1da385b6d9b2cac6d658b813fbb57dc5231ddd52420"
  BASE_SHELL_OPERATOR: "registry.deckhouse.io/base_images/flant/shell-operator:v1.0.1@sha256:51dbdbad17303c31265af389c6acc73d1b6b6c66bd2112542e09b42566ac05bf"
  BASE_UBUNTU: "registry.deckhouse.io/base_images/ubuntu:bionic-20210118@sha256:ea188fdc5be9b25ca048f1e882b33f1bc763fb976a8a4fea446b38ed0efcbeba"

  # Terraform settings
  TF_AWS_NAMESPACE: hashicorp
  TF_AWS_TYPE: aws
  TF_AWS_VERSION: 3.56.0
  TF_AZURE_NAMESPACE: hashicorp
  TF_AZURE_TYPE: azurerm
  TF_AZURE_VERSION: 2.36.0
  TF_GCP_NAMESPACE: hashicorp
  TF_GCP_TYPE: google
  TF_GCP_VERSION: 3.48.0
  TF_OPENSTACK_NAMESPACE: terraform-provider-openstack
  TF_OPENSTACK_TYPE: openstack
  TF_OPENSTACK_VERSION: 1.32.0
  TF_VERSION: 0.13.4
  TF_VSPHERE_NAMESPACE: hashicorp
  TF_VSPHERE_TYPE: vsphere
  TF_VSPHERE_VERSION: 2.0.2
  TF_YANDEX_NAMESPACE: yandex-cloud
  TF_YANDEX_TYPE: yandex
  TF_YANDEX_VERSION: 0.45.1

# Note: no concurrency section for e2e workflows.
# Usually you run e2e and wait until it ends.

jobs:
  started_at:
    name: Save start timestamp
    outputs:
      started_at: ${{ steps.started_at.outputs.started_at }}
    runs-on: "ubuntu-latest"
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>


  # <template: git_info_job>

  git_info:
    name: Get git info
    runs-on: ubuntu-latest
    outputs:
      ci_commit_tag: ${{ steps.git_info.outputs.ci_commit_tag }}
      ci_commit_branch: ${{ steps.git_info.outputs.ci_commit_branch }}
      ci_commit_ref_name: ${{ steps.git_info.outputs.ci_commit_ref_name }}
      ci_commit_ref_slug: ${{ steps.git_info.outputs.ci_commit_ref_slug }}
      ci_pipeline_created_at: ${{ steps.git_info.outputs.ci_pipeline_created_at }}
      github_sha: ${{ steps.git_info.outputs.github_sha }}
    # Skip the CI for automation PRs, e.g. changelog
    if: ${{ github.event.pull_request.user.login != 'deckhouse-BOaTswain' }}
    steps:
      - id: git_info
        name: Get tag name and SHA
        uses: actions/github-script@v5.0.0
        with:
          script: |
            const { GITHUB_REF_TYPE, GITHUB_REF_NAME } = process.env

            let githubBranch = '';
            let githubTag = '';
            let githubSHA = '';
            let refName = '';
            let refSlug = '';
            if (context.eventName === "workflow_dispatch" && context.payload.inputs && context.payload.inputs.pull_request_ref) {
              // workflow_dispatch run for pull request should have input 'pull_request_ref'.
              // Note: value in inputs.pull_request_ref is for pull_request_info job.
              refName       = context.payload.inputs.ci_commit_ref_name
              githubBranch  = refName
              githubSHA     = context.payload.inputs.pull_request_sha
              // Extract pull request number from 'refs/pull/<NUM>/merge'
              const prNum   = context.payload.inputs.pull_request_ref.replace('refs/pull/', '').replace('/merge', '').replace('/head', '');
              refSlug       = `pr${prNum}`;
              core.info(`workflow_dispatch event: set git info from inputs. inputs: ${JSON.stringify(context.payload.inputs)}`)
            } else if (context.eventName === "pull_request" || context.eventName === "pull_request_target" ) {
              // For PRs from forks, tag images with `prXXX` to avoid clashes between branches.
              const targetRepo = context.payload.repository.full_name;
              const prRepo = context.payload.pull_request.head.repo.full_name
              const prRef = context.payload.pull_request.head.ref

              refSlug = `pr${context.issue.number}`;
              refName = (prRepo === targetRepo) ? prRef : refSlug;
              githubBranch = refName
              githubSHA = context.payload.pull_request.head.sha
              core.info(`pull request event: set git info from pull_request.head. pr:${prRepo}:${prRef} target:${targetRepo}:${context.ref}`)
            } else {
              // Events: workflow_dispatch without pull_request_ref, schedule, push...
              refName       = GITHUB_REF_NAME
              githubTag     = GITHUB_REF_TYPE == "tag"    ? refName : ""
              githubBranch  = GITHUB_REF_TYPE == "branch" ? refName : ""
              githubSHA     = context.sha
              // refName is 'main' or tag name, so slugification is not necessary.
              refSlug       = refName
              core.info(`${context.eventName} event: set git info from context: ${JSON.stringify({GITHUB_REF_NAME, GITHUB_REF_TYPE, sha: context.sha })}`)
            }

            core.info(`output.ci_commit_ref_slug: '${refSlug}'`)
            core.info(`output.ci_commit_ref_name: '${refName}'`)
            core.info(`output.ci_commit_tag:      '${githubTag}'`)
            core.info(`output.ci_commit_branch:   '${githubBranch}'`)
            core.info(`output.github_sha:         '${githubSHA}'`)

            core.setOutput('ci_commit_ref_slug', refSlug)
            core.setOutput('ci_commit_ref_name', refName)
            core.setOutput(`ci_commit_tag`, githubTag)
            core.setOutput(`ci_commit_branch`, githubBranch)
            core.setOutput('github_sha', githubSHA)

  # </template: git_info_job>

  # <template: check_e2e_labels_job>
  check_e2e_labels:
    name: Check e2e labels
    runs-on: ubuntu-latest
    outputs:

      run_docker_1_19: ${{ steps.check.outputs.run_docker_1_19 }}
      run_docker_1_20: ${{ steps.check.outputs.run_docker_1_20 }}
      run_docker_1_21: ${{ steps.check.outputs.run_docker_1_21 }}
      run_docker_1_22: ${{ steps.check.outputs.run_docker_1_22 }}
      run_containerd_1_19: ${{ steps.check.outputs.run_containerd_1_19 }}
      run_containerd_1_20: ${{ steps.check.outputs.run_containerd_1_20 }}
      run_containerd_1_21: ${{ steps.check.outputs.run_containerd_1_21 }}
      run_containerd_1_22: ${{ steps.check.outputs.run_containerd_1_22 }}
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0

      # </template: checkout_step>
      - name: Check e2e labels
        id: check
        uses: actions/github-script@v5.0.0
        with:
          script: |
            const provider = 'azure';

            const ci = require('./.github/scripts/js/ci');
            return await ci.checkE2ELabels({github, context, core, provider});
  # </template: check_e2e_labels_job>


  # <template: e2e_run_job_template>
  run_docker_1_19:
    name: "e2e: Azure, Docker, Kubernetes 1.19"
    needs:
      - check_e2e_labels
      - git_info
    if: needs.check_e2e_labels.outputs.run_docker_1_19 == 'true'
    env:
      PROVIDER: Azure
      CRI: Docker
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.19"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const name = 'e2e: Azure, Docker, Kubernetes 1.19';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>

      # <template: login_dev_registry_step>
      - name: Login to dev registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_readonly_registry_step>
      - name: Login to readonly registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Login to rw registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        run: |
          # Random delay to sparse 'update comment' steps in time.
          delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
          echo Delay for $delay
          sleep $delay

          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          echo "::set-output name=prefix::${prefix}"
          echo "prefix=${prefix}"

          # Create tmppath for test script.
          tmppath=/mnt/cloud-layouts/layouts/${prefix}
          if [[ -d "${tmppath}" ]] ; then
            echo "Temporary dir already exists: ${tmppath}. ERROR!"
            ls -la ${tmppath}
            exit 1
          else
            echo "Create temporary dir for job: ${tmppath}."
            mkdir -p "${tmppath}"
          fi
          echo "::set-output name=tmppath::${tmppath}"

          CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
          CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

          if [[ -n "${CI_COMMIT_TAG}" ]] ; then
            CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
          fi
          if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
            CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
          fi
          echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

          ## Deckhouse 'install' image name
          ## Source: ci_templates/build.yml

          IMAGE_NAME=
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            # Use it as image tag.
            IMAGE_TAG=${CI_COMMIT_REF_SLUG}

            if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
              IMAGE_NAME=${DEV_REGISTRY_PATH}/install:${IMAGE_TAG}
            else
              IMAGE_NAME=${CI_REGISTRY_IMAGE}/install:${IMAGE_TAG}
            fi
          fi

          if [[ -n $CI_COMMIT_TAG ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
              IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${CI_COMMIT_TAG}
            else
              echo "DECKHOUSE_REGISTRY_HOST is empty."
              exit 1
            fi
          fi

          echo "::set-output name=install-image-name::${IMAGE_NAME}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Name: ${IMAGE_NAME}" | tr '[:upper:]' '[:lower:]'
          echo "Pull 'dev/install' image"
          docker pull "${IMAGE_NAME}"

      - name: "Run e2e test: Azure/Docker/1.19"
        env:
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.19"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Cleanup bootstrapped cluster
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.19"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test_output_azure_docker_1_19
          path: |
            testing/cloud_layouts/

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'job,separate';
            const name = 'e2e: Azure, Docker, Kubernetes 1.19';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

      - name: Alert on fail in default branch
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
        env:
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.19"
        run: |
          WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
          echo $WORKFLOW_URL

          alertData=$(cat <<EOF
          {
            "labels": {
              "severity_level": 7,
              "trigger": "CloudLayoutTestFailed",
              "provider": "${PROVIDER}",
              "layout": "${LAYOUT}",
              "cri": "${CRI}",
              "kubernetes_version": "${KUBERNETES_VERSION}"
            },
            "annotations": {
              "summary": "Cloud Layout Test failed",
              "description": "Check Github workflow log for more information",
              "plk_protocol_version": "1",
              "plk_link_url/job": "${WORKFLOW_URL}",
              "plk_link_title_en/job": "Github job run",
              "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
              "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
            }
          }
          EOF
          )

          curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
            -H 'Content-Type: application/json' \
            -d "${alertData}"
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_docker_1_20:
    name: "e2e: Azure, Docker, Kubernetes 1.20"
    needs:
      - check_e2e_labels
      - git_info
    if: needs.check_e2e_labels.outputs.run_docker_1_20 == 'true'
    env:
      PROVIDER: Azure
      CRI: Docker
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.20"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const name = 'e2e: Azure, Docker, Kubernetes 1.20';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>

      # <template: login_dev_registry_step>
      - name: Login to dev registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_readonly_registry_step>
      - name: Login to readonly registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Login to rw registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        run: |
          # Random delay to sparse 'update comment' steps in time.
          delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
          echo Delay for $delay
          sleep $delay

          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          echo "::set-output name=prefix::${prefix}"
          echo "prefix=${prefix}"

          # Create tmppath for test script.
          tmppath=/mnt/cloud-layouts/layouts/${prefix}
          if [[ -d "${tmppath}" ]] ; then
            echo "Temporary dir already exists: ${tmppath}. ERROR!"
            ls -la ${tmppath}
            exit 1
          else
            echo "Create temporary dir for job: ${tmppath}."
            mkdir -p "${tmppath}"
          fi
          echo "::set-output name=tmppath::${tmppath}"

          CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
          CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

          if [[ -n "${CI_COMMIT_TAG}" ]] ; then
            CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
          fi
          if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
            CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
          fi
          echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

          ## Deckhouse 'install' image name
          ## Source: ci_templates/build.yml

          IMAGE_NAME=
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            # Use it as image tag.
            IMAGE_TAG=${CI_COMMIT_REF_SLUG}

            if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
              IMAGE_NAME=${DEV_REGISTRY_PATH}/install:${IMAGE_TAG}
            else
              IMAGE_NAME=${CI_REGISTRY_IMAGE}/install:${IMAGE_TAG}
            fi
          fi

          if [[ -n $CI_COMMIT_TAG ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
              IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${CI_COMMIT_TAG}
            else
              echo "DECKHOUSE_REGISTRY_HOST is empty."
              exit 1
            fi
          fi

          echo "::set-output name=install-image-name::${IMAGE_NAME}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Name: ${IMAGE_NAME}" | tr '[:upper:]' '[:lower:]'
          echo "Pull 'dev/install' image"
          docker pull "${IMAGE_NAME}"

      - name: "Run e2e test: Azure/Docker/1.20"
        env:
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.20"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Cleanup bootstrapped cluster
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.20"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test_output_azure_docker_1_20
          path: |
            testing/cloud_layouts/

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'job,separate';
            const name = 'e2e: Azure, Docker, Kubernetes 1.20';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

      - name: Alert on fail in default branch
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
        env:
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.20"
        run: |
          WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
          echo $WORKFLOW_URL

          alertData=$(cat <<EOF
          {
            "labels": {
              "severity_level": 7,
              "trigger": "CloudLayoutTestFailed",
              "provider": "${PROVIDER}",
              "layout": "${LAYOUT}",
              "cri": "${CRI}",
              "kubernetes_version": "${KUBERNETES_VERSION}"
            },
            "annotations": {
              "summary": "Cloud Layout Test failed",
              "description": "Check Github workflow log for more information",
              "plk_protocol_version": "1",
              "plk_link_url/job": "${WORKFLOW_URL}",
              "plk_link_title_en/job": "Github job run",
              "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
              "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
            }
          }
          EOF
          )

          curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
            -H 'Content-Type: application/json' \
            -d "${alertData}"
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_docker_1_21:
    name: "e2e: Azure, Docker, Kubernetes 1.21"
    needs:
      - check_e2e_labels
      - git_info
    if: needs.check_e2e_labels.outputs.run_docker_1_21 == 'true'
    env:
      PROVIDER: Azure
      CRI: Docker
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.21"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const name = 'e2e: Azure, Docker, Kubernetes 1.21';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>

      # <template: login_dev_registry_step>
      - name: Login to dev registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_readonly_registry_step>
      - name: Login to readonly registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Login to rw registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        run: |
          # Random delay to sparse 'update comment' steps in time.
          delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
          echo Delay for $delay
          sleep $delay

          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          echo "::set-output name=prefix::${prefix}"
          echo "prefix=${prefix}"

          # Create tmppath for test script.
          tmppath=/mnt/cloud-layouts/layouts/${prefix}
          if [[ -d "${tmppath}" ]] ; then
            echo "Temporary dir already exists: ${tmppath}. ERROR!"
            ls -la ${tmppath}
            exit 1
          else
            echo "Create temporary dir for job: ${tmppath}."
            mkdir -p "${tmppath}"
          fi
          echo "::set-output name=tmppath::${tmppath}"

          CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
          CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

          if [[ -n "${CI_COMMIT_TAG}" ]] ; then
            CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
          fi
          if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
            CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
          fi
          echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

          ## Deckhouse 'install' image name
          ## Source: ci_templates/build.yml

          IMAGE_NAME=
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            # Use it as image tag.
            IMAGE_TAG=${CI_COMMIT_REF_SLUG}

            if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
              IMAGE_NAME=${DEV_REGISTRY_PATH}/install:${IMAGE_TAG}
            else
              IMAGE_NAME=${CI_REGISTRY_IMAGE}/install:${IMAGE_TAG}
            fi
          fi

          if [[ -n $CI_COMMIT_TAG ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
              IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${CI_COMMIT_TAG}
            else
              echo "DECKHOUSE_REGISTRY_HOST is empty."
              exit 1
            fi
          fi

          echo "::set-output name=install-image-name::${IMAGE_NAME}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Name: ${IMAGE_NAME}" | tr '[:upper:]' '[:lower:]'
          echo "Pull 'dev/install' image"
          docker pull "${IMAGE_NAME}"

      - name: "Run e2e test: Azure/Docker/1.21"
        env:
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.21"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Cleanup bootstrapped cluster
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.21"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test_output_azure_docker_1_21
          path: |
            testing/cloud_layouts/

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'job,separate';
            const name = 'e2e: Azure, Docker, Kubernetes 1.21';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

      - name: Alert on fail in default branch
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
        env:
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.21"
        run: |
          WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
          echo $WORKFLOW_URL

          alertData=$(cat <<EOF
          {
            "labels": {
              "severity_level": 7,
              "trigger": "CloudLayoutTestFailed",
              "provider": "${PROVIDER}",
              "layout": "${LAYOUT}",
              "cri": "${CRI}",
              "kubernetes_version": "${KUBERNETES_VERSION}"
            },
            "annotations": {
              "summary": "Cloud Layout Test failed",
              "description": "Check Github workflow log for more information",
              "plk_protocol_version": "1",
              "plk_link_url/job": "${WORKFLOW_URL}",
              "plk_link_title_en/job": "Github job run",
              "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
              "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
            }
          }
          EOF
          )

          curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
            -H 'Content-Type: application/json' \
            -d "${alertData}"
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_docker_1_22:
    name: "e2e: Azure, Docker, Kubernetes 1.22"
    needs:
      - check_e2e_labels
      - git_info
    if: needs.check_e2e_labels.outputs.run_docker_1_22 == 'true'
    env:
      PROVIDER: Azure
      CRI: Docker
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.22"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const name = 'e2e: Azure, Docker, Kubernetes 1.22';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>

      # <template: login_dev_registry_step>
      - name: Login to dev registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_readonly_registry_step>
      - name: Login to readonly registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Login to rw registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        run: |
          # Random delay to sparse 'update comment' steps in time.
          delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
          echo Delay for $delay
          sleep $delay

          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          echo "::set-output name=prefix::${prefix}"
          echo "prefix=${prefix}"

          # Create tmppath for test script.
          tmppath=/mnt/cloud-layouts/layouts/${prefix}
          if [[ -d "${tmppath}" ]] ; then
            echo "Temporary dir already exists: ${tmppath}. ERROR!"
            ls -la ${tmppath}
            exit 1
          else
            echo "Create temporary dir for job: ${tmppath}."
            mkdir -p "${tmppath}"
          fi
          echo "::set-output name=tmppath::${tmppath}"

          CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
          CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

          if [[ -n "${CI_COMMIT_TAG}" ]] ; then
            CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
          fi
          if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
            CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
          fi
          echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

          ## Deckhouse 'install' image name
          ## Source: ci_templates/build.yml

          IMAGE_NAME=
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            # Use it as image tag.
            IMAGE_TAG=${CI_COMMIT_REF_SLUG}

            if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
              IMAGE_NAME=${DEV_REGISTRY_PATH}/install:${IMAGE_TAG}
            else
              IMAGE_NAME=${CI_REGISTRY_IMAGE}/install:${IMAGE_TAG}
            fi
          fi

          if [[ -n $CI_COMMIT_TAG ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
              IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${CI_COMMIT_TAG}
            else
              echo "DECKHOUSE_REGISTRY_HOST is empty."
              exit 1
            fi
          fi

          echo "::set-output name=install-image-name::${IMAGE_NAME}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Name: ${IMAGE_NAME}" | tr '[:upper:]' '[:lower:]'
          echo "Pull 'dev/install' image"
          docker pull "${IMAGE_NAME}"

      - name: "Run e2e test: Azure/Docker/1.22"
        env:
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.22"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Cleanup bootstrapped cluster
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.22"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test_output_azure_docker_1_22
          path: |
            testing/cloud_layouts/

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'job,separate';
            const name = 'e2e: Azure, Docker, Kubernetes 1.22';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

      - name: Alert on fail in default branch
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
        env:
          PROVIDER: Azure
          CRI: Docker
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.22"
        run: |
          WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
          echo $WORKFLOW_URL

          alertData=$(cat <<EOF
          {
            "labels": {
              "severity_level": 7,
              "trigger": "CloudLayoutTestFailed",
              "provider": "${PROVIDER}",
              "layout": "${LAYOUT}",
              "cri": "${CRI}",
              "kubernetes_version": "${KUBERNETES_VERSION}"
            },
            "annotations": {
              "summary": "Cloud Layout Test failed",
              "description": "Check Github workflow log for more information",
              "plk_protocol_version": "1",
              "plk_link_url/job": "${WORKFLOW_URL}",
              "plk_link_title_en/job": "Github job run",
              "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
              "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
            }
          }
          EOF
          )

          curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
            -H 'Content-Type: application/json' \
            -d "${alertData}"
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_19:
    name: "e2e: Azure, Containerd, Kubernetes 1.19"
    needs:
      - check_e2e_labels
      - git_info
    if: needs.check_e2e_labels.outputs.run_containerd_1_19 == 'true'
    env:
      PROVIDER: Azure
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.19"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const name = 'e2e: Azure, Containerd, Kubernetes 1.19';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>

      # <template: login_dev_registry_step>
      - name: Login to dev registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_readonly_registry_step>
      - name: Login to readonly registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Login to rw registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        run: |
          # Random delay to sparse 'update comment' steps in time.
          delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
          echo Delay for $delay
          sleep $delay

          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          echo "::set-output name=prefix::${prefix}"
          echo "prefix=${prefix}"

          # Create tmppath for test script.
          tmppath=/mnt/cloud-layouts/layouts/${prefix}
          if [[ -d "${tmppath}" ]] ; then
            echo "Temporary dir already exists: ${tmppath}. ERROR!"
            ls -la ${tmppath}
            exit 1
          else
            echo "Create temporary dir for job: ${tmppath}."
            mkdir -p "${tmppath}"
          fi
          echo "::set-output name=tmppath::${tmppath}"

          CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
          CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

          if [[ -n "${CI_COMMIT_TAG}" ]] ; then
            CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
          fi
          if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
            CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
          fi
          echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

          ## Deckhouse 'install' image name
          ## Source: ci_templates/build.yml

          IMAGE_NAME=
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            # Use it as image tag.
            IMAGE_TAG=${CI_COMMIT_REF_SLUG}

            if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
              IMAGE_NAME=${DEV_REGISTRY_PATH}/install:${IMAGE_TAG}
            else
              IMAGE_NAME=${CI_REGISTRY_IMAGE}/install:${IMAGE_TAG}
            fi
          fi

          if [[ -n $CI_COMMIT_TAG ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
              IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${CI_COMMIT_TAG}
            else
              echo "DECKHOUSE_REGISTRY_HOST is empty."
              exit 1
            fi
          fi

          echo "::set-output name=install-image-name::${IMAGE_NAME}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Name: ${IMAGE_NAME}" | tr '[:upper:]' '[:lower:]'
          echo "Pull 'dev/install' image"
          docker pull "${IMAGE_NAME}"

      - name: "Run e2e test: Azure/Containerd/1.19"
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.19"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Cleanup bootstrapped cluster
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.19"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test_output_azure_containerd_1_19
          path: |
            testing/cloud_layouts/

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'job,separate';
            const name = 'e2e: Azure, Containerd, Kubernetes 1.19';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

      - name: Alert on fail in default branch
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.19"
        run: |
          WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
          echo $WORKFLOW_URL

          alertData=$(cat <<EOF
          {
            "labels": {
              "severity_level": 7,
              "trigger": "CloudLayoutTestFailed",
              "provider": "${PROVIDER}",
              "layout": "${LAYOUT}",
              "cri": "${CRI}",
              "kubernetes_version": "${KUBERNETES_VERSION}"
            },
            "annotations": {
              "summary": "Cloud Layout Test failed",
              "description": "Check Github workflow log for more information",
              "plk_protocol_version": "1",
              "plk_link_url/job": "${WORKFLOW_URL}",
              "plk_link_title_en/job": "Github job run",
              "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
              "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
            }
          }
          EOF
          )

          curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
            -H 'Content-Type: application/json' \
            -d "${alertData}"
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_20:
    name: "e2e: Azure, Containerd, Kubernetes 1.20"
    needs:
      - check_e2e_labels
      - git_info
    if: needs.check_e2e_labels.outputs.run_containerd_1_20 == 'true'
    env:
      PROVIDER: Azure
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.20"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const name = 'e2e: Azure, Containerd, Kubernetes 1.20';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>

      # <template: login_dev_registry_step>
      - name: Login to dev registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_readonly_registry_step>
      - name: Login to readonly registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Login to rw registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        run: |
          # Random delay to sparse 'update comment' steps in time.
          delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
          echo Delay for $delay
          sleep $delay

          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          echo "::set-output name=prefix::${prefix}"
          echo "prefix=${prefix}"

          # Create tmppath for test script.
          tmppath=/mnt/cloud-layouts/layouts/${prefix}
          if [[ -d "${tmppath}" ]] ; then
            echo "Temporary dir already exists: ${tmppath}. ERROR!"
            ls -la ${tmppath}
            exit 1
          else
            echo "Create temporary dir for job: ${tmppath}."
            mkdir -p "${tmppath}"
          fi
          echo "::set-output name=tmppath::${tmppath}"

          CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
          CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

          if [[ -n "${CI_COMMIT_TAG}" ]] ; then
            CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
          fi
          if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
            CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
          fi
          echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

          ## Deckhouse 'install' image name
          ## Source: ci_templates/build.yml

          IMAGE_NAME=
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            # Use it as image tag.
            IMAGE_TAG=${CI_COMMIT_REF_SLUG}

            if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
              IMAGE_NAME=${DEV_REGISTRY_PATH}/install:${IMAGE_TAG}
            else
              IMAGE_NAME=${CI_REGISTRY_IMAGE}/install:${IMAGE_TAG}
            fi
          fi

          if [[ -n $CI_COMMIT_TAG ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
              IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${CI_COMMIT_TAG}
            else
              echo "DECKHOUSE_REGISTRY_HOST is empty."
              exit 1
            fi
          fi

          echo "::set-output name=install-image-name::${IMAGE_NAME}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Name: ${IMAGE_NAME}" | tr '[:upper:]' '[:lower:]'
          echo "Pull 'dev/install' image"
          docker pull "${IMAGE_NAME}"

      - name: "Run e2e test: Azure/Containerd/1.20"
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.20"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Cleanup bootstrapped cluster
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.20"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test_output_azure_containerd_1_20
          path: |
            testing/cloud_layouts/

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'job,separate';
            const name = 'e2e: Azure, Containerd, Kubernetes 1.20';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

      - name: Alert on fail in default branch
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.20"
        run: |
          WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
          echo $WORKFLOW_URL

          alertData=$(cat <<EOF
          {
            "labels": {
              "severity_level": 7,
              "trigger": "CloudLayoutTestFailed",
              "provider": "${PROVIDER}",
              "layout": "${LAYOUT}",
              "cri": "${CRI}",
              "kubernetes_version": "${KUBERNETES_VERSION}"
            },
            "annotations": {
              "summary": "Cloud Layout Test failed",
              "description": "Check Github workflow log for more information",
              "plk_protocol_version": "1",
              "plk_link_url/job": "${WORKFLOW_URL}",
              "plk_link_title_en/job": "Github job run",
              "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
              "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
            }
          }
          EOF
          )

          curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
            -H 'Content-Type: application/json' \
            -d "${alertData}"
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_21:
    name: "e2e: Azure, Containerd, Kubernetes 1.21"
    needs:
      - check_e2e_labels
      - git_info
    if: needs.check_e2e_labels.outputs.run_containerd_1_21 == 'true'
    env:
      PROVIDER: Azure
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.21"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const name = 'e2e: Azure, Containerd, Kubernetes 1.21';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>

      # <template: login_dev_registry_step>
      - name: Login to dev registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_readonly_registry_step>
      - name: Login to readonly registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Login to rw registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        run: |
          # Random delay to sparse 'update comment' steps in time.
          delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
          echo Delay for $delay
          sleep $delay

          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          echo "::set-output name=prefix::${prefix}"
          echo "prefix=${prefix}"

          # Create tmppath for test script.
          tmppath=/mnt/cloud-layouts/layouts/${prefix}
          if [[ -d "${tmppath}" ]] ; then
            echo "Temporary dir already exists: ${tmppath}. ERROR!"
            ls -la ${tmppath}
            exit 1
          else
            echo "Create temporary dir for job: ${tmppath}."
            mkdir -p "${tmppath}"
          fi
          echo "::set-output name=tmppath::${tmppath}"

          CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
          CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

          if [[ -n "${CI_COMMIT_TAG}" ]] ; then
            CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
          fi
          if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
            CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
          fi
          echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

          ## Deckhouse 'install' image name
          ## Source: ci_templates/build.yml

          IMAGE_NAME=
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            # Use it as image tag.
            IMAGE_TAG=${CI_COMMIT_REF_SLUG}

            if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
              IMAGE_NAME=${DEV_REGISTRY_PATH}/install:${IMAGE_TAG}
            else
              IMAGE_NAME=${CI_REGISTRY_IMAGE}/install:${IMAGE_TAG}
            fi
          fi

          if [[ -n $CI_COMMIT_TAG ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
              IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${CI_COMMIT_TAG}
            else
              echo "DECKHOUSE_REGISTRY_HOST is empty."
              exit 1
            fi
          fi

          echo "::set-output name=install-image-name::${IMAGE_NAME}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Name: ${IMAGE_NAME}" | tr '[:upper:]' '[:lower:]'
          echo "Pull 'dev/install' image"
          docker pull "${IMAGE_NAME}"

      - name: "Run e2e test: Azure/Containerd/1.21"
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.21"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Cleanup bootstrapped cluster
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.21"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test_output_azure_containerd_1_21
          path: |
            testing/cloud_layouts/

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'job,separate';
            const name = 'e2e: Azure, Containerd, Kubernetes 1.21';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

      - name: Alert on fail in default branch
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.21"
        run: |
          WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
          echo $WORKFLOW_URL

          alertData=$(cat <<EOF
          {
            "labels": {
              "severity_level": 7,
              "trigger": "CloudLayoutTestFailed",
              "provider": "${PROVIDER}",
              "layout": "${LAYOUT}",
              "cri": "${CRI}",
              "kubernetes_version": "${KUBERNETES_VERSION}"
            },
            "annotations": {
              "summary": "Cloud Layout Test failed",
              "description": "Check Github workflow log for more information",
              "plk_protocol_version": "1",
              "plk_link_url/job": "${WORKFLOW_URL}",
              "plk_link_title_en/job": "Github job run",
              "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
              "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
            }
          }
          EOF
          )

          curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
            -H 'Content-Type: application/json' \
            -d "${alertData}"
  # </template: e2e_run_job_template>

  # <template: e2e_run_job_template>
  run_containerd_1_22:
    name: "e2e: Azure, Containerd, Kubernetes 1.22"
    needs:
      - check_e2e_labels
      - git_info
    if: needs.check_e2e_labels.outputs.run_containerd_1_22 == 'true'
    env:
      PROVIDER: Azure
      CRI: Containerd
      LAYOUT: Standard
      KUBERNETES_VERSION: "1.22"
      EVENT_LABEL: ${{ github.event.label.name }}
    runs-on: [self-hosted, e2e-common]
    steps:

      # <template: started_at_output>
      - name: Job started timestamp
        id: started_at
        run: |
          unixTimestamp=$(date +%s)
          echo "::set-output name=started_at::${unixTimestamp}"
      # </template: started_at_output>

      # <template: checkout_from_event_ref_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0
        with:
          ref: ${{ github.event.inputs.pull_request_ref || github.event.ref }}
          fetch-depth: 0
      # </template: checkout_from_event_ref_step>
      # <template: update_comment_on_start>
      - name: Update comment on start
        if: ${{ github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const name = 'e2e: Azure, Containerd, Kubernetes 1.22';

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnStart({github, context, core, name})

      # </template: update_comment_on_start>

      # <template: login_dev_registry_step>
      - name: Login to dev registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_DEV_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_DEV_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_DEV_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_dev_registry_step>

      # <template: login_readonly_registry_step>
      - name: Login to readonly registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_READ_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_READ_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_READ_PASSWORD }}
          logout: false
      # </template: login_readonly_registry_step>

      # <template: login_rw_registry_step>
      - name: Login to rw registry
        uses: docker/login-action@v1.10.0
        with:
          registry: ${{ secrets.DECKHOUSE_REGISTRY_HOST }}
          username: ${{ secrets.DECKHOUSE_REGISTRY_USER }}
          password: ${{ secrets.DECKHOUSE_REGISTRY_PASSWORD }}
          logout: false
      # </template: login_rw_registry_step>

      # <template: werf_install_step>
      - name: Install werf CLI
        uses: werf/actions/install@v1.2
        with:
          channel: ${{env.WERF_CHANNEL}}
      # </template: werf_install_step>

      - name: Setup
        id: setup
        env:
          DECKHOUSE_REGISTRY_HOST: ${{secrets.DECKHOUSE_REGISTRY_HOST}}
          GITHUB_SHA: ${{needs.git_info.outputs.github_sha}}
        run: |
          # Random delay to sparse 'update comment' steps in time.
          delay=$[ $RANDOM % 5 ].$[ ( $RANDOM % 4 ) * 250 ]
          echo Delay for $delay
          sleep $delay

          # Calculate unique prefix for e2e test.
          # GITHUB_RUN_ID is a unique number for each workflow run.
          # Add CRI and KUBERNETES_VERSION to create unique directory for each job.
          prefix=$(echo "${GITHUB_RUN_ID}-$(echo ${CRI} | head -c 3)-${KUBERNETES_VERSION}" | tr '.' '-' | tr '[:upper:]' '[:lower:]')
          echo "::set-output name=prefix::${prefix}"
          echo "prefix=${prefix}"

          # Create tmppath for test script.
          tmppath=/mnt/cloud-layouts/layouts/${prefix}
          if [[ -d "${tmppath}" ]] ; then
            echo "Temporary dir already exists: ${tmppath}. ERROR!"
            ls -la ${tmppath}
            exit 1
          else
            echo "Create temporary dir for job: ${tmppath}."
            mkdir -p "${tmppath}"
          fi
          echo "::set-output name=tmppath::${tmppath}"

          CI_COMMIT_TAG="${{needs.git_info.outputs.ci_commit_tag}}"
          CI_COMMIT_BRANCH="${{needs.git_info.outputs.ci_commit_branch}}"

          if [[ -n "${CI_COMMIT_TAG}" ]] ; then
            CI_COMMIT_REF_SLUG=$(werf slugify --format docker-tag "${CI_COMMIT_TAG}")
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_TAG}"
          fi
          if [[ -n "${CI_COMMIT_BRANCH}" ]] ; then
            CI_COMMIT_REF_SLUG="${{needs.git_info.outputs.ci_commit_ref_slug}}"
            echo "Deckhouse Deployment will use docker tag '${CI_COMMIT_REF_SLUG}' to test branch ${CI_COMMIT_BRANCH}"
          fi
          echo "::set-output name=ci_commit_ref_slug::${CI_COMMIT_REF_SLUG}"

          ## Deckhouse 'install' image name
          ## Source: ci_templates/build.yml

          IMAGE_NAME=
          if [[ -n "${CI_COMMIT_BRANCH}" ]]; then
            # CI_COMMIT_REF_SLUG is a 'prNUM' for dev branches or 'main' for default branch.
            # Use it as image tag.
            IMAGE_TAG=${CI_COMMIT_REF_SLUG}

            if [[ -n "${DEV_REGISTRY_PATH}" ]]; then
              IMAGE_NAME=${DEV_REGISTRY_PATH}/install:${IMAGE_TAG}
            else
              IMAGE_NAME=${CI_REGISTRY_IMAGE}/install:${IMAGE_TAG}
            fi
          fi

          if [[ -n $CI_COMMIT_TAG ]] ; then
            REGISTRY_SUFFIX=$(echo ${WERF_ENV} | tr '[:upper:]' '[:lower:]') # CE/EE/FE -> ce/ee/fe
            if [[ -n "${DECKHOUSE_REGISTRY_HOST}" ]]; then
              IMAGE_NAME=${DECKHOUSE_REGISTRY_HOST}/deckhouse/${REGISTRY_SUFFIX}/install:${CI_COMMIT_TAG}
            else
              echo "DECKHOUSE_REGISTRY_HOST is empty."
              exit 1
            fi
          fi

          echo "::set-output name=install-image-name::${IMAGE_NAME}"

          # Print image name in uppercase to prevent hiding non-secret registry host stored in secret.
          echo "Name: ${IMAGE_NAME}" | tr '[:upper:]' '[:lower:]'
          echo "Pull 'dev/install' image"
          docker pull "${IMAGE_NAME}"

      - name: "Run e2e test: Azure/Containerd/1.22"
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.22"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh run-test' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh run-test

        # </template: e2e_run_template>

      - name: Cleanup bootstrapped cluster
        if: always()
        env:
          JOB_STATUS: ${{ job.status }}
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.22"
          LAYOUT_DECKHOUSE_DOCKERCFG: ${{ secrets.LAYOUT_DECKHOUSE_DOCKERCFG }}
          LAYOUT_SSH_KEY: ${{ secrets.LAYOUT_SSH_KEY}}
          WERF_REPO: ${{env.DEV_REGISTRY_PATH}}
          CI_COMMIT_TAG: ${{needs.git_info.outputs.ci_commit_tag}}
          CI_COMMIT_REF_NAME: ${{needs.git_info.outputs.ci_commit_ref_name}}
          CI_COMMIT_REF_SLUG: ${{steps.setup.outputs.ci_commit_ref_slug}}
          CI_PIPELINE_CREATED_AT: ${{needs.git_info.outputs.ci_pipeline_created_at}}
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
          PREFIX: ${{ steps.setup.outputs.prefix}}
          INSTALL_IMAGE_NAME: ${{ steps.setup.outputs.install-image-name }}
        # <template: e2e_run_template>
          LAYOUT_AZURE_SUBSCRIPTION_ID: ${{ secrets.LAYOUT_AZURE_SUBSCRIPTION_ID }}
          LAYOUT_AZURE_CLIENT_ID: ${{ secrets.LAYOUT_AZURE_CLIENT_ID }}
          LAYOUT_AZURE_CLIENT_SECRET: ${{ secrets.LAYOUT_AZURE_CLIENT_SECRET }}
          LAYOUT_AZURE_TENANT_ID: ${{ secrets.LAYOUT_AZURE_TENANT_ID }}
        run: |
          echo "Execute 'script.sh cleanup' via 'docker run', using environment:
            PREFIX=${PREFIX}
            TMPPATH=${TMPPATH}
            DEV_BRANCH=${CI_COMMIT_REF_SLUG}
            PROVIDER=${PROVIDER}
            CRI=${CRI}
            LAYOUT=${LAYOUT}
            KUBERNETES_VERSION=${KUBERNETES_VERSION}
            CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY}
            JOB_STATUS=${JOB_STATUS}
          "

          docker run --rm \
            -e CLOUD_TESTS_RUN_BOOTSTRAP_ONLY=${CLOUD_TESTS_RUN_BOOTSTRAP_ONLY} \
            -e CLOUD_TESTS_RUN_ACTION=${CLOUD_TESTS_RUN_ACTION} \
            -e DECKHOUSE_DOCKERCFG=${LAYOUT_DECKHOUSE_DOCKERCFG} \
            -e PREFIX=${PREFIX} \
            -e DEV_BRANCH=${CI_COMMIT_REF_SLUG} \
            -e KUBERNETES_VERSION=${KUBERNETES_VERSION} \
            -e CRI=${CRI} \
            -e PROVIDER=${PROVIDER:-not_provided} \
            -e LAYOUT=${LAYOUT:-not_provided} \
            -e SSH_KEY=${LAYOUT_SSH_KEY:-not_provided} \
            -e LAYOUT_AZURE_SUBSCRIPTION_ID=${LAYOUT_AZURE_SUBSCRIPTION_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_ID=${LAYOUT_AZURE_CLIENT_ID:-not_provided} \
            -e LAYOUT_AZURE_CLIENT_SECRET=${LAYOUT_AZURE_CLIENT_SECRET:-not_provided} \
            -e LAYOUT_AZURE_TENANT_ID=${LAYOUT_AZURE_TENANT_ID:-not_provided} \
            -v $(pwd)/testing:/deckhouse/testing \
            -v ${TMPPATH}:/tmp \
            --user $(id -u):$(id -u) \
            -v /etc/group:/etc/group:ro \
            -v /etc/passwd:/etc/passwd:ro \
            -v /etc/shadow:/etc/shadow:ro \
            -w /deckhouse \
          ${INSTALL_IMAGE_NAME} \
          bash /deckhouse/testing/cloud_layouts/script.sh cleanup

        # </template: e2e_run_template>

      - name: Save test results
        if: always()
        uses: actions/upload-artifact@v2
        with:
          name: test_output_azure_containerd_1_22
          path: |
            testing/cloud_layouts/

      - name: Cleanup temp directory
        if: always()
        env:
          TMPPATH: ${{ steps.setup.outputs.tmppath}}
        run: |
          echo "Remove temporary directory '${TMPPATH}' ..."
          if [[ -d "${TMPPATH}" && ${#TMPPATH} > 1 ]] ; then
            rm -rf "${TMPPATH}"
          else
            echo Not a directory.
          fi

      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'job,separate';
            const name = 'e2e: Azure, Containerd, Kubernetes 1.22';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>

      - name: Alert on fail in default branch
        if: ${{ github.event_name == 'workflow_dispatch' && github.ref == 'refs/heads/main' && (cancelled() || failure()) }}
        env:
          PROVIDER: Azure
          CRI: Containerd
          LAYOUT: Standard
          KUBERNETES_VERSION: "1.22"
        run: |
          WORKFLOW_URL="${{github.server_url}}/${{github.repository}}/actions/runs/${{github.run_id}}"
          echo $WORKFLOW_URL

          alertData=$(cat <<EOF
          {
            "labels": {
              "severity_level": 7,
              "trigger": "CloudLayoutTestFailed",
              "provider": "${PROVIDER}",
              "layout": "${LAYOUT}",
              "cri": "${CRI}",
              "kubernetes_version": "${KUBERNETES_VERSION}"
            },
            "annotations": {
              "summary": "Cloud Layout Test failed",
              "description": "Check Github workflow log for more information",
              "plk_protocol_version": "1",
              "plk_link_url/job": "${WORKFLOW_URL}",
              "plk_link_title_en/job": "Github job run",
              "plk_create_group_if_not_exists/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider",
              "plk_grouped_by/cloudlayouttestfailed": "CloudLayoutTestFailedGroup,provider=~provider"
            }
          }
          EOF
          )

          curl -sS -X "POST" "https://madison.flant.com/api/events/custom/${CLOUD_LAYOUT_TESTS_MADISON_KEY}" \
            -H 'Content-Type: application/json' \
            -d "${alertData}"
  # </template: e2e_run_job_template>


  last_comment:
    name: Update comment on finish
    needs: ["started_at","run_docker_1_19","run_docker_1_20","run_docker_1_21","run_docker_1_22","run_containerd_1_19","run_containerd_1_20","run_containerd_1_21","run_containerd_1_22"]
    if: ${{ always() }}
    runs-on: ubuntu-latest
    env:
      JOB_NAMES: |
        {"run_containerd_1_19":"e2e: Azure, Containerd, Kubernetes 1.19","run_containerd_1_20":"e2e: Azure, Containerd, Kubernetes 1.20","run_containerd_1_21":"e2e: Azure, Containerd, Kubernetes 1.21","run_containerd_1_22":"e2e: Azure, Containerd, Kubernetes 1.22","run_docker_1_19":"e2e: Azure, Docker, Kubernetes 1.19","run_docker_1_20":"e2e: Azure, Docker, Kubernetes 1.20","run_docker_1_21":"e2e: Azure, Docker, Kubernetes 1.21","run_docker_1_22":"e2e: Azure, Docker, Kubernetes 1.22"}
    steps:

      # <template: checkout_step>
      - name: Checkout sources
        uses: actions/checkout@v2.4.0

      # </template: checkout_step>
      # <template: update_comment_on_finish>
      - name: Update comment on finish
        id: update_comment_on_finish
        if: ${{ always() && github.event_name == 'workflow_dispatch' && !!github.event.inputs.issue_number }}
        env:
          NEEDS_CONTEXT: ${{ toJSON(needs) }}
          JOB_CONTEXT: ${{ toJSON(job) }}
          STEPS_CONTEXT: ${{ toJSON(steps) }}
        uses: actions/github-script@v5.0.0
        with:
          github-token: ${{secrets.BOATSWAIN_GITHUB_TOKEN}}
          script: |
            const statusConfig = 'workflow,final,no-skipped,restore-separate';
            const name = 'e2e: Azure';
            const needsContext = JSON.parse(process.env.NEEDS_CONTEXT);
            const jobContext = JSON.parse(process.env.JOB_CONTEXT);
            const stepsContext = JSON.parse(process.env.STEPS_CONTEXT);
            let jobNames = null
            if (process.env.JOB_NAMES) {
              jobNames = JSON.parse(process.env.JOB_NAMES);
            }

            core.info(`needsContext: ${JSON.stringify(needsContext)}`);
            core.info(`jobContext: ${JSON.stringify(jobContext)}`);
            core.info(`stepsContext: ${JSON.stringify(stepsContext)}`);
            core.info(`jobNames: ${JSON.stringify(jobNames)}`);

            const ci = require('./.github/scripts/js/ci');
            return await ci.updateCommentOnFinish({github, context, core, statusConfig, name, needsContext, jobContext, stepsContext, jobNames});
      # </template: update_comment_on_finish>
# </template: e2e_workflow_template>
