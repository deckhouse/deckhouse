// Code generated by http://github.com/gojuno/minimock (v3.4.7). DO NOT EDIT.

package operatormock

//go:generate minimock -i github.com/deckhouse/deckhouse/deckhouse-controller/internal/packages/operator.moduleManager -o module_manager_minimock.go -n ModuleManagerMock -p operatormock

import (
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/flant/addon-operator/pkg/module_manager/models/modules"
	"github.com/gojuno/minimock/v3"
)

// ModuleManagerMock implements mm_operator.moduleManager
type ModuleManagerMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcGetGlobal          func() (gp1 *modules.GlobalModule)
	funcGetGlobalOrigin    string
	inspectFuncGetGlobal   func()
	afterGetGlobalCounter  uint64
	beforeGetGlobalCounter uint64
	GetGlobalMock          mModuleManagerMockGetGlobal

	funcIsModuleEnabled          func(moduleName string) (b1 bool)
	funcIsModuleEnabledOrigin    string
	inspectFuncIsModuleEnabled   func(moduleName string)
	afterIsModuleEnabledCounter  uint64
	beforeIsModuleEnabledCounter uint64
	IsModuleEnabledMock          mModuleManagerMockIsModuleEnabled
}

// NewModuleManagerMock returns a mock for mm_operator.moduleManager
func NewModuleManagerMock(t minimock.Tester) *ModuleManagerMock {
	m := &ModuleManagerMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.GetGlobalMock = mModuleManagerMockGetGlobal{mock: m}

	m.IsModuleEnabledMock = mModuleManagerMockIsModuleEnabled{mock: m}
	m.IsModuleEnabledMock.callArgs = []*ModuleManagerMockIsModuleEnabledParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mModuleManagerMockGetGlobal struct {
	optional           bool
	mock               *ModuleManagerMock
	defaultExpectation *ModuleManagerMockGetGlobalExpectation
	expectations       []*ModuleManagerMockGetGlobalExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleManagerMockGetGlobalExpectation specifies expectation struct of the moduleManager.GetGlobal
type ModuleManagerMockGetGlobalExpectation struct {
	mock *ModuleManagerMock

	results      *ModuleManagerMockGetGlobalResults
	returnOrigin string
	Counter      uint64
}

// ModuleManagerMockGetGlobalResults contains results of the moduleManager.GetGlobal
type ModuleManagerMockGetGlobalResults struct {
	gp1 *modules.GlobalModule
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmGetGlobal *mModuleManagerMockGetGlobal) Optional() *mModuleManagerMockGetGlobal {
	mmGetGlobal.optional = true
	return mmGetGlobal
}

// Expect sets up expected params for moduleManager.GetGlobal
func (mmGetGlobal *mModuleManagerMockGetGlobal) Expect() *mModuleManagerMockGetGlobal {
	if mmGetGlobal.mock.funcGetGlobal != nil {
		mmGetGlobal.mock.t.Fatalf("ModuleManagerMock.GetGlobal mock is already set by Set")
	}

	if mmGetGlobal.defaultExpectation == nil {
		mmGetGlobal.defaultExpectation = &ModuleManagerMockGetGlobalExpectation{}
	}

	return mmGetGlobal
}

// Inspect accepts an inspector function that has same arguments as the moduleManager.GetGlobal
func (mmGetGlobal *mModuleManagerMockGetGlobal) Inspect(f func()) *mModuleManagerMockGetGlobal {
	if mmGetGlobal.mock.inspectFuncGetGlobal != nil {
		mmGetGlobal.mock.t.Fatalf("Inspect function is already set for ModuleManagerMock.GetGlobal")
	}

	mmGetGlobal.mock.inspectFuncGetGlobal = f

	return mmGetGlobal
}

// Return sets up results that will be returned by moduleManager.GetGlobal
func (mmGetGlobal *mModuleManagerMockGetGlobal) Return(gp1 *modules.GlobalModule) *ModuleManagerMock {
	if mmGetGlobal.mock.funcGetGlobal != nil {
		mmGetGlobal.mock.t.Fatalf("ModuleManagerMock.GetGlobal mock is already set by Set")
	}

	if mmGetGlobal.defaultExpectation == nil {
		mmGetGlobal.defaultExpectation = &ModuleManagerMockGetGlobalExpectation{mock: mmGetGlobal.mock}
	}
	mmGetGlobal.defaultExpectation.results = &ModuleManagerMockGetGlobalResults{gp1}
	mmGetGlobal.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmGetGlobal.mock
}

// Set uses given function f to mock the moduleManager.GetGlobal method
func (mmGetGlobal *mModuleManagerMockGetGlobal) Set(f func() (gp1 *modules.GlobalModule)) *ModuleManagerMock {
	if mmGetGlobal.defaultExpectation != nil {
		mmGetGlobal.mock.t.Fatalf("Default expectation is already set for the moduleManager.GetGlobal method")
	}

	if len(mmGetGlobal.expectations) > 0 {
		mmGetGlobal.mock.t.Fatalf("Some expectations are already set for the moduleManager.GetGlobal method")
	}

	mmGetGlobal.mock.funcGetGlobal = f
	mmGetGlobal.mock.funcGetGlobalOrigin = minimock.CallerInfo(1)
	return mmGetGlobal.mock
}

// Times sets number of times moduleManager.GetGlobal should be invoked
func (mmGetGlobal *mModuleManagerMockGetGlobal) Times(n uint64) *mModuleManagerMockGetGlobal {
	if n == 0 {
		mmGetGlobal.mock.t.Fatalf("Times of ModuleManagerMock.GetGlobal mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmGetGlobal.expectedInvocations, n)
	mmGetGlobal.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmGetGlobal
}

func (mmGetGlobal *mModuleManagerMockGetGlobal) invocationsDone() bool {
	if len(mmGetGlobal.expectations) == 0 && mmGetGlobal.defaultExpectation == nil && mmGetGlobal.mock.funcGetGlobal == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmGetGlobal.mock.afterGetGlobalCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmGetGlobal.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// GetGlobal implements mm_operator.moduleManager
func (mmGetGlobal *ModuleManagerMock) GetGlobal() (gp1 *modules.GlobalModule) {
	mm_atomic.AddUint64(&mmGetGlobal.beforeGetGlobalCounter, 1)
	defer mm_atomic.AddUint64(&mmGetGlobal.afterGetGlobalCounter, 1)

	mmGetGlobal.t.Helper()

	if mmGetGlobal.inspectFuncGetGlobal != nil {
		mmGetGlobal.inspectFuncGetGlobal()
	}

	if mmGetGlobal.GetGlobalMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmGetGlobal.GetGlobalMock.defaultExpectation.Counter, 1)

		mm_results := mmGetGlobal.GetGlobalMock.defaultExpectation.results
		if mm_results == nil {
			mmGetGlobal.t.Fatal("No results are set for the ModuleManagerMock.GetGlobal")
		}
		return (*mm_results).gp1
	}
	if mmGetGlobal.funcGetGlobal != nil {
		return mmGetGlobal.funcGetGlobal()
	}
	mmGetGlobal.t.Fatalf("Unexpected call to ModuleManagerMock.GetGlobal.")
	return
}

// GetGlobalAfterCounter returns a count of finished ModuleManagerMock.GetGlobal invocations
func (mmGetGlobal *ModuleManagerMock) GetGlobalAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGlobal.afterGetGlobalCounter)
}

// GetGlobalBeforeCounter returns a count of ModuleManagerMock.GetGlobal invocations
func (mmGetGlobal *ModuleManagerMock) GetGlobalBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmGetGlobal.beforeGetGlobalCounter)
}

// MinimockGetGlobalDone returns true if the count of the GetGlobal invocations corresponds
// the number of defined expectations
func (m *ModuleManagerMock) MinimockGetGlobalDone() bool {
	if m.GetGlobalMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.GetGlobalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.GetGlobalMock.invocationsDone()
}

// MinimockGetGlobalInspect logs each unmet expectation
func (m *ModuleManagerMock) MinimockGetGlobalInspect() {
	for _, e := range m.GetGlobalMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ModuleManagerMock.GetGlobal")
		}
	}

	afterGetGlobalCounter := mm_atomic.LoadUint64(&m.afterGetGlobalCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.GetGlobalMock.defaultExpectation != nil && afterGetGlobalCounter < 1 {
		m.t.Errorf("Expected call to ModuleManagerMock.GetGlobal at\n%s", m.GetGlobalMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcGetGlobal != nil && afterGetGlobalCounter < 1 {
		m.t.Errorf("Expected call to ModuleManagerMock.GetGlobal at\n%s", m.funcGetGlobalOrigin)
	}

	if !m.GetGlobalMock.invocationsDone() && afterGetGlobalCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleManagerMock.GetGlobal at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.GetGlobalMock.expectedInvocations), m.GetGlobalMock.expectedInvocationsOrigin, afterGetGlobalCounter)
	}
}

type mModuleManagerMockIsModuleEnabled struct {
	optional           bool
	mock               *ModuleManagerMock
	defaultExpectation *ModuleManagerMockIsModuleEnabledExpectation
	expectations       []*ModuleManagerMockIsModuleEnabledExpectation

	callArgs []*ModuleManagerMockIsModuleEnabledParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ModuleManagerMockIsModuleEnabledExpectation specifies expectation struct of the moduleManager.IsModuleEnabled
type ModuleManagerMockIsModuleEnabledExpectation struct {
	mock               *ModuleManagerMock
	params             *ModuleManagerMockIsModuleEnabledParams
	paramPtrs          *ModuleManagerMockIsModuleEnabledParamPtrs
	expectationOrigins ModuleManagerMockIsModuleEnabledExpectationOrigins
	results            *ModuleManagerMockIsModuleEnabledResults
	returnOrigin       string
	Counter            uint64
}

// ModuleManagerMockIsModuleEnabledParams contains parameters of the moduleManager.IsModuleEnabled
type ModuleManagerMockIsModuleEnabledParams struct {
	moduleName string
}

// ModuleManagerMockIsModuleEnabledParamPtrs contains pointers to parameters of the moduleManager.IsModuleEnabled
type ModuleManagerMockIsModuleEnabledParamPtrs struct {
	moduleName *string
}

// ModuleManagerMockIsModuleEnabledResults contains results of the moduleManager.IsModuleEnabled
type ModuleManagerMockIsModuleEnabledResults struct {
	b1 bool
}

// ModuleManagerMockIsModuleEnabledOrigins contains origins of expectations of the moduleManager.IsModuleEnabled
type ModuleManagerMockIsModuleEnabledExpectationOrigins struct {
	origin           string
	originModuleName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) Optional() *mModuleManagerMockIsModuleEnabled {
	mmIsModuleEnabled.optional = true
	return mmIsModuleEnabled
}

// Expect sets up expected params for moduleManager.IsModuleEnabled
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) Expect(moduleName string) *mModuleManagerMockIsModuleEnabled {
	if mmIsModuleEnabled.mock.funcIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("ModuleManagerMock.IsModuleEnabled mock is already set by Set")
	}

	if mmIsModuleEnabled.defaultExpectation == nil {
		mmIsModuleEnabled.defaultExpectation = &ModuleManagerMockIsModuleEnabledExpectation{}
	}

	if mmIsModuleEnabled.defaultExpectation.paramPtrs != nil {
		mmIsModuleEnabled.mock.t.Fatalf("ModuleManagerMock.IsModuleEnabled mock is already set by ExpectParams functions")
	}

	mmIsModuleEnabled.defaultExpectation.params = &ModuleManagerMockIsModuleEnabledParams{moduleName}
	mmIsModuleEnabled.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmIsModuleEnabled.expectations {
		if minimock.Equal(e.params, mmIsModuleEnabled.defaultExpectation.params) {
			mmIsModuleEnabled.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmIsModuleEnabled.defaultExpectation.params)
		}
	}

	return mmIsModuleEnabled
}

// ExpectModuleNameParam1 sets up expected param moduleName for moduleManager.IsModuleEnabled
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) ExpectModuleNameParam1(moduleName string) *mModuleManagerMockIsModuleEnabled {
	if mmIsModuleEnabled.mock.funcIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("ModuleManagerMock.IsModuleEnabled mock is already set by Set")
	}

	if mmIsModuleEnabled.defaultExpectation == nil {
		mmIsModuleEnabled.defaultExpectation = &ModuleManagerMockIsModuleEnabledExpectation{}
	}

	if mmIsModuleEnabled.defaultExpectation.params != nil {
		mmIsModuleEnabled.mock.t.Fatalf("ModuleManagerMock.IsModuleEnabled mock is already set by Expect")
	}

	if mmIsModuleEnabled.defaultExpectation.paramPtrs == nil {
		mmIsModuleEnabled.defaultExpectation.paramPtrs = &ModuleManagerMockIsModuleEnabledParamPtrs{}
	}
	mmIsModuleEnabled.defaultExpectation.paramPtrs.moduleName = &moduleName
	mmIsModuleEnabled.defaultExpectation.expectationOrigins.originModuleName = minimock.CallerInfo(1)

	return mmIsModuleEnabled
}

// Inspect accepts an inspector function that has same arguments as the moduleManager.IsModuleEnabled
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) Inspect(f func(moduleName string)) *mModuleManagerMockIsModuleEnabled {
	if mmIsModuleEnabled.mock.inspectFuncIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("Inspect function is already set for ModuleManagerMock.IsModuleEnabled")
	}

	mmIsModuleEnabled.mock.inspectFuncIsModuleEnabled = f

	return mmIsModuleEnabled
}

// Return sets up results that will be returned by moduleManager.IsModuleEnabled
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) Return(b1 bool) *ModuleManagerMock {
	if mmIsModuleEnabled.mock.funcIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("ModuleManagerMock.IsModuleEnabled mock is already set by Set")
	}

	if mmIsModuleEnabled.defaultExpectation == nil {
		mmIsModuleEnabled.defaultExpectation = &ModuleManagerMockIsModuleEnabledExpectation{mock: mmIsModuleEnabled.mock}
	}
	mmIsModuleEnabled.defaultExpectation.results = &ModuleManagerMockIsModuleEnabledResults{b1}
	mmIsModuleEnabled.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmIsModuleEnabled.mock
}

// Set uses given function f to mock the moduleManager.IsModuleEnabled method
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) Set(f func(moduleName string) (b1 bool)) *ModuleManagerMock {
	if mmIsModuleEnabled.defaultExpectation != nil {
		mmIsModuleEnabled.mock.t.Fatalf("Default expectation is already set for the moduleManager.IsModuleEnabled method")
	}

	if len(mmIsModuleEnabled.expectations) > 0 {
		mmIsModuleEnabled.mock.t.Fatalf("Some expectations are already set for the moduleManager.IsModuleEnabled method")
	}

	mmIsModuleEnabled.mock.funcIsModuleEnabled = f
	mmIsModuleEnabled.mock.funcIsModuleEnabledOrigin = minimock.CallerInfo(1)
	return mmIsModuleEnabled.mock
}

// When sets expectation for the moduleManager.IsModuleEnabled which will trigger the result defined by the following
// Then helper
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) When(moduleName string) *ModuleManagerMockIsModuleEnabledExpectation {
	if mmIsModuleEnabled.mock.funcIsModuleEnabled != nil {
		mmIsModuleEnabled.mock.t.Fatalf("ModuleManagerMock.IsModuleEnabled mock is already set by Set")
	}

	expectation := &ModuleManagerMockIsModuleEnabledExpectation{
		mock:               mmIsModuleEnabled.mock,
		params:             &ModuleManagerMockIsModuleEnabledParams{moduleName},
		expectationOrigins: ModuleManagerMockIsModuleEnabledExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmIsModuleEnabled.expectations = append(mmIsModuleEnabled.expectations, expectation)
	return expectation
}

// Then sets up moduleManager.IsModuleEnabled return parameters for the expectation previously defined by the When method
func (e *ModuleManagerMockIsModuleEnabledExpectation) Then(b1 bool) *ModuleManagerMock {
	e.results = &ModuleManagerMockIsModuleEnabledResults{b1}
	return e.mock
}

// Times sets number of times moduleManager.IsModuleEnabled should be invoked
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) Times(n uint64) *mModuleManagerMockIsModuleEnabled {
	if n == 0 {
		mmIsModuleEnabled.mock.t.Fatalf("Times of ModuleManagerMock.IsModuleEnabled mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmIsModuleEnabled.expectedInvocations, n)
	mmIsModuleEnabled.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmIsModuleEnabled
}

func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) invocationsDone() bool {
	if len(mmIsModuleEnabled.expectations) == 0 && mmIsModuleEnabled.defaultExpectation == nil && mmIsModuleEnabled.mock.funcIsModuleEnabled == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmIsModuleEnabled.mock.afterIsModuleEnabledCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmIsModuleEnabled.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// IsModuleEnabled implements mm_operator.moduleManager
func (mmIsModuleEnabled *ModuleManagerMock) IsModuleEnabled(moduleName string) (b1 bool) {
	mm_atomic.AddUint64(&mmIsModuleEnabled.beforeIsModuleEnabledCounter, 1)
	defer mm_atomic.AddUint64(&mmIsModuleEnabled.afterIsModuleEnabledCounter, 1)

	mmIsModuleEnabled.t.Helper()

	if mmIsModuleEnabled.inspectFuncIsModuleEnabled != nil {
		mmIsModuleEnabled.inspectFuncIsModuleEnabled(moduleName)
	}

	mm_params := ModuleManagerMockIsModuleEnabledParams{moduleName}

	// Record call args
	mmIsModuleEnabled.IsModuleEnabledMock.mutex.Lock()
	mmIsModuleEnabled.IsModuleEnabledMock.callArgs = append(mmIsModuleEnabled.IsModuleEnabledMock.callArgs, &mm_params)
	mmIsModuleEnabled.IsModuleEnabledMock.mutex.Unlock()

	for _, e := range mmIsModuleEnabled.IsModuleEnabledMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.b1
		}
	}

	if mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.Counter, 1)
		mm_want := mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.params
		mm_want_ptrs := mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.paramPtrs

		mm_got := ModuleManagerMockIsModuleEnabledParams{moduleName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.moduleName != nil && !minimock.Equal(*mm_want_ptrs.moduleName, mm_got.moduleName) {
				mmIsModuleEnabled.t.Errorf("ModuleManagerMock.IsModuleEnabled got unexpected parameter moduleName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.expectationOrigins.originModuleName, *mm_want_ptrs.moduleName, mm_got.moduleName, minimock.Diff(*mm_want_ptrs.moduleName, mm_got.moduleName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmIsModuleEnabled.t.Errorf("ModuleManagerMock.IsModuleEnabled got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmIsModuleEnabled.IsModuleEnabledMock.defaultExpectation.results
		if mm_results == nil {
			mmIsModuleEnabled.t.Fatal("No results are set for the ModuleManagerMock.IsModuleEnabled")
		}
		return (*mm_results).b1
	}
	if mmIsModuleEnabled.funcIsModuleEnabled != nil {
		return mmIsModuleEnabled.funcIsModuleEnabled(moduleName)
	}
	mmIsModuleEnabled.t.Fatalf("Unexpected call to ModuleManagerMock.IsModuleEnabled. %v", moduleName)
	return
}

// IsModuleEnabledAfterCounter returns a count of finished ModuleManagerMock.IsModuleEnabled invocations
func (mmIsModuleEnabled *ModuleManagerMock) IsModuleEnabledAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsModuleEnabled.afterIsModuleEnabledCounter)
}

// IsModuleEnabledBeforeCounter returns a count of ModuleManagerMock.IsModuleEnabled invocations
func (mmIsModuleEnabled *ModuleManagerMock) IsModuleEnabledBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmIsModuleEnabled.beforeIsModuleEnabledCounter)
}

// Calls returns a list of arguments used in each call to ModuleManagerMock.IsModuleEnabled.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmIsModuleEnabled *mModuleManagerMockIsModuleEnabled) Calls() []*ModuleManagerMockIsModuleEnabledParams {
	mmIsModuleEnabled.mutex.RLock()

	argCopy := make([]*ModuleManagerMockIsModuleEnabledParams, len(mmIsModuleEnabled.callArgs))
	copy(argCopy, mmIsModuleEnabled.callArgs)

	mmIsModuleEnabled.mutex.RUnlock()

	return argCopy
}

// MinimockIsModuleEnabledDone returns true if the count of the IsModuleEnabled invocations corresponds
// the number of defined expectations
func (m *ModuleManagerMock) MinimockIsModuleEnabledDone() bool {
	if m.IsModuleEnabledMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.IsModuleEnabledMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.IsModuleEnabledMock.invocationsDone()
}

// MinimockIsModuleEnabledInspect logs each unmet expectation
func (m *ModuleManagerMock) MinimockIsModuleEnabledInspect() {
	for _, e := range m.IsModuleEnabledMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ModuleManagerMock.IsModuleEnabled at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterIsModuleEnabledCounter := mm_atomic.LoadUint64(&m.afterIsModuleEnabledCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.IsModuleEnabledMock.defaultExpectation != nil && afterIsModuleEnabledCounter < 1 {
		if m.IsModuleEnabledMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ModuleManagerMock.IsModuleEnabled at\n%s", m.IsModuleEnabledMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ModuleManagerMock.IsModuleEnabled at\n%s with params: %#v", m.IsModuleEnabledMock.defaultExpectation.expectationOrigins.origin, *m.IsModuleEnabledMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcIsModuleEnabled != nil && afterIsModuleEnabledCounter < 1 {
		m.t.Errorf("Expected call to ModuleManagerMock.IsModuleEnabled at\n%s", m.funcIsModuleEnabledOrigin)
	}

	if !m.IsModuleEnabledMock.invocationsDone() && afterIsModuleEnabledCounter > 0 {
		m.t.Errorf("Expected %d calls to ModuleManagerMock.IsModuleEnabled at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.IsModuleEnabledMock.expectedInvocations), m.IsModuleEnabledMock.expectedInvocationsOrigin, afterIsModuleEnabledCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ModuleManagerMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockGetGlobalInspect()

			m.MinimockIsModuleEnabledInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ModuleManagerMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ModuleManagerMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockGetGlobalDone() &&
		m.MinimockIsModuleEnabledDone()
}
