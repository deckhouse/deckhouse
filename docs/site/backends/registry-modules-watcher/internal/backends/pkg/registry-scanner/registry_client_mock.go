// Code generated by http://github.com/gojuno/minimock (v3.4.4). DO NOT EDIT.

package registryscanner

//go:generate minimock -i registry-modules-watcher/internal/backends/pkg/registry-scanner.Client -o registry_client_mock.go -n ClientMock -p registryscanner

import (
	"context"
	"sync"
	mm_atomic "sync/atomic"
	mm_time "time"

	"github.com/gojuno/minimock/v3"
	v1 "github.com/google/go-containerregistry/pkg/v1"
)

// ClientMock implements Client
type ClientMock struct {
	t          minimock.Tester
	finishOnce sync.Once

	funcImage          func(ctx context.Context, moduleName string, version string) (i1 v1.Image, err error)
	funcImageOrigin    string
	inspectFuncImage   func(ctx context.Context, moduleName string, version string)
	afterImageCounter  uint64
	beforeImageCounter uint64
	ImageMock          mClientMockImage

	funcListTags          func(ctx context.Context, moduleName string) (sa1 []string, err error)
	funcListTagsOrigin    string
	inspectFuncListTags   func(ctx context.Context, moduleName string)
	afterListTagsCounter  uint64
	beforeListTagsCounter uint64
	ListTagsMock          mClientMockListTags

	funcModules          func(ctx context.Context) (sa1 []string, err error)
	funcModulesOrigin    string
	inspectFuncModules   func(ctx context.Context)
	afterModulesCounter  uint64
	beforeModulesCounter uint64
	ModulesMock          mClientMockModules

	funcName          func() (s1 string)
	funcNameOrigin    string
	inspectFuncName   func()
	afterNameCounter  uint64
	beforeNameCounter uint64
	NameMock          mClientMockName

	funcReleaseImage          func(ctx context.Context, moduleName string, releaseChannel string) (i1 v1.Image, err error)
	funcReleaseImageOrigin    string
	inspectFuncReleaseImage   func(ctx context.Context, moduleName string, releaseChannel string)
	afterReleaseImageCounter  uint64
	beforeReleaseImageCounter uint64
	ReleaseImageMock          mClientMockReleaseImage
}

// NewClientMock returns a mock for Client
func NewClientMock(t minimock.Tester) *ClientMock {
	m := &ClientMock{t: t}

	if controller, ok := t.(minimock.MockController); ok {
		controller.RegisterMocker(m)
	}

	m.ImageMock = mClientMockImage{mock: m}
	m.ImageMock.callArgs = []*ClientMockImageParams{}

	m.ListTagsMock = mClientMockListTags{mock: m}
	m.ListTagsMock.callArgs = []*ClientMockListTagsParams{}

	m.ModulesMock = mClientMockModules{mock: m}
	m.ModulesMock.callArgs = []*ClientMockModulesParams{}

	m.NameMock = mClientMockName{mock: m}

	m.ReleaseImageMock = mClientMockReleaseImage{mock: m}
	m.ReleaseImageMock.callArgs = []*ClientMockReleaseImageParams{}

	t.Cleanup(m.MinimockFinish)

	return m
}

type mClientMockImage struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockImageExpectation
	expectations       []*ClientMockImageExpectation

	callArgs []*ClientMockImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockImageExpectation specifies expectation struct of the Client.Image
type ClientMockImageExpectation struct {
	mock               *ClientMock
	params             *ClientMockImageParams
	paramPtrs          *ClientMockImageParamPtrs
	expectationOrigins ClientMockImageExpectationOrigins
	results            *ClientMockImageResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockImageParams contains parameters of the Client.Image
type ClientMockImageParams struct {
	ctx        context.Context
	moduleName string
	version    string
}

// ClientMockImageParamPtrs contains pointers to parameters of the Client.Image
type ClientMockImageParamPtrs struct {
	ctx        *context.Context
	moduleName *string
	version    *string
}

// ClientMockImageResults contains results of the Client.Image
type ClientMockImageResults struct {
	i1  v1.Image
	err error
}

// ClientMockImageOrigins contains origins of expectations of the Client.Image
type ClientMockImageExpectationOrigins struct {
	origin           string
	originCtx        string
	originModuleName string
	originVersion    string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmImage *mClientMockImage) Optional() *mClientMockImage {
	mmImage.optional = true
	return mmImage
}

// Expect sets up expected params for Client.Image
func (mmImage *mClientMockImage) Expect(ctx context.Context, moduleName string, version string) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.paramPtrs != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by ExpectParams functions")
	}

	mmImage.defaultExpectation.params = &ClientMockImageParams{ctx, moduleName, version}
	mmImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmImage.expectations {
		if minimock.Equal(e.params, mmImage.defaultExpectation.params) {
			mmImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmImage.defaultExpectation.params)
		}
	}

	return mmImage
}

// ExpectCtxParam1 sets up expected param ctx for Client.Image
func (mmImage *mClientMockImage) ExpectCtxParam1(ctx context.Context) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &ClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmImage
}

// ExpectModuleNameParam2 sets up expected param moduleName for Client.Image
func (mmImage *mClientMockImage) ExpectModuleNameParam2(moduleName string) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &ClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.moduleName = &moduleName
	mmImage.defaultExpectation.expectationOrigins.originModuleName = minimock.CallerInfo(1)

	return mmImage
}

// ExpectVersionParam3 sets up expected param version for Client.Image
func (mmImage *mClientMockImage) ExpectVersionParam3(version string) *mClientMockImage {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{}
	}

	if mmImage.defaultExpectation.params != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Expect")
	}

	if mmImage.defaultExpectation.paramPtrs == nil {
		mmImage.defaultExpectation.paramPtrs = &ClientMockImageParamPtrs{}
	}
	mmImage.defaultExpectation.paramPtrs.version = &version
	mmImage.defaultExpectation.expectationOrigins.originVersion = minimock.CallerInfo(1)

	return mmImage
}

// Inspect accepts an inspector function that has same arguments as the Client.Image
func (mmImage *mClientMockImage) Inspect(f func(ctx context.Context, moduleName string, version string)) *mClientMockImage {
	if mmImage.mock.inspectFuncImage != nil {
		mmImage.mock.t.Fatalf("Inspect function is already set for ClientMock.Image")
	}

	mmImage.mock.inspectFuncImage = f

	return mmImage
}

// Return sets up results that will be returned by Client.Image
func (mmImage *mClientMockImage) Return(i1 v1.Image, err error) *ClientMock {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	if mmImage.defaultExpectation == nil {
		mmImage.defaultExpectation = &ClientMockImageExpectation{mock: mmImage.mock}
	}
	mmImage.defaultExpectation.results = &ClientMockImageResults{i1, err}
	mmImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmImage.mock
}

// Set uses given function f to mock the Client.Image method
func (mmImage *mClientMockImage) Set(f func(ctx context.Context, moduleName string, version string) (i1 v1.Image, err error)) *ClientMock {
	if mmImage.defaultExpectation != nil {
		mmImage.mock.t.Fatalf("Default expectation is already set for the Client.Image method")
	}

	if len(mmImage.expectations) > 0 {
		mmImage.mock.t.Fatalf("Some expectations are already set for the Client.Image method")
	}

	mmImage.mock.funcImage = f
	mmImage.mock.funcImageOrigin = minimock.CallerInfo(1)
	return mmImage.mock
}

// When sets expectation for the Client.Image which will trigger the result defined by the following
// Then helper
func (mmImage *mClientMockImage) When(ctx context.Context, moduleName string, version string) *ClientMockImageExpectation {
	if mmImage.mock.funcImage != nil {
		mmImage.mock.t.Fatalf("ClientMock.Image mock is already set by Set")
	}

	expectation := &ClientMockImageExpectation{
		mock:               mmImage.mock,
		params:             &ClientMockImageParams{ctx, moduleName, version},
		expectationOrigins: ClientMockImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmImage.expectations = append(mmImage.expectations, expectation)
	return expectation
}

// Then sets up Client.Image return parameters for the expectation previously defined by the When method
func (e *ClientMockImageExpectation) Then(i1 v1.Image, err error) *ClientMock {
	e.results = &ClientMockImageResults{i1, err}
	return e.mock
}

// Times sets number of times Client.Image should be invoked
func (mmImage *mClientMockImage) Times(n uint64) *mClientMockImage {
	if n == 0 {
		mmImage.mock.t.Fatalf("Times of ClientMock.Image mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmImage.expectedInvocations, n)
	mmImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmImage
}

func (mmImage *mClientMockImage) invocationsDone() bool {
	if len(mmImage.expectations) == 0 && mmImage.defaultExpectation == nil && mmImage.mock.funcImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmImage.mock.afterImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Image implements Client
func (mmImage *ClientMock) Image(ctx context.Context, moduleName string, version string) (i1 v1.Image, err error) {
	mm_atomic.AddUint64(&mmImage.beforeImageCounter, 1)
	defer mm_atomic.AddUint64(&mmImage.afterImageCounter, 1)

	mmImage.t.Helper()

	if mmImage.inspectFuncImage != nil {
		mmImage.inspectFuncImage(ctx, moduleName, version)
	}

	mm_params := ClientMockImageParams{ctx, moduleName, version}

	// Record call args
	mmImage.ImageMock.mutex.Lock()
	mmImage.ImageMock.callArgs = append(mmImage.ImageMock.callArgs, &mm_params)
	mmImage.ImageMock.mutex.Unlock()

	for _, e := range mmImage.ImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmImage.ImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmImage.ImageMock.defaultExpectation.Counter, 1)
		mm_want := mmImage.ImageMock.defaultExpectation.params
		mm_want_ptrs := mmImage.ImageMock.defaultExpectation.paramPtrs

		mm_got := ClientMockImageParams{ctx, moduleName, version}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmImage.t.Errorf("ClientMock.Image got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.moduleName != nil && !minimock.Equal(*mm_want_ptrs.moduleName, mm_got.moduleName) {
				mmImage.t.Errorf("ClientMock.Image got unexpected parameter moduleName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originModuleName, *mm_want_ptrs.moduleName, mm_got.moduleName, minimock.Diff(*mm_want_ptrs.moduleName, mm_got.moduleName))
			}

			if mm_want_ptrs.version != nil && !minimock.Equal(*mm_want_ptrs.version, mm_got.version) {
				mmImage.t.Errorf("ClientMock.Image got unexpected parameter version, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmImage.ImageMock.defaultExpectation.expectationOrigins.originVersion, *mm_want_ptrs.version, mm_got.version, minimock.Diff(*mm_want_ptrs.version, mm_got.version))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmImage.t.Errorf("ClientMock.Image got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmImage.ImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmImage.ImageMock.defaultExpectation.results
		if mm_results == nil {
			mmImage.t.Fatal("No results are set for the ClientMock.Image")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmImage.funcImage != nil {
		return mmImage.funcImage(ctx, moduleName, version)
	}
	mmImage.t.Fatalf("Unexpected call to ClientMock.Image. %v %v %v", ctx, moduleName, version)
	return
}

// ImageAfterCounter returns a count of finished ClientMock.Image invocations
func (mmImage *ClientMock) ImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImage.afterImageCounter)
}

// ImageBeforeCounter returns a count of ClientMock.Image invocations
func (mmImage *ClientMock) ImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmImage.beforeImageCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Image.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmImage *mClientMockImage) Calls() []*ClientMockImageParams {
	mmImage.mutex.RLock()

	argCopy := make([]*ClientMockImageParams, len(mmImage.callArgs))
	copy(argCopy, mmImage.callArgs)

	mmImage.mutex.RUnlock()

	return argCopy
}

// MinimockImageDone returns true if the count of the Image invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockImageDone() bool {
	if m.ImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ImageMock.invocationsDone()
}

// MinimockImageInspect logs each unmet expectation
func (m *ClientMock) MinimockImageInspect() {
	for _, e := range m.ImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterImageCounter := mm_atomic.LoadUint64(&m.afterImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ImageMock.defaultExpectation != nil && afterImageCounter < 1 {
		if m.ImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s", m.ImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Image at\n%s with params: %#v", m.ImageMock.defaultExpectation.expectationOrigins.origin, *m.ImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcImage != nil && afterImageCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Image at\n%s", m.funcImageOrigin)
	}

	if !m.ImageMock.invocationsDone() && afterImageCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Image at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ImageMock.expectedInvocations), m.ImageMock.expectedInvocationsOrigin, afterImageCounter)
	}
}

type mClientMockListTags struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockListTagsExpectation
	expectations       []*ClientMockListTagsExpectation

	callArgs []*ClientMockListTagsParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockListTagsExpectation specifies expectation struct of the Client.ListTags
type ClientMockListTagsExpectation struct {
	mock               *ClientMock
	params             *ClientMockListTagsParams
	paramPtrs          *ClientMockListTagsParamPtrs
	expectationOrigins ClientMockListTagsExpectationOrigins
	results            *ClientMockListTagsResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockListTagsParams contains parameters of the Client.ListTags
type ClientMockListTagsParams struct {
	ctx        context.Context
	moduleName string
}

// ClientMockListTagsParamPtrs contains pointers to parameters of the Client.ListTags
type ClientMockListTagsParamPtrs struct {
	ctx        *context.Context
	moduleName *string
}

// ClientMockListTagsResults contains results of the Client.ListTags
type ClientMockListTagsResults struct {
	sa1 []string
	err error
}

// ClientMockListTagsOrigins contains origins of expectations of the Client.ListTags
type ClientMockListTagsExpectationOrigins struct {
	origin           string
	originCtx        string
	originModuleName string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmListTags *mClientMockListTags) Optional() *mClientMockListTags {
	mmListTags.optional = true
	return mmListTags
}

// Expect sets up expected params for Client.ListTags
func (mmListTags *mClientMockListTags) Expect(ctx context.Context, moduleName string) *mClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.paramPtrs != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by ExpectParams functions")
	}

	mmListTags.defaultExpectation.params = &ClientMockListTagsParams{ctx, moduleName}
	mmListTags.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmListTags.expectations {
		if minimock.Equal(e.params, mmListTags.defaultExpectation.params) {
			mmListTags.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmListTags.defaultExpectation.params)
		}
	}

	return mmListTags
}

// ExpectCtxParam1 sets up expected param ctx for Client.ListTags
func (mmListTags *mClientMockListTags) ExpectCtxParam1(ctx context.Context) *mClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &ClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.ctx = &ctx
	mmListTags.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmListTags
}

// ExpectModuleNameParam2 sets up expected param moduleName for Client.ListTags
func (mmListTags *mClientMockListTags) ExpectModuleNameParam2(moduleName string) *mClientMockListTags {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{}
	}

	if mmListTags.defaultExpectation.params != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Expect")
	}

	if mmListTags.defaultExpectation.paramPtrs == nil {
		mmListTags.defaultExpectation.paramPtrs = &ClientMockListTagsParamPtrs{}
	}
	mmListTags.defaultExpectation.paramPtrs.moduleName = &moduleName
	mmListTags.defaultExpectation.expectationOrigins.originModuleName = minimock.CallerInfo(1)

	return mmListTags
}

// Inspect accepts an inspector function that has same arguments as the Client.ListTags
func (mmListTags *mClientMockListTags) Inspect(f func(ctx context.Context, moduleName string)) *mClientMockListTags {
	if mmListTags.mock.inspectFuncListTags != nil {
		mmListTags.mock.t.Fatalf("Inspect function is already set for ClientMock.ListTags")
	}

	mmListTags.mock.inspectFuncListTags = f

	return mmListTags
}

// Return sets up results that will be returned by Client.ListTags
func (mmListTags *mClientMockListTags) Return(sa1 []string, err error) *ClientMock {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	if mmListTags.defaultExpectation == nil {
		mmListTags.defaultExpectation = &ClientMockListTagsExpectation{mock: mmListTags.mock}
	}
	mmListTags.defaultExpectation.results = &ClientMockListTagsResults{sa1, err}
	mmListTags.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// Set uses given function f to mock the Client.ListTags method
func (mmListTags *mClientMockListTags) Set(f func(ctx context.Context, moduleName string) (sa1 []string, err error)) *ClientMock {
	if mmListTags.defaultExpectation != nil {
		mmListTags.mock.t.Fatalf("Default expectation is already set for the Client.ListTags method")
	}

	if len(mmListTags.expectations) > 0 {
		mmListTags.mock.t.Fatalf("Some expectations are already set for the Client.ListTags method")
	}

	mmListTags.mock.funcListTags = f
	mmListTags.mock.funcListTagsOrigin = minimock.CallerInfo(1)
	return mmListTags.mock
}

// When sets expectation for the Client.ListTags which will trigger the result defined by the following
// Then helper
func (mmListTags *mClientMockListTags) When(ctx context.Context, moduleName string) *ClientMockListTagsExpectation {
	if mmListTags.mock.funcListTags != nil {
		mmListTags.mock.t.Fatalf("ClientMock.ListTags mock is already set by Set")
	}

	expectation := &ClientMockListTagsExpectation{
		mock:               mmListTags.mock,
		params:             &ClientMockListTagsParams{ctx, moduleName},
		expectationOrigins: ClientMockListTagsExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmListTags.expectations = append(mmListTags.expectations, expectation)
	return expectation
}

// Then sets up Client.ListTags return parameters for the expectation previously defined by the When method
func (e *ClientMockListTagsExpectation) Then(sa1 []string, err error) *ClientMock {
	e.results = &ClientMockListTagsResults{sa1, err}
	return e.mock
}

// Times sets number of times Client.ListTags should be invoked
func (mmListTags *mClientMockListTags) Times(n uint64) *mClientMockListTags {
	if n == 0 {
		mmListTags.mock.t.Fatalf("Times of ClientMock.ListTags mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmListTags.expectedInvocations, n)
	mmListTags.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmListTags
}

func (mmListTags *mClientMockListTags) invocationsDone() bool {
	if len(mmListTags.expectations) == 0 && mmListTags.defaultExpectation == nil && mmListTags.mock.funcListTags == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmListTags.mock.afterListTagsCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmListTags.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ListTags implements Client
func (mmListTags *ClientMock) ListTags(ctx context.Context, moduleName string) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmListTags.beforeListTagsCounter, 1)
	defer mm_atomic.AddUint64(&mmListTags.afterListTagsCounter, 1)

	mmListTags.t.Helper()

	if mmListTags.inspectFuncListTags != nil {
		mmListTags.inspectFuncListTags(ctx, moduleName)
	}

	mm_params := ClientMockListTagsParams{ctx, moduleName}

	// Record call args
	mmListTags.ListTagsMock.mutex.Lock()
	mmListTags.ListTagsMock.callArgs = append(mmListTags.ListTagsMock.callArgs, &mm_params)
	mmListTags.ListTagsMock.mutex.Unlock()

	for _, e := range mmListTags.ListTagsMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmListTags.ListTagsMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmListTags.ListTagsMock.defaultExpectation.Counter, 1)
		mm_want := mmListTags.ListTagsMock.defaultExpectation.params
		mm_want_ptrs := mmListTags.ListTagsMock.defaultExpectation.paramPtrs

		mm_got := ClientMockListTagsParams{ctx, moduleName}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmListTags.t.Errorf("ClientMock.ListTags got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.moduleName != nil && !minimock.Equal(*mm_want_ptrs.moduleName, mm_got.moduleName) {
				mmListTags.t.Errorf("ClientMock.ListTags got unexpected parameter moduleName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.originModuleName, *mm_want_ptrs.moduleName, mm_got.moduleName, minimock.Diff(*mm_want_ptrs.moduleName, mm_got.moduleName))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmListTags.t.Errorf("ClientMock.ListTags got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmListTags.ListTagsMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmListTags.ListTagsMock.defaultExpectation.results
		if mm_results == nil {
			mmListTags.t.Fatal("No results are set for the ClientMock.ListTags")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmListTags.funcListTags != nil {
		return mmListTags.funcListTags(ctx, moduleName)
	}
	mmListTags.t.Fatalf("Unexpected call to ClientMock.ListTags. %v %v", ctx, moduleName)
	return
}

// ListTagsAfterCounter returns a count of finished ClientMock.ListTags invocations
func (mmListTags *ClientMock) ListTagsAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.afterListTagsCounter)
}

// ListTagsBeforeCounter returns a count of ClientMock.ListTags invocations
func (mmListTags *ClientMock) ListTagsBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmListTags.beforeListTagsCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ListTags.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmListTags *mClientMockListTags) Calls() []*ClientMockListTagsParams {
	mmListTags.mutex.RLock()

	argCopy := make([]*ClientMockListTagsParams, len(mmListTags.callArgs))
	copy(argCopy, mmListTags.callArgs)

	mmListTags.mutex.RUnlock()

	return argCopy
}

// MinimockListTagsDone returns true if the count of the ListTags invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockListTagsDone() bool {
	if m.ListTagsMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ListTagsMock.invocationsDone()
}

// MinimockListTagsInspect logs each unmet expectation
func (m *ClientMock) MinimockListTagsInspect() {
	for _, e := range m.ListTagsMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterListTagsCounter := mm_atomic.LoadUint64(&m.afterListTagsCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ListTagsMock.defaultExpectation != nil && afterListTagsCounter < 1 {
		if m.ListTagsMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s", m.ListTagsMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ListTags at\n%s with params: %#v", m.ListTagsMock.defaultExpectation.expectationOrigins.origin, *m.ListTagsMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcListTags != nil && afterListTagsCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ListTags at\n%s", m.funcListTagsOrigin)
	}

	if !m.ListTagsMock.invocationsDone() && afterListTagsCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ListTags at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ListTagsMock.expectedInvocations), m.ListTagsMock.expectedInvocationsOrigin, afterListTagsCounter)
	}
}

type mClientMockModules struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockModulesExpectation
	expectations       []*ClientMockModulesExpectation

	callArgs []*ClientMockModulesParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockModulesExpectation specifies expectation struct of the Client.Modules
type ClientMockModulesExpectation struct {
	mock               *ClientMock
	params             *ClientMockModulesParams
	paramPtrs          *ClientMockModulesParamPtrs
	expectationOrigins ClientMockModulesExpectationOrigins
	results            *ClientMockModulesResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockModulesParams contains parameters of the Client.Modules
type ClientMockModulesParams struct {
	ctx context.Context
}

// ClientMockModulesParamPtrs contains pointers to parameters of the Client.Modules
type ClientMockModulesParamPtrs struct {
	ctx *context.Context
}

// ClientMockModulesResults contains results of the Client.Modules
type ClientMockModulesResults struct {
	sa1 []string
	err error
}

// ClientMockModulesOrigins contains origins of expectations of the Client.Modules
type ClientMockModulesExpectationOrigins struct {
	origin    string
	originCtx string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmModules *mClientMockModules) Optional() *mClientMockModules {
	mmModules.optional = true
	return mmModules
}

// Expect sets up expected params for Client.Modules
func (mmModules *mClientMockModules) Expect(ctx context.Context) *mClientMockModules {
	if mmModules.mock.funcModules != nil {
		mmModules.mock.t.Fatalf("ClientMock.Modules mock is already set by Set")
	}

	if mmModules.defaultExpectation == nil {
		mmModules.defaultExpectation = &ClientMockModulesExpectation{}
	}

	if mmModules.defaultExpectation.paramPtrs != nil {
		mmModules.mock.t.Fatalf("ClientMock.Modules mock is already set by ExpectParams functions")
	}

	mmModules.defaultExpectation.params = &ClientMockModulesParams{ctx}
	mmModules.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmModules.expectations {
		if minimock.Equal(e.params, mmModules.defaultExpectation.params) {
			mmModules.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmModules.defaultExpectation.params)
		}
	}

	return mmModules
}

// ExpectCtxParam1 sets up expected param ctx for Client.Modules
func (mmModules *mClientMockModules) ExpectCtxParam1(ctx context.Context) *mClientMockModules {
	if mmModules.mock.funcModules != nil {
		mmModules.mock.t.Fatalf("ClientMock.Modules mock is already set by Set")
	}

	if mmModules.defaultExpectation == nil {
		mmModules.defaultExpectation = &ClientMockModulesExpectation{}
	}

	if mmModules.defaultExpectation.params != nil {
		mmModules.mock.t.Fatalf("ClientMock.Modules mock is already set by Expect")
	}

	if mmModules.defaultExpectation.paramPtrs == nil {
		mmModules.defaultExpectation.paramPtrs = &ClientMockModulesParamPtrs{}
	}
	mmModules.defaultExpectation.paramPtrs.ctx = &ctx
	mmModules.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmModules
}

// Inspect accepts an inspector function that has same arguments as the Client.Modules
func (mmModules *mClientMockModules) Inspect(f func(ctx context.Context)) *mClientMockModules {
	if mmModules.mock.inspectFuncModules != nil {
		mmModules.mock.t.Fatalf("Inspect function is already set for ClientMock.Modules")
	}

	mmModules.mock.inspectFuncModules = f

	return mmModules
}

// Return sets up results that will be returned by Client.Modules
func (mmModules *mClientMockModules) Return(sa1 []string, err error) *ClientMock {
	if mmModules.mock.funcModules != nil {
		mmModules.mock.t.Fatalf("ClientMock.Modules mock is already set by Set")
	}

	if mmModules.defaultExpectation == nil {
		mmModules.defaultExpectation = &ClientMockModulesExpectation{mock: mmModules.mock}
	}
	mmModules.defaultExpectation.results = &ClientMockModulesResults{sa1, err}
	mmModules.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmModules.mock
}

// Set uses given function f to mock the Client.Modules method
func (mmModules *mClientMockModules) Set(f func(ctx context.Context) (sa1 []string, err error)) *ClientMock {
	if mmModules.defaultExpectation != nil {
		mmModules.mock.t.Fatalf("Default expectation is already set for the Client.Modules method")
	}

	if len(mmModules.expectations) > 0 {
		mmModules.mock.t.Fatalf("Some expectations are already set for the Client.Modules method")
	}

	mmModules.mock.funcModules = f
	mmModules.mock.funcModulesOrigin = minimock.CallerInfo(1)
	return mmModules.mock
}

// When sets expectation for the Client.Modules which will trigger the result defined by the following
// Then helper
func (mmModules *mClientMockModules) When(ctx context.Context) *ClientMockModulesExpectation {
	if mmModules.mock.funcModules != nil {
		mmModules.mock.t.Fatalf("ClientMock.Modules mock is already set by Set")
	}

	expectation := &ClientMockModulesExpectation{
		mock:               mmModules.mock,
		params:             &ClientMockModulesParams{ctx},
		expectationOrigins: ClientMockModulesExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmModules.expectations = append(mmModules.expectations, expectation)
	return expectation
}

// Then sets up Client.Modules return parameters for the expectation previously defined by the When method
func (e *ClientMockModulesExpectation) Then(sa1 []string, err error) *ClientMock {
	e.results = &ClientMockModulesResults{sa1, err}
	return e.mock
}

// Times sets number of times Client.Modules should be invoked
func (mmModules *mClientMockModules) Times(n uint64) *mClientMockModules {
	if n == 0 {
		mmModules.mock.t.Fatalf("Times of ClientMock.Modules mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmModules.expectedInvocations, n)
	mmModules.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmModules
}

func (mmModules *mClientMockModules) invocationsDone() bool {
	if len(mmModules.expectations) == 0 && mmModules.defaultExpectation == nil && mmModules.mock.funcModules == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmModules.mock.afterModulesCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmModules.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Modules implements Client
func (mmModules *ClientMock) Modules(ctx context.Context) (sa1 []string, err error) {
	mm_atomic.AddUint64(&mmModules.beforeModulesCounter, 1)
	defer mm_atomic.AddUint64(&mmModules.afterModulesCounter, 1)

	mmModules.t.Helper()

	if mmModules.inspectFuncModules != nil {
		mmModules.inspectFuncModules(ctx)
	}

	mm_params := ClientMockModulesParams{ctx}

	// Record call args
	mmModules.ModulesMock.mutex.Lock()
	mmModules.ModulesMock.callArgs = append(mmModules.ModulesMock.callArgs, &mm_params)
	mmModules.ModulesMock.mutex.Unlock()

	for _, e := range mmModules.ModulesMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.sa1, e.results.err
		}
	}

	if mmModules.ModulesMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmModules.ModulesMock.defaultExpectation.Counter, 1)
		mm_want := mmModules.ModulesMock.defaultExpectation.params
		mm_want_ptrs := mmModules.ModulesMock.defaultExpectation.paramPtrs

		mm_got := ClientMockModulesParams{ctx}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmModules.t.Errorf("ClientMock.Modules got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmModules.ModulesMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmModules.t.Errorf("ClientMock.Modules got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmModules.ModulesMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmModules.ModulesMock.defaultExpectation.results
		if mm_results == nil {
			mmModules.t.Fatal("No results are set for the ClientMock.Modules")
		}
		return (*mm_results).sa1, (*mm_results).err
	}
	if mmModules.funcModules != nil {
		return mmModules.funcModules(ctx)
	}
	mmModules.t.Fatalf("Unexpected call to ClientMock.Modules. %v", ctx)
	return
}

// ModulesAfterCounter returns a count of finished ClientMock.Modules invocations
func (mmModules *ClientMock) ModulesAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModules.afterModulesCounter)
}

// ModulesBeforeCounter returns a count of ClientMock.Modules invocations
func (mmModules *ClientMock) ModulesBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmModules.beforeModulesCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.Modules.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmModules *mClientMockModules) Calls() []*ClientMockModulesParams {
	mmModules.mutex.RLock()

	argCopy := make([]*ClientMockModulesParams, len(mmModules.callArgs))
	copy(argCopy, mmModules.callArgs)

	mmModules.mutex.RUnlock()

	return argCopy
}

// MinimockModulesDone returns true if the count of the Modules invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockModulesDone() bool {
	if m.ModulesMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ModulesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ModulesMock.invocationsDone()
}

// MinimockModulesInspect logs each unmet expectation
func (m *ClientMock) MinimockModulesInspect() {
	for _, e := range m.ModulesMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.Modules at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterModulesCounter := mm_atomic.LoadUint64(&m.afterModulesCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ModulesMock.defaultExpectation != nil && afterModulesCounter < 1 {
		if m.ModulesMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.Modules at\n%s", m.ModulesMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.Modules at\n%s with params: %#v", m.ModulesMock.defaultExpectation.expectationOrigins.origin, *m.ModulesMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcModules != nil && afterModulesCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Modules at\n%s", m.funcModulesOrigin)
	}

	if !m.ModulesMock.invocationsDone() && afterModulesCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Modules at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ModulesMock.expectedInvocations), m.ModulesMock.expectedInvocationsOrigin, afterModulesCounter)
	}
}

type mClientMockName struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockNameExpectation
	expectations       []*ClientMockNameExpectation

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockNameExpectation specifies expectation struct of the Client.Name
type ClientMockNameExpectation struct {
	mock *ClientMock

	results      *ClientMockNameResults
	returnOrigin string
	Counter      uint64
}

// ClientMockNameResults contains results of the Client.Name
type ClientMockNameResults struct {
	s1 string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmName *mClientMockName) Optional() *mClientMockName {
	mmName.optional = true
	return mmName
}

// Expect sets up expected params for Client.Name
func (mmName *mClientMockName) Expect() *mClientMockName {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("ClientMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &ClientMockNameExpectation{}
	}

	return mmName
}

// Inspect accepts an inspector function that has same arguments as the Client.Name
func (mmName *mClientMockName) Inspect(f func()) *mClientMockName {
	if mmName.mock.inspectFuncName != nil {
		mmName.mock.t.Fatalf("Inspect function is already set for ClientMock.Name")
	}

	mmName.mock.inspectFuncName = f

	return mmName
}

// Return sets up results that will be returned by Client.Name
func (mmName *mClientMockName) Return(s1 string) *ClientMock {
	if mmName.mock.funcName != nil {
		mmName.mock.t.Fatalf("ClientMock.Name mock is already set by Set")
	}

	if mmName.defaultExpectation == nil {
		mmName.defaultExpectation = &ClientMockNameExpectation{mock: mmName.mock}
	}
	mmName.defaultExpectation.results = &ClientMockNameResults{s1}
	mmName.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmName.mock
}

// Set uses given function f to mock the Client.Name method
func (mmName *mClientMockName) Set(f func() (s1 string)) *ClientMock {
	if mmName.defaultExpectation != nil {
		mmName.mock.t.Fatalf("Default expectation is already set for the Client.Name method")
	}

	if len(mmName.expectations) > 0 {
		mmName.mock.t.Fatalf("Some expectations are already set for the Client.Name method")
	}

	mmName.mock.funcName = f
	mmName.mock.funcNameOrigin = minimock.CallerInfo(1)
	return mmName.mock
}

// Times sets number of times Client.Name should be invoked
func (mmName *mClientMockName) Times(n uint64) *mClientMockName {
	if n == 0 {
		mmName.mock.t.Fatalf("Times of ClientMock.Name mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmName.expectedInvocations, n)
	mmName.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmName
}

func (mmName *mClientMockName) invocationsDone() bool {
	if len(mmName.expectations) == 0 && mmName.defaultExpectation == nil && mmName.mock.funcName == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmName.mock.afterNameCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmName.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// Name implements Client
func (mmName *ClientMock) Name() (s1 string) {
	mm_atomic.AddUint64(&mmName.beforeNameCounter, 1)
	defer mm_atomic.AddUint64(&mmName.afterNameCounter, 1)

	mmName.t.Helper()

	if mmName.inspectFuncName != nil {
		mmName.inspectFuncName()
	}

	if mmName.NameMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmName.NameMock.defaultExpectation.Counter, 1)

		mm_results := mmName.NameMock.defaultExpectation.results
		if mm_results == nil {
			mmName.t.Fatal("No results are set for the ClientMock.Name")
		}
		return (*mm_results).s1
	}
	if mmName.funcName != nil {
		return mmName.funcName()
	}
	mmName.t.Fatalf("Unexpected call to ClientMock.Name.")
	return
}

// NameAfterCounter returns a count of finished ClientMock.Name invocations
func (mmName *ClientMock) NameAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.afterNameCounter)
}

// NameBeforeCounter returns a count of ClientMock.Name invocations
func (mmName *ClientMock) NameBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmName.beforeNameCounter)
}

// MinimockNameDone returns true if the count of the Name invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockNameDone() bool {
	if m.NameMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.NameMock.invocationsDone()
}

// MinimockNameInspect logs each unmet expectation
func (m *ClientMock) MinimockNameInspect() {
	for _, e := range m.NameMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Error("Expected call to ClientMock.Name")
		}
	}

	afterNameCounter := mm_atomic.LoadUint64(&m.afterNameCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.NameMock.defaultExpectation != nil && afterNameCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Name at\n%s", m.NameMock.defaultExpectation.returnOrigin)
	}
	// if func was set then invocations count should be greater than zero
	if m.funcName != nil && afterNameCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.Name at\n%s", m.funcNameOrigin)
	}

	if !m.NameMock.invocationsDone() && afterNameCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.Name at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.NameMock.expectedInvocations), m.NameMock.expectedInvocationsOrigin, afterNameCounter)
	}
}

type mClientMockReleaseImage struct {
	optional           bool
	mock               *ClientMock
	defaultExpectation *ClientMockReleaseImageExpectation
	expectations       []*ClientMockReleaseImageExpectation

	callArgs []*ClientMockReleaseImageParams
	mutex    sync.RWMutex

	expectedInvocations       uint64
	expectedInvocationsOrigin string
}

// ClientMockReleaseImageExpectation specifies expectation struct of the Client.ReleaseImage
type ClientMockReleaseImageExpectation struct {
	mock               *ClientMock
	params             *ClientMockReleaseImageParams
	paramPtrs          *ClientMockReleaseImageParamPtrs
	expectationOrigins ClientMockReleaseImageExpectationOrigins
	results            *ClientMockReleaseImageResults
	returnOrigin       string
	Counter            uint64
}

// ClientMockReleaseImageParams contains parameters of the Client.ReleaseImage
type ClientMockReleaseImageParams struct {
	ctx            context.Context
	moduleName     string
	releaseChannel string
}

// ClientMockReleaseImageParamPtrs contains pointers to parameters of the Client.ReleaseImage
type ClientMockReleaseImageParamPtrs struct {
	ctx            *context.Context
	moduleName     *string
	releaseChannel *string
}

// ClientMockReleaseImageResults contains results of the Client.ReleaseImage
type ClientMockReleaseImageResults struct {
	i1  v1.Image
	err error
}

// ClientMockReleaseImageOrigins contains origins of expectations of the Client.ReleaseImage
type ClientMockReleaseImageExpectationOrigins struct {
	origin               string
	originCtx            string
	originModuleName     string
	originReleaseChannel string
}

// Marks this method to be optional. The default behavior of any method with Return() is '1 or more', meaning
// the test will fail minimock's automatic final call check if the mocked method was not called at least once.
// Optional() makes method check to work in '0 or more' mode.
// It is NOT RECOMMENDED to use this option unless you really need it, as default behaviour helps to
// catch the problems when the expected method call is totally skipped during test run.
func (mmReleaseImage *mClientMockReleaseImage) Optional() *mClientMockReleaseImage {
	mmReleaseImage.optional = true
	return mmReleaseImage
}

// Expect sets up expected params for Client.ReleaseImage
func (mmReleaseImage *mClientMockReleaseImage) Expect(ctx context.Context, moduleName string, releaseChannel string) *mClientMockReleaseImage {
	if mmReleaseImage.mock.funcReleaseImage != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Set")
	}

	if mmReleaseImage.defaultExpectation == nil {
		mmReleaseImage.defaultExpectation = &ClientMockReleaseImageExpectation{}
	}

	if mmReleaseImage.defaultExpectation.paramPtrs != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by ExpectParams functions")
	}

	mmReleaseImage.defaultExpectation.params = &ClientMockReleaseImageParams{ctx, moduleName, releaseChannel}
	mmReleaseImage.defaultExpectation.expectationOrigins.origin = minimock.CallerInfo(1)
	for _, e := range mmReleaseImage.expectations {
		if minimock.Equal(e.params, mmReleaseImage.defaultExpectation.params) {
			mmReleaseImage.mock.t.Fatalf("Expectation set by When has same params: %#v", *mmReleaseImage.defaultExpectation.params)
		}
	}

	return mmReleaseImage
}

// ExpectCtxParam1 sets up expected param ctx for Client.ReleaseImage
func (mmReleaseImage *mClientMockReleaseImage) ExpectCtxParam1(ctx context.Context) *mClientMockReleaseImage {
	if mmReleaseImage.mock.funcReleaseImage != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Set")
	}

	if mmReleaseImage.defaultExpectation == nil {
		mmReleaseImage.defaultExpectation = &ClientMockReleaseImageExpectation{}
	}

	if mmReleaseImage.defaultExpectation.params != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Expect")
	}

	if mmReleaseImage.defaultExpectation.paramPtrs == nil {
		mmReleaseImage.defaultExpectation.paramPtrs = &ClientMockReleaseImageParamPtrs{}
	}
	mmReleaseImage.defaultExpectation.paramPtrs.ctx = &ctx
	mmReleaseImage.defaultExpectation.expectationOrigins.originCtx = minimock.CallerInfo(1)

	return mmReleaseImage
}

// ExpectModuleNameParam2 sets up expected param moduleName for Client.ReleaseImage
func (mmReleaseImage *mClientMockReleaseImage) ExpectModuleNameParam2(moduleName string) *mClientMockReleaseImage {
	if mmReleaseImage.mock.funcReleaseImage != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Set")
	}

	if mmReleaseImage.defaultExpectation == nil {
		mmReleaseImage.defaultExpectation = &ClientMockReleaseImageExpectation{}
	}

	if mmReleaseImage.defaultExpectation.params != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Expect")
	}

	if mmReleaseImage.defaultExpectation.paramPtrs == nil {
		mmReleaseImage.defaultExpectation.paramPtrs = &ClientMockReleaseImageParamPtrs{}
	}
	mmReleaseImage.defaultExpectation.paramPtrs.moduleName = &moduleName
	mmReleaseImage.defaultExpectation.expectationOrigins.originModuleName = minimock.CallerInfo(1)

	return mmReleaseImage
}

// ExpectReleaseChannelParam3 sets up expected param releaseChannel for Client.ReleaseImage
func (mmReleaseImage *mClientMockReleaseImage) ExpectReleaseChannelParam3(releaseChannel string) *mClientMockReleaseImage {
	if mmReleaseImage.mock.funcReleaseImage != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Set")
	}

	if mmReleaseImage.defaultExpectation == nil {
		mmReleaseImage.defaultExpectation = &ClientMockReleaseImageExpectation{}
	}

	if mmReleaseImage.defaultExpectation.params != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Expect")
	}

	if mmReleaseImage.defaultExpectation.paramPtrs == nil {
		mmReleaseImage.defaultExpectation.paramPtrs = &ClientMockReleaseImageParamPtrs{}
	}
	mmReleaseImage.defaultExpectation.paramPtrs.releaseChannel = &releaseChannel
	mmReleaseImage.defaultExpectation.expectationOrigins.originReleaseChannel = minimock.CallerInfo(1)

	return mmReleaseImage
}

// Inspect accepts an inspector function that has same arguments as the Client.ReleaseImage
func (mmReleaseImage *mClientMockReleaseImage) Inspect(f func(ctx context.Context, moduleName string, releaseChannel string)) *mClientMockReleaseImage {
	if mmReleaseImage.mock.inspectFuncReleaseImage != nil {
		mmReleaseImage.mock.t.Fatalf("Inspect function is already set for ClientMock.ReleaseImage")
	}

	mmReleaseImage.mock.inspectFuncReleaseImage = f

	return mmReleaseImage
}

// Return sets up results that will be returned by Client.ReleaseImage
func (mmReleaseImage *mClientMockReleaseImage) Return(i1 v1.Image, err error) *ClientMock {
	if mmReleaseImage.mock.funcReleaseImage != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Set")
	}

	if mmReleaseImage.defaultExpectation == nil {
		mmReleaseImage.defaultExpectation = &ClientMockReleaseImageExpectation{mock: mmReleaseImage.mock}
	}
	mmReleaseImage.defaultExpectation.results = &ClientMockReleaseImageResults{i1, err}
	mmReleaseImage.defaultExpectation.returnOrigin = minimock.CallerInfo(1)
	return mmReleaseImage.mock
}

// Set uses given function f to mock the Client.ReleaseImage method
func (mmReleaseImage *mClientMockReleaseImage) Set(f func(ctx context.Context, moduleName string, releaseChannel string) (i1 v1.Image, err error)) *ClientMock {
	if mmReleaseImage.defaultExpectation != nil {
		mmReleaseImage.mock.t.Fatalf("Default expectation is already set for the Client.ReleaseImage method")
	}

	if len(mmReleaseImage.expectations) > 0 {
		mmReleaseImage.mock.t.Fatalf("Some expectations are already set for the Client.ReleaseImage method")
	}

	mmReleaseImage.mock.funcReleaseImage = f
	mmReleaseImage.mock.funcReleaseImageOrigin = minimock.CallerInfo(1)
	return mmReleaseImage.mock
}

// When sets expectation for the Client.ReleaseImage which will trigger the result defined by the following
// Then helper
func (mmReleaseImage *mClientMockReleaseImage) When(ctx context.Context, moduleName string, releaseChannel string) *ClientMockReleaseImageExpectation {
	if mmReleaseImage.mock.funcReleaseImage != nil {
		mmReleaseImage.mock.t.Fatalf("ClientMock.ReleaseImage mock is already set by Set")
	}

	expectation := &ClientMockReleaseImageExpectation{
		mock:               mmReleaseImage.mock,
		params:             &ClientMockReleaseImageParams{ctx, moduleName, releaseChannel},
		expectationOrigins: ClientMockReleaseImageExpectationOrigins{origin: minimock.CallerInfo(1)},
	}
	mmReleaseImage.expectations = append(mmReleaseImage.expectations, expectation)
	return expectation
}

// Then sets up Client.ReleaseImage return parameters for the expectation previously defined by the When method
func (e *ClientMockReleaseImageExpectation) Then(i1 v1.Image, err error) *ClientMock {
	e.results = &ClientMockReleaseImageResults{i1, err}
	return e.mock
}

// Times sets number of times Client.ReleaseImage should be invoked
func (mmReleaseImage *mClientMockReleaseImage) Times(n uint64) *mClientMockReleaseImage {
	if n == 0 {
		mmReleaseImage.mock.t.Fatalf("Times of ClientMock.ReleaseImage mock can not be zero")
	}
	mm_atomic.StoreUint64(&mmReleaseImage.expectedInvocations, n)
	mmReleaseImage.expectedInvocationsOrigin = minimock.CallerInfo(1)
	return mmReleaseImage
}

func (mmReleaseImage *mClientMockReleaseImage) invocationsDone() bool {
	if len(mmReleaseImage.expectations) == 0 && mmReleaseImage.defaultExpectation == nil && mmReleaseImage.mock.funcReleaseImage == nil {
		return true
	}

	totalInvocations := mm_atomic.LoadUint64(&mmReleaseImage.mock.afterReleaseImageCounter)
	expectedInvocations := mm_atomic.LoadUint64(&mmReleaseImage.expectedInvocations)

	return totalInvocations > 0 && (expectedInvocations == 0 || expectedInvocations == totalInvocations)
}

// ReleaseImage implements Client
func (mmReleaseImage *ClientMock) ReleaseImage(ctx context.Context, moduleName string, releaseChannel string) (i1 v1.Image, err error) {
	mm_atomic.AddUint64(&mmReleaseImage.beforeReleaseImageCounter, 1)
	defer mm_atomic.AddUint64(&mmReleaseImage.afterReleaseImageCounter, 1)

	mmReleaseImage.t.Helper()

	if mmReleaseImage.inspectFuncReleaseImage != nil {
		mmReleaseImage.inspectFuncReleaseImage(ctx, moduleName, releaseChannel)
	}

	mm_params := ClientMockReleaseImageParams{ctx, moduleName, releaseChannel}

	// Record call args
	mmReleaseImage.ReleaseImageMock.mutex.Lock()
	mmReleaseImage.ReleaseImageMock.callArgs = append(mmReleaseImage.ReleaseImageMock.callArgs, &mm_params)
	mmReleaseImage.ReleaseImageMock.mutex.Unlock()

	for _, e := range mmReleaseImage.ReleaseImageMock.expectations {
		if minimock.Equal(*e.params, mm_params) {
			mm_atomic.AddUint64(&e.Counter, 1)
			return e.results.i1, e.results.err
		}
	}

	if mmReleaseImage.ReleaseImageMock.defaultExpectation != nil {
		mm_atomic.AddUint64(&mmReleaseImage.ReleaseImageMock.defaultExpectation.Counter, 1)
		mm_want := mmReleaseImage.ReleaseImageMock.defaultExpectation.params
		mm_want_ptrs := mmReleaseImage.ReleaseImageMock.defaultExpectation.paramPtrs

		mm_got := ClientMockReleaseImageParams{ctx, moduleName, releaseChannel}

		if mm_want_ptrs != nil {

			if mm_want_ptrs.ctx != nil && !minimock.Equal(*mm_want_ptrs.ctx, mm_got.ctx) {
				mmReleaseImage.t.Errorf("ClientMock.ReleaseImage got unexpected parameter ctx, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReleaseImage.ReleaseImageMock.defaultExpectation.expectationOrigins.originCtx, *mm_want_ptrs.ctx, mm_got.ctx, minimock.Diff(*mm_want_ptrs.ctx, mm_got.ctx))
			}

			if mm_want_ptrs.moduleName != nil && !minimock.Equal(*mm_want_ptrs.moduleName, mm_got.moduleName) {
				mmReleaseImage.t.Errorf("ClientMock.ReleaseImage got unexpected parameter moduleName, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReleaseImage.ReleaseImageMock.defaultExpectation.expectationOrigins.originModuleName, *mm_want_ptrs.moduleName, mm_got.moduleName, minimock.Diff(*mm_want_ptrs.moduleName, mm_got.moduleName))
			}

			if mm_want_ptrs.releaseChannel != nil && !minimock.Equal(*mm_want_ptrs.releaseChannel, mm_got.releaseChannel) {
				mmReleaseImage.t.Errorf("ClientMock.ReleaseImage got unexpected parameter releaseChannel, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
					mmReleaseImage.ReleaseImageMock.defaultExpectation.expectationOrigins.originReleaseChannel, *mm_want_ptrs.releaseChannel, mm_got.releaseChannel, minimock.Diff(*mm_want_ptrs.releaseChannel, mm_got.releaseChannel))
			}

		} else if mm_want != nil && !minimock.Equal(*mm_want, mm_got) {
			mmReleaseImage.t.Errorf("ClientMock.ReleaseImage got unexpected parameters, expected at\n%s:\nwant: %#v\n got: %#v%s\n",
				mmReleaseImage.ReleaseImageMock.defaultExpectation.expectationOrigins.origin, *mm_want, mm_got, minimock.Diff(*mm_want, mm_got))
		}

		mm_results := mmReleaseImage.ReleaseImageMock.defaultExpectation.results
		if mm_results == nil {
			mmReleaseImage.t.Fatal("No results are set for the ClientMock.ReleaseImage")
		}
		return (*mm_results).i1, (*mm_results).err
	}
	if mmReleaseImage.funcReleaseImage != nil {
		return mmReleaseImage.funcReleaseImage(ctx, moduleName, releaseChannel)
	}
	mmReleaseImage.t.Fatalf("Unexpected call to ClientMock.ReleaseImage. %v %v %v", ctx, moduleName, releaseChannel)
	return
}

// ReleaseImageAfterCounter returns a count of finished ClientMock.ReleaseImage invocations
func (mmReleaseImage *ClientMock) ReleaseImageAfterCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReleaseImage.afterReleaseImageCounter)
}

// ReleaseImageBeforeCounter returns a count of ClientMock.ReleaseImage invocations
func (mmReleaseImage *ClientMock) ReleaseImageBeforeCounter() uint64 {
	return mm_atomic.LoadUint64(&mmReleaseImage.beforeReleaseImageCounter)
}

// Calls returns a list of arguments used in each call to ClientMock.ReleaseImage.
// The list is in the same order as the calls were made (i.e. recent calls have a higher index)
func (mmReleaseImage *mClientMockReleaseImage) Calls() []*ClientMockReleaseImageParams {
	mmReleaseImage.mutex.RLock()

	argCopy := make([]*ClientMockReleaseImageParams, len(mmReleaseImage.callArgs))
	copy(argCopy, mmReleaseImage.callArgs)

	mmReleaseImage.mutex.RUnlock()

	return argCopy
}

// MinimockReleaseImageDone returns true if the count of the ReleaseImage invocations corresponds
// the number of defined expectations
func (m *ClientMock) MinimockReleaseImageDone() bool {
	if m.ReleaseImageMock.optional {
		// Optional methods provide '0 or more' call count restriction.
		return true
	}

	for _, e := range m.ReleaseImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			return false
		}
	}

	return m.ReleaseImageMock.invocationsDone()
}

// MinimockReleaseImageInspect logs each unmet expectation
func (m *ClientMock) MinimockReleaseImageInspect() {
	for _, e := range m.ReleaseImageMock.expectations {
		if mm_atomic.LoadUint64(&e.Counter) < 1 {
			m.t.Errorf("Expected call to ClientMock.ReleaseImage at\n%s with params: %#v", e.expectationOrigins.origin, *e.params)
		}
	}

	afterReleaseImageCounter := mm_atomic.LoadUint64(&m.afterReleaseImageCounter)
	// if default expectation was set then invocations count should be greater than zero
	if m.ReleaseImageMock.defaultExpectation != nil && afterReleaseImageCounter < 1 {
		if m.ReleaseImageMock.defaultExpectation.params == nil {
			m.t.Errorf("Expected call to ClientMock.ReleaseImage at\n%s", m.ReleaseImageMock.defaultExpectation.returnOrigin)
		} else {
			m.t.Errorf("Expected call to ClientMock.ReleaseImage at\n%s with params: %#v", m.ReleaseImageMock.defaultExpectation.expectationOrigins.origin, *m.ReleaseImageMock.defaultExpectation.params)
		}
	}
	// if func was set then invocations count should be greater than zero
	if m.funcReleaseImage != nil && afterReleaseImageCounter < 1 {
		m.t.Errorf("Expected call to ClientMock.ReleaseImage at\n%s", m.funcReleaseImageOrigin)
	}

	if !m.ReleaseImageMock.invocationsDone() && afterReleaseImageCounter > 0 {
		m.t.Errorf("Expected %d calls to ClientMock.ReleaseImage at\n%s but found %d calls",
			mm_atomic.LoadUint64(&m.ReleaseImageMock.expectedInvocations), m.ReleaseImageMock.expectedInvocationsOrigin, afterReleaseImageCounter)
	}
}

// MinimockFinish checks that all mocked methods have been called the expected number of times
func (m *ClientMock) MinimockFinish() {
	m.finishOnce.Do(func() {
		if !m.minimockDone() {
			m.MinimockImageInspect()

			m.MinimockListTagsInspect()

			m.MinimockModulesInspect()

			m.MinimockNameInspect()

			m.MinimockReleaseImageInspect()
		}
	})
}

// MinimockWait waits for all mocked methods to be called the expected number of times
func (m *ClientMock) MinimockWait(timeout mm_time.Duration) {
	timeoutCh := mm_time.After(timeout)
	for {
		if m.minimockDone() {
			return
		}
		select {
		case <-timeoutCh:
			m.MinimockFinish()
			return
		case <-mm_time.After(10 * mm_time.Millisecond):
		}
	}
}

func (m *ClientMock) minimockDone() bool {
	done := true
	return done &&
		m.MinimockImageDone() &&
		m.MinimockListTagsDone() &&
		m.MinimockModulesDone() &&
		m.MinimockNameDone() &&
		m.MinimockReleaseImageDone()
}
