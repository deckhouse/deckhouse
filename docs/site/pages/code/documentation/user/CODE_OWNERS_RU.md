---
title: "CODEOWNERS"
menuTitle: CODEOWNERS
force_searchable: true
description: CODEOWNERS
permalink: ru/code/documentation/user/code-owners.html
lang: ru
weight: 50
---

Функция **CODEOWNERS** позволяет определить пользователей и группы, которые являются ответственными за отдельные части репозитория. Изменения, затрагивающие файлы, указанные в `CODEOWNERS`, должны быть апрувнуты владельцами кода.

Использование CODEOWNERS помогает:

- требовать апрувы от доменных экспертов для важных директорий;
- упростить процесс поиска «ответственных» за конкретный участок кода.

CODEOWNERS дополняет механизм [правил апрува](/products/code/documentation/user/approval-rules.html), но не заменяет их. В отличие от правил апрува, которые задаются вручную в UI, CODEOWNERS работает через файл CODEOWNERS в репозитории.

---

## Как работает CODEOWNERS

`CODEOWNERS` — текстовый файл в репозитории.  
Code использует его для определения владельцев файлов, участвующих в запросе на слияние.

Ищется в трёх местах (по приоритету):

1. `./CODEOWNERS`
2. `./docs/CODEOWNERS`
3. `./.gitlab/CODEOWNERS`

Используется **только первый найденный файл**.

---

### Где применяется CODEOWNERS

Если MR, изменяющий файл, попадает под правила CODEOWNERS, то необходимо получить апрувы от владельцев.

---

### Формат CODEOWNERS

Строка правила:

```plaintext

<путь или паттерн> <список владельцев>
```

Владельцы:

- `@user`
- `@group`
- `@group/subgroup`
- роли: `@@developer`, `@@maintainer`, `@@owner`

---

### Примеры

```plaintext
# Владелец всех файлов
* @default-team

# README.md только в корне
/README.md @docs-team

# Все Ruby файлы
*.rb @backend-team

# Вся директория config
/config/ @devops

# README.md в любом месте
README.md @docs
```

---

## Паттерны путей

Code использует подмножество glob:

- `*` — любые символы кроме `/`
- `**` — матч нескольких уровней директорий
- `/dir/` — только указанная директория
- `*.md` — все Markdown-файлы
- `/config/**/*.rb` — все Ruby-файлы внутри config/* на всех уровнях

---

### Примеры паттернов

```plaintext
/docs/*       @docs-one      # один уровень
/docs/**      @docs-two      # рекурсивно
/app/**/*.rb  @ruby-team
```

---

## Секции CODEOWNERS

В файле CODEOWNERS секции — это именованные области, которые анализируются отдельно и всегда применяются. Пока вы не определите ни одной секции, GitLab рассматривает весь файл CODEOWNERS как одну единственную секцию.

- Code рассматривает записи без секций, включая правила, определённые до первой секции, как отдельную, безымянную секцию.
- Каждая секция обрабатывает свои правила отдельно.
- Если путь к файлу соответствует нескольким записям внутри одной секции, используется только последняя подходящая запись в этой секции.
- Если путь к файлу соответствует записям в нескольких секциях, используется последняя подходящая запись в каждой секции.

Например, в файле CODEOWNERS со следующими секциями, определяющими владельцев для README:

```plaintext
* @root

[README Owners]
README.md @user1 @user2
internal/README.md @user4

[README other owners]
README.md @user3
```

Владельцы для `README.md` в корневой директории:

- `@root` — из безымянной секции.
- `@user1` и `@user2` — из секции `[README Owners]`.
- `@user3` — из секции `[README other owners]`.

Владельцы для `internal/README.md`:

- `@root` — из безымянной секции.
- `@user4` — из секции `[README Owners]`. (И `README.md`, и `internal/README.md` подходят под правила секции, но используется только последняя подходящая запись в этой секции.)
- `@user3` — из секции `[README other owners]`.

В виджете merge request’а каждый владелец кода отображается под своим ярлыком.

![Пример codeowners](/images/code/code_owners_ru_example.png)

---

### Детальный пример: сложная комбинация секций

Ниже — пример реального промышленного файла, показывающий:

- секции с разным количеством апрувов,
- переопределение владельцев,
- опциональные секции,
- исключения,
- наследование секций с одинаковыми именами.

```plaintext
# Глобальные настройки
* @fallback-team
!*.lock                    # lock-файлы не требуют апрувов
!**/generated/**           # автоматическая генерация

[Backend][2] @backend-core
# Требуются 2 апрува от backend-core для любого Ruby-кода
app/**/*.rb

# Но для критических моделей определяем другой порядок
app/models/**/*.rb @backend-core @security-team

# А вот эта модель — исключение, владелец другой
app/models/legacy/**/*.rb @migration-team

[Backend]
# Дополнение секции: теперь Backend включает также SQL
db/**/*.sql @db-team

[Ruby Optional]
# Дополнительная подсветка владельцев, апрувы НЕ обязательны
^[Ruby Optional]
*.rb @ruby-advisors

[Frontend][3]
# Для UI требуется 3 апрува
*.vue @frontend-team
*.js  @frontend-team

# override: конкретный файл → конкретный человек
frontend/critical_entry.vue @frontend-lead

[Docs]
*.md @technical-writers

[Docs]
# override: README всегда принадлежит docs-lead
README.md @docs-lead
```

Особенности примера:

- секция `[Backend]` объявлена дважды → Code объединит её;
- `[Backend][2] @backend-core` задаёт **обязательные 2 апрува**;
- `[Frontend][3]` требует **3 апрува** от фронтенда;
- `[Ruby Optional]` отмечена как опциональная — владельцы видны, но их апрув не обязателен;
- исключения `!*.lock` и `!**/generated/**` означают, что эти файлы вообще не требуют апрувов.

---

## Исключения (!)

Используются для исключения файлов внутри секции:

```plaintext
* @default
!package-lock.json
!**/generated/**
```

После исключения файл **не может быть снова включён** в ту же секцию.

---

## Порядок обработки правил

- Code читает файл сверху вниз.
- В пределах одной секции правила с одинаковым путём **переопределяют** предыдущие.
- Если файл подходит под несколько секций — владельцы из всех этих секций добавляются.
- Секции не переопределяют друг друга — они *независимы*.

---

## Кто может быть владельцем (eligible owners)

### 1. Пользователи (через `@username`)

Пользователь считается валидным владельцем, если:

- Имеет **прямое** членство в проекте (Developer, Maintainer или Owner)

- Имеет членство в группе проекта (включая наследуемое). группа проекта, родительская группа, предки родительских групп

- Является членом группы, которая напрямую приглашена в проект.

#### Не считается владельцем, если

- забанен,
- доступ отозван,
- у него роль ниже Developer.

---

### 2. Группы (через `@group` или `@group/subgroup`)

Группа может быть владельцем **только если:**

- Она напрямую приглашена в проект с ролью Developer+ (через "Share group with project").
- Только *прямые участники* этой группы являются владельцами (наследуемые участники через её родителя не считаются).

---

### 3. Роли (через `@@role`)

Формат:

```plaintext
@@developer
@@maintainer
@@owner
```

При этом:

- Учитываются **только прямые участники проекта**
- участники групп не считаются.

#### Роли не наследуют друг друга

(`@@developer` НЕ включает maintainer'ов).

#### Можно указывать несколько ролей в одной строке

```plaintext
file.md @@developer @@maintainer
```

---

## Взаимодействие с rules

CODEOWNERS и Approval Rules работают независимо, но складываются:

Пример:

- Approval Rule «Security» → 1 апрув
- `[Backend][2]` → 2 апрува
- MR затрагивает backend-файл

Итог: требуется **3 апрува**.

---

## Рекомендации по оформлению

- Сначала задавайте широкие правила (`* @team`).
- Далее уточняющие (`app/**/*.rb @backend-team`).
- Секции используйте для чёткого UI и логики.
- Избегайте дубликатов — последнее правило в секции выигрывает.
- Используйте опциональные секции для «подсвечивания экспертов» без обязательных апрувов.

---

## Пример финального файла

```plaintext
# Глобальные владельцы
* @default-team

# Исключения
!yarn.lock
!**/generated/**

[Backend][2]
app/**/*.rb @backend-core

[Frontend][3]
*.vue @frontend-team
*.js @frontend-team

^[Docs]
*.md @docs-team

[Critical Overrides]
/config/production.yml @ops-lead
```
