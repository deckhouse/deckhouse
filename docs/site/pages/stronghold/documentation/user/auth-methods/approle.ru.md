---
title: "Метод Approle"
permalink: ru/stronghold/documentation/user/auth-methods/approle.html
lang: ru
---

### Метод AppRole

Методы аутентификации могут быть включены и отключены с помощью UI, CLI или API.

Включение с помощью CLI:

```shell
d8 stronghold auth enable approle
```

При включении методы аутентификации аналогичны механизмам секретов: они монтируются в таблицу монтирования Stronghold и могут быть доступны и настраиваться с использованием стандартного API для чтения/записи. Все методы аутентификации по умолчанию монтируются в поддиректории auth/ и выглядят как `auth/<type>`, например `auth/oidc/`.

Администраторы Stronghold с продвинутыми кейсами могут монтировать один метод аутентификации несколько раз, включая модуль с помощью CLI с отличным от стандартного путём:

```shell
d8 stronghold auth enable -path=my-login approle
```

Включение с помощью UI:
![Включение метода аутентификации](/images/stronghold/admin-guide-image1.ru.png)

Выберите метод аутентификации:
![Выбор метода аутентификации](/images/stronghold/admin-guide-image2.ru.png)

Настройте и подтвердите включение метода аутентификации:
![Настройка и подтверждение метода аутентификации](/images/stronghold/admin-guide-image3.ru.png)

Для отключения метода аутентификации выберите метод:
![Выбор метода аутентификации](/images/stronghold/admin-guide-image4.ru.png)

Подтвердите удаление метода:
![Подтверждение удаление метода](/images/stronghold/admin-guide-image5.ru.png)

### Метод аутентификации AppRole

Метод аутентификации `approle` позволяет машинам или _приложениям_ аутентифицироваться с помощью определенных в Stronghold _ролей_. Открытый дизайн `AppRole` позволяет использовать различные рабочие процессы и конфигурации для обработки большого количества приложений. Этот метод аутентификации ориентирован на автоматизированные рабочие процессы. Мы рекомендуем использовать `batch` токены с методом аутентификации `AppRole`.

AppRole представляет собой набор политик и ограничений аутентификации, которые должны быть применены для получения токена с этими политиками. Область применения может быть как узкой, так и широкой. AppRole может быть создан для конкретной машины, для сервиса на этой машине, или сервиса, работающего на многих машинах. Требуемые учетные данные для успешной аутентификации зависят от ограничений, установленных для AppRole, связанного с этими учетными данными.

#### Аутентификация с помощью CLI

Путь по умолчанию - `/approle`. Если этот метод аутентификации был включен по другому пути, укажите нужный путь вместо пути по умолчанию.

```shell
d8 stronghold write auth/approle/login \
  role_id=db02de05-fa49-4055-059b-67221c5c2f63 \
  secret_id=6a174c20-f6de-a63c-74d2-6018fcceff64

Key                Value
---                -----
token              75b74ffd-842c-fd43-1386-f7d7006e520a
token_accessor     4c29bc22-5c72-11a6-f778-2bc8f48cea0e
token_duration     20m0s
token_renewable    true
token_policies     [default]
```

#### Аутентификация с помощью API

Путь по умолчанию - `auth/approle/login`. При использовании другого пути, укажите нужный путь вместо пути по умолчанию.

Пример запроса:

```shell
curl \
  --header "X-Vault-Token: ${STRONGHOLD_TOKEN}" \
  --request POST \
  --data '{"role_id":"988a9df-...","secret_id":"37b74931..."}' \
  ${STRONGHOLD_ADDR}/v1/auth/approle/login
```

Ответ API будет содержать токен в качестве значения `auth.client_token`:

```json
{
  "auth": {
    "renewable": true,
    "lease_duration": 2764800,
    "metadata": {},
    "policies": ["default", "dev-policy", "test-policy"],
    "accessor": "5d7fb475-07cb-4060-c2de-1ca3fcbf0c56",
    "client_token": "98a4c7ab-b1fe-361b-ba0b-e307aacfd587"
  }
}
```

-> **Application Integration:** See the [Code Example](#code-example) section
for a code snippet demonstrating the authentication with Vault using the
AppRole auth method.

#### Конфигурирование

Методы аутентификации должны быть настроены заранее, прежде чем пользователи или машины смогут проходить аутентификацию. Эти шаги обычно выполняются оператором или инструментом управления конфигурацией.

#### Конфигурирование через CLI

1. Включите метод аутентификации AppRole:

  ```shell
  d8 stronghold auth enable approle
  ```

1. Создайте именованную роль:

  ```shell
  d8 stronghold write auth/approle/role/my-role \
    token_type=batch \
    secret_id_ttl=10m \
    token_num_uses=10 \
    token_ttl=20m \
    token_max_ttl=30m \
    secret_id_num_uses=40
  ```

**Примечание:** Если токен, выданный вашим approle, требует возможности создания дочерних токенов, вам необходимо установить значение token_num_uses равным 0.

Для полного списка параметров конфигурации, пожалуйста, ознакомьтесь с [API](api_guide.html)
документацией.

1. Получите RoleID для AppRole:

   ```shell
   d8 stronghold read auth/approle/role/my-role/role-id
     role_id     db02de05-fa49-4055-059b-67221c5c2f63
   ```

1. Получите SecretID, выданный для AppRole:

  ```shell
  d8 stronghold write -f auth/approle/role/my-role/secret-id
    secret_id               6a174c20-f6de-a63c-74d2-6018fcceff64
    secret_id_accessor      c454f7e5-996e-7230-6074-6ef26b7bcf86
    secret_id_ttl           10m
    secret_id_num_uses      40
  ```

#### Конфигурирование через API

1. Включение метода аутентификации AppRole:

  ```shell
  curl \
    --header "X-Vault-Token: ${STRONGHOLD_TOKEN}" \
    --request POST \
    --data '{"type": "approle"}' \
    ${STRONGHOLD_ADDR}/v1/sys/auth/approle
  ```

1. Создайте AppRole с необходимым набором политик:

  ```shell
  curl \
    --header "X-Vault-Token: ${STRONGHOLD_TOKEN}" \

    --data '{"policies": "dev-policy,test-policy", "token_type": "batch"}' \
    ${STRONGHOLD_ADDR}/v1/auth/approle/role/my-role
  ```

1. Получите идентификатор роли:

  ```shell
  curl \
    --header "X-Vault-Token: ${STRONGHOLD_TOKEN}" \
    ${STRONGHOLD_ADDR}/v1/auth/approle/role/my-role/role-id
  ```

  Пример ответа API:

  ```json
  {
    "data": {
    "role_id": "888a9dfd-ea69-4a53-6cb6-9d6b86474bba"
    }
  }
  ```

1. Создайте новый идентификатор секрета для роли:

  ```shell
  curl \
    --header "X-Vault-Token: ${STRONGHOLD_TOKEN}" \
    --request POST \
    ${STRONGHOLD_ADDR}/v1/auth/approle/role/my-role/secret-id
  ```

  Пример ответа API:

  ```json
  {
    "data": {
      "secret_id_accessor": "65946873-1d96-a9d4-678c-9229f74386a5",
      "secret_id": "37b24931-c4cd-d49a-9246-ccc62d682a25",
      "secret_id_ttl": 600,
      "secret_id_num_uses": 40
    }
  }
  ```

#### Учетные данные/Ограничения

##### RoleID

RoleID - это идентификатор, который выбирает AppRole, по которому оцениваются другие учетные данные. При аутентификации с использованием конечной точки входа этого метода аутентификации, RoleID является обязательным аргументом (через `role_id`) всегда. По умолчанию RoleID являются уникальными UUID, что позволяет им служить вторичными секретами для другой информации об учетных данных. Однако они могут быть установлены на определенные значения для сопоставления с информацией, полученной клиентом (например, доменное имя клиента).

##### SecretID

SecretID - это учетные данные, которые по умолчанию требуются для любого входа (через `secret_id`) и всегда должны быть секретными. (Для расширенного использования требование SecretID может быть отключено с помощью параметра `bind_secret_id` AppRole, позволяя машинам, знающим только RoleID или соответствующие другие ограничения, получить токен). SecretID может быть создан для AppRole либо путем генерации 128-битного полностью случайного UUID самим ролью (`Pull` режим), либо путем указания определенных пользовательских значений (`Push` режим). Аналогично токенам, у SecretID есть свойства, такие как ограничение использования, TTL и сроки действия.

#### Режимы Pull и Push SecretID

Если SecretID, используемый для входа, извлекается из AppRole, это работает в режиме Pull. Если клиент устанавливает "пользовательский" SecretID для AppRole, это называется режимом Push. Режим Push имитирует поведение устаревшего метода аутентификации App-ID; однако в большинстве случаев режим Pull является более предпочтительным подходом. Причина в том, что режим Push требует, чтобы некая другая система знала полный набор учетных данных клиента (RoleID и SecretID), чтобы создать запись, даже если они затем распространяются по разным путям. Однако в режиме Pull, хотя RoleID должен быть известен для его распространения клиенту, SecretID может быть сохранен в тайне от всех сторон, кроме конечного аутентифицирующего клиента с использованием [Response Wrapping](/vault/docs/concepts/response-wrapping).

Режим Push доступен для совместимости с рабочим процессом App-ID, который в некоторых конкретных случаях предпочтителен, но в большинстве случаев режим Pull является более безопасным и предпочтительным.

##### Дополнительные ограничения

`role_id` - это обязательные учетные данные на конечной точке входа. AppRole, на который указывает `role_id`, будет иметь настроенные ограничения. Это определяет другие `required` учетные данные для входа. Ограничение `bind_secret_id` требует представления `secret_id` на конечной точке входа. В будущем этот метод аутентификации может поддерживать больше параметров ограничений для поддержки различных наборов приложений. Некоторые ограничения не потребуют учетных данных, но все равно будут применять ограничения для входа. Например, `secret_id_bound_cidrs` позволит только входы, приходящие с IP-адресов, принадлежащих настроенным CIDR-блокам на AppRole.
