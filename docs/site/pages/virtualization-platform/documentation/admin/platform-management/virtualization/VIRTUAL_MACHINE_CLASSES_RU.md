---
title: "Классы виртуальных машин"
permalink: ru/virtualization-platform/documentation/admin/platform-management/virtualization/virtual-machine-classes.html
lang: ru
---

Ресурс [`VirtualMachineClass`](/modules/virtualization/cr.html#virtualmachineclass) предназначен для централизованной конфигурации предпочтительных параметров виртуальных машин.
Он позволяет определять инструкции CPU, политики конфигурации ресурсов CPU и памяти для виртуальных машин, а также определять соотношения этих ресурсов.
Помимо этого, [VirtualMachineClass](/modules/virtualization/cr.html#virtualmachineclass) обеспечивает управление размещением виртуальных машин по узлам платформы.
Это позволяет администраторам эффективно управлять ресурсами платформы виртуализации и оптимально размещать виртуальные машины на узлах платформы.

Во время установки автоматически создаётся ресурс VirtualMachineClass с именем `generic`. Он представляет собой универсальный тип процессора на основе более старой, но широко поддерживаемой архитектуры Nehalem. Это позволяет запускать виртуальные машины на любых узлах кластера и поддерживает их живую миграцию.

Администратор может изменять параметры ресурса VirtualMachineClass `generic` (за исключением секции `.spec.cpu`), либо удалить данный ресурс.

{% alert level="info" %}
Не рекомендуется использовать VirtualMachineClass `generic` для запуска рабочих нагрузок в production-средах, поскольку данный класс соответствует процессору с наименьшей функциональностью.

Рекомендуется после добавления и настройки всех узлов в кластере создать хотя бы один ресурс VirtualMachineClass с типом `Discovery`. Это обеспечит выбор наилучшей доступной конфигурации процессора с учётом всех CPU в вашем кластере, позволит виртуальным машинам максимально эффективно использовать возможности процессоров и обеспечит беспрепятственную миграцию между узлами.

Пример настройки смотрите в разделе [Пример конфигурации vCPU Discovery](#пример-конфигурации-vcpu-discovery).
{% endalert %}

Чтобы вывести список ресурсов VirtualMachineClass, выполните следующую команду:

```bash
d8 k get virtualmachineclass
```

Пример вывода:

```console
NAME               PHASE   AGE
generic            Ready   6d1h
```

Обязательно указывайте ресурс VirtualMachineClass в конфигурации виртуальной машины.
Пример указания класса в спецификации ВМ:

```yaml
apiVersion: virtualization.deckhouse.io/v1alpha2
kind: VirtualMachine
metadata:
  name: linux-vm
spec:
  virtualMachineClassName: generic # Название ресурса VirtualMachineClass.
  ...
```

### VirtualMachineClass по умолчанию

Для удобства можно назначить VirtualMachineClass по умолчанию. Этот класс будет использоваться в поле `spec.virtualMachineClassName`, если оно не указано в манифесте виртуальной машины.

VirtualMachineClass по умолчанию задаётся с помощью аннотации `virtualmachineclass.virtualization.deckhouse.io/is-default-class`. В кластере может быть только один класс по умолчанию. Класс по умолчанию изменяется снятием аннотации с одного класса и добавлением её к другому.

Не рекомендуется ставить аннотацию на класс `generic`, так как при обновлении она может пропасть. Рекомендуется создать собственный класс и назначить его классом по умолчанию.

Чтобы вывести список всех ресурсов VirtualMachineClass, выполните команду:

```shell
d8 k get virtualmachineclass
```

Пример вывода (без класса по умолчанию):

```console
NAME                                    PHASE   ISDEFAULT   AGE
generic                                 Ready               1d
host-passthrough-custom                 Ready               1d
```

Чтобы назначить класс по умолчанию, выполните:

```shell
d8 k annotate vmclass host-passthrough-custom virtualmachineclass.virtualization.deckhouse.io/is-default-class=true
```

Пример вывода:

```console
virtualmachineclass.virtualization.deckhouse.io/host-passthrough-custom annotated
```

После назначения класса по умолчанию снова выведите список всех ресурсов VirtualMachineClass:

```shell
d8 k get vmclass
```

Пример вывода (с классом по умолчанию):

```console
NAME                                    PHASE   ISDEFAULT   AGE
generic                                 Ready               1d
host-passthrough-custom                 Ready   true        1d
```

При создании ВМ без указания значения для поля `spec.virtualMachineClassName` в него будет подставлено имя `host-passthrough-custom`.

## Настройки VirtualMachineClass

Структура ресурса `VirtualMachineClass` выглядит следующим образом:

```yaml
apiVersion: virtualization.deckhouse.io/v1alpha2
kind: VirtualMachineClass
metadata:
  name: <vmclass-name>
  # (опционально) Класс по умолчанию.
  # annotations:
  #   virtualmachineclass.virtualization.deckhouse.io/is-default-class: "true"
spec:
  # Блок описывает параметры виртуального процессора для виртуальных машин.
  # Изменять данный блок нельзя после создания ресурса.
  cpu: ...
  # (опциональный блок) Описывает правила размещения виртуальных машины по узлам.
  # При изменении автоматически применяется ко всем виртуальных машинам, использующим данный VirtualMachineClass.
  nodeSelector: ...
  # (опциональный блок) Описывает политику настройки ресурсов виртуальных машин.
  # При изменении автоматически применяется ко всем виртуальных машинам, использующим данный VirtualMachineClass.
  sizingPolicies: ...
```

Как настроить VirtualMachineClass в веб-интерфейсе:

- Перейдите на вкладку «Система», далее в раздел «Виртуализация» → «Классы ВМ».
- Нажмите кнопку «Создать».
- В открывшемся окне введите имя для класса ВМ в поле «Имя».

Далее рассмотрим настройки блоков более детально.

### Настройки vCPU

Блок `.spec.cpu` позволяет задать или настроить vCPU для ВМ.

{% alert level="warning" %}
Настройки блока `.spec.cpu` после создания ресурса VirtualMachineClass изменять нельзя.
{% endalert %}

Примеры настройки блока `.spec.cpu`:

- Класс с vCPU с требуемым набором процессорных инструкций. Для этого используйте `type: Features`, чтобы задать необходимый набор поддерживаемых инструкций для процессора:

  ```yaml
  spec:
    cpu:
      features:
        - vmx
      type: Features
  ```

  Как настроить vCPU в веб-интерфейсе в [форме создания классов ВМ](#настройки-virtualmachineclass):

  - В блоке «Настройки ЦП» в поле «Тип» выберите `Features`.
  - В поле «Обязательный набор поддерживаемых инструкций» выберите необходимые вам инструкции для процессора.
  - Для создания класса ВМ нажмите кнопку «Создать».

- Класс c универсальным vCPU для заданного набора узлов. Для этого используйте `type: Discovery`:

  ```yaml
  spec:
    cpu:
      discovery:
        nodeSelector:
          matchExpressions:
            - key: node-role.kubernetes.io/control-plane
              operator: DoesNotExist
      type: Discovery
  ```

  Как выполнить операцию в веб-интерфейсе в [форме создания классов ВМ](#настройки-virtualmachineclass):

  - В блоке «Настройки ЦП» в поле «Тип» выберите `Discovery`.
  - Нажмите «Добавить» в блоке «Условия для создания универсального процессора» → «Лейблы и выражения».
  - Во всплывающем окне можете задать «Ключ», «Оператор» и «Значение» ключа, что соответствует настройкам `spec.cpu.discovery.nodeSelector`.
  - Для подтверждения параметров ключа нажмите кнопку «Enter».
  - Для создания класса ВМ нажмите кнопку «Создать».

- Класс c `type: Host` использует виртуальный vCPU, максимально соответствующий набору инструкций vCPU узла платформы, что обеспечивает высокую производительность и функциональность.
  Он также гарантирует совместимость с живой миграцией для узлов с похожими типами процессоров.
  Например, миграция виртуальной машины между узлами с процессорами Intel и AMD невозможна. Это также относится к процессорам разных поколений, так как их наборы инструкций могут отличаться.

  ```yaml
  spec:
    cpu:
      type: Host
  ```

  Как выполнить операцию в веб-интерфейсе в [форме создания классов ВМ](#настройки-virtualmachineclass):

  - В блоке «Настройки ЦП» в поле «Тип» выберите `Host`.
  - Для создания класса ВМ нажмите кнопку «Создать».

- Класс с `type: HostPassthrough` использует физический CPU узла платформы без изменений.
  Виртуальная машина, использующая этот класс, может быть мигрирована только на узел, у которого CPU точно совпадает с CPU исходного узла.

  ```yaml
  spec:
    cpu:
      type: HostPassthrough
  ```

  Как выполнить операцию в веб-интерфейсе в [форме создания классов ВМ](#настройки-virtualmachineclass):

  - В блоке «Настройки ЦП» в поле «Тип» выберите `HostPassthrough`.
  - Для создания класса ВМ нажмите кнопку «Создать».

- Чтобы создать vCPU конкретного процессора с предварительно определённым набором инструкций, используйте тип `type: Model`.
  Предварительно, чтобы получить перечень названий поддерживаемых CPU для узла кластера, выполните команду:

  ```bash
  d8 k get nodes <node-name> -o json | jq '.metadata.labels | to_entries[] | select(.key | test("cpu-model.node.virtualization.deckhouse.io")) | .key | split("/")[1]' -r
  ```

  Пример вывода:

  ```console
  Broadwell-noTSX
  Broadwell-noTSX-IBRS
  Haswell-noTSX
  Haswell-noTSX-IBRS
  IvyBridge
  IvyBridge-IBRS
  Nehalem
  Nehalem-IBRS
  Penryn
  SandyBridge
  SandyBridge-IBRS
  Skylake-Client-noTSX-IBRS
  Westmere
  Westmere-IBRS
  ```

  Далее укажите в спецификации ресурса VirtualMachineClass следующее:

  ```yaml
  spec:
    cpu:
      model: IvyBridge
      type: Model
  ```

  Как выполнить операцию в веб-интерфейсе в [форме создания классов ВМ](#настройки-virtualmachineclass):

  - В блоке «Настройки ЦП» в поле «Тип» выберите `Model`.
  - В поле «Модель» выберите необходимую модель процессора.
  - Для создания класса ВМ нажмите кнопку «Создать».

### Настройки размещения

Блок `.spec.nodeSelector` опционален. Он позволяет задать узлы, на которых будут размещаться ВМ, использующие данный vmclass:

```yaml
  spec:
    nodeSelector:
      matchExpressions:
        - key: node.deckhouse.io/group
          operator: In
          values:
          - green
```

{% alert level="warning" %}
Поскольку изменение параметра `.spec.nodeSelector` влияет на все виртуальные машины, использующие данный ресурс VirtualMachineClass, следует учитывать следующее:

- в Enterprise-редакции это может привести к миграции виртуальных машин на новые узлы назначения, если текущие узлы не соответствуют требованиям размещения;
- в Community-редакции это может вызвать перезапуск виртуальных машин в соответствии с автоматической политикой применения изменений, установленной в параметре `.spec.disruptions.restartApprovalMode`.
{% endalert %}

Как выполнить операцию в веб-интерфейсе в [форме создания классов ВМ](#настройки-virtualmachineclass):

- Нажмите «Добавить» в блоке «Условия планирования ВМ на узлах» → «Лейблы и выражения».
- Во всплывающем окне можете задать «Ключ», «Оператор» и «Значение» ключа, что соответствует настройкам `spec.nodeSelector`.
- Для подтверждения параметров ключа нажмите кнопку «Enter».
- Для создания класса ВМ нажмите кнопку «Создать».

### Настройки политики сайзинга

Блок `.spec.sizingPolicy` позволяет задать политики сайзинга ресурсов виртуальных машин, которые используют vmclass.

{% alert level="warning" %}
Изменения в блоке `.spec.sizingPolicy` также могут повлиять на виртуальные машины.
Для виртуальных машин, чья политика сайзинга не будет соответствовать новым требованиям политики, условие `SizingPolicyMatched` в блоке `.status.conditions` будет ложным (`status: False`).

При настройке `sizingPolicy` будьте внимательны и учитывайте [топологию CPU](../../../user/resource-management/virtual-machines.html#топологии-cpu) для виртуальных машин.
{% endalert %}

Блок `cores` обязательный и задает диапазоны ядер, на которые распространяется правило, описанное в этом же блоке.

Диапазоны [min; max] для параметра `cores` должны быть строго последовательными и непересекающимися.

Правильная структура (диапазоны идут друг за другом без пересечений):

```yaml
- cores:
    min: 1
    max: 4
    ...
- cores:
    min: 5   # Начало следующего диапазона = (предыдущий max + 1)
    max: 8
```

Недопустимый вариант (пересечение значений):

```yaml
- cores:
    min: 1
    max: 4
    ...
- cores:
    min: 4   # Ошибка: Значение 4 уже входит в предыдущий диапазон
    max: 8
```

{% alert level="warning" %}
Правило: Каждый новый диапазон должен начинаться со значения, непосредственно следующего за max предыдущего диапазона.
{% endalert %}

Для каждого диапазона ядер `cores` можно задать дополнительные требования:

1. Память (`memory`) — указывается:

   - Либо минимум и максимум памяти для всех ядер в диапазоне,
   - Либо минимум и максимум памяти на одно ядро (`memory.perCore`).

1. Допустимые доли ядер (`coreFractions`) — список разрешенных значений (например, [25, 50, 100] для 25%, 50% или 100% использования ядра). Если в спецификации виртуальной машины явно указан параметр `coreFraction`, его значение должно быть из этого списка.

1. Значение по умолчанию для доли ядер (`defaultCoreFraction`) — указывает, какая доля ядра будет использоваться по умолчанию для данного диапазона ядер, если в спецификации виртуальной машины явно не указан параметр `coreFraction`. Это значение должно присутствовать в списке `coreFractions`. Если `defaultCoreFraction` не задан, по умолчанию применяется значение `100%`.

{% alert level="warning" %}
Для каждого диапазона ядер обязательно укажите:

- либо memory (или `memory.perCore`);
- либо `coreFractions`;
- либо оба параметра одновременно.
{% endalert %}

Примеры зависимости объема памяти от числа ядер:

- При использовании параметра `memory` объем разрешенной памяти фиксирован для всего диапазона ядер и не зависит от их количества:

  ```yaml
  - cores:
      min: 1
      max: 4
    memory:
      min: 2Gi
      max: 8Gi
  ```

  В этом примере для любой виртуальной машины с количеством ядер от 1 до 4 можно выбрать любой объём памяти от 2 до 8 ГБ — независимо от числа ядер. Память не зависит от количества ядер в диапазоне.

- При использовании параметра `memory.perCore` объем разрешенной памяти рассчитывается как произведение числа ядер на указанный диапазон памяти на одно ядро:

  ```yaml
  - cores:
      min: 1
      max: 4
    memory:
      perCore:
        min: 1Gi
        max: 2Gi
  ```

  В этом случае:
  - для виртуальной машины с 1 ядром: от 1×1 ГиБ = 1 ГиБ до 1×2 ГиБ = 2 ГиБ памяти;
  - для виртуальной машины с 2 ядрами: от 2×1 ГиБ = 2 ГиБ до 2×2 ГиБ = 4 ГиБ памяти;
  - для виртуальной машины с 3 ядрами: от 3×1 ГиБ = 3 ГиБ до 3×2 ГиБ = 6 ГиБ памяти;
  - для виртуальной машины с 4 ядрами: от 4×1 ГиБ = 4 ГиБ до 4×2 ГиБ = 8 ГиБ памяти.

  Таким образом, при использовании `memory.perCore` объем разрешенной памяти автоматически масштабируется пропорционально числу ядер, что обеспечивает более гибкое и справедливое распределение ресурсов.

- Примеры использования параметра `memory.step` для дискретизации памяти:

  Параметр `step` определяет шаг дискретизации размера памяти. Он позволяет ограничить доступные значения памяти определенными шагами, что упрощает управление ресурсами и предотвращает установку произвольных значений.

  - Пример с `memory.min` и `memory.max` шагом 1 ГБ:

    ```yaml
    - cores:
        min: 1
        max: 4
      memory:
        min: 2Gi
        max: 8Gi
        step: 1Gi
    ```

    В этом случае доступны только следующие значения памяти: 2 ГБ, 3 ГБ, 4 ГБ, 5 ГБ, 6 ГБ, 7 ГБ, 8 ГБ. Нельзя установить, например, 2.5 ГБ или 7.5 ГБ.

  - Пример с `memory.perCore` и шагом:

    ```yaml
    - cores:
        min: 1
        max: 4
      memory:
        perCore:
          min: 1Gi
          max: 2Gi
        step: 512Mi
    ```

    В этом случае для каждой виртуальной машины доступные значения памяти рассчитываются с учетом шага:
    - для 1 ядра: 1 ГБ, 1.5 ГБ, 2 ГБ;
    - для 2 ядер: 2 ГБ, 3 ГБ, 4 ГБ;
    - для 3 ядер: 3 ГБ, 4.5 ГБ, 6 ГБ;
    - для 4 ядер: 4 ГБ, 6 ГБ, 8 ГБ.

    Обратите внимание, что шаг применяется к итоговому объему памяти, а не к памяти на ядро.

Пример политики с подобными настройками:

```yaml
spec:
  sizingPolicies:
    # Для диапазона от 1 до 4 ядер возможно использовать от 1 до 8 ГБ оперативной памяти с шагом 512Mi,
    # т.е 1 ГБ, 1,5 ГБ, 2 ГБ, 2,5 ГБ и т. д.
    # Запрещено использовать выделенные ядра.
    # Доступны все варианты параметра `corefraction`.
    - cores:
        min: 1
        max: 4
      memory:
        min: 1Gi
        max: 8Gi
        step: 512Mi
      coreFractions: [5, 10, 20, 50, 100]
      defaultCoreFraction: 50  # Значение по умолчанию для диапазона 1-4 ядра
        # Для диапазона от 5 до 8 ядер возможно использовать от 5 до 16 ГБ оперативной памяти с шагом 1 ГБ,
        # т.е. 5 ГБ, 6 ГБ, 7 ГБ и т. д.
        # Запрещено использовать выделенные ядра.
        max: 16Gi
        step: 1Gi
      coreFractions: [20, 50, 100]
      defaultCoreFraction: 100  # Значение по умолчанию для диапазона 5-8 ядер
    # Для диапазона от 9 до 16 ядер возможно использовать от 9 до 32 ГБ оперативной памяти с шагом 1 ГБ.
    # При необходимости можно использовать выделенные ядра.
    # Доступны некоторые варианты параметра `corefraction`.
    - cores:
        min: 9
        max: 16
      memory:
        min: 9Gi
        max: 32Gi
        step: 1Gi
      coreFractions: [50, 100]
    # Для диапазона от 17 до 248 ядер возможно использовать от 1 до 2 ГБ оперативной памяти из расчёта на одно ядро.
    # Доступны для использования только выделенные ядра.
    # Единственный доступный параметр `corefraction` = 100%.
    - cores:
        min: 17
        max: 248
      memory:
        perCore:
          min: 1Gi
          max: 2Gi
      coreFractions: [100]
```

Как настроить политики сайзинга в веб-интерфейсе в [форме создания классов ВМ](#настройки-virtualmachineclass):

- Нажмите «Добавить» в блоке «Правила выделения ресурсов для виртуальных машин».
- В блоке «ЦП» в поле «Мин» укажите `1`.
- В блоке «ЦП» в поле «Макс» укажите `4`.
- В блоке «ЦП» в поле «Разрешить задать доли ядра» выберите по порядку значения `5%`, `10%`, `20%`, `50%`, `100%`.
- В блоке «Память» установите переключатель в положение «Объем на 1 ядро».
- В блоке «Память» в поле «Мин» укажите `1`.
- В блоке «Память» в поле «Макс» укажите `8`.
- В блоке «Память» в поле «Шаг дискретизации» укажите `1`.
- Вы можете добавить больше диапазонов с помощью кнопки «Добавить».
- Для создания класса ВМ нажмите кнопку «Создать».

## Управление переподпиской на CPU

Переподписка на CPU — это практика выделения виртуальным машинам большего количества виртуальных ядер, чем доступно физических ядер на узле гипервизора. Это позволяет более эффективно использовать вычислительные ресурсы кластера, так как не все ВМ одновременно работают на полную мощность.

Для управления переподпиской используется параметр `coreFraction`, который задаётся в VirtualMachineClass через политику сайзинга (`sizingPolicies`). Параметр определяет гарантированную минимальную долю вычислительной мощности на каждое ядро ВМ (например, `coreFraction: 20%` означает, что ВМ гарантированно получит 20% мощности ядра, но может использовать до 100% при наличии свободных ресурсов). Администратор задаёт разрешённые значения `coreFractions` и `defaultCoreFraction` (значение по умолчанию, если пользователь не указал `coreFraction`).

{% alert level="info" %}
Если в VirtualMachineClass не задан параметр `coreFractions` (или задано множество значений), пользователь может самостоятельно управлять переподпиской, указывая `coreFraction` при создании ВМ.
{% endalert %}

При планировании размещения ВМ учитывается сумма гарантированных ресурсов: `Σ(cores × coreFraction / 100)` для всех ВМ на узле. Если эта сумма превышает количество физических ядер, ВМ не будет запущена на этом узле.

Пример: Узел с 4 физическими ядрами, 5 ВМ с `cores: 2` и `coreFraction: 20%`:

- Гарантированные ресурсы: 5 × 2 × 0.2 = 2 CPU
- Виртуальных ядер: 10 на 4 физических (коэффициент переподписки 2.5:1)
- Все ВМ могут быть размещены, так как 2 CPU < 4 CPU

Пример 1: Жёстко заданная переподписка

Администратор жёстко задаёт уровень переподписки — пользователь не может его изменить:

```yaml
apiVersion: virtualization.deckhouse.io/v1alpha2
kind: VirtualMachineClass
metadata:
  name: oversubscribed
spec:
  sizingPolicies:
    - cores:
        min: 1
        max: 8
      memory:
        perCore:
          min: 1Gi
          max: 8Gi
      coreFractions: [20]  # Только одно значение
      defaultCoreFraction: 20
```

Для всех ВМ этого класса жёстко задан `coreFraction: 20%`, что обеспечивает фиксированный коэффициент переподписки 5:1.

Пример 2: Гибкая настройка

Пользователь может выбирать из нескольких значений:

```yaml
apiVersion: virtualization.deckhouse.io/v1alpha2
kind: VirtualMachineClass
metadata:
  name: standard
spec:
  sizingPolicies:
    - cores:
        min: 1
        max: 4
      memory:
        perCore:
          min: 1Gi
          max: 8Gi
      coreFractions: [5, 10, 20, 50, 100]
      defaultCoreFraction: 20
```

Пользователь может выбрать `coreFraction` из списка, при отсутствии указания применяется значение 20%.

## Пример конфигурации vCPU Discovery

![Пример конфигурации VirtualMachineClass](/../../../../../images/virtualization-platform/vmclass-examples.ru.png)

Представим, что у нас есть кластер из четырех узлов. Два из этих узлов с лейблом `group=blue` оснащены процессором «CPU X» с тремя наборами инструкций, а остальные два узла с лейблом `group=green` имеют более новый процессор «CPU Y» с четырьмя наборами инструкций.

Для оптимального использования ресурсов данного кластера рекомендуется создать три дополнительных класса виртуальных машин (VirtualMachineClass):

- `universal` — этот класс позволит виртуальным машинам запускаться на всех узлах платформы и мигрировать между ними. При этом будет использоваться набор инструкций для самой младшей модели CPU, что обеспечит наибольшую совместимость;
- `cpuX` — этот класс будет предназначен для виртуальных машин, которые должны запускаться только на узлах с процессором «CPU X». ВМ смогут мигрировать между этими узлами, используя доступные наборы инструкций «CPU X»;
- `cpuY` — этот класс предназначен для виртуальных машин, которые должны запускаться только на узлах с процессором «CPU Y». ВМ смогут мигрировать между этими узлами, используя доступные наборы инструкций «CPU Y».

{% alert level="info" %}
Набор инструкций для процессора — это набор всех команд, которые процессор может выполнять, таких как сложение, вычитание или работа с памятью. Они определяют, какие операции возможны, влияют на совместимость программ и производительность, а также могут меняться от одного поколения процессоров к другому.
{% endalert %}

Примерные конфигурации ресурсов для данного кластера:

```yaml
---
apiVersion: virtualization.deckhouse.io/v1alpha2
kind: VirtualMachineClass
metadata:
  name: universal
spec:
  cpu:
    discovery: {}
    type: Discovery
  sizingPolicies: { ... }
---
apiVersion: virtualization.deckhouse.io/v1alpha2
kind: VirtualMachineClass
metadata:
  name: cpuX
spec:
  cpu:
    discovery:
      nodeSelector:
        matchExpressions:
          - key: group
            operator: In
            values: ["blue"]
    type: Discovery
  nodeSelector:
    matchExpressions:
      - key: group
        operator: In
        values: ["blue"]
  sizingPolicies: { ... }
---
apiVersion: virtualization.deckhouse.io/v1alpha2
kind: VirtualMachineClass
metadata:
  name: cpuY
spec:
  cpu:
    discovery:
      nodeSelector:
        matchExpressions:
          - key: group
            operator: In
            values: ["green"]
    type: Discovery
  sizingPolicies: { ... }
```
